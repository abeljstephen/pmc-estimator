/**
 * SECTION 1: MENU SETUP
 * Defines the custom menu in Google Sheets to provide user access to key functionalities.
 */

/**
 * Adds an Add-On menu to the Google Sheets UI for user interaction.
 */
function onOpen(e) {
  var ui = SpreadsheetApp.getUi();
  ui.createAddonMenu()
    .addItem('PERT', 'addPertColumns')
    .addItem('PLOT', 'showPlot')
    .addToUi();
}

/**
 * Displays a modal dialog for plotting.
 */
function showPlot() {
  var sheet = SpreadsheetApp.getActiveSheet();
  var activeRange = sheet.getActiveRange();
  var rowIndex = activeRange ? activeRange.getRow() : 2; // Default to row 2 if no selection
  if (rowIndex < 2) rowIndex = 2; // Ensure row index is at least 2
  var sheetId = SpreadsheetApp.getActiveSpreadsheet().getId();
  
  Logger.log('showPlot: sheetId = ' + sheetId);
  Logger.log('showPlot: sheetName = ' + sheet.getName());
  Logger.log('showPlot: rowIndex = ' + rowIndex);
  
  var html = HtmlService.createHtmlOutputFromFile('Plot')
      .setWidth(1200)
      .setHeight(900);
  
  html.setContent(
    '<script>' +
    'var sheetId = ' + JSON.stringify(sheetId) + ';' +
    'var sheetName = ' + JSON.stringify(sheet.getName()) + ';' +
    'var rowIndex = ' + JSON.stringify(rowIndex) + ';' +
    '</script>' + html.getContent()
  );
  
  SpreadsheetApp.getUi().showModalDialog(html, 'Interactive Probability Simulator');
}

/**
 * SECTION 2: API INTERACTION
 * Handles secure API calls to pmcEstimatorAPI with JWT authentication.
 */

/**
 * Calls the web API to perform estimation calculations using secure JWT authentication.
 * @param {Array} tasks - Array of task objects with flattened structure.
 * @returns {Object} API response with computed metrics.
 */
function callEstimatorAPI(tasks) {
  const url = 'https://us-central1-pmc-estimator.cloudfunctions.net/pmcEstimatorAPI';
  const keyJsonString = PropertiesService.getScriptProperties().getProperty('SERVICE_ACCOUNT_KEY');
  if (!keyJsonString) {
    Logger.log('Error: SERVICE_ACCOUNT_KEY not found');
    throw new Error('SERVICE_ACCOUNT_KEY not found');
  }
  let keyJson;
  try {
    keyJson = JSON.parse(keyJsonString);
  } catch (e) {
    Logger.log('Error parsing SERVICE_ACCOUNT_KEY: ' + e.message);
    throw new Error('Failed to parse SERVICE_ACCOUNT_KEY: ' + e.message);
  }
  tasks.forEach(task => {
    if (!task.task || 
        typeof task.optimistic !== 'number' || !isFinite(task.optimistic) ||
        typeof task.mostLikely !== 'number' || !isFinite(task.mostLikely) ||
        typeof task.pessimistic !== 'number' || !isFinite(task.pessimistic) ||
        typeof task.targetValue !== 'number' || !isFinite(task.targetValue)) {
      Logger.log('Invalid task data: ' + JSON.stringify(task));
      throw new Error('All task estimates and targetValue must be finite numbers');
    }
  });
  const now = Math.floor(Date.now() / 1000);
  const claimSet = {
    iss: keyJson.client_email,
    aud: 'https://oauth2.googleapis.com/token',
    exp: now + 3600,
    iat: now,
    target_audience: url
  };
  const header = { alg: 'RS256', typ: 'JWT' };
  const toSign = Utilities.base64EncodeWebSafe(JSON.stringify(header)) + '.' +
                 Utilities.base64EncodeWebSafe(JSON.stringify(claimSet));
  let token;
  try {
    const signature = Utilities.computeRsaSha256Signature(toSign, keyJson.private_key);
    const jwt = toSign + '.' + Utilities.base64EncodeWebSafe(signature);
    Logger.log('Generated JWT: [Redacted]');
    const response = UrlFetchApp.fetch('https://oauth2.googleapis.com/token', {
      method: 'POST',
      contentType: 'application/x-www-form-urlencoded',
      payload: {
        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
        assertion: jwt
      },
      muteHttpExceptions: true
    });
    Logger.log('Token endpoint response code: ' + response.getResponseCode());
    Logger.log('Token endpoint response: [Redacted]');
    if (response.getResponseCode() !== 200) {
      throw new Error('Failed to obtain token: ' + response.getContentText());
    }
    const tokenData = JSON.parse(response.getContentText());
    token = tokenData.id_token;
    Logger.log('Generated Token: [Redacted]');
  } catch (e) {
    Logger.log('Token generation failed: ' + e.message);
    throw new Error('Failed to obtain token: ' + e.message);
  }
  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: {
      'Authorization': 'Bearer ' + token
    },
    payload: JSON.stringify(tasks),
    muteHttpExceptions: true
  };
  Logger.log('Calling API with ' + tasks.length + ' tasks');
  Logger.log('Payload: ' + JSON.stringify(tasks));
  const response = UrlFetchApp.fetch(url, options);
  Logger.log('API response code: ' + response.getResponseCode());
  Logger.log('API response content: ' + response.getContentText());
  if (response.getResponseCode() !== 200) {
    Logger.log('API request failed: ' + response.getContentText());
    throw new Error('API request failed: ' + response.getContentText());
  }
  const responseData = JSON.parse(response.getContentText());
  Logger.log('API response data received with ' + (responseData.results ? responseData.results.length : 0) + ' results');
  return responseData;
}

/**
 * SECTION 3: TASK RETRIEVAL
 * Fetches tasks from the spreadsheet for use in Plot.html’s dropdown and other functions.
 */

/**
 * Fetches all tasks from the first sheet of the active Google Spreadsheet for Plot.html’s dropdown.
 * Validates that the sheet has at least 4 columns (Name, Best Case, Most Likely, Worst Case) and data starting from row 2.
 * Ensures estimates are numeric, finite, and in valid order (bestCase ≤ mostLikely ≤ worstCase).
 * Returns an array of task objects for use in Plot.html’s "Select Task" dropdown.
 * Called via google.script.run from Plot.html. Logs errors for debugging and skips invalid rows.
 * @returns {Array} Array of task objects with task name and PERT estimates.
 */
function getAllTasks() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const firstSheet = ss.getSheets()[0];
    if (firstSheet.getLastColumn() < 4) {
      Logger.log('Error: First sheet must have at least 4 columns (Name, Best Case, Most Likely, Worst Case)');
      throw new Error('First sheet must have at least 4 columns');
    }
    const lastRow = firstSheet.getLastRow();
    if (lastRow < 2) {
      Logger.log('Error: No data found in the first sheet');
      throw new Error('No data found in the first sheet');
    }
    const dataRange = firstSheet.getRange(2, 1, lastRow - 1, Math.max(4, firstSheet.getLastColumn()));
    const data = dataRange.getValues();
    const tasks = data.map(row => {
      const [name, bestCase, mostLikely, worstCase] = row;
      if (typeof bestCase !== 'number' || !isFinite(bestCase) || 
          typeof mostLikely !== 'number' || !isFinite(mostLikely) || 
          typeof worstCase !== 'number' || !isFinite(worstCase)) {
        Logger.log(`Skipping row with non-numeric or non-finite estimates: ${JSON.stringify(row)}`);
        return null;
      }
      if (bestCase > mostLikely || mostLikely > worstCase) {
        Logger.log(`Skipping row with invalid estimate order: ${JSON.stringify(row)}`);
        return null;
      }
      return {
        task: name || 'Unnamed Task',
        optimistic: bestCase * 1.0,
        mostLikely: mostLikely * 1.0,
        pessimistic: worstCase * 1.0
      };
    }).filter(task => task !== null);
    Logger.log('Fetched ' + tasks.length + ' valid tasks');
    return tasks;
  } catch (error) {
    Logger.log('Error in getAllTasks: ' + error.message);
    throw error;
  }
}

/**
 * SECTION 4: PERT CALCULATIONS
 * Processes spreadsheet data and adds PERT metrics to the Estimate Calculations sheet.
 */

/**
 * Adds PERT columns to the "Estimate Calculations" sheet using API-provided metrics.
 * Highlights PERT Mean and Monte Carlo Smoothed 90th Percentile Confidence in light green for emphasis.
 * Adds a description row (row 2) under the header with explanations for each column.
 * Validates input data and handles errors appropriately based on context (UI or web app).
 * @param {boolean} isWebAppContext - Indicates if called from a web app (no UI alerts).
 * @returns {Object} Result object with status and message for web app context.
 */
function addPertColumns(isWebAppContext = false) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = "Estimate Calculations";
  let sheet = ss.getSheetByName(sheetName);
  let result = { status: 'success', message: '' };

  if (sheet && !isWebAppContext) {
    const ui = SpreadsheetApp.getUi();
    const response = ui.alert(
      "Sheet exists",
      "The sheet '" + sheetName + "' already exists. Do you want to overwrite its content?",
      ui.ButtonSet.YES_NO
    );

    if (response === ui.Button.YES) {
      sheet.clear();
    } else {
      throw new Error("Operation cancelled by user.");
    }
  } else if (sheet) {
    // In web app context, silently overwrite the sheet
    sheet.clear();
  } else {
    sheet = ss.insertSheet(sheetName);
  }

  const headers = [
    "Name", "Best Case", "Most Likely", "Worst Case",
    "Triangle Mean", "Triangle Variance", "Triangle StdDev", "Triangle Skewness", "Triangle Kurtosis", "Triangle Points",
    "PERT Mean", "PERT StdDev", "PERT Variance", "PERT Skewness", "PERT Kurtosis", "PERT Points",
    "Beta Mean", "Beta Variance", "Beta Skewness", "Beta Kurtosis", "Alpha", "Beta", "Beta Mode", "Beta Points",
    "MC On Beta Unsmoothed Mean", "MC On Beta Unsmoothed Variance", "MC On Beta Unsmoothed Skewness", "MC On Beta Unsmoothed Kurtosis", "MC On Beta Unsmoothed VaR 90%", "MC On Beta Unsmoothed CVaR 90%", "MC On Beta Unsmoothed MAD", "MC On Beta Unsmoothed Points",
    "MC On Beta Smoothed Mean", "MC On Beta Smoothed Variance", "MC On Beta Smoothed Skewness", "MC On Beta Smoothed Kurtosis", "MC On Beta Smoothed VaR 90%", "MC On Beta Smoothed CVaR 90%", "MC On Beta Smoothed MAD", "MC On Beta Smoothed 90th Percentile Confidence", "MC On Beta Smoothed Points",
    "Weighted Estimate (Conservative)", "Weighted Estimate (Neutral)", "Weighted Estimate (Optimistic)",
    "Probability Exceeding PERT Mean (Beta)", "Probability Exceeding PERT Mean (MC Unsmoothed)", "Probability Exceeding PERT Mean (MC Smoothed)", "CDF Points"
  ];

  const descriptions = [
    "Task name or identifier. Use to track specific tasks in planning.", 
    "Optimistic estimate (best-case scenario). Use as the lower bound for planning.", 
    "Most likely estimate (expected value). Use as the central estimate for planning.", 
    "Pessimistic estimate (worst-case scenario). Use as the upper bound for planning.",
    "Average of triangle distribution estimates. Use for a simple average estimate.", 
    "Spread of triangle distribution. Use to assess estimate variability.", 
    "Standard deviation of triangle distribution. Use to measure estimate uncertainty.", 
    "Asymmetry of triangle distribution. Use to understand estimate bias.", 
    "Peakedness of triangle distribution. Use to assess estimate concentration.", 
    "Cumulative distribution points for triangle model. Use in Plot.html for visualization.",
    "Weighted average emphasizing most likely value. Use for balanced project planning.", 
    "Standard deviation of PERT distribution. Use to measure estimate uncertainty.", 
    "Spread of PERT distribution. Use to assess estimate variability.", 
    "Asymmetry of PERT distribution. Use to understand estimate bias.", 
    "Peakedness of PERT distribution. Use to assess estimate concentration.", 
    "Cumulative distribution points for PERT model. Use in Plot.html for visualization.",
    "Mean of beta distribution. Use for a scaled estimate between best and worst case.", 
    "Spread of beta distribution. Use to assess estimate variability.", 
    "Asymmetry of beta distribution. Use to understand estimate bias.", 
    "Peakedness of beta distribution. Use to assess estimate concentration.", 
    "Shape parameter (alpha) for beta distribution. Use for technical analysis.", 
    "Shape parameter (beta) for beta distribution. Use for technical analysis.", 
    "Most frequent value in beta distribution. Use for peak likelihood estimate.", 
    "Cumulative distribution points for beta model. Use in Plot.html for visualization.",
    "Average from unsmoothed Monte Carlo samples. Use for raw simulation-based estimate.", 
    "Spread from unsmoothed Monte Carlo samples. Use to assess raw variability.", 
    "Asymmetry from unsmoothed Monte Carlo samples. Use to understand raw bias.", 
    "Peakedness from unsmoothed Monte Carlo samples. Use to assess raw concentration.", 
    "Value at Risk (90%) from unsmoothed Monte Carlo. Use for risk assessment.", 
    "Conditional VaR (90%) from unsmoothed Monte Carlo. Use for expected loss in worst 10%.", 
    "Mean Absolute Deviation from unsmoothed Monte Carlo. Use to measure average error.", 
    "Cumulative distribution points for unsmoothed Monte Carlo. Use in Plot.html for visualization.",
    "Average from smoothed Monte Carlo simulation. Use for refined central estimate.", 
    "Spread from smoothed Monte Carlo simulation. Use to assess refined variability.", 
    "Asymmetry from smoothed Monte Carlo simulation. Use to understand refined bias.", 
    "Peakedness from smoothed Monte Carlo simulation. Use to assess refined concentration.", 
    "Value at Risk (90%) from smoothed Monte Carlo. Use for refined risk assessment.", 
    "Conditional VaR (90%) from smoothed Monte Carlo. Use for expected loss in worst 10%.", 
    "Mean Absolute Deviation from smoothed Monte Carlo. Use to measure refined average error.", 
    "Value below which 90% of outcomes fall in smoothed Monte Carlo. Use for high-confidence planning or risk assessment.", 
    "Cumulative distribution points for smoothed Monte Carlo. Use in Plot.html for visualization.",
    "Conservative weighted estimate. Use for risk-averse planning.", 
    "Neutral weighted estimate (PERT Mean). Use for balanced planning.", 
    "Optimistic weighted estimate. Use for aggressive planning.", 
    "Probability of exceeding PERT Mean (Beta). Use to assess likelihood of higher outcomes.", 
    "Probability of exceeding PERT Mean (MC Unsmoothed). Use to assess raw simulation likelihood.", 
    "Probability of exceeding PERT Mean (MC Smoothed). Use to assess refined simulation likelihood.", 
    "Cumulative distribution points for visualization. Use in Plot.html for CDF plots."
  ];

  // Set headers and descriptions
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');
  sheet.getRange(2, 1, 1, headers.length).setValues([descriptions]).setFontStyle('italic');

  const firstSheet = ss.getSheets()[0];
  if (firstSheet.getLastColumn() < 4) {
    throw new Error("The first sheet must have at least 4 columns: Name, Best Case, Most Likely, Worst Case.");
  }
  const lastRow = firstSheet.getLastRow();

  if (lastRow < 2) {
    throw new Error("No data found in the first sheet.");
  }

  const dataRange = firstSheet.getRange(2, 1, lastRow - 1, Math.max(4, firstSheet.getLastColumn()));
  const data = dataRange.getValues();
  const errorMessages = [];

  const tasks = data.map((row, index) => {
    const [name, bestCase, mostLikely, worstCase] = row;
    if (typeof bestCase !== 'number' || !isFinite(bestCase) || 
        typeof mostLikely !== 'number' || !isFinite(mostLikely) || 
        typeof worstCase !== 'number' || !isFinite(worstCase)) {
      const error = `Row ${index + 2} may be an issue due to non-numeric or non-finite estimates and will result in "N/A"`;
      Logger.log(error + `: ${JSON.stringify(row)}`);
      errorMessages.push(error);
      return { name: name || "Unnamed Task", error: error };
    }
    if (bestCase > mostLikely || mostLikely > worstCase) {
      const error = `Row ${index + 2} may be an issue due to invalid estimate order (must be optimistic <= most likely <= pessimistic) and will result in "N/A"`;
      Logger.log(error + `: ${JSON.stringify(row)}`);
      errorMessages.push(error);
      return { name: name || "Unnamed Task", error: error };
    }
    if (bestCase === mostLikely || mostLikely === worstCase) {
      const error = `Row ${index + 2} may be an issue due to estimates being too close (optimistic equals most likely or most likely equals pessimistic) and will result in "N/A"`;
      Logger.log(error + `: ${JSON.stringify(row)}`);
      errorMessages.push(error);
      return { name: name || "Unnamed Task", error: error };
    }
    const range = worstCase - bestCase;
    const minRange = mostLikely * 0.001;
    if (range < minRange) {
      const error = `Row ${index + 2} may be an issue due to estimate range being too small (${range} < ${minRange}) and will result in "N/A"`;
      Logger.log(error + `: ${JSON.stringify(row)}`);
      errorMessages.push(error);
      return { name: name || "Unnamed Task", error: error };
    }
    if (bestCase === mostLikely && mostLikely === worstCase) {
      const error = `Row ${index + 2} may be an issue due to zero variance (all estimates equal) and will result in "N/A"`;
      Logger.log(error + `: ${JSON.stringify(row)}`);
      errorMessages.push(error);
      return { name: name || "Unnamed Task", error: error };
    }
    return {
      task: name || "Unnamed Task",
      optimistic: bestCase * 1.0,
      mostLikely: mostLikely * 1.0,
      pessimistic: worstCase * 1.0,
      budgetFlexibility: 0.0,
      scheduleFlexibility: 0.0,
      scopeCertainty: 0.0,
      qualityTolerance: 0.0,
      targetValue: bestCase * 1.0,
      confidenceLevel: 0.9,
      targetProbabilityOnly: false,
      optimizeFor: "target"
    };
  });

  if (errorMessages.length > 0) {
    if (!isWebAppContext) {
      const ui = SpreadsheetApp.getUi();
      const errorSummary = errorMessages.join('\n');
      const response = ui.alert(
        'Errors Encountered',
        `${errorSummary}\n\nPress "Continue" to proceed with "N/A" for invalid rows, or "Cancel" to stop.`,
        ui.ButtonSet.OK_CANCEL
      );
      if (response === ui.Button.CANCEL) {
        throw new Error("Operation cancelled by user due to invalid input data.");
      }
    } else {
      // In web app context, log errors and proceed
      result.message = errorMessages.join('; ');
    }
  }

  const validTasks = tasks.filter(task => !task.error);
  if (validTasks.length === 0 && tasks.length > 0) {
    Logger.log('No valid tasks to send to API, but processing all rows for output.');
  }

  let apiResponse = { results: [] };
  if (validTasks.length > 0) {
    try {
      apiResponse = callEstimatorAPI(validTasks);
    } catch (error) {
      Logger.log('API call failed: ' + error.message);
      errorMessages.push(`API call failed: ${error.message} and will result in "N/A" for valid tasks`);
      result.message = errorMessages.join('; ');
    }
  }

  const results = apiResponse.results || [];
  let resultIndex = 0;
  const allRowData = tasks.map((task, index) => {
    if (task.error) {
      return [task.name, "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A",
              "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A",
              "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A",
              "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A",
              "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A"];
    }
    const result = results[resultIndex] || {};
    resultIndex++;
    if (result.error) {
      const error = `Row ${index + 2} may be an issue due to API error: ${result.error} and will result in "N/A"`;
      Logger.log(error);
      errorMessages.push(error);
      return [task.task || "Unnamed Task", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A",
              "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A",
              "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A",
              "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A",
              "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A"];
    }
    return [
      result.task?.value || "N/A",
      result.bestCase?.value || "N/A",
      result.mostLikely?.value || "N/A",
      result.worstCase?.value || "N/A",
      result.triangleMean?.value || "N/A",
      result.triangleVariance?.value || "N/A",
      result.triangleStdDev?.value || "N/A",
      result.triangleSkewness?.value || "N/A",
      result.triangleKurtosis?.value || "N/A",
      result.trianglePoints?.value ? JSON.stringify(result.trianglePoints.value) : "N/A",
      result.pertMean?.value || "N/A",
      result.pertStdDev?.value || "N/A",
      result.pertVariance?.value || "N/A",
      result.pertSkewness?.value || "N/A",
      result.pertKurtosis?.value || "N/A",
      result.pertPoints?.value ? JSON.stringify(result.pertPoints.value) : "N/A",
      result.betaMean?.value || "N/A",
      result.betaVariance?.value || "N/A",
      result.betaSkewness?.value || "N/A",
      result.betaKurtosis?.value || "N/A",
      result.alpha?.value || "N/A",
      result.beta?.value || "N/A",
      result.betaMode?.value || "N/A",
      result.betaPoints?.value ? JSON.stringify(result.betaPoints.value) : "N/A",
      result.mcMean?.value || "N/A",
      result.mcVariance?.value || "N/A",
      result.mcSkewness?.value || "N/A",
      result.mcKurtosis?.value || "N/A",
      result.mcVaR?.value || "N/A",
      result.mcCVaR?.value || "N/A",
      result.mcMAD?.value || "N/A",
      result.mcPoints?.value ? JSON.stringify(result.mcPoints.value) : "N/A",
      result.mcSmoothedMean?.value || "N/A",
      result.mcSmoothedVariance?.value || "N/A",
      result.mcSmoothedSkewness?.value || "N/A",
      result.mcSmoothedKurtosis?.value || "N/A",
      result.mcSmoothedVaR?.value || "N/A",
      result.mcSmoothedCVaR?.value || "N/A",
      result.mcSmoothedMAD?.value || "N/A",
      result.mcSmoothedConfidenceValues?.value?.valueAt90Percent || "N/A",
      result.mcSmoothedPoints?.value ? JSON.stringify(result.mcSmoothedPoints.value) : "N/A",
      result.weightedConservative?.value || "N/A",
      result.weightedNeutral?.value || "N/A",
      result.weightedOptimistic?.value || "N/A",
      result.probExceedPertMeanBeta?.value || "N/A",
      result.probExceedPertMeanMCUnsmoothed?.value || "N/A",
      result.probExceedPertMeanMCSmoothed?.value || "N/A",
      result.cdfPoints?.value ? JSON.stringify(result.cdfPoints.value) : "N/A"
    ];
  });

  if (allRowData.length > 0) {
    // Write data starting at row 3 to accommodate description row
    sheet.getRange(3, 1, allRowData.length, allRowData[0].length).setValues(allRowData);
    const numRows = allRowData.length;
    // Highlight PERT Mean (column 11) and MC Smoothed 90th Percentile Confidence (column 40)
    const columnsToHighlight = [11, 40];
    columnsToHighlight.forEach(col => {
      sheet.getRange(1, col).setFontWeight('bold').setBackground('#d1e7dd');
      sheet.getRange(3, col, numRows, 1).setBackground('#d1e7dd');
    });
  }

  if (errorMessages.length > 0 && !isWebAppContext) {
    const ui = SpreadsheetApp.getUi();
    const errorSummary = errorMessages.slice(tasks.length).join('\n');
    ui.alert(
      'Additional Errors Encountered',
      `${errorSummary}\n\nThe script completed with "N/A" for affected rows.`,
      ui.ButtonSet.OK
    );
  } else if (errorMessages.length === 0 && !isWebAppContext) {
    const ui = SpreadsheetApp.getUi();
    ui.alert(
      'Success',
      'PERT calculations completed successfully.',
      ui.ButtonSet.OK
    );
  }

  if (errorMessages.length > 0) {
    result.message = errorMessages.join('; ');
  } else {
    result.message = 'PERT calculations completed successfully.';
  }

  return result;
}

/**
 * SECTION 5: PLOT DATA FETCHING
 * Fetches data for Plot.html visualizations, including dynamic probability calculations.
 */

/**
 * Fetches properties directly from the API for plotting in Plot.html.
 * Validates input data and handles edge cases for robust plotting.
 * @param {string} sheetId - Spreadsheet ID.
 * @param {string} sheetName - Name of the sheet.
 * @param {number} rowIndex - Row index to fetch input data from.
 * @returns {Object} Properties object with metrics, points, and task name.
 */
function getProperties(sheetId, sheetName, rowIndex) {
  try {
    Logger.log(`getProperties called with sheetId: ${sheetId}, sheetName: ${sheetName}, rowIndex: ${rowIndex}`);

    // Input validation
    if (typeof sheetId !== 'string' || !sheetId) {
      Logger.log('Error: sheetId must be a non-empty string');
      throw new Error('sheetId must be a non-empty string');
    }
    if (typeof sheetName !== 'string' || !sheetName) {
      Logger.log('Error: sheetName must be a non-empty string');
      throw new Error('sheetName must be a non-empty string');
    }
    if (typeof rowIndex !== 'number' || rowIndex < 2 || !Number.isInteger(rowIndex)) {
      Logger.log('Error: rowIndex must be an integer >= 2');
      throw new Error('rowIndex must be an integer >= 2');
    }

    const spreadsheet = SpreadsheetApp.openById(sheetId);
    if (!spreadsheet) {
      Logger.log('Error: Spreadsheet not found');
      throw new Error('Spreadsheet not found');
    }
    const sheet = spreadsheet.getSheetByName(sheetName);
    if (!sheet) {
      Logger.log(`Error: Sheet "${sheetName}" not found`);
      throw new Error(`Sheet "${sheetName}" not found`);
    }

    const lastRow = sheet.getLastRow();
    if (rowIndex > lastRow) {
      Logger.log(`Error: rowIndex ${rowIndex} exceeds sheet's last row: ${lastRow}`);
      throw new Error(`rowIndex ${rowIndex} exceeds sheet's last row: ${lastRow}`);
    }

    // Validate column count before fetching data
    if (sheet.getLastColumn() < 4) {
      Logger.log('Error: Sheet "' + sheetName + '" has fewer than 4 columns');
      throw new Error('Sheet "' + sheetName + '" must have at least 4 columns');
    }

    // Read input data (columns 1-4: Name, best_case, most_likely, worst_case)
    const data = sheet.getRange(rowIndex, 1, 1, 4).getValues()[0];
    if (!data || data.length < 4) {
      Logger.log(`Error: Insufficient data at row ${rowIndex}`);
      throw new Error(`Insufficient data at row ${rowIndex}`);
    }
    Logger.log('Input data from sheet: ' + JSON.stringify(data));

    const [name, bestCase, mostLikely, worstCase] = data;
    if (typeof bestCase !== 'number' || !isFinite(bestCase) || 
        typeof mostLikely !== 'number' || !isFinite(mostLikely) || 
        typeof worstCase !== 'number' || !isFinite(worstCase)) {
      Logger.log(`Error: Invalid numeric inputs at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
      throw new Error(`Invalid numeric inputs at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
    }
    if (bestCase > mostLikely || mostLikely > worstCase) {
      Logger.log(`Error: Invalid estimate order at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
      throw new Error(`Invalid estimate order at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
    }
    if (bestCase === mostLikely || mostLikely === worstCase) {
      Logger.log(`Error: Estimates too close at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
      throw new Error(`Estimates too close at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
    }
    const range = worstCase - bestCase;
    const minRange = mostLikely * 0.001;
    if (range < minRange) {
      Logger.log(`Error: Estimate range too small at row ${rowIndex}: range=${range}, minRange=${minRange}`);
      throw new Error(`Estimate range too small at row ${rowIndex}: range=${range}, minRange=${minRange}`);
    }
    if (bestCase === mostLikely && mostLikely === worstCase) {
      Logger.log(`Error: Zero variance at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
      throw new Error(`Zero variance at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
    }

    const task = {
      task: name || "Unnamed Task",
      optimistic: bestCase * 1.0,
      mostLikely: mostLikely * 1.0,
      pessimistic: worstCase * 1.0,
      budgetFlexibility: 0.0,
      scheduleFlexibility: 0.0,
      scopeCertainty: 0.0,
      qualityTolerance: 0.0,
      targetValue: bestCase * 1.0,
      confidenceLevel: 0.9,
      targetProbabilityOnly: false,
      optimizeFor: "target"
    };
    Logger.log('Task object prepared for API: ' + JSON.stringify(task));

    // Fetch data from API
    const apiResponse = callEstimatorAPI([task]);
    if (!apiResponse || !apiResponse.results || !Array.isArray(apiResponse.results) || apiResponse.results.length === 0) {
      Logger.log('Error: API response missing or invalid "results" array');
      throw new Error('API response missing or invalid "results" array');
    }

    const result = apiResponse.results[0];
    Logger.log('API result for task: ' + result.task?.value);

    // Helper functions for safe extraction with logging
    function getValue(field, fieldName) {
      const value = result[field]?.value;
      if (value === undefined || value === null || typeof value !== 'number' || isNaN(value)) {
        Logger.log(`Warning: ${fieldName} is invalid or missing (value: ${value}), defaulting to 0`);
        return 0;
      }
      return value;
    }

    function getPoints(field, fieldName) {
      const points = result[field]?.value;
      if (!Array.isArray(points) || points.length === 0) {
        Logger.log(`Warning: ${fieldName} is invalid or empty, defaulting to []`);
        return [];
      }
      if (!points.every(p => typeof p.x === 'number' && typeof p.y === 'number')) {
        Logger.log(`Warning: ${fieldName} contains invalid point format, defaulting to []`);
        return [];
      }
      return points;
    }

    // Construct properties object
    const properties = {
      TASK_NAME: result.task?.value || "Unnamed Task",
      MIN: getValue('bestCase', 'MIN'),
      MOST_LIKELY: getValue('mostLikely', 'MOST_LIKELY'),
      MAX: getValue('worstCase', 'MAX'),
      TRIANGLE_MEAN: getValue('triangleMean', 'TRIANGLE_MEAN'),
      TRIANGLE_VARIANCE: getValue('triangleVariance', 'TRIANGLE_VARIANCE'),
      TRIANGLE_STD: getValue('triangleStdDev', 'TRIANGLE_STD'),
      TRIANGLE_SKEWNESS: getValue('triangleSkewness', 'TRIANGLE_SKEWNESS'),
      TRIANGLE_KURTOSIS: getValue('triangleKurtosis', 'TRIANGLE_KURTOSIS'),
      TRIANGLE_POINTS: getPoints('trianglePoints', 'TRIANGLE_POINTS'),
      PERT_MEAN: getValue('pertMean', 'PERT_MEAN'),
      PERT_STD: getValue('pertStdDev', 'PERT_STD'),
      PERT_VARIANCE: getValue('pertVariance', 'PERT_VARIANCE'),
      PERT_SKEWNESS: getValue('pertSkewness', 'PERT_SKEWNESS'),
      PERT_KURTOSIS: getValue('pertKurtosis', 'PERT_KURTOSIS'),
      PERT_POINTS: getPoints('pertPoints', 'PERT_POINTS'),
      BETA_MEAN: getValue('betaMean', 'BETA_MEAN'),
      BETA_VARIANCE: getValue('betaVariance', 'BETA_VARIANCE'),
      BETA_SKEWNESS: getValue('betaSkewness', 'BETA_SKEWNESS'),
      BETA_KURTOSIS: getValue('betaKurtosis', 'BETA_KURTOSIS'),
      ALPHA: getValue('alpha', 'ALPHA'),
      BETA: getValue('beta', 'BETA'),
      BETA_MODE: getValue('betaMode', 'BETA_MODE'),
      BETA_POINTS: getPoints('betaPoints', 'BETA_POINTS'),
      MC_UNSMOOTHED_MEAN: getValue('mcMean', 'MC_UNSMOOTHED_MEAN'),
      MC_UNSMOOTHED_VARIANCE: getValue('mcVariance', 'MC_UNSMOOTHED_VARIANCE'),
      MC_UNSMOOTHED_SKEWNESS: getValue('mcSkewness', 'MC_UNSMOOTHED_SKEWNESS'),
      MC_UNSMOOTHED_KURTOSIS: getValue('mcKurtosis', 'MC_UNSMOOTHED_KURTOSIS'),
      MC_UNSMOOTHED_VaR_90: getValue('mcVaR', 'MC_UNSMOOTHED_VaR_90'),
      MC_UNSMOOTHED_CVaR_90: getValue('mcCVaR', 'MC_UNSMOOTHED_CVaR_90'),
      MC_UNSMOOTHED_MAD: getValue('mcMAD', 'MC_UNSMOOTHED_MAD'),
      MC_UNSMOOTHED_POINTS: getPoints('mcPoints', 'MC_UNSMOOTHED_POINTS'),
      MC_SMOOTHED_MEAN: getValue('mcSmoothedMean', 'MC_SMOOTHED_MEAN'),
      MC_SMOOTHED_VARIANCE: getValue('mcSmoothedVariance', 'MC_SMOOTHED_VARIANCE'),
      MC_SMOOTHED_SKEWNESS: getValue('mcSmoothedSkewness', 'MC_SMOOTHED_SKEWNESS'),
      MC_SMOOTHED_KURTOSIS: getValue('mcSmoothedKurtosis', 'MC_SMOOTHED_KURTOSIS'),
      MC_SMOOTHED_VaR_90: getValue('mcSmoothedVaR', 'MC_SMOOTHED_VaR_90'),
      MC_SMOOTHED_CVaR_90: getValue('mcSmoothedCVaR', 'MC_SMOOTHED_CVaR_90'),
      MC_SMOOTHED_MAD: getValue('mcSmoothedMAD', 'MC_SMOOTHED_MAD'),
      MC_SMOOTHED_POINTS: getPoints('mcSmoothedPoints', 'MC_SMOOTHED_POINTS'),
      WEIGHTED_CONSERVATIVE: getValue('weightedConservative', 'WEIGHTED_CONSERVATIVE'),
      WEIGHTED_NEUTRAL: getValue('weightedNeutral', 'WEIGHTED_NEUTRAL'),
      WEIGHTED_OPTIMISTIC: getValue('weightedOptimistic', 'WEIGHTED_OPTIMISTIC'),
      PROB_EXCEED_PERT_MEAN_BETA: getValue('probExceedPertMeanBeta', 'PROB_EXCEED_PERT_MEAN_BETA'),
      PROB_EXCEED_PERT_MEAN_MC_UNSMOOTHED: getValue('probExceedPertMeanMCUnsmoothed', 'PROB_EXCEED_PERT_MEAN_MC_UNSMOOTHED'),
      PROB_EXCEED_PERT_MEAN_MC_SMOOTHED: getValue('probExceedPertMeanMCSmoothed', 'PROB_EXCEED_PERT_MEAN_MC_SMOOTHED'),
      CDF_POINTS: getPoints('cdfPoints', 'CDF_POINTS'),
      TARGET_PROBABILITY_POINTS: getPoints('targetProbabilityPoints', 'TARGET_PROBABILITY_POINTS')
    };

    // Verify critical fields for Plot.html
    const requiredPointFields = [
      'TRIANGLE_POINTS', 'PERT_POINTS', 'BETA_POINTS',
      'MC_UNSMOOTHED_POINTS', 'MC_SMOOTHED_POINTS', 'CDF_POINTS',
      'TARGET_PROBABILITY_POINTS'
    ];
    requiredPointFields.forEach(field => {
      if (!properties[field] || properties[field].length === 0) {
        Logger.log(`Warning: ${field} is empty; plot may not render correctly`);
      }
    });

    Logger.log('Returning properties for task: ' + properties.TASK_NAME);
    return properties;
  } catch (error) {
    Logger.log('Error in getProperties: ' + error.message);
    throw error; // Re-throw to allow caller (e.g., Plot.html) to handle
  }
}

/**
 * Fetches target probability data for Plot.html based on user inputs from sliders and mode.
 * Handles dynamic API calls with validation and caching to optimize performance.
 * Called via google.script.run from Plot.html to avoid CORS issues with client-side API calls.
 * @param {Object} params - Parameters including task, estimates, slider values, target value, confidence level, and mode.
 * @returns {Object} API response with probability data or error details.
 */
function getTargetProbabilityData(params) {
  try {
    Logger.log('getTargetProbabilityData called with params: ' + JSON.stringify(params));

    // Input validation
    if (!params.task || typeof params.task !== 'string') {
      Logger.log('Error: task must be a non-empty string');
      throw new Error('Task must be a non-empty string');
    }
    if (typeof params.optimistic !== 'number' || !isFinite(params.optimistic) ||
        typeof params.mostLikely !== 'number' || !isFinite(params.mostLikely) ||
        typeof params.pessimistic !== 'number' || !isFinite(params.pessimistic)) {
      Logger.log(`Error: Invalid numeric inputs: optimistic=${params.optimistic}, mostLikely=${params.mostLikely}, pessimistic=${params.pessimistic}`);
      throw new Error(`Invalid numeric inputs: optimistic=${params.optimistic}, mostLikely=${params.mostLikely}, pessimistic=${params.pessimistic}`);
    }
    if (params.optimistic > params.mostLikely || params.mostLikely > params.pessimistic) {
      Logger.log(`Error: Invalid estimate order: optimistic=${params.optimistic}, mostLikely=${params.mostLikely}, pessimistic=${params.pessimistic}`);
      throw new Error(`Invalid estimate order: optimistic=${params.optimistic}, mostLikely=${params.mostLikely}, pessimistic=${params.pessimistic}`);
    }
    if (params.optimistic === params.mostLikely || params.mostLikely === params.pessimistic) {
      Logger.log(`Error: Estimates too close: optimistic=${params.optimistic}, mostLikely=${params.mostLikely}, pessimistic=${params.pessimistic}`);
      throw new Error(`Estimates too close: optimistic=${params.optimistic}, mostLikely=${params.mostLikely}, pessimistic=${params.pessimistic}`);
    }
    const range = params.pessimistic - params.optimistic;
    const minRange = params.mostLikely * 0.001;
    if (range < minRange) {
      Logger.log(`Error: Estimate range too small: range=${range}, minRange=${minRange}`);
      throw new Error(`Estimate range too small: range=${range}, minRange=${minRange}`);
    }
    if (params.optimistic === params.mostLikely && params.mostLikely === params.pessimistic) {
      Logger.log(`Error: Zero variance: optimistic=${params.optimistic}, mostLikely=${params.mostLikely}, pessimistic=${params.pessimistic}`);
      throw new Error(`Zero variance: optimistic=${params.optimistic}, mostLikely=${params.mostLikely}, pessimistic=${params.pessimistic}`);
    }
    if (!params.sliderValues || 
        typeof params.sliderValues.budgetFlexibility !== 'number' || !isFinite(params.sliderValues.budgetFlexibility) ||
        typeof params.sliderValues.scheduleFlexibility !== 'number' || !isFinite(params.sliderValues.scheduleFlexibility) ||
        typeof params.sliderValues.scopeCertainty !== 'number' || !isFinite(params.sliderValues.scopeCertainty) ||
        typeof params.sliderValues.qualityTolerance !== 'number' || !isFinite(params.sliderValues.qualityTolerance)) {
      Logger.log('Error: Invalid slider values: ' + JSON.stringify(params.sliderValues));
      throw new Error('All slider values must be finite numbers');
    }
    if (params.sliderValues.budgetFlexibility < 0 || params.sliderValues.budgetFlexibility > 100 ||
        params.sliderValues.scheduleFlexibility < 0 || params.sliderValues.scheduleFlexibility > 100 ||
        params.sliderValues.scopeCertainty < 0 || params.sliderValues.scopeCertainty > 100 ||
        params.sliderValues.qualityTolerance < 0 || params.sliderValues.qualityTolerance > 100) {
      Logger.log('Error: Slider values must be between 0 and 100: ' + JSON.stringify(params.sliderValues));
      throw new Error('Slider values must be between 0 and 100');
    }
    if (typeof params.targetValue !== 'number' || !isFinite(params.targetValue)) {
      Logger.log('Error: Invalid targetValue: ' + params.targetValue);
      throw new Error('Target value must be a finite number');
    }
    if (params.targetValue < params.optimistic || params.targetValue > params.pessimistic) {
      Logger.log(`Error: Target value ${params.targetValue} out of range: [${params.optimistic}, ${params.pessimistic}]`);
      throw new Error(`Target value ${params.targetValue} must be between optimistic (${params.optimistic}) and pessimistic (${params.pessimistic})`);
    }
    if (typeof params.confidenceLevel !== 'number' || !isFinite(params.confidenceLevel) || params.confidenceLevel < 0 || params.confidenceLevel > 1) {
      Logger.log('Error: Invalid confidenceLevel: ' + params.confidenceLevel);
      throw new Error('Confidence level must be a number between 0 and 1');
    }
    if (typeof params.isOptimizeMode !== 'boolean') {
      Logger.log('Error: isOptimizeMode must be a boolean: ' + params.isOptimizeMode);
      throw new Error('isOptimizeMode must be a boolean');
    }
    if (!['target', 'confidence'].includes(params.mode)) {
      Logger.log('Error: Invalid mode: ' + params.mode);
      throw new Error('Mode must be "target" or "confidence"');
    }

    // Check cache for targetProbabilityOriginalCdf
    const cache = CacheService.getScriptCache();
    const cacheKey = `cdf_${params.task}`;
    let cachedCdf = cache.get(cacheKey);
    let targetProbabilityOriginalCdf = null;
    if (cachedCdf) {
      try {
        targetProbabilityOriginalCdf = JSON.parse(cachedCdf);
        Logger.log('Retrieved cached targetProbabilityOriginalCdf for task: ' + params.task);
      } catch (e) {
        Logger.log('Error parsing cached CDF: ' + e.message);
        cachedCdf = null;
      }
    }

    // Construct payload
    const task = {
      task: params.task,
      optimistic: params.optimistic * 1.0,
      mostLikely: params.mostLikely * 1.0,
      pessimistic: params.pessimistic * 1.0,
      budgetFlexibility: params.isOptimizeMode && params.previousOptimalSliderSettings ?
        params.previousOptimalSliderSettings.budgetFlexibility * 1.0 :
        params.sliderValues.budgetFlexibility * 1.0,
      scheduleFlexibility: params.isOptimizeMode && params.previousOptimalSliderSettings ?
        params.previousOptimalSliderSettings.scheduleFlexibility * 1.0 :
        params.sliderValues.scheduleFlexibility * 1.0,
      scopeCertainty: params.isOptimizeMode && params.previousOptimalSliderSettings ?
        params.previousOptimalSliderSettings.scopeCertainty * 1.0 :
        params.sliderValues.scopeCertainty * 1.0,
      qualityTolerance: params.isOptimizeMode && params.previousOptimalSliderSettings ?
        params.previousOptimalSliderSettings.qualityTolerance * 1.0 :
        params.sliderValues.qualityTolerance * 1.0,
      targetValue: params.targetValue * 1.0,
      confidenceLevel: params.confidenceLevel,
      targetProbabilityOnly: false,
      optimizeFor: params.mode
    };
    Logger.log('Task object prepared for API: ' + JSON.stringify(task));

    // Fetch data from API
    const apiResponse = callEstimatorAPI([task]);
    if (!apiResponse || !apiResponse.results || !Array.isArray(apiResponse.results) || apiResponse.results.length === 0) {
      Logger.log('Error: API response missing or invalid "results" array');
      throw new Error('API response missing or invalid "results" array');
    }

    const result = apiResponse.results[0];
    Logger.log('API result for task: ' + result.task?.value);

    // Cache targetProbabilityOriginalCdf if not already cached
    if (!cachedCdf && result.targetProbabilityOriginalCdf?.value) {
      try {
        cache.put(cacheKey, JSON.stringify(result.targetProbabilityOriginalCdf.value), 3600); // Cache for 1 hour
        Logger.log('Cached targetProbabilityOriginalCdf for task: ' + params.task);
      } catch (e) {
        Logger.log('Error caching targetProbabilityOriginalCdf: ' + e.message);
      }
    }

    // Return response with cached or fresh CDF
    return {
      ...result,
      targetProbabilityOriginalCdf: { value: cachedCdf ? targetProbabilityOriginalCdf : result.targetProbabilityOriginalCdf?.value || [] }
    };
  } catch (error) {
    Logger.log('Error in getTargetProbabilityData: ' + error.message);
    throw new Error('Failed to fetch target probability data: ' + error.message);
  }
}

/**
 * SECTION 6: WEB APP INTEGRATION
 * Handles web app requests for creating and submitting estimate sheets.
 */

/**
 * Shows the HTML form or auto-creates the Sheet for the web app.
 * @param {Object} e - HTTP event with parameters.
 * @returns {HtmlOutput|TextOutput} HTML form or JSON response.
 */
function doGet(e) {
  Logger.log('doGet parameters: ' + JSON.stringify(e?.parameter));
  try {
    if (e?.parameter?.sheetId) {
      Logger.log('Serving Plot.html');
      return HtmlService.createHtmlOutputFromFile('Plot')
        .setTitle("PERT Estimate Plot")
        .append('<script>var sheetId = "' + e.parameter.sheetId + '";</script>');
    }
    Logger.log('Serving submit.html');
    return HtmlService.createHtmlOutputFromFile('submit')
      .setTitle("Submit Your Estimates");
  } catch (error) {
    Logger.log("Error in doGet: " + error.message);
    return ContentService.createTextOutput(
      JSON.stringify({ error: error.message })
    ).setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * Creates a spreadsheet and returns URLs for the web app.
 * @param {Array} tasks - Array of task objects.
 * @returns {Object} Object containing sheetUrl and plotUrl.
 */
function createEstimateSheet(tasks) {
  if (!tasks || tasks.length === 0) {
    throw new Error("No tasks provided.");
  }

  tasks.forEach(task => {
    if (!task.taskName || 
        typeof task.bestCase !== 'number' || !isFinite(task.bestCase) ||
        typeof task.mostLikely !== 'number' || !isFinite(task.mostLikely) ||
        typeof task.worstCase !== 'number' || !isFinite(task.worstCase)) {
      throw new Error("Invalid task data: " + JSON.stringify(task));
    }
    if (task.bestCase > task.mostLikely || task.mostLikely > task.worstCase) {
      throw new Error("Invalid estimate order: " + JSON.stringify(task));
    }
    if (task.bestCase === task.mostLikely || task.mostLikely === task.worstCase) {
      throw new Error("Estimates too close: " + JSON.stringify(task));
    }
    const range = task.worstCase - task.bestCase;
    const minRange = task.mostLikely * 0.001;
    if (range < minRange) {
      throw new Error(`Estimate range too small (${range} < ${minRange}): ` + JSON.stringify(task));
    }
    if (task.bestCase === task.mostLikely && task.mostLikely === task.worstCase) {
      throw new Error("Zero variance: " + JSON.stringify(task));
    }
  });

  const spreadsheet = SpreadsheetApp.create("Project Estimates");
  const sheet = spreadsheet.getActiveSheet();
  sheet.clear();

  sheet.getRange("A1:E1").setValues([
    ["Name", "best_case", "most_likely", "worst_case", "SelectedForPlot"]
  ]);

  tasks.forEach((task, i) => {
    sheet.getRange(i + 2, 1, 1, 5).setValues([
      [task.taskName, task.bestCase, task.mostLikely, task.worstCase, task.selectedForPlot ? "TRUE" : "FALSE"]
    ]);
  });

  SpreadsheetApp.setActiveSpreadsheet(spreadsheet);
  const pertResult = addPertColumns(true); // Pass true for web app context

  if (pertResult.status === 'error') {
    throw new Error(pertResult.message || "Failed to generate PERT calculations.");
  }

  const calcSheet = spreadsheet.getSheetByName('Estimate Calculations');
  const sheetId = spreadsheet.getId();
  const sheetUrl = spreadsheet.getUrl() + "#gid=" + calcSheet.getSheetId();
  const plotUrl = ScriptApp.getService().getUrl() + "?sheetId=" + sheetId;

  return {
    sheetUrl: sheetUrl,
    plotUrl: plotUrl,
    message: pertResult.message
  };
}

/**
 * Handles POST requests to auto-create a sheet for the web app.
 * @param {Object} e - HTTP event with parameters.
 * @returns {TextOutput} JSON containing sheetUrl and plotUrl.
 */
function doPost(e) {
  try {
    if (!e || !e.parameter || !e.parameter.data) {
      throw new Error("Missing data parameter.");
    }

    const tasks = JSON.parse(e.parameter.data);
    if (!Array.isArray(tasks) || tasks.length === 0) {
      throw new Error("Invalid or empty tasks array.");
    }

    // Validate tasks
    tasks.forEach(task => {
      if (!task.taskName || 
          typeof task.bestCase !== 'number' || !isFinite(task.bestCase) ||
          typeof task.mostLikely !== 'number' || !isFinite(task.mostLikely) ||
          typeof task.worstCase !== 'number' || !isFinite(task.worstCase)) {
        throw new Error("Invalid task data: " + JSON.stringify(task));
      }
      if (task.bestCase > task.mostLikely || task.mostLikely > task.worstCase) {
        throw new Error("Invalid estimate order: " + JSON.stringify(task));
      }
      if (task.bestCase === task.mostLikely || task.mostLikely === task.worstCase) {
        throw new Error("Estimates too close: " + JSON.stringify(task));
      }
      const range = task.worstCase - task.bestCase;
      const minRange = task.mostLikely * 0.001;
      if (range < minRange) {
        throw new Error(`Estimate range too small (${range} < ${minRange}): ` + JSON.stringify(task));
      }
      if (task.bestCase === task.mostLikely && task.mostLikely === task.worstCase) {
        throw new Error("Zero variance: " + JSON.stringify(task));
      }
    });

    const spreadsheet = SpreadsheetApp.create("Project Estimates");
    const sheet = spreadsheet.getActiveSheet();
    sheet.clear();

    sheet.getRange("A1:E1").setValues([
      ["Name", "best_case", "most_likely", "worst_case", "SelectedForPlot"]
    ]);

    tasks.forEach((task, i) => {
      sheet.getRange(i + 2, 1, 1, 5).setValues([
        [task.taskName, task.bestCase, task.mostLikely, task.worstCase, task.selectedForPlot ? "TRUE" : "FALSE"]
      ]);
    });

    spreadsheet.setActiveSheet(sheet);
    const pertResult = addPertColumns(true); // Pass true for web app context

    if (pertResult.status === 'error') {
      throw new Error(pertResult.message || "Failed to generate PERT calculations.");
    }

    const calcSheet = spreadsheet.getSheetByName('Estimate Calculations');
    spreadsheet.setActiveSheet(calcSheet);

    const sheetId = spreadsheet.getId();
    const plotUrl = ScriptApp.getService().getUrl() + "?sheetId=" + sheetId;

    const result = {
      sheetUrl: spreadsheet.getUrl(),
      plotUrl: plotUrl,
      message: pertResult.message
    };

    return ContentService.createTextOutput(
      JSON.stringify(result)
    ).setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    Logger.log("Error in doPost: " + error.message);
    return ContentService.createTextOutput(
      JSON.stringify({ error: error.message })
    ).setMimeType(ContentService.MimeType.JSON);
  }
}



/**
 * SECTION 1: Configuration and Constants
 * Defines the global CONFIG object with UI labels, error messages, and settings, along with constants for sheet names, API URLs, and timeouts.
 */
const CONFIG = {
    PAGE_TITLE: 'Interactive Probability Simulator',
    GOOGLE_CHARTS_URL: 'https://www.google.com/jsapi',
    MATHJAX_URL: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML',
    GOOGLE_FONTS_URL: 'https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap',
    LOADING_MESSAGE: 'Loading...',
    ERROR_NO_SHEET_ID_MESSAGE: 'Spreadsheet ID not provided. Please contact support.',
    ERROR_NO_SIMULATOR_CONTAINER: 'Simulator container not found',
    ERROR_PAGE_LOAD_FAILED: 'Failed to load page',
    ERROR_NO_TASK_SELECT: 'Task select element not found',
    ERROR_NO_VALID_TASKS: 'No valid tasks found',
    ERROR_NO_VALID_TASKS_MESSAGE: 'No valid tasks available in the spreadsheet.',
    ERROR_NO_TASKS_AVAILABLE: 'No tasks available',
    ERROR_CONTACT_SUPPORT: 'Please contact support.',
    ERROR_FETCH_TASKS: 'Failed to fetch tasks',
    ERROR_FETCH_TASKS_MESSAGE: 'Error fetching tasks: ',
    ERROR_INVALID_TASK: 'Invalid task selected',
    ERROR_INVALID_TASK_RESULTS_MESSAGE: 'Invalid task data, cannot display results.',
    ERROR_NO_EXPLORE_RESULTS: 'Explore results element not found',
    ERROR_NO_COMBINATION_TABLE: 'Combination table not found',
    ERROR_NO_COMBINATION_DATA: 'No combination data available',
    WARNING_NO_COMBINATIONS: 'No combinations available',
    WARNING_ELEMENT_NOT_FOUND: 'Element not found: ',
    WARNING_OPTIMAL_SLIDER_SETTINGS_MISSING: 'Optimal slider settings missing',
    ERROR_TASK_TIMEOUT: 'Task fetch timeout',
    ERROR_TASK_TIMEOUT_MESSAGE: 'Task fetch timed out. Please try again.',
    ERROR_DATA_TIMEOUT: 'Data fetch timeout',
    ERROR_DATA_TIMEOUT_MESSAGE: 'Data fetch timed out. Please try again.',
    ERROR_INVALID_API_RESPONSE: 'Invalid API response',
    ERROR_API_FAILURE: 'Failed to fetch data from server',
    ERROR_RENDERING_PDF: 'Error rendering PDF chart',
    ERROR_RENDERING_CDF: 'Error rendering CDF chart',
    ERROR_INVALID_TASK_RECOMMENDATIONS: 'Invalid task data for recommendations',
    WARNING_OPTIMAL_VALUE_ADJUSTED: 'Optimal value adjusted',
    DEFAULT_BEST_CASE: 0,
    DEFAULT_MOST_LIKELY: 0,
    DEFAULT_WORST_CASE: 0,
    DEFAULT_TARGET_VALUE: 0,
    DEFAULT_CONFIDENCE_LEVEL: 0.9,
    DEFAULT_ORIGINAL_PROBABILITY: 50,
    DEFAULT_ADJUSTED_PROBABILITY: 50,
    DEFAULT_ORIGINAL_VALUE_AT_CONFIDENCE: 0,
    DEFAULT_VALUE_AT_CONFIDENCE: 0,
    DEFAULT_OPTIMAL_PROBABILITY: 50,
    DEFAULT_VARIANCE_SCALE: 1,
    DEFAULT_ORIGINAL_MEAN: 0,
    DEFAULT_ADJUSTED_MEAN: 0,
    DEFAULT_VARIANCE: 0,
    DEFAULT_STD_DEV: 0,
    DEFAULT_SKEWNESS: 0,
    DEFAULT_CV: 0,
    DEFAULT_CI: '[0, 0]',
    DEFAULT_VAR: 0,
    DEFAULT_CVAR: 0,
    INITIAL_SETUP_TITLE: 'Initial Setup',
    INITIAL_SETUP_DESCRIPTION: 'Select a task and configure settings.',
    TASK_SELECT_LABEL: 'Select Task',
    TASK_LOADING_MESSAGE: 'Loading tasks...',
    MODE_SELECT_LABEL: 'Mode',
    TARGET_MODE_LABEL: 'Target',
    CONFIDENCE_MODE_LABEL: 'Confidence',
    TARGET_VALUE_LABEL: 'Target Value',
    CONFIDENCE_LEVEL_LABEL: 'Confidence Level',
    OPTIMIZE_LABEL: 'Optimize',
    OPTIMIZE_NO_LABEL: 'No',
    OPTIMIZE_YES_LABEL: 'Yes',
    EXPLORATION_RESULTS_HEADER: 'Exploration Results',
    EXPLORATION_RESULTS_DEFAULT_TEXT: 'Select a task to view results.',
    BUDGET_FLEXIBILITY_LABEL: 'Budget Flexibility',
    SCHEDULE_FLEXIBILITY_LABEL: 'Schedule Flexibility',
    SCOPE_CERTAINTY_LABEL: 'Scope Certainty',
    QUALITY_TOLERANCE_LABEL: 'Quality Tolerance',
    BUDGET_FLEXIBILITY_HELP_TEXT: 'Adjust budget flexibility.',
    SCHEDULE_FLEXIBILITY_HELP_TEXT: 'Adjust schedule flexibility.',
    SCOPE_CERTAINTY_HELP_TEXT: 'Adjust scope certainty.',
    QUALITY_TOLERANCE_HELP_TEXT: 'Adjust quality tolerance.',
    USE_CASE_LABEL: 'Use Case',
    PDF_USE_CASE_WHEN: 'When analyzing probability density.',
    PDF_USE_CASE_HOW: 'Use the PDF chart to view probability distributions.',
    PDF_USE_CASE_BENEFIT: 'Helps understand likelihood of outcomes.',
    CDF_USE_CASE_WHEN: 'When analyzing cumulative probability.',
    CDF_USE_CASE_HOW: 'Use the CDF chart to view cumulative distributions.',
    CDF_USE_CASE_BENEFIT: 'Helps understand cumulative probabilities.',
    SLIDER_COMBINATION_LABEL: 'Slider Combinations',
    FILTER_LABEL: 'Filter Combinations',
    FILTER_CURRENT_LABEL: 'Current Selection',
    FILTER_ALL_LABEL: 'All Combinations',
    FILTER_ABOVE_50_LABEL: 'Above 50%',
    FILTER_ABOVE_75_LABEL: 'Above 75%',
    FILTER_BELOW_50_LABEL: 'Below 50%',
    FILTER_OPTIMIZED_LABEL: 'Optimized',
    FILTER_HELP_TEXT: 'Filter slider combinations.',
    PREV_PAGE_LABEL: 'Previous',
    NEXT_PAGE_LABEL: 'Next',
    PAGE_INFO_DEFAULT_TEXT: 'Page 1 of 1',
    INSIGHTS_RECOMMENDATIONS_LABEL: 'Insights & Recommendations',
    RECOMMENDATIONS_HEADER: 'Recommendations',
    STATISTICAL_METRICS_TITLE: 'Statistical Metrics',
    METRIC_HEADER: 'Metric',
    PURPOSE_HEADER: 'Purpose',
    GENERAL_FORMULA_HEADER: 'General Formula',
    DYNAMIC_FORMULA_HEADER: 'Dynamic Formula',
    RESULT_HEADER: 'Result',
    PERT_MEAN_LABEL: 'PERT Mean',
    PERT_MEAN_PURPOSE: 'Estimate expected value.',
    PERT_MEAN_FORMULA: '(a + 4m + b) / 6',
    PERT_MEAN_DYNAMIC_FORMULA: '(optimistic + 4*mostLikely + pessimistic) / 6',
    TRIANGLE_MEAN_LABEL: 'Triangle Mean',
    TRIANGLE_MEAN_PURPOSE: 'Estimate expected value.',
    TRIANGLE_MEAN_FORMULA: '(a + m + b) / 3',
    TRIANGLE_MEAN_DYNAMIC_FORMULA: '(optimistic + mostLikely + pessimistic) / 3',
    BETA_MEAN_LABEL: 'Beta Mean',
    BETA_MEAN_PURPOSE: 'Estimate expected value.',
    BETA_MEAN_FORMULA: '(a + 4m + b) / 6',
    BETA_MEAN_DYNAMIC_FORMULA: '(optimistic + 4*mostLikely + pessimistic) / 6',
    MC_UNSMOOTHED_MEAN_LABEL: 'MC Unsmoothed Mean',
    MC_UNSMOOTHED_MEAN_PURPOSE: 'Monte Carlo mean.',
    MC_UNSMOOTHED_MEAN_FORMULA: 'Mean of samples',
    MC_UNSMOOTHED_MEAN_DYNAMIC_FORMULA: 'Mean of Monte Carlo samples',
    MC_SMOOTHED_MEAN_LABEL: 'MC Smoothed Mean',
    MC_SMOOTHED_MEAN_PURPOSE: 'Smoothed Monte Carlo mean.',
    MC_SMOOTHED_MEAN_FORMULA: 'Smoothed mean of samples',
    MC_SMOOTHED_MEAN_DYNAMIC_FORMULA: 'Smoothed mean of Monte Carlo samples',
    MC_SMOOTHED_MEDIAN_LABEL: 'MC Smoothed Median',
    MC_SMOOTHED_MEDIAN_PURPOSE: 'Smoothed Monte Carlo median.',
    MC_SMOOTHED_MEDIAN_FORMULA: 'Median of smoothed samples',
    MC_SMOOTHED_MEDIAN_DYNAMIC_FORMULA: 'Median of smoothed Monte Carlo samples',
    STD_DEV_LABEL: 'Standard Deviation',
    STD_DEV_PURPOSE: 'Measure of dispersion.',
    STD_DEV_FORMULA: 'sqrt(variance)',
    STD_DEV_DYNAMIC_FORMULA: 'sqrt(variance of samples)',
    VARIANCE_LABEL: 'Variance',
    VARIANCE_PURPOSE: 'Measure of variability.',
    VARIANCE_FORMULA: 'E[(X - μ)^2]',
    VARIANCE_DYNAMIC_FORMULA: 'Variance of samples',
    SKEWNESS_LABEL: 'Skewness',
    SKEWNESS_PURPOSE: 'Measure of asymmetry.',
    SKEWNESS_FORMULA: 'E[(X - μ)^3] / σ^3',
    SKEWNESS_DYNAMIC_FORMULA: 'Skewness of samples',
    CV_LABEL: 'Coefficient of Variation',
    CV_PURPOSE: 'Relative variability.',
    CV_FORMULA: 'σ / μ',
    CV_DYNAMIC_FORMULA: 'Standard deviation / mean',
    CI_LABEL: 'Confidence Interval',
    CI_PURPOSE: 'Range of likely values.',
    CI_FORMULA: '[μ - z*σ, μ + z*σ]',
    CI_DYNAMIC_FORMULA: 'Confidence interval of samples',
    VAR_LABEL: 'Value at Risk',
    VAR_PURPOSE: 'Risk measure.',
    VAR_FORMULA: 'Value at percentile',
    VAR_DYNAMIC_FORMULA: 'Value at risk percentile',
    CVAR_LABEL: 'Conditional Value at Risk',
    CVAR_PURPOSE: 'Expected shortfall.',
    CVAR_FORMULA: 'E[X | X ≥ VaR]',
    CVAR_DYNAMIC_FORMULA: 'Conditional value at risk',
    RECOMMENDATIONS_OVERVIEW_HEADER: 'Overview',
    RECOMMENDATIONS_OVERVIEW_TEXT: 'Recommendations based on your settings.',
    RECOMMENDATIONS_BASELINE_TEXT: 'Baseline Risk',
    RECOMMENDATIONS_CURRENT_TEXT: 'Current Settings',
    RECOMMENDATIONS_OPTIMIZED_TEXT: 'Optimized Settings',
    RECOMMENDATIONS_SLIDERS_INTRO: 'Use sliders to adjust settings.',
    RECOMMENDATIONS_SLIDERS_HEADER: 'Slider Settings',
    RECOMMENDATIONS_SLIDERS_TEXT: 'Adjust sliders to optimize outcomes.',
    RECOMMENDATIONS_CONTROLLED_OVERRUNS_TEXT: 'Control cost and schedule overruns.',
    RECOMMENDATIONS_SCOPE_QUALITY_TEXT: 'Manage scope and quality.',
    RECOMMENDATIONS_RISK_SCENARIOS_TEXT: 'Explore risk scenarios.',
    RECOMMENDATIONS_SLIDER_TABLE_TEXT: 'Use the slider combination table.',
    RECOMMENDATIONS_OPTIMIZE_TEXT: 'Optimize settings.',
    RECOMMENDATIONS_MITIGATION_HEADER: 'Risk Mitigation',
    RECOMMENDATIONS_EXAMPLE_HEADER: 'Example Recommendations',
    RECOMMENDATIONS_EXAMPLE_TEXT: 'Example scenarios.',
    RECOMMENDATIONS_EXAMPLE_BASELINE: 'Baseline Scenario',
    RECOMMENDATIONS_EXAMPLE_CURRENT: 'Current Scenario',
    RECOMMENDATIONS_EXAMPLE_IMPROVE: 'Improvement Steps',
    RECOMMENDATIONS_EXAMPLE_CHECK: 'Verification Steps',
    RISK_LEVEL_VERY_LOW: 'Very Low',
    RISK_LEVEL_LOW: 'Low',
    RISK_LEVEL_MODERATE: 'Moderate',
    RISK_LEVEL_HIGH: 'High',
    BUDGET_FLEXIBILITY_DOES_TEXT: 'Adjusts budget allowance.',
    BUDGET_FLEXIBILITY_IMPACT_TEXT: 'Increases cost tolerance.',
    BUDGET_FLEXIBILITY_DISTRIBUTION_TEXT: 'Shifts distribution.',
    BUDGET_FLEXIBILITY_FORMULA: 'Budget adjustment formula.',
    BUDGET_FLEXIBILITY_HELPS_TEXT: 'Reduces cost overrun risk.',
    BUDGET_FLEXIBILITY_NEXT_STEP: 'Increase budget flexibility.',
    SCHEDULE_FLEXIBILITY_DOES_TEXT: 'Adjusts schedule allowance.',
    SCHEDULE_FLEXIBILITY_IMPACT_TEXT: 'Increases schedule tolerance.',
    SCHEDULE_FLEXIBILITY_DISTRIBUTION_TEXT: 'Shifts schedule distribution.',
    SCHEDULE_FLEXIBILITY_FORMULA: 'Schedule adjustment formula.',
    SCHEDULE_FLEXIBILITY_HELPS_TEXT: 'Reduces delay risk.',
    SCHEDULE_FLEXIBILITY_NEXT_STEP: 'Increase schedule flexibility.',
    SCOPE_CERTAINTY_DOES_TEXT: 'Adjusts scope certainty.',
    SCOPE_CERTAINTY_IMPACT_TEXT: 'Reduces scope creep.',
    SCOPE_CERTAINTY_DISTRIBUTION_TEXT: 'Narrows distribution.',
    SCOPE_CERTAINTY_FORMULA: 'Scope adjustment formula.',
    SCOPE_CERTAINTY_HELPS_TEXT: 'Improves scope control.',
    SCOPE_CERTAINTY_NEXT_STEP: 'Increase scope certainty.',
    QUALITY_TOLERANCE_DOES_TEXT: 'Adjusts quality tolerance.',
    QUALITY_TOLERANCE_IMPACT_TEXT: 'Manages quality trade-offs.',
    QUALITY_TOLERANCE_DISTRIBUTION_TEXT: 'Adjusts quality distribution.',
    QUALITY_TOLERANCE_FORMULA: 'Quality adjustment formula.',
    QUALITY_TOLERANCE_HELPS_TEXT: 'Reduces defect risk.',
    QUALITY_TOLERANCE_NEXT_STEP: 'Adjust quality tolerance.',
    COMBINED_EFFECT_DOES_TEXT: 'Combines all adjustments.',
    COMBINED_EFFECT_IMPACT_TEXT: 'Optimizes overall risk.',
    COMBINED_EFFECT_DISTRIBUTION_TEXT: 'Adjusts combined distribution.',
    COMBINED_EFFECT_FORMULA: 'Combined adjustment formula.',
    COMBINED_EFFECT_HELPS_TEXT: 'Balances all risks.',
    COMBINED_EFFECT_NEXT_STEP: 'Optimize all settings.',
    COMBINATION_TABLE_COL_COMBINATION: 'Combination',
    COMBINATION_TABLE_COL_BALANCED: 'Balanced',
    COMBINATION_TABLE_COL_UNBALANCED: 'Unbalanced',
    COMBINATION_TABLE_SUCCESS_TEXT: 'Success',
    COMBINATION_TABLE_FAILURE_TEXT: 'Failure',
    MAX_TASKS: 100,
    EXPLORE_MODE_DEFAULT_TITLE_PREFIX: 'Explore',
    EXPLORE_MODE_DEFAULT_TITLE_SUFFIX: 'Mode',
    EXPLORE_MODE_OPTIMIZED_TITLE: 'Optimized Mode',
    PDF_CHART_TITLE: 'Probability Density Function',
    PDF_X_AXIS_LABEL: 'Value',
    PDF_Y_AXIS_LABEL: 'Probability Density',
    PDF_ORIGINAL_LABEL: 'Original',
    PDF_ADJUSTED_LABEL: 'Adjusted',
    PDF_OPTIMIZED_ADJUSTED_LABEL: 'Optimized',
    PDF_ORIGINAL_TOOLTIP: 'Original',
    PDF_ADJUSTED_TOOLTIP: 'Adjusted',
    PDF_OPTIMIZED_TOOLTIP: 'Optimized',
    PDF_ORIGINAL_TARGET_LABEL: 'Original Target',
    PDF_ADJUSTED_TARGET_LABEL: 'Adjusted Target',
    CDF_CHART_TITLE: 'Cumulative Distribution Function',
    CDF_X_AXIS_LABEL: 'Value',
    CDF_Y_AXIS_LABEL: 'Cumulative Probability',
    CDF_ORIGINAL_LABEL: 'Original',
    CDF_ADJUSTED_LABEL: 'Adjusted',
    CDF_OPTIMIZED_ADJUSTED_LABEL: 'Optimized',
    CDF_ORIGINAL_TOOLTIP: 'Original',
    CDF_ADJUSTED_TOOLTIP: 'Adjusted',
    CDF_OPTIMIZED_TOOLTIP: 'Optimized',
    CDF_ORIGINAL_TARGET_LABEL: 'Original Target',
    CDF_ADJUSTED_TARGET_LABEL: 'Adjusted Target',
    SHOW_EXECUTING_USER: true,
    BACK_TO_TOP_LABEL: 'Back to Top',
    SUBMIT_PAGE_TITLE: 'Submit Tasks'
};
const ESTIMATION_DATA_SHEET_NAME = 'Estimation Data';
const ESTIMATE_CALCULATIONS_SHEET_NAME = 'Estimate Calculations';
const ADDON_CALCULATIONS_SHEET_NAME = 'Estimate Calculations Addon';
const DEFAULT_PROJECT_NAME = 'Untitled Project';
const DEFAULT_ROW_INDEX = 2;
const MIN_RANGE_MULTIPLIER = 0.1;
const DOGET_TIMEOUT_MS = 15000;
const SERVICE_ACCOUNT_KEY_NAME = 'SERVICE_ACCOUNT_KEY';
const API_URL = 'https://us-central1-pmc-estimator.cloudfunctions.net/pmcEstimatorAPI';
const TOKEN_ENDPOINT_URL = 'https://oauth2.googleapis.com/token';
const API_TIMEOUT_MS = 30000;
const SESSION_ID_PREFIX = 'Session_';
const DEPLOYMENT_ID_PROPERTY = 'DEPLOYMENT_ID';

/**
 * SECTION 2: Deployment ID Management
 * Handles dynamic retrieval of the deployment ID for web app URLs, supporting development, web app, and add-on modes.
 */
function getDeploymentId() {
    const scriptProperties = PropertiesService.getScriptProperties();
    let deploymentId = scriptProperties.getProperty(DEPLOYMENT_ID_PROPERTY);
    
    if (deploymentId === 'AKfycbyYNTqfEyeQ6hhdu1OVJAA9voM4d0SURRewZQ1QMYDCHRYg-Hg') {
        Logger.log('Outdated deployment ID detected, clearing cache.');
        scriptProperties.deleteProperty(DEPLOYMENT_ID_PROPERTY);
        deploymentId = null;
    }
    
    if (!deploymentId) {
        try {
            const url = ScriptApp.getService().getUrl();
            Logger.log('Retrieved web app URL: ' + url);
            if (url.includes('/dev')) {
                Logger.log('Running in development mode (/dev URL). Using latest deployment ID.');
                deploymentId = 'AKfycbxPMikpb1W7qHCYwuIfx1696rU-rsnZka_SRhdSL6x8r8EnhRVbwQ1Kofdjm8jIFcaL';
                scriptProperties.setProperty(DEPLOYMENT_ID_PROPERTY, deploymentId);
                Logger.log('Stored deployment ID: ' + deploymentId);
            } else {
                const match = url.match(/\/s\/([^/]+)\/exec/);
                if (match && match[1]) {
                    deploymentId = match[1];
                    scriptProperties.setProperty(DEPLOYMENT_ID_PROPERTY, deploymentId);
                    Logger.log('Stored deployment ID from URL: ' + deploymentId);
                } else {
                    Logger.log('Error: Could not parse deployment ID from URL: ' + url);
                    deploymentId = 'AKfycbxPMikpb1W7qHCYwuIfx1696rU-rsnZka_SRhdSL6x8r8EnhRVbwQ1Kofdjm8jIFcaL';
                    scriptProperties.setProperty(DEPLOYMENT_ID_PROPERTY, deploymentId);
                    Logger.log('Stored default deployment ID: ' + deploymentId);
                }
            }
        } catch (error) {
            Logger.log('Error retrieving deployment ID: ' + error.message);
            deploymentId = 'AKfycbxPMikpb1W7qHCYwuIfx1696rU-rsnZka_SRhdSL6x8r8EnhRVbwQ1Kofdjm8jIFcaL';
            scriptProperties.setProperty(DEPLOYMENT_ID_PROPERTY, deploymentId);
            Logger.log('Stored default deployment ID due to error: ' + deploymentId);
        }
    }
    Logger.log('Returning deployment ID: ' + deploymentId);
    return deploymentId;
}

function clearDeploymentId() {
    PropertiesService.getScriptProperties().deleteProperty('DEPLOYMENT_ID');
    Logger.log('Cleared DEPLOYMENT_ID_PROPERTY');
}

/**
 * SECTION 3: Context and Persona Configuration
 * Determines the execution context (dev, add-on, or web) and generates configuration for subsequent functions.
 */
function personas(e, context) {
    Logger.log('personas called with event: ' + JSON.stringify(e || 'null') + ', context: ' + context);
    const config = {
        mode: 'addon',
        sheetId: null,
        sheetName: null,
        defaultTask: null,
        rowIndex: DEFAULT_ROW_INDEX,
        isWebAppContext: false,
        errorHandler: 'alert',
        userEmail: Session.getEffectiveUser().getEmail() || 'anonymous_' + new Date().getTime(),
        sessionId: SESSION_ID_PREFIX + Utilities.getUuid()
    };
    try {
        const scriptProperties = PropertiesService.getScriptProperties();
        const serviceUrl = ScriptApp.getService().getUrl();
        const isDevMode = serviceUrl.includes('/dev');

        if (e && e.parameter && e.parameter.sheetId) {
            config.mode = 'web';
            config.isWebAppContext = true;
            config.errorHandler = 'confirm';
            config.sheetId = e.parameter.sheetId;
            config.sessionId = e.parameter.sessionId || config.sessionId;
            Logger.log('Web app mode - sheetId: ' + config.sheetId + ', sessionId: ' + config.sessionId);
            const ss = SpreadsheetApp.openById(config.sheetId);
            scriptProperties.setProperty('LAST_SPREADSHEET_ID', config.sheetId);
            const createdBy = scriptProperties.getProperty('createdBy');
            if (createdBy && createdBy !== config.userEmail) {
                Logger.log('Warning: Spreadsheet created by ' + createdBy + ', current user: ' + config.userEmail);
            }
            config.sheetName = ESTIMATION_DATA_SHEET_NAME;
        } else if (isDevMode || context === 'dev') {
            config.mode = 'dev';
            Logger.log('Development mode - running from Apps Script editor or dev URL');
            let ss = SpreadsheetApp.getActiveSpreadsheet();
            if (!ss) {
                Logger.log('Error: No active spreadsheet found in dev mode, attempting to use last known sheet ID');
                const lastSheetId = scriptProperties.getProperty('LAST_SPREADSHEET_ID') || '1VAIlRRqiIOdWe6wwIdKqNeQKfWlbIIEdjLA8ZzIxOqI';
                try {
                    ss = SpreadsheetApp.openById(lastSheetId);
                    Logger.log('Successfully opened spreadsheet by ID: ' + lastSheetId);
                } catch (fallbackError) {
                    Logger.log('Error: Failed to open last known spreadsheet: ' + fallbackError.message);
                    throw new Error('No active spreadsheet found. Please run the script from within a Google Sheet.');
                }
            }
            config.sheetId = ss.getId();
            scriptProperties.setProperty('LAST_SPREADSHEET_ID', config.sheetId);
            Logger.log('Spreadsheet ID: ' + config.sheetId);
            const activeSheet = SpreadsheetApp.getActiveSheet();
            if (!activeSheet) {
                Logger.log('Error: No active sheet found');
                throw new Error('No active sheet found. Please select a sheet with task data.');
            }
            config.sheetName = activeSheet.getName();
            Logger.log('Active Sheet: ' + config.sheetName);
        } else {
            config.mode = 'addon';
            Logger.log('Add-on mode - running from Google Sheets add-on');
            let ss = SpreadsheetApp.getActiveSpreadsheet();
            if (!ss) {
                Logger.log('Error: No active spreadsheet found in add-on mode, attempting to use last known sheet ID');
                const lastSheetId = scriptProperties.getProperty('LAST_SPREADSHEET_ID') || '1VAIlRRqiIOdWe6wwIdKqNeQKfWlbIIEdjLA8ZzIxOqI';
                try {
                    ss = SpreadsheetApp.openById(lastSheetId);
                    Logger.log('Successfully opened spreadsheet by ID: ' + lastSheetId);
                } catch (fallbackError) {
                    Logger.log('Error: Failed to open last known spreadsheet: ' + fallbackError.message);
                    throw new Error('No active spreadsheet found. Please run the script from within a Google Sheet.');
                }
            }
            config.sheetId = ss.getId();
            scriptProperties.setProperty('LAST_SPREADSHEET_ID', config.sheetId);
            Logger.log('Spreadsheet ID: ' + config.sheetId);
            const activeSheet = SpreadsheetApp.getActiveSheet();
            if (!activeSheet) {
                Logger.log('Error: No active sheet found');
                throw new Error('No active sheet found. Please select a sheet with task data.');
            }
            config.sheetName = activeSheet.getName();
            Logger.log('Active Sheet: ' + config.sheetName);
        }

        // Handle defaultTask for showPlot in all modes
        if (context === 'showPlot' || context === 'showPlotWeb' || context === 'dev' || context === 'addon') {
            const ss = SpreadsheetApp.openById(config.sheetId);
            let activeSheet = SpreadsheetApp.getActiveSheet();
            let activeRowIndex = DEFAULT_ROW_INDEX;
            let taskName = null;
            let bestCase, mostLikely, worstCase;

            if (activeSheet && (activeSheet.getName() === ESTIMATION_DATA_SHEET_NAME || activeSheet.getName() === ESTIMATE_CALCULATIONS_SHEET_NAME)) {
                const activeRange = activeSheet.getActiveRange();
                activeRowIndex = activeRange ? activeRange.getRow() : DEFAULT_ROW_INDEX;
                if (activeRowIndex < DEFAULT_ROW_INDEX) activeRowIndex = DEFAULT_ROW_INDEX;
                const activeRowData = activeSheet.getRange(activeRowIndex, 1, 1, 4).getValues()[0];
                taskName = activeRowData[0]?.toString().trim();
                bestCase = parseFloat(activeRowData[1]);
                mostLikely = parseFloat(activeRowData[2]);
                worstCase = parseFloat(activeRowData[3]);
                if (taskName && Number.isFinite(bestCase) && Number.isFinite(mostLikely) && Number.isFinite(worstCase) &&
                    bestCase < mostLikely && mostLikely < worstCase) {
                    config.defaultTask = taskName;
                    config.rowIndex = activeRowIndex;
                    Logger.log(`Selected valid task from active row ${activeRowIndex}: ${taskName}`);
                }
            }

            if (!config.defaultTask) {
                const estimationSheet = ss.getSheetByName(ESTIMATION_DATA_SHEET_NAME) || ss.getSheets()[0];
                const data = estimationSheet.getDataRange().getValues();
                for (let i = 1; i < data.length; i++) {
                    const row = data[i];
                    taskName = row[0]?.toString().trim();
                    bestCase = parseFloat(row[1]);
                    mostLikely = parseFloat(row[2]);
                    worstCase = parseFloat(row[3]);
                    if (taskName && Number.isFinite(bestCase) && Number.isFinite(mostLikely) && Number.isFinite(worstCase) &&
                        bestCase < mostLikely && mostLikely < worstCase) {
                        config.defaultTask = taskName;
                        config.rowIndex = i + 1;
                        Logger.log(`Defaulted to first viable task at row ${i + 1}: ${taskName}`);
                        break;
                    }
                }
                if (!config.defaultTask) {
                    Logger.log('Warning: No viable tasks found in Estimation Data sheet');
                    config.defaultTask = null;
                    config.rowIndex = DEFAULT_ROW_INDEX;
                }
            }
            config.sheetName = ESTIMATION_DATA_SHEET_NAME;
        }
        Logger.log('Config returned: ' + JSON.stringify(config));
        return config;
    } catch (error) {
        Logger.log('Error in personas: ' + error.message + '\nStack: ' + error.stack);
        throw error;
    }
}

/**
 * SECTION 4: Menu Setup
 * Creates the custom menu in Google Sheets for add-on functionality and validates sheet columns.
 */
function onOpen(e) {
    try {
        const ui = SpreadsheetApp.getUi();
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const activeSheet = SpreadsheetApp.getActiveSheet();
        const hasRequiredColumns = activeSheet && checkSheetColumns(activeSheet);
        const menu = ui.createAddonMenu();
        if (hasRequiredColumns) {
            menu.addItem('PERT', 'addPertColumnsWrapper')
                .addItem('PLOT', 'showPlotWrapper');
        } else {
            menu.addItem('PERT', 'showNoSheetError')
                .addItem('PLOT', 'showNoSheetError');
        }
        menu.addToUi();
        Logger.log('onOpen completed: Menu created with ' + (hasRequiredColumns ? 'PERT and PLOT options' : 'error options'));
    } catch (error) {
        Logger.log('Error in onOpen: ' + error.message + '\nStack: ' + error.stack);
    }
}

function checkSheetColumns(sheet) {
    try {
        const columnHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => h.toString().trim().toLowerCase());
        Logger.log(`checkSheetColumns: Sheet "${sheet.getName()}" headers: ${JSON.stringify(columnHeaders)}`);
        const requiredColumns = ['name', 'best case', 'best_case', 'most likely', 'most_likely', 'worst case', 'worst_case'];
        const foundColumns = requiredColumns.filter(col => columnHeaders.includes(col));
        const missingColumns = requiredColumns.filter(col => !columnHeaders.includes(col));
        const hasRequiredColumns = columnHeaders.includes('name') &&
                                  (columnHeaders.includes('best case') || columnHeaders.includes('best_case')) &&
                                  (columnHeaders.includes('most likely') || columnHeaders.includes('most_likely')) &&
                                  (columnHeaders.includes('worst case') || columnHeaders.includes('worst_case'));
        Logger.log(`checkSheetColumns: Found columns: ${JSON.stringify(foundColumns)}, Missing columns: ${JSON.stringify(missingColumns)}, Has required columns: ${hasRequiredColumns}`);
        if (!hasRequiredColumns) {
            Logger.log(`Error: Missing required columns. Expected: ${JSON.stringify(requiredColumns)}, Found: ${JSON.stringify(columnHeaders)}`);
        }
        return hasRequiredColumns;
    } catch (error) {
        Logger.log('Error in checkSheetColumns: ' + error.message + '\nStack: ' + error.stack);
        return false;
    }
}

function showNoSheetError() {
    try {
        SpreadsheetApp.getUi().alert('Error', `The active sheet must have columns: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case). Please ensure these columns exist with valid data.`, SpreadsheetApp.getUi().ButtonSet.OK);
    } catch (error) {
        Logger.log('Error in showNoSheetError: ' + error.message);
    }
}

/**
 * SECTION 5: PERT Calculations
 * Handles PERT calculations and sheet updates for the Add-on and Web Personas.
 */

/**
 * SECTION 5.1: Sidebar Management
 * Functions to display and update the status sidebar for user feedback during PERT calculations.
 */

/**
 * Displays the status sidebar in Google Sheets.
 */
function showStatusSidebar() {
    try {
        const html = HtmlService.createHtmlOutputFromFile('StatusSidebar')
            .setTitle('Processing Status')
            .setWidth(300);
        SpreadsheetApp.getUi().showSidebar(html);
        Logger.log('Displayed status sidebar');
        // Initialize status
        PropertiesService.getScriptProperties().setProperty('PERT_STATUS', JSON.stringify({ message: 'Initializing...', details: '', progress: 0 }));
    } catch (e) {
        Logger.log(`Error displaying sidebar: ${e.message}`);
        // Fallback: Write status to a cell
        try {
            const ss = SpreadsheetApp.getActiveSpreadsheet();
            const sheet = ss.getSheetByName(ESTIMATION_DATA_SHEET_NAME) || ss.getSheets()[0];
            sheet.getRange('A1').setValue('Error: Failed to display status sidebar. Check logs for details.')
                .setFontColor('#ff0000')
                .setBackground('#f5f7fa');
            Logger.log('Wrote fallback error status to sheet');
        } catch (fallbackError) {
            Logger.log(`Error writing fallback status to sheet: ${fallbackError.message}`);
        }
    }
}

/**
 * Updates the sidebar status by storing it in PropertiesService for client-side polling.
 * @param {string} message - The main status message.
 * @param {string} details - Additional details about the status.
 * @param {number} progress - Progress percentage (0-100).
 */
function updateSidebarStatus(message, details = '', progress = 0) {
    try {
        // Store status in PropertiesService for polling
        PropertiesService.getScriptProperties().setProperty('PERT_STATUS', JSON.stringify({ message, details, progress }));
        Logger.log(`Stored status: ${message}, Details: ${details}, Progress: ${progress}%`);
    } catch (e) {
        Logger.log(`Error storing status: ${e.message}`);
        // Fallback: Write status to a cell
        try {
            const ss = SpreadsheetApp.getActiveSpreadsheet();
            const sheet = ss.getSheetByName(ESTIMATION_DATA_SHEET_NAME) || ss.getSheets()[0];
            sheet.getRange('A1').setValue(`${message}: ${details}`)
                .setFontColor('#333333')
                .setBackground('#f5f7fa');
            Logger.log('Wrote fallback status to sheet');
        } catch (fallbackError) {
            Logger.log(`Error writing fallback status to sheet: ${fallbackError.message}`);
        }
    }
}

/**
 * Retrieves the current status for sidebar polling.
 * @returns {Object} The current status object with message, details, and progress.
 */
function getStatus() {
    const scriptProperties = PropertiesService.getScriptProperties();
    const status = scriptProperties.getProperty('PERT_STATUS') || '{}';
    try {
        return JSON.parse(status);
    } catch (e) {
        Logger.log(`Error parsing status: ${e.message}`);
        return { message: 'Error', details: 'Failed to fetch status', progress: 0 };
    }
}

/**
 * SECTION 5.2: PERT Calculation Wrapper
 * Initializes and orchestrates PERT calculations by calling addPertColumns with the appropriate configuration.
 */

/**
 * Wrapper function to initiate PERT calculations and display status updates.
 */
function addPertColumnsWrapper() {
    Logger.log('addPertColumnsWrapper called');
    try {
        const config = personas(null, 'addPertColumnsWrapper');
        if (!config) {
            Logger.log('Error: personas returned null or undefined config');
            showStatusSidebar();
            updateSidebarStatus('Error', 'Failed to initialize configuration. Please ensure you are running the script from a Google Sheet with valid data.', 0);
            return;
        }
        // Force sheetName to ESTIMATION_DATA_SHEET_NAME for input data
        config.sheetName = ESTIMATION_DATA_SHEET_NAME;
        Logger.log('addPertColumnsWrapper config: ' + JSON.stringify(config));
        if (!config.sheetId) {
            Logger.log('Error: No active spreadsheet found in addPertColumnsWrapper');
            showStatusSidebar();
            updateSidebarStatus('Error', 'No active spreadsheet found. Please open a spreadsheet with task data.', 0);
            return;
        }
        showStatusSidebar();
        updateSidebarStatus('Processing...', 'Starting PERT calculations...', 0);
        const result = addPertColumns(config);
        if (result.status === 'error') {
            Logger.log('addPertColumnsWrapper errors: ' + result.errors.join('; '));
            updateSidebarStatus('Completed with Errors', result.message + '\nCheck the "Error Log" sheet for details.', 100);
        } else {
            Logger.log('addPertColumnsWrapper completed successfully');
            updateSidebarStatus('Completed', 'PERT calculations completed successfully.', 100);
        }
    } catch (error) {
        Logger.log('Error in addPertColumnsWrapper: ' + error.message + '\nStack: ' + error.stack);
        showStatusSidebar();
        updateSidebarStatus('Error', 'Failed to process PERT calculations: ' + error.message + '\nCheck the "Error Log" sheet for details if available.', 100);
    }
}

/**
 * SECTION 5.3: Core PERT Calculations
 * Performs data validation, API calls, and sheet updates for PERT calculations.
 */

/**
 * Processes PERT calculations by validating input data, calling the estimator API, and writing results to the Estimate Calculations sheet.
 * @param {Object} config - Configuration object containing sheetId and sheetName.
 * @returns {Object} Result object with status, errors, and message.
 */
function addPertColumns(config) {
    Logger.log('addPertColumns called with config: ' + JSON.stringify(config || 'undefined'));
    if (typeof config === 'undefined') {
        Logger.log('Error: addPertColumns called directly without config. Please use the "PERT" menu item in the Google Sheet.');
        throw new Error('addPertColumns must be called via the "PERT" menu item. Please run the script from a Google Sheet with valid data.');
    }
    const startTime = Date.now();
    const EXECUTION_TIMEOUT_MS = 300000; // 5 minutes
    const RETRY_DELAY_MS = 3000; // Increased to 3 seconds
    const errors = [];
    let output = { status: 'success', errors: [], message: '' };
    let errorRows = [];
    let ss;
    let calcSheet; // Define calcSheet at function scope for finally block
    try {
        if (!config || typeof config !== 'object') {
            errors.push('Invalid or missing config object');
            Logger.log('Error: Invalid or missing config object');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: Invalid or missing config object';
            updateSidebarStatus('Error', output.message, 0);
            return output;
        }
        if (!config.sheetId) {
            errors.push('No spreadsheet ID provided');
            Logger.log('Error: No spreadsheet ID provided');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: No spreadsheet ID provided';
            updateSidebarStatus('Error', output.message, 0);
            return output;
        }

        // Retry spreadsheet access
        updateSidebarStatus('Processing...', 'Accessing spreadsheet...', 10);
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                ss = SpreadsheetApp.openById(config.sheetId);
                Logger.log('Successfully accessed spreadsheet: ' + config.sheetId);
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to access spreadsheet: ${e.message}`);
                if (attempt === 3) {
                    throw new Error(`Failed to access spreadsheet after 3 attempts: ${e.message}`);
                }
                Utilities.sleep(RETRY_DELAY_MS);
            }
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while accessing spreadsheet');
            }
        }

        const sheet = ss.getSheetByName(config.sheetName) || ss.getSheets()[0];
        if (!sheet) {
            errors.push(`Sheet "${config.sheetName}" not found`);
            Logger.log(`Error: Sheet "${config.sheetName}" not found`);
            output.status = 'error';
            output.errors = errors;
            output.message = `Failed to process: Sheet "${config.sheetName}" not found`;
            updateSidebarStatus('Error', output.message, 10);
            return output;
        }
        if (!checkSheetColumns(sheet)) {
            errors.push('Sheet must have columns: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case)');
            Logger.log('Error: Sheet missing required columns');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: Sheet must have columns: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case)';
            updateSidebarStatus('Error', output.message, 10);
            return output;
        }

        // Batch read data
        updateSidebarStatus('Processing...', 'Reading sheet data...', 20);
        const data = sheet.getDataRange().getValues();
        Logger.log(`Sheet data (first two rows): ${JSON.stringify(data.slice(0, 2))}`);
        if (data.length < 2) {
            errors.push('No task data found in sheet');
            Logger.log('Error: No task data found in sheet');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: No task data found in sheet';
            updateSidebarStatus('Error', output.message, 20);
            return output;
        }

        const columnHeaders = data[0].map(h => h.toString().trim().toLowerCase());
        Logger.log(`addPertColumns: Column headers: ${JSON.stringify(columnHeaders)}`);
        const nameCol = columnHeaders.indexOf('name');
        const bestCaseCol = columnHeaders.indexOf('best case') !== -1 ? columnHeaders.indexOf('best case') : columnHeaders.indexOf('best_case');
        const mostLikelyCol = columnHeaders.indexOf('most likely') !== -1 ? columnHeaders.indexOf('most likely') : columnHeaders.indexOf('most_likely');
        const worstCaseCol = columnHeaders.indexOf('worst case') !== -1 ? columnHeaders.indexOf('worst case') : columnHeaders.indexOf('worst_case');
        const selectedCol = columnHeaders.indexOf('selected for plot') !== -1 ? columnHeaders.indexOf('selected for plot') : -1;
        if (nameCol === -1 || bestCaseCol === -1 || mostLikelyCol === -1 || worstCaseCol === -1) {
            errors.push(`Required columns missing: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case). Found: ${JSON.stringify(columnHeaders)}`);
            Logger.log('Error: Required columns missing');
            output.status = 'error';
            output.errors = errors;
            output.message = `Failed to process: Required columns missing: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case). Found: ${JSON.stringify(columnHeaders)}`;
            updateSidebarStatus('Error', output.message, 20);
            return output;
        }

        const tasks = [];
        let selectedForPlotCount = 0;
        let selectedTaskIndex = -1;
        updateSidebarStatus('Processing...', 'Validating tasks...', 30);
        for (let i = 1; i < data.length; i++) {
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while validating tasks');
            }
            const progress = 30 + ((i / (data.length - 1)) * 30); // Progress from 30% to 60%
            updateSidebarStatus('Processing...', `Validating task ${i} of ${data.length - 1}...`, progress);
            const row = data[i];
            const name = row[nameCol]?.toString().trim();
            const bestCase = parseFloat(row[bestCaseCol]);
            const mostLikely = parseFloat(row[mostLikelyCol]);
            const worstCase = parseFloat(row[worstCaseCol]);
            const selectedForPlot = selectedCol !== -1 ? (row[selectedCol] === true || row[selectedCol] === 'TRUE') : false;
            if (!name && (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase))) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                Logger.log(`Row ${i + 1} is empty, filling with N/A`); // FIXED: Corrected quote mismatch
                continue;
            }
            if (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase)) {
                errors.push(`Invalid numeric inputs at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([i + 1, `Invalid numeric inputs: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Invalid numeric inputs at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            if (bestCase >= mostLikely || mostLikely >= worstCase) {
                errors.push(`Invalid estimate order at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([i + 1, `Invalid estimate order: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Invalid estimate order at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            if (bestCase === mostLikely || mostLikely === worstCase) {
                errors.push(`Estimates too close at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([i + 1, `Estimates too close: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Estimates too close at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            const range = worstCase - bestCase;
            const minRange = mostLikely * MIN_RANGE_MULTIPLIER;
            if (range < minRange) {
                errors.push(`Estimate range too small at row ${i + 1}: range=${range}, minRange=${minRange}`);
                errorRows.push([i + 1, `Estimate range too small: range=${range}, minRange=${minRange}`]);
                Logger.log(`Error: Estimate range too small at row ${i + 1}: range=${range}, minRange=${minRange}`);
                continue;
            }
            tasks.push({
                task: name || `Task_${i}`,
                optimistic: bestCase * 1.0,
                mostLikely: mostLikely * 1.0,
                pessimistic: worstCase * 1.0,
                budgetFlexibility: 0.0,
                scheduleFlexibility: 0.0,
                scopeCertainty: 0.0,
                qualityTolerance: 0.0,
                targetValue: bestCase * 1.0,
                confidenceLevel: 0.9,
                targetProbabilityOnly: false,
                optimizeFor: 'target'
            });
            if (selectedForPlot) {
                selectedForPlotCount++;
                selectedTaskIndex = i;
            }
        }
        if (selectedForPlotCount > 1) {
            errors.push('Only one task can be selected for plotting');
            Logger.log('Error: Multiple tasks selected for plotting');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: Only one task can be selected for plotting';
            updateSidebarStatus('Error', output.message, 60);
            return output;
        }
        if (tasks.length === 0) {
            errors.push('No valid tasks found after validation');
            Logger.log('Error: No valid tasks found');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: No valid tasks found';
            updateSidebarStatus('Error', output.message, 60);
            return output;
        }

        // Call API without caching
        updateSidebarStatus('Processing...', 'Calling API for calculations...', 60);
        let apiResponse;
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                apiResponse = callEstimatorAPI(tasks);
                if (!apiResponse || !apiResponse.results || !Array.isArray(apiResponse.results)) {
                    throw new Error('API response missing or invalid "results" array');
                }
                Logger.log('API response data received with ' + apiResponse.results.length + ' results');
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to call API: ${e.message}`);
                if (attempt === 3) {
                    errors.push('API call failed after 3 attempts: ' + e.message);
                    output.status = 'error';
                    output.errors = errors;
                    output.message = 'Failed to process: API call failed after 3 attempts';
                    updateSidebarStatus('Error', output.message, 60);
                    return output;
                }
                Utilities.sleep(RETRY_DELAY_MS);
            }
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while calling API');
            }
        }

        // Create or update calculation sheet
        updateSidebarStatus('Processing...', 'Creating calculation sheet...', 70);
        calcSheet = ss.getSheets().find(s => s.getName().toLowerCase() === ESTIMATE_CALCULATIONS_SHEET_NAME.toLowerCase());
        if (calcSheet) {
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    ss.deleteSheet(calcSheet);
                    Logger.log('Deleted existing "Estimate Calculations" sheet');
                    break;
                } catch (e) {
                    Logger.log(`Attempt ${attempt} failed to delete "Estimate Calculations" sheet: ${e.message}`);
                    if (attempt === 3) {
                        throw new Error(`Failed to delete "Estimate Calculations" sheet after 3 attempts: ${e.message}`);
                    }
                    Utilities.sleep(RETRY_DELAY_MS);
                }
                if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                    throw new Error('Operation timed out while deleting calculation sheet');
                }
            }
        }
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                calcSheet = ss.insertSheet(ESTIMATE_CALCULATIONS_SHEET_NAME);
                Logger.log('Created new "Estimate Calculations" sheet');
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to create "Estimate Calculations" sheet: ${e.message}`);
                if (attempt === 3) {
                    throw new Error(`Failed to create "Estimate Calculations" sheet after 3 attempts: ${e.message}`);
                }
                Utilities.sleep(RETRY_DELAY_MS);
            }
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while creating calculation sheet');
            }
        }

        // Batch write headers and descriptions
        updateSidebarStatus('Processing...', 'Writing headers to calculation sheet...', 80);
        const calcHeaders = [
            'Name',
            'PERT Mean',
            'MC On Beta Smoothed 90th Percentile Confidence'
        ];
        const headerDescriptions = [
            'Task name or identifier.',
            'Weighted average (PERT).',
            'Smoothed Monte Carlo 90th Percentile Confidence Interval: The range within which the task value (e.g., cost, duration) is expected to fall with 90% confidence, based on smoothed Monte Carlo simulations using a Beta distribution. Use the lower bound for conservative planning and the upper bound for worst-case budgeting to manage risks.'
        ];
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                // Batch write headers, descriptions, and formatting
                calcSheet.getRange(1, 1, 2, calcHeaders.length).setValues([calcHeaders, headerDescriptions]);
                calcSheet.getRange(1, 2, 1, 2).setBackground('#d1e7dd'); // Highlight headers
                calcSheet.getRange(2, 1, 1, calcHeaders.length)
                    .setFontColor('#666666') // Style descriptions
                    .setWrap(true) // Enable word-wrap for descriptions
                    .setVerticalAlignment('top'); // Align text to top for better readability
                calcSheet.setRowHeight(2, 100); // Set row height to 100 pixels
                calcSheet.setColumnWidth(1, 340); // NEW: Set column A to 340 pixels
                calcSheet.setColumnWidth(2, 340); // NEW: Set column B to 340 pixels
                calcSheet.setColumnWidth(3, 340); // NEW: Set column C to 340 pixels
                Logger.log('Successfully wrote headers and descriptions with word-wrap, set row height to 100 pixels, and set first three columns to 340 pixels'); // UPDATED: Logger message
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to write headers to "Estimate Calculations" sheet: ${e.message}`);
                if (attempt === 3) {
                    // Fallback: Write minimal headers without formatting
                    try {
                        calcSheet.getRange(1, 1, 1, calcHeaders.length).setValues([calcHeaders]);
                        calcSheet.setColumnWidth(1, 340); // NEW: Set column A to 340 pixels
                        calcSheet.setColumnWidth(2, 340); // NEW: Set column B to 340 pixels
                        calcSheet.setColumnWidth(3, 340); // NEW: Set column C to 340 pixels
                        Logger.log('Wrote minimal headers and set first three columns to 340 pixels as fallback'); // UPDATED: Logger message
                    } catch (fallbackError) {
                        Logger.log(`Fallback header write failed: ${fallbackError.message}`);
                    }
                    errors.push(`Failed to write headers to "Estimate Calculations" sheet after 3 attempts: ${e.message}`);
                    output.status = 'error';
                    output.errors = errors;
                    output.message = 'Failed to process: Unable to write headers due to timeout. Please try again.';
                    updateSidebarStatus('Error', output.message, 80);
                    return output;
                }
                Utilities.sleep(RETRY_DELAY_MS);
            }
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while writing headers');
            }
        }

        // Process and write data rows in batches
        updateSidebarStatus('Processing...', 'Writing data to calculation sheet...', 90);
        const dataRows = [];
        for (let i = 1; i < data.length; i++) {
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while processing data rows');
            }
            const progress = 90 + ((i / (data.length - 1)) * 5); // Progress from 90% to 95%
            updateSidebarStatus('Processing...', `Processing task ${i} of ${data.length - 1}...`, progress);
            const originalRowIndex = i + 1;
            const row = data[i];
            const name = row[nameCol]?.toString().trim();
            const bestCase = parseFloat(row[bestCaseCol]);
            const mostLikely = parseFloat(row[mostLikelyCol]);
            const worstCase = parseFloat(row[worstCaseCol]);
            if (!name && (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase))) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                Logger.log(`Row ${originalRowIndex} is empty, filling with N/A`); // FIXED: Corrected quote mismatch
                continue;
            }
            if (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase)) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`Invalid numeric inputs at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([originalRowIndex, `Invalid numeric inputs: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Invalid numeric inputs at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            if (bestCase >= mostLikely || mostLikely >= worstCase) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`Invalid estimate order at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([originalRowIndex, `Invalid estimate order: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Invalid estimate order at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            if (bestCase === mostLikely || mostLikely === worstCase) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`Estimates too close at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([originalRowIndex, `Estimates too close: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Estimates too close at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            const range = worstCase - bestCase;
            const minRange = mostLikely * MIN_RANGE_MULTIPLIER;
            if (range < minRange) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`Estimate range too small at row ${originalRowIndex}: range=${range}, minRange=${minRange}`);
                errorRows.push([originalRowIndex, `Estimate range too small: range=${range}, minRange=${minRange}`]);
                Logger.log(`Error: Estimate range too small at row ${originalRowIndex}: range=${range}, minRange=${minRange}`);
                continue;
            }
            const resultIndex = tasks.findIndex(task => task.task === (name || `Task_${i}`));
            if (resultIndex === -1 || !apiResponse.results[resultIndex]) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`No API results for task at row ${originalRowIndex}: ${name || `Task_${i}`}`);
                errorRows.push([originalRowIndex, `No API results for task: ${name || `Task_${i}`}`]);
                Logger.log(`Error: No API results for task at row ${originalRowIndex}`);
                continue;
            }
            const result = apiResponse.results[resultIndex];
            const rowData = [
                result.task?.value || name || `Task_${i}`,
                result.pertMean?.value || 'N/A',
                result.mcSmoothedConfidenceInterval?.value ? `[${result.mcSmoothedConfidenceInterval.value.lower.toFixed(2)}, ${result.mcSmoothedConfidenceInterval.value.upper.toFixed(2)}]` : 'N/A'
            ];
            dataRows.push(rowData);
            Logger.log(`Processed row ${originalRowIndex} with data: ${JSON.stringify(rowData)}`);
        }

        // Write data rows with retry
        if (dataRows.length > 0) {
            updateSidebarStatus('Processing...', 'Writing data to calculation sheet...', 95);
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    calcSheet.getRange(3, 1, dataRows.length, calcHeaders.length).setValues(dataRows);
                    calcSheet.getRange(3, 2, dataRows.length, 2).setBackground('#d1e7dd');
                    calcSheet.getRange(3, 1, dataRows.length, calcHeaders.length).setWrap(true);
                    Logger.log('Successfully wrote data rows');
                    break;
                } catch (e) {
                    Logger.log(`Attempt ${attempt} failed to write data to "Estimate Calculations" sheet: ${e.message}`);
                    if (attempt === 3) {
                        errors.push(`Failed to write data to "Estimate Calculations" sheet after 3 attempts: ${e.message}`);
                        output.status = 'error';
                        output.errors = errors;
                        output.message = 'Failed to process: Unable to write data due to timeout. Please try again.';
                        updateSidebarStatus('Error', output.message, 95);
                        return output;
                    }
                    Utilities.sleep(RETRY_DELAY_MS);
                }
                if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                    throw new Error('Operation timed out while writing data rows');
                }
            }
        }

        // Create and write to Error Log sheet only if errors exist
        if (errorRows.length > 0) {
            updateSidebarStatus('Processing...', 'Writing error log...', 98);
            let errorSheet = ss.getSheets().find(s => s.getName().toLowerCase() === 'Error Log'.toLowerCase());
            if (errorSheet) {
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        ss.deleteSheet(errorSheet);
                        Logger.log('Deleted existing "Error Log" sheet');
                        break;
                    } catch (e) {
                        Logger.log(`Attempt ${attempt} failed to delete "Error Log" sheet: ${e.message}`);
                        if (attempt === 3) {
                            throw new Error(`Failed to delete "Error Log" sheet after 3 attempts: ${e.message}`);
                        }
                        Utilities.sleep(RETRY_DELAY_MS);
                    }
                    if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                        throw new Error('Operation timed out while deleting error log sheet');
                    }
                }
            }
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    errorSheet = ss.insertSheet('Error Log');
                    Logger.log('Created new "Error Log" sheet');
                    errorSheet.getRange(1, 1, 1, 2).setValues([['Row', 'Error Message']]).setFontWeight('bold');
                    errorSheet.getRange(2, 1, errorRows.length, 2).setValues(errorRows);
                    errorSheet.getRange(1, 1, errorRows.length + 1, 2).setWrap(true);
                    Logger.log('Successfully wrote error log');
                    break;
                } catch (e) {
                    Logger.log(`Attempt ${attempt} failed to write to "Error Log" sheet: ${e.message}`);
                    if (attempt === 3) {
                        throw new Error(`Failed to write to "Error Log" sheet after 3 attempts: ${e.message}`);
                    }
                    Utilities.sleep(RETRY_DELAY_MS);
                }
                if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                    throw new Error('Operation timed out while writing error log');
                }
            }
        }

        output.message = 'Successfully processed PERT calculations';
        if (errors.length > 0) {
            output.status = 'error';
            output.errors = errors;
            output.message = 'Processed with errors: ' + errors.join('; ');
            updateSidebarStatus('Completed with Errors', output.message + '\nCheck the "Error Log" sheet for details.', 100);
        } else {
            updateSidebarStatus('Completed', 'PERT calculations completed successfully.', 100);
        }
        if (config.isWebAppContext && errors.length > 0) {
            Logger.log('Web app context with errors: ' + errors.join('; '));
            output.message += '\nSome rows were invalid and marked as N/A. Check the "Error Log" sheet.';
            updateSidebarStatus('Completed with Errors', output.message, 100);
        }
        Logger.log('addPertColumns completed: ' + output.message);
        return output;
    } catch (error) {
        Logger.log('Error in addPertColumns: ' + error.message + '\nStack: ' + error.stack);
        output.status = 'error';
        output.errors.push(error.message);
        output.message = 'Failed to process PERT calculations: ' + error.message + '. Please check spreadsheet access and try again.';
        if (errorRows.length > 0 && ss) {
            let errorSheet = ss.getSheets().find(s => s.getName().toLowerCase() === 'Error Log'.toLowerCase());
            if (errorSheet) {
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        ss.deleteSheet(errorSheet);
                        Logger.log('Deleted existing "Error Log" sheet due to error');
                        break;
                    } catch (e) {
                        Logger.log(`Attempt ${attempt} failed to delete "Error Log" sheet: ${e.message}`);
                        if (attempt === 3) {
                            throw new Error(`Failed to delete "Error Log" sheet after 3 attempts: ${e.message}`);
                        }
                        Utilities.sleep(RETRY_DELAY_MS);
                    }
                    if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                        throw new Error('Operation timed out while deleting error log sheet due to error');
                    }
                }
            }
            if (ss) {
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        errorSheet = ss.insertSheet('Error Log');
                        Logger.log('Created new "Error Log" sheet due to error');
                        errorSheet.getRange(1, 1, 1, 2).setValues([['Row', 'Error Message']]).setFontWeight('bold');
                        errorRows.push([0, `General error: ${error.message}`]);
                        errorSheet.getRange(2, 1, errorRows.length, 2).setValues(errorRows);
                        errorSheet.getRange(1, 1, errorRows.length + 1, 2).setWrap(true);
                        Logger.log('Successfully wrote error log due to error');
                        break;
                    } catch (e) {
                        Logger.log(`Attempt ${attempt} failed to write to "Error Log" sheet: ${e.message}`);
                        if (attempt === 3) {
                            throw new Error(`Failed to write to "Error Log" sheet after 3 attempts: ${e.message}`);
                        }
                        Utilities.sleep(RETRY_DELAY_MS);
                    }
                    if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                        throw new Error('Operation timed out while writing error log due to error');
                    }
                }
            } else {
                Logger.log('Error: Spreadsheet object (ss) not defined, cannot create Error Log sheet');
            }
        }
        updateSidebarStatus('Error', output.message + '\nCheck the "Error Log" sheet for details if available.', 100);
        return output;
    } finally {
        // Clear status to prevent stale data
        PropertiesService.getScriptProperties().deleteProperty('PERT_STATUS');
        // Activate the Estimate Calculations sheet if created
        if (calcSheet) {
            try {
                SpreadsheetApp.getActiveSpreadsheet().setActiveSheet(calcSheet);
                SpreadsheetApp.flush(); // NEW: Ensure changes are applied immediately
                Logger.log('Activated "Estimate Calculations" sheet and applied changes');
            } catch (e) {
                Logger.log(`Error activating "Estimate Calculations" sheet: ${e.message}`);
            }
        }
    }
}

/**
 * SECTION 6: API Interaction
 * Handles secure API calls to pmcEstimatorAPI with JWT authentication.
 */
function callEstimatorAPI(tasks) {
    const startTime = Date.now();
    const lock = LockService.getScriptLock();
    try {
        if (!lock.tryLock(10000)) {
            Logger.log('Error: API is busy, please try again later.');
            throw new Error('API is busy, please try again later.');
        }
        if (!Array.isArray(tasks) || tasks.length === 0) {
            Logger.log('Error: tasks must be a non-empty array');
            throw new Error('Tasks must be a non-empty array');
        }
        tasks.forEach((task, i) => {
            if (!task.task || 
                typeof task.optimistic !== 'number' || !isFinite(task.optimistic) ||
                typeof task.mostLikely !== 'number' || !isFinite(task.mostLikely) ||
                typeof task.pessimistic !== 'number' || !isFinite(task.pessimistic) ||
                (task.targetValue !== undefined && (typeof task.targetValue !== 'number' || !isFinite(task.targetValue)))) {
                Logger.log(`Invalid task data at index ${i}: ${JSON.stringify(task)}`);
                throw new Error(`Invalid task data at index ${i}: All task estimates and targetValue (if provided) must be finite numbers`);
            }
        });
        const keyJsonString = PropertiesService.getScriptProperties().getProperty(SERVICE_ACCOUNT_KEY_NAME);
        if (!keyJsonString) {
            Logger.log('Error: Script property "' + SERVICE_ACCOUNT_KEY_NAME + '" not found. Please set it in Project Settings > Script Properties with your service account key JSON.');
            throw new Error('Script property "' + SERVICE_ACCOUNT_KEY_NAME + '" not found. Please set it in Project Settings > Script Properties with your service account key JSON.');
        }
        let keyJson;
        try {
            keyJson = JSON.parse(keyJsonString);
        } catch (e) {
            Logger.log('Error parsing ' + SERVICE_ACCOUNT_KEY_NAME + ': ' + e.message);
            throw new Error('Failed to parse ' + SERVICE_ACCOUNT_KEY_NAME + ': ' + e.message);
        }
        if (!keyJson.client_email || !keyJson.private_key) {
            Logger.log('Error: Invalid ' + SERVICE_ACCOUNT_KEY_NAME + ' JSON; missing client_email or private_key');
            throw new Error('Invalid ' + SERVICE_ACCOUNT_KEY_NAME + ' JSON; missing client_email or private_key');
        }
        const now = Math.floor(Date.now() / 1000);
        const claimSet = {
            iss: keyJson.client_email,
            aud: TOKEN_ENDPOINT_URL,
            exp: now + 3600,
            iat: now,
            target_audience: API_URL
        };
        const header = { alg: 'RS256', typ: 'JWT' };
        const toSign = Utilities.base64EncodeWebSafe(JSON.stringify(header)) + '.' +
                       Utilities.base64EncodeWebSafe(JSON.stringify(claimSet));
        let token;
        try {
            const signature = Utilities.computeRsaSha256Signature(toSign, keyJson.private_key);
            const jwt = toSign + '.' + Utilities.base64EncodeWebSafe(signature);
            Logger.log('Generated JWT: [Redacted]');
            const response = UrlFetchApp.fetch(TOKEN_ENDPOINT_URL, {
                method: 'POST',
                contentType: 'application/x-www-form-urlencoded',
                payload: {
                    grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                    assertion: jwt
                },
                muteHttpExceptions: true,
                timeout: API_TIMEOUT_MS
            });
            if (Date.now() - startTime > API_TIMEOUT_MS) {
                Logger.log('Error: Token request timed out');
                throw new Error('Token request timed out');
            }
            Logger.log('Token endpoint response code: ' + response.getResponseCode());
            Logger.log('Token endpoint response: [Redacted]');
            if (response.getResponseCode() !== 200) {
                Logger.log('Token request failed: ' + response.getContentText());
                throw new Error('Failed to obtain token: ' + response.getContentText());
            }
            const tokenData = JSON.parse(response.getContentText());
            token = tokenData.id_token;
            Logger.log('Generated Token: [Redacted]');
        } catch (e) {
            Logger.log('Token generation failed: ' + e.message);
            throw new Error('Failed to obtain token: ' + e.message);
        }
        const options = {
            method: 'POST',
            contentType: 'application/json',
            headers: {
                'Authorization': 'Bearer ' + token
            },
            payload: JSON.stringify(tasks),
            muteHttpExceptions: true,
            timeout: API_TIMEOUT_MS
        };
        Logger.log('Calling API with ' + tasks.length + ' tasks');
        Logger.log('Payload: ' + JSON.stringify(tasks));
        const response = UrlFetchApp.fetch(API_URL, options);
        if (Date.now() - startTime > API_TIMEOUT_MS) {
            Logger.log('Error: API request timed out');
            throw new Error('API request timed out');
        }
        Logger.log('API response code: ' + response.getResponseCode());
        Logger.log('Full API response: ' + JSON.stringify(response.getContentText()));
        if (response.getResponseCode() !== 200) {
            Logger.log('API request failed: ' + response.getContentText());
            throw new Error('API request failed: ' + response.getContentText());
        }
        const responseData = JSON.parse(response.getContentText());
        Logger.log('API response data received with ' + (responseData.results ? responseData.results.length : 0) + ' results');
        return responseData;
    } catch (error) {
        Logger.log('Error in callEstimatorAPI: ' + error.message + '\nStack: ' + error.stack);
        throw error;
    } finally {
        if (lock.hasLock()) {
            lock.releaseLock();
        }
    }
}

/**
 * SECTION 7: Task Retrieval
 * Retrieves valid tasks from a specified sheet for processing or plotting.
 */
function getAllTasks(sheetId) {
    try {
        Logger.log('getAllTasks called with sheetId: ' + sheetId);
        if (!sheetId) {
            Logger.log('Error: No sheetId provided to getAllTasks');
            throw new Error('No spreadsheet ID provided');
        }
        const ss = SpreadsheetApp.openById(sheetId);
        const sheet = ss.getSheetByName(ESTIMATION_DATA_SHEET_NAME) || ss.getSheets()[0];
        Logger.log('Accessing sheet: ' + sheet.getName());
        const data = sheet.getDataRange().getValues();
        const tasks = [];
        let defaultTaskIndex = -1;
        for (let i = 1; i < data.length; i++) {
            const taskName = data[i][0]?.toString().trim();
            const optimistic = parseFloat(data[i][1]);
            const mostLikely = parseFloat(data[i][2]);
            const pessimistic = parseFloat(data[i][3]);
            if (taskName && Number.isFinite(optimistic) && Number.isFinite(mostLikely) && Number.isFinite(pessimistic) &&
                optimistic < mostLikely && mostLikely < pessimistic) {
                tasks.push({
                    task: taskName,
                    optimistic: optimistic,
                    mostLikely: mostLikely,
                    pessimistic: pessimistic,
                    selectedForPlot: i === DEFAULT_ROW_INDEX - 1
                });
                if (i === DEFAULT_ROW_INDEX - 1) {
                    defaultTaskIndex = tasks.length - 1;
                }
            }
        }
        Logger.log('Tasks retrieved: ' + JSON.stringify(tasks));
        return { tasks: tasks, defaultTaskIndex: defaultTaskIndex };
    } catch (error) {
        Logger.log('Error in getAllTasks: ' + error.message + '\nStack: ' + error.stack);
        return { error: error.message, tasks: [], defaultTaskIndex: -1 };
    }
}


/**
 * SECTION 8: Plot Data Fetching
 * Retrieves data for the Plot.html dashboard and opens the dashboard.
 */
function getProperties(sheetId, sheetName, rowIndex) {
    try {
        Logger.log(`getProperties called with sheetId: ${sheetId}, sheetName: ${sheetName}, rowIndex: ${rowIndex}`);
        if (typeof sheetId !== 'string' || !sheetId) {
            throw new Error('sheetId must be a non-empty string');
        }
        if (typeof sheetName !== 'string' || !sheetName) {
            throw new Error('sheetName must be a non-empty string');
        }
        if (typeof rowIndex !== 'number' || rowIndex < DEFAULT_ROW_INDEX || !Number.isInteger(rowIndex)) {
            throw new Error('rowIndex must be an integer >= ' + DEFAULT_ROW_INDEX);
        }

        // Retry spreadsheet access
        let spreadsheet;
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                spreadsheet = SpreadsheetApp.openById(sheetId);
                Logger.log('Successfully accessed spreadsheet: ' + sheetId);
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to access spreadsheet: ${e.message}`);
                if (attempt === 3) {
                    throw new Error(`Failed to access spreadsheet after 3 attempts: ${e.message}`);
                }
                Utilities.sleep(1000);
            }
        }

        const sheet = spreadsheet.getSheetByName(sheetName) || spreadsheet.getSheets()[0];
        if (!sheet) {
            throw new Error(`Sheet "${sheetName}" not found`);
        }
        const lastRow = sheet.getLastRow();
        if (rowIndex > lastRow) {
            throw new Error(`rowIndex ${rowIndex} exceeds sheet's last row: ${lastRow}`);
        }
        const columnHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => h.toString().trim().toLowerCase());
        Logger.log(`getProperties: Sheet "${sheet.getName()}" headers: ${JSON.stringify(columnHeaders)}`);
        const nameCol = columnHeaders.indexOf('name');
        const bestCaseCol = columnHeaders.indexOf('best case') !== -1 ? columnHeaders.indexOf('best case') : columnHeaders.indexOf('best_case');
        const mostLikelyCol = columnHeaders.indexOf('most likely') !== -1 ? columnHeaders.indexOf('most likely') : columnHeaders.indexOf('most_likely');
        const worstCaseCol = columnHeaders.indexOf('worst case') !== -1 ? columnHeaders.indexOf('worst case') : columnHeaders.indexOf('worst_case');
        if (nameCol === -1 || bestCaseCol === -1 || mostLikelyCol === -1 || worstCaseCol === -1) {
            throw new Error('Sheet must have columns: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case)');
        }
        const data = sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn()).getValues()[0];
        const name = data[nameCol]?.toString().trim();
        const bestCase = parseFloat(data[bestCaseCol]);
        const mostLikely = parseFloat(data[mostLikelyCol]);
        const worstCase = parseFloat(data[worstCaseCol]);
        if (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase)) {
            throw new Error(`Invalid numeric inputs at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
        }
        if (bestCase >= mostLikely || mostLikely >= worstCase) {
            throw new Error(`Invalid estimate order at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
        }
        if (bestCase === mostLikely || mostLikely === worstCase) {
            throw new Error(`Estimates too close at row ${rowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
        }
        const range = worstCase - bestCase;
        const minRange = mostLikely * MIN_RANGE_MULTIPLIER;
        if (range < minRange) {
            throw new Error(`Estimate range too small at row ${rowIndex}: range=${range}, minRange=${minRange}`);
        }
        const task = {
            task: name || 'Unnamed Task',
            optimistic: bestCase * 1.0,
            mostLikely: mostLikely * 1.0,
            pessimistic: worstCase * 1.0,
            budgetFlexibility: 0.0,
            scheduleFlexibility: 0.0,
            scopeCertainty: 0.0,
            qualityTolerance: 0.0,
            targetValue: bestCase * 1.0,
            confidenceLevel: 0.9,
            targetProbabilityOnly: false,
            optimizeFor: 'target'
        };
        Logger.log('Task object prepared for API: ' + JSON.stringify(task));
        const apiResponse = callEstimatorAPI([task]);
        if (!apiResponse || !apiResponse.results || !Array.isArray(apiResponse.results) || apiResponse.results.length === 0) {
            throw new Error('API response missing or invalid "results" array');
        }
        const result = apiResponse.results[0];
        Logger.log('API result for task: ' + result.task?.value);
        function getValue(field, fieldName) {
            const value = result[field]?.value;
            if (value === undefined || value === null || typeof value !== 'number' || isNaN(value)) {
                Logger.log(`Warning: ${fieldName} is invalid or missing (value: ${value}), defaulting to 0`);
                return 0;
            }
            return value;
        }
        function getPoints(field, fieldName) {
            const points = result[field]?.value;
            if (!Array.isArray(points) || points.length === 0) {
                Logger.log(`Warning: ${fieldName} is invalid or empty, defaulting to []`);
                return [];
            }
            if (!points.every(p => typeof p.x === 'number' && typeof p.y === 'number')) {
                Logger.log(`Warning: ${fieldName} contains invalid point format, defaulting to []`);
                return [];
            }
            return points;
        }
        const properties = {
            TASK_NAME: result.task?.value || 'Unnamed Task',
            MIN: getValue('bestCase', 'MIN'),
            MOST_LIKELY: getValue('mostLikely', 'MOST_LIKELY'),
            MAX: getValue('worstCase', 'MAX'),
            TRIANGLE_MEAN: getValue('triangleMean', 'TRIANGLE_MEAN'),
            TRIANGLE_VARIANCE: getValue('triangleVariance', 'TRIANGLE_VARIANCE'),
            TRIANGLE_STD: getValue('triangleStdDev', 'TRIANGLE_STD'),
            TRIANGLE_SKEWNESS: getValue('triangleSkewness', 'TRIANGLE_SKEWNESS'),
            TRIANGLE_KURTOSIS: getValue('triangleKurtosis', 'TRIANGLE_KURTOSIS'),
            TRIANGLE_POINTS: getPoints('trianglePoints', 'TRIANGLE_POINTS'),
            PERT_MEAN: getValue('pertMean', 'PERT_MEAN'),
            PERT_STD: getValue('pertStdDev', 'PERT_STD'),
            PERT_VARIANCE: getValue('pertVariance', 'PERT_VARIANCE'),
            PERT_SKEWNESS: getValue('pertSkewness', 'PERT_SKEWNESS'),
            PERT_KURTOSIS: getValue('pertKurtosis', 'PERT_KURTOSIS'),
            PERT_POINTS: getPoints('pertPoints', 'PERT_POINTS'),
            BETA_MEAN: getValue('betaMean', 'BETA_MEAN'),
            BETA_VARIANCE: getValue('betaVariance', 'BETA_VARIANCE'),
            BETA_SKEWNESS: getValue('betaSkewness', 'BETA_SKEWNESS'),
            BETA_KURTOSIS: getValue('betaKurtosis', 'BETA_KURTOSIS'),
            ALPHA: getValue('alpha', 'ALPHA'),
            BETA: getValue('beta', 'BETA'),
            BETA_MODE: getValue('betaMode', 'BETA_MODE'),
            BETA_POINTS: getPoints('betaPoints', 'BETA_POINTS'),
            MC_UNSMOOTHED_MEAN: getValue('mcMean', 'MC_UNSMOOTHED_MEAN'),
            MC_UNSMOOTHED_VARIANCE: getValue('mcVariance', 'MC_UNSMOOTHED_VARIANCE'),
            MC_UNSMOOTHED_SKEWNESS: getValue('mcSkewness', 'MC_UNSMOOTHED_SKEWNESS'),
            MC_UNSMOOTHED_KURTOSIS: getValue('mcKurtosis', 'MC_UNSMOOTHED_KURTOSIS'),
            MC_UNSMOOTHED_VaR_90: getValue('mcVaR', 'MC_UNSMOOTHED_VaR_90'),
            MC_UNSMOOTHED_CVaR_90: getValue('mcCVaR', 'MC_UNSMOOTHED_CVaR_90'),
            MC_UNSMOOTHED_MAD: getValue('mcMAD', 'MC_UNSMOOTHED_MAD'),
            MC_UNSMOOTHED_POINTS: getPoints('mcPoints', 'MC_UNSMOOTHED_POINTS'),
            MC_SMOOTHED_MEAN: getValue('mcSmoothedMean', 'MC_SMOOTHED_MEAN'),
            MC_SMOOTHED_VARIANCE: getValue('mcSmoothedVariance', 'MC_SMOOTHED_VARIANCE'),
            MC_SMOOTHED_SKEWNESS: getValue('mcSmoothedSkewness', 'MC_SMOOTHED_SKEWNESS'),
            MC_SMOOTHED_KURTOSIS: getValue('mcSmoothedKurtosis', 'MC_SMOOTHED_KURTOSIS'),
            MC_SMOOTHED_VaR_90: getValue('mcSmoothedVaR', 'MC_SMOOTHED_VaR_90'),
            MC_SMOOTHED_CVaR_90: getValue('mcSmoothedCVaR', 'MC_SMOOTHED_CVaR_90'),
            MC_SMOOTHED_MAD: getValue('mcSmoothedMAD', 'MC_SMOOTHED_MAD'),
            MC_SMOOTHED_POINTS: getPoints('mcSmoothedPoints', 'MC_SMOOTHED_POINTS'),
            WEIGHTED_CONSERVATIVE: getValue('weightedConservative', 'WEIGHTED_CONSERVATIVE'),
            WEIGHTED_NEUTRAL: getValue('weightedNeutral', 'WEIGHTED_NEUTRAL'),
            WEIGHTED_OPTIMISTIC: getValue('weightedOptimistic', 'WEIGHTED_OPTIMISTIC'),
            PROB_EXCEED_PERT_MEAN_BETA: getValue('probExceedPertMeanBeta', 'PROB_EXCEED_PERT_MEAN_BETA'),
            PROB_EXCEED_PERT_MEAN_MC_UNSMOOTHED: getValue('probExceedPertMeanMCUnsmoothed', 'PROB_EXCEED_PERT_MEAN_MC_UNSMOOTHED'),
            PROB_EXCEED_PERT_MEAN_MC_SMOOTHED: getValue('probExceedPertMeanMCSmoothed', 'PROB_EXCEED_PERT_MEAN_MC_SMOOTHED'),
            CDF_POINTS: getPoints('cdfPoints', 'CDF_POINTS'),
            TARGET_PROBABILITY_POINTS: getPoints('targetProbabilityPoints', 'TARGET_PROBABILITY_POINTS')
        };
        const requiredPointFields = [
            'TRIANGLE_POINTS', 'PERT_POINTS', 'BETA_POINTS',
            'MC_UNSMOOTHED_POINTS', 'MC_SMOOTHED_POINTS', 'CDF_POINTS',
            'TARGET_PROBABILITY_POINTS'
        ];
        requiredPointFields.forEach(field => {
            if (!properties[field] || properties[field].length === 0) {
                Logger.log(`Warning: ${field} is empty; plot may not render correctly`);
            }
        });
        Logger.log('Returning properties for task: ' + properties.TASK_NAME);
        return properties;
    } catch (error) {
        Logger.log('Error in getProperties: ' + error.message);
        throw error;
    }
}

function showPlotWrapper() {
    Logger.log('showPlotWrapper called');
    let config = null;
    try {
        config = personas(null, 'dev');
        Logger.log('showPlotWrapper config: ' + JSON.stringify(config));
        const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
        if (!spreadsheet) {
            Logger.log('Error: No active spreadsheet found in showPlotWrapper');
            throw new Error('No active spreadsheet found');
        }
        config.sheetId = config.sheetId || spreadsheet.getId();
        Logger.log('Successfully accessed spreadsheet in showPlotWrapper: ' + config.sheetId);
        const sheetName = spreadsheet.getActiveSheet().getName();
        config.sheetName = sheetName;
        Logger.log('Active Sheet: ' + sheetName);
        const tasksData = getAllTasks(config.sheetId);
        Logger.log('Tasks retrieved: ' + JSON.stringify(tasksData));
        
        // Handle both array and object responses from getAllTasks
        let tasks = Array.isArray(tasksData) ? tasksData : tasksData.tasks;
        if (!Array.isArray(tasks)) {
            Logger.log('Error: getAllTasks did not return a valid array');
            throw new Error('Invalid task data: expected an array');
        }
        if (tasks.length === 0) {
            Logger.log('Error: No tasks retrieved from getAllTasks');
            throw new Error('No tasks found in spreadsheet');
        }
        let defaultTaskIndex = tasks.findIndex(task => task.selectedForPlot);
        if (defaultTaskIndex === -1) {
            defaultTaskIndex = tasks.findIndex(task => isValidTask(task));
            if (defaultTaskIndex === -1) {
                Logger.log('Error: No valid tasks found');
                throw new Error('No valid tasks found in spreadsheet');
            }
            Logger.log('Defaulted to first viable task at row ' + (defaultTaskIndex + 2) + ': ' + tasks[defaultTaskIndex].task);
        }
        config.defaultTask = tasks[defaultTaskIndex].task;
        config.rowIndex = defaultTaskIndex + 2;
        const plotUrl = showPlot(config);
        Logger.log('showPlotWrapper received plotUrl: ' + plotUrl);
        if (config.mode === 'dev') {
            const html = HtmlService.createHtmlOutputFromFile('Plot')
                .setWidth(1200)
                .setHeight(900);
            html.setContent(
                '<script>' +
                'window.sheetId = ' + JSON.stringify(config.sheetId) + ';' +
                'window.sessionId = ' + JSON.stringify(config.sessionId) + ';' +
                'window.defaultTask = ' + JSON.stringify(config.defaultTask) + ';' +
                'window.GOOGLE_FONTS_URL = "https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap";' +
                'window.GOOGLE_CHARTS_URL = "https://www.google.com/jsapi";' +
                'window.MATHJAX_URL = "https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML";' +
                'window.CONFIG = ' + JSON.stringify(CONFIG) + ';' +
                'var link = document.createElement("link");' +
                'link.rel = "stylesheet";' +
                'link.href = window.GOOGLE_FONTS_URL;' +
                'link.onerror = () => console.error("Failed to load Google Fonts", { url: window.GOOGLE_FONTS_URL });' +
                'document.head.appendChild(link);' +
                'var script1 = document.createElement("script");' +
                'script1.src = window.GOOGLE_CHARTS_URL;' +
                'script1.async = true;' +
                'script1.onerror = () => console.error("Failed to load Google Charts", { url: window.GOOGLE_CHARTS_URL });' +
                'document.head.appendChild(script1);' +
                'var script2 = document.createElement("script");' +
                'script2.src = window.MATHJAX_URL;' +
                'script2.async = true;' +
                'script2.onerror = () => console.error("Failed to load MathJax", { url: window.MATHJAX_URL });' +
                'document.head.appendChild(script2);' +
                '</script>' + html.getContent()
            );
            Logger.log('dev mode: Displayed Plot.html as modal dialog with injected variables');
            SpreadsheetApp.getUi().showModalDialog(html, 'Interactive Probability Simulator');
        } else {
            const html = HtmlService.createHtmlOutput(
                '<p>Probability Simulator Dashboard ready. <a href="' + plotUrl + '" target="_blank">Click here to open the dashboard</a>.</p>'
            );
            SpreadsheetApp.getUi().showModalDialog(html, 'Open Probability Simulator Dashboard');
        }
        return plotUrl;
    } catch (error) {
        Logger.log('Error in showPlotWrapper: ' + error.message + '\nStack: ' + error.stack);
        if (config && config.errorHandler === 'alert') {
            SpreadsheetApp.getUi().alert('Error', 'Failed to load dashboard: ' + error.message, SpreadsheetApp.getUi().ButtonSet.OK);
        } else {
            SpreadsheetApp.getUi().alert('Error', 'Failed to load dashboard: ' + error.message, SpreadsheetApp.getUi().ButtonSet.OK);
        }
        throw error;
    }
}

function logClientError(errorMessage) {
    Logger.log('Client-side error: ' + errorMessage);
}

function showPlot(config) {
    try {
        Logger.log('showPlot called with config: ' + JSON.stringify(config));
        if (!config || !config.sheetId) {
            throw new Error('No active spreadsheet found. Please open a spreadsheet with task data.');
        }
        const deploymentId = getDeploymentId();
        if (!deploymentId) {
            throw new Error('No deployment ID available. Please deploy the script as a web app to use the dashboard.');
        }
        const sessionId = SESSION_ID_PREFIX + Utilities.getUuid();
        const plotUrl = `https://script.google.com/macros/s/${deploymentId}/exec?sheetId=${config.sheetId}&sessionId=${sessionId}`;
        Logger.log('Generated plot URL: ' + plotUrl);
        
        if (config.mode === 'web') {
            Logger.log('Web mode: Dashboard URL: ' + plotUrl);
        }
        return plotUrl;
    } catch (error) {
        Logger.log('Error in showPlot: ' + error.message + '\nStack: ' + error.stack);
        throw error;
    }
}

function getTargetProbabilityData(params) {
    Logger.log('getTargetProbabilityData called with params: ' + JSON.stringify(params));
    try {
        if (!params || typeof params !== 'object') {
            throw new Error('Invalid or missing parameters');
        }
        if (!params.task || typeof params.task !== 'string') {
            throw new Error('Task must be a non-empty string');
        }
        if (!Number.isFinite(params.optimistic) || !Number.isFinite(params.mostLikely) || !Number.isFinite(params.pessimistic)) {
            throw new Error('Optimistic, mostLikely, and pessimistic must be finite numbers');
        }
        if (params.optimistic >= params.mostLikely || params.mostLikely >= params.pessimistic) {
            throw new Error('Invalid estimate order: optimistic < mostLikely < pessimistic required');
        }
        if (params.optimistic === params.mostLikely || params.mostLikely === params.pessimistic) {
            throw new Error('Estimates must be distinct');
        }
        const range = params.pessimistic - params.optimistic;
        const minRange = params.mostLikely * MIN_RANGE_MULTIPLIER;
        if (range < minRange) {
            throw new Error(`Estimate range too small: range=${range}, minRange=${minRange}`);
        }
        if (!params.sliderValues || typeof params.sliderValues !== 'object') {
            throw new Error('sliderValues must be an object');
        }
        const { budgetFlexibility, scheduleFlexibility, scopeCertainty, qualityTolerance } = params.sliderValues;
        if (!Number.isFinite(budgetFlexibility) || budgetFlexibility < 0 || budgetFlexibility > 100 ||
            !Number.isFinite(scheduleFlexibility) || scheduleFlexibility < 0 || scheduleFlexibility > 100 ||
            !Number.isFinite(scopeCertainty) || scopeCertainty < 0 || scopeCertainty > 100 ||
            !Number.isFinite(qualityTolerance) || qualityTolerance < 0 || qualityTolerance > 100) {
            throw new Error('Slider values must be numbers between 0 and 100');
        }
        if (params.mode === 'target' && (!Number.isFinite(params.targetValue) || params.targetValue < params.optimistic || params.targetValue > params.pessimistic)) {
            throw new Error(`Target value must be a number between ${params.optimistic} and ${params.pessimistic}`);
        }
        if (params.mode === 'confidence' && (!Number.isFinite(params.confidenceLevel) || params.confidenceLevel <= 0 || params.confidenceLevel >= 1)) {
            throw new Error('Confidence level must be a number between 0 and 1');
        }
        if (params.isOptimizeMode && (!params.previousOptimalSliderSettings || typeof params.previousOptimalSliderSettings !== 'object')) {
            Logger.log('Warning: previousOptimalSliderSettings missing or invalid in optimize mode; proceeding without previous settings');
        }

        const tasks = [{
            task: params.task,
            optimistic: params.optimistic,
            mostLikely: params.mostLikely,
            pessimistic: params.pessimistic,
            budgetFlexibility: budgetFlexibility / 100,
            scheduleFlexibility: scheduleFlexibility / 100,
            scopeCertainty: scopeCertainty / 100,
            qualityTolerance: qualityTolerance / 100,
            targetValue: params.mode === 'target' ? params.targetValue : params.mostLikely,
            confidenceLevel: params.mode === 'confidence' ? params.confidenceLevel : 0.9,
            targetProbabilityOnly: true,
            optimizeFor: params.isOptimizeMode ? params.mode : 'none'
        }];
        Logger.log('Calling API with task: ' + JSON.stringify(tasks[0]));
        const apiResponse = callEstimatorAPI(tasks);
        if (!apiResponse || !apiResponse.results || !Array.isArray(apiResponse.results) || apiResponse.results.length === 0) {
            throw new Error('API response missing or invalid "results" array');
        }
        const result = apiResponse.results[0];
        Logger.log('API result for task: ' + result.task?.value);

        return result;
    } catch (error) {
        Logger.log('Error in getTargetProbabilityData: ' + error.message + '\nStack: ' + error.stack);
        throw new Error('Failed to fetch target probability data: ' + error.message);
    }
}


/**
 * SECTION 9: Web App Integration
 * Serves Plot.html or submit.html based on URL parameters and handles task submission for the Web Persona.
 */
function doGet(e) {
    try {
        Logger.log('doGet called with params: ' + JSON.stringify(e));
        const config = personas(e, 'web');
        Logger.log('doGet config: ' + JSON.stringify(config));
        if (!config.sheetId) {
            Logger.log('Error: No spreadsheet ID provided in doGet');
            return HtmlService.createHtmlOutput(
                '<p>Error: No spreadsheet ID provided. Please access this web app from the add-on or ensure a valid sheetId parameter is included.</p>'
            );
        }
        const template = HtmlService.createHtmlOutputFromFile('Plot');
        template.setContent(
            '<script>' +
            'window.sheetId = ' + JSON.stringify(config.sheetId) + ';' +
            'window.sessionId = ' + JSON.stringify(config.sessionId) + ';' +
            'window.defaultTask = ' + JSON.stringify(config.defaultTask) + ';' +
            'window.GOOGLE_FONTS_URL = "https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap";' +
            'window.GOOGLE_CHARTS_URL = "https://www.google.com/jsapi";' +
            'window.MATHJAX_URL = "https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML";' +
            'window.CONFIG = ' + JSON.stringify(CONFIG) + ';' +
            'var link = document.createElement("link");' +
            'link.rel = "stylesheet";' +
            'link.href = window.GOOGLE_FONTS_URL;' +
            'link.onerror = () => console.error("Failed to load Google Fonts", { url: window.GOOGLE_FONTS_URL });' +
            'document.head.appendChild(link);' +
            'var script1 = document.createElement("script");' +
            'script1.src = window.GOOGLE_CHARTS_URL;' +
            'script1.async = true;' +
            'script1.onerror = () => console.error("Failed to load Google Charts", { url: window.GOOGLE_CHARTS_URL });' +
            'document.head.appendChild(script1);' +
            'var script2 = document.createElement("script");' +
            'script2.src = window.MATHJAX_URL;' +
            'script2.async = true;' +
            'script2.onerror = () => console.error("Failed to load MathJax", { url: window.MATHJAX_URL });' +
            'document.head.appendChild(script2);' +
            '</script>' + template.getContent()
        );
        return template
            .setTitle('Interactive Probability Simulator')
            .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    } catch (error) {
        Logger.log('Error in doGet: ' + error.message + '\nStack: ' + error.stack);
        return HtmlService.createHtmlOutput(
            '<p>Error: Failed to load dashboard: ' + error.message + '</p>'
        );
    }
}

function doPost(e) {
    Logger.log('doPost called with parameters: ' + JSON.stringify(e?.parameter));
    try {
        if (!e || !e.parameter || !e.parameter.data) {
            throw new Error('Missing data parameter.');
        }
        const tasks = JSON.parse(e.parameter.data);
        if (!Array.isArray(tasks) || tasks.length === 0) {
            throw new Error('Invalid or empty tasks array.');
        }
        return ContentService.createTextOutput(
            JSON.stringify(createEstimateSheet(tasks))
        ).setMimeType(ContentService.MimeType.JSON);
    } catch (error) {
        Logger.log('Error in doPost: ' + error.message + '\nStack: ' + error.stack);
        return ContentService.createTextOutput(
            JSON.stringify({ error: error.message })
        ).setMimeType(ContentService.MimeType.JSON);
    }
}

function createEstimateSheet(tasks) {
    Logger.log('createEstimateSheet called with tasks: ' + JSON.stringify(tasks));
    try {
        if (!Array.isArray(tasks) || tasks.length === 0) {
            throw new Error('Invalid or empty tasks array');
        }
        if (tasks.length > CONFIG.MAX_TASKS) {
            throw new Error(`Too many tasks provided: ${tasks.length}, max allowed: ${CONFIG.MAX_TASKS}`);
        }
        let selectedTask = null;
        const userEmail = Session.getEffectiveUser().getEmail() || 'anonymous_' + new Date().getTime();
        const sessionId = SESSION_ID_PREFIX + Utilities.getUuid();
        tasks.forEach((task, i) => {
            task.taskName = (task.taskName || '').replace(/[^a-zA-Z0-9_]/g, '_').substring(0, 50) || `Task_${i + 1}`;
            if (!task.taskName || 
                typeof task.bestCase !== 'number' || !isFinite(task.bestCase) || task.bestCase < 0 ||
                typeof task.mostLikely !== 'number' || !isFinite(task.mostLikely) || task.mostLikely < 0 ||
                typeof task.worstCase !== 'number' || !isFinite(task.worstCase) || task.worstCase < 0) {
                throw new Error(`Invalid task data at index ${i}: ${JSON.stringify(task)}`);
            }
            if (task.bestCase >= task.mostLikely || task.mostLikely >= task.worstCase) {
                throw new Error(`Invalid estimate order at index ${i}`);
            }
            if (task.bestCase === task.mostLikely || task.mostLikely === task.worstCase) {
                throw new Error(`Estimates must be distinct at index ${i}`);
            }
            const range = task.worstCase - task.bestCase;
            const minRange = task.mostLikely * MIN_RANGE_MULTIPLIER;
            if (range < minRange) {
                throw new Error(`Estimate range too small at index ${i}`);
            }
            if (task.selectedForPlot) {
                if (selectedTask) {
                    throw new Error('Only one task can be selected for plotting');
                }
                selectedTask = task.taskName;
            }
        });
        if (!selectedTask && tasks.length > 0) {
            tasks[0].selectedForPlot = true;
            selectedTask = tasks[0].taskName;
        }
        const timestamp = new Date().toISOString().replace(/[-:T.]/g, '');
        let ss;
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                ss = SpreadsheetApp.create(`PERT Estimates ${timestamp}_${userEmail.split('@')[0]}_${sessionId}`);
                Logger.log('Successfully created spreadsheet: ' + ss.getId());
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to create spreadsheet: ${e.message}`);
                if (attempt === 3) {
                    throw new Error(`Failed to create spreadsheet after 3 attempts: ${e.message}`);
                }
                Utilities.sleep(1000);
            }
        }
        const scriptProperties = PropertiesService.getScriptProperties();
        scriptProperties.setProperty('createdBy', userEmail);
        scriptProperties.setProperty('sessionId', sessionId);
        const sheet = ss.getSheets()[0];
        sheet.setName(ESTIMATION_DATA_SHEET_NAME);
        const data = tasks.map(task => [
            task.taskName,
            task.bestCase,
            task.mostLikely,
            task.worstCase,
            task.selectedForPlot ? 'TRUE' : 'FALSE'
        ]);
        sheet.getRange(1, 1, 1, 5).setValues([['Name', 'Best Case', 'Most Likely', 'Worst Case', 'Selected for Plot']]).setFontWeight('bold');
        sheet.getRange(2, 1, data.length, 5).setValues(data);
        const config = {
            sheetId: ss.getId(),
            sheetName: ESTIMATION_DATA_SHEET_NAME,
            isWebAppContext: true,
            errorHandler: 'confirm',
            userEmail: userEmail,
            sessionId: sessionId
        };
        const result = addPertColumns(config);
        const sheetUrl = ss.getUrl();
        const deploymentId = getDeploymentId();
        let plotUrl = '';
        if (deploymentId) {
            plotUrl = `https://script.google.com/macros/s/${deploymentId}/exec?sheetId=${ss.getId()}&sessionId=${sessionId}`;
            Logger.log('Generated plotUrl: ' + plotUrl);
        } else {
            Logger.log('Warning: No deployment ID available. Dashboard URL will be empty.');
            plotUrl = '';
        }
        return {
            status: result.status,
            sheetUrl: sheetUrl,
            plotUrl: plotUrl,
            message: deploymentId ? result.message : result.message + ' Note: Dashboard unavailable without a valid deployment ID; please deploy as a web app.',
            errors: result.errors,
            selectedTask: selectedTask
        };
    } catch (error) {
        Logger.log('Error in createEstimateSheet: ' + error.message + '\nStack: ' + error.stack);
        throw new Error('Failed to create estimate sheet: ' + error.message);
    }
}



   

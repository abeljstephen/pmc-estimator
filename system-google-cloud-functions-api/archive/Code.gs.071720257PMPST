/**
 * SECTION 1: Configuration and Constants
 * Defines the global CONFIG object with UI labels, error messages, and settings, along with constants for sheet names, API URLs, and timeouts.
 */
const CONFIG = {
    PAGE_TITLE: 'Interactive Probability Simulator',
    GOOGLE_CHARTS_URL: 'https://www.google.com/jsapi',
    MATHJAX_URL: 'https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML',
    GOOGLE_FONTS_URL: 'https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap',
    LOADING_MESSAGE: 'Loading, please wait...',
    ERROR_NO_SHEET_ID_MESSAGE: 'Spreadsheet ID not provided. Please contact support.',
    ERROR_NO_SIMULATOR_CONTAINER: 'Simulator container not found',
    ERROR_PAGE_LOAD_FAILED: 'Failed to load page',
    ERROR_NO_TASK_SELECT: 'Task select element not found',
    ERROR_NO_VALID_TASKS: 'No valid tasks found',
    ERROR_NO_VALID_TASKS_MESSAGE: 'Error: No valid tasks found (best case < most likely < worst case not satisfied). Using default values. Please contact support.',
    ERROR_NO_TASKS_AVAILABLE: 'No tasks available',
    ERROR_CONTACT_SUPPORT: 'Please contact support.',
    ERROR_FETCH_TASKS: 'Failed to fetch tasks',
    ERROR_FETCH_TASKS_MESSAGE: 'Error fetching tasks: ',
    ERROR_INVALID_TASK: 'Invalid task selected',
    ERROR_INVALID_TASK_RESULTS_MESSAGE: 'Error: Invalid task data (best case < most likely < worst case not satisfied) or no task selected. Using default values (target: 2400.00). Please select a valid task or contact support.',
    ERROR_NO_EXPLORE_RESULTS: 'Explore results element not found',
    ERROR_NO_COMBINATION_TABLE: 'Combination table not found',
    ERROR_NO_COMBINATION_DATA: 'No combination data available',
    WARNING_NO_COMBINATIONS: 'No combinations available',
    WARNING_ELEMENT_NOT_FOUND: 'Element not found: ',
    WARNING_OPTIMAL_SLIDER_SETTINGS_MISSING: 'Optimal slider settings missing in API response',
    ERROR_TASK_TIMEOUT: 'Task fetch timeout',
    ERROR_TASK_TIMEOUT_MESSAGE: 'Task fetch timed out. Please try again.',
    ERROR_DATA_TIMEOUT: 'Data fetch timeout',
    ERROR_DATA_TIMEOUT_MESSAGE: 'Data fetch timed out. Please try again.',
    ERROR_INVALID_API_RESPONSE: 'Invalid API response',
    ERROR_API_FAILURE: 'Failed to fetch data from server',
    ERROR_RENDERING_PDF: 'Error rendering PDF chart',
    ERROR_RENDERING_CDF: 'Error rendering CDF chart',
    ERROR_INVALID_TASK_RECOMMENDATIONS: 'Invalid task data for recommendations',
    WARNING_OPTIMAL_VALUE_ADJUSTED: 'Optimal value adjusted due to range violation',
    DEFAULT_BEST_CASE: 1800.00,
    DEFAULT_MOST_LIKELY: 2400.00,
    DEFAULT_WORST_CASE: 3000.00,
    DEFAULT_TARGET_VALUE: 2400.00,
    DEFAULT_CONFIDENCE_LEVEL: 0.9,
    DEFAULT_ORIGINAL_PROBABILITY: 54.0,
    DEFAULT_ADJUSTED_PROBABILITY: 97.6,
    DEFAULT_ORIGINAL_VALUE_AT_CONFIDENCE: 2504.91,
    DEFAULT_VALUE_AT_CONFIDENCE: 2325.50,
    DEFAULT_OPTIMAL_PROBABILITY: 100.0,
    DEFAULT_VARIANCE_SCALE: 1.0,
    DEFAULT_ORIGINAL_MEAN: 2400.00,
    DEFAULT_ADJUSTED_MEAN: 2420.50,
    DEFAULT_VARIANCE: 32580.25,
    DEFAULT_STD_DEV: 180.50,
    DEFAULT_SKEWNESS: 0.05,
    DEFAULT_CV: 0.075,
    DEFAULT_CI: '[2079.19, 2761.81]',
    DEFAULT_VAR: 2520.00,
    DEFAULT_CVAR: 2520.00,
    INITIAL_SETUP_TITLE: 'Initial Setup / User Choices',
    INITIAL_SETUP_DESCRIPTION: 'Choose a task and define your target value or confidence level to begin.',
    TASK_SELECT_LABEL: 'Select Task',
    TASK_LOADING_MESSAGE: 'Loading tasks...',
    MODE_SELECT_LABEL: 'Target Mode',
    TARGET_MODE_LABEL: 'Target',
    CONFIDENCE_MODE_LABEL: 'Confidence',
    TARGET_VALUE_LABEL: 'Value',
    CONFIDENCE_LEVEL_LABEL: 'Value (1-100%)',
    OPTIMIZE_LABEL: 'Optimize',
    OPTIMIZE_NO_LABEL: 'No',
    OPTIMIZE_YES_LABEL: 'Yes',
    CLEAR_BUTTON_LABEL: 'Clear',
    EXPLORATION_RESULTS_HEADER: 'Exploration Results',
    EXPLORATION_RESULTS_DEFAULT_TEXT: 'Select a mode to view results.',
    BUDGET_FLEXIBILITY_LABEL: 'Budget Flexibility (%)',
    SCHEDULE_FLEXIBILITY_LABEL: 'Schedule Flexibility (%)',
    SCOPE_CERTAINTY_LABEL: 'Scope Certainty (%)',
    QUALITY_TOLERANCE_LABEL: 'Tolerance for Poor Quality (%)',
    BUDGET_FLEXIBILITY_HELP_TEXT: 'Higher flexibility allows for a larger budget buffer.',
    SCHEDULE_FLEXIBILITY_HELP_TEXT: 'Higher flexibility extends the timeline.',
    SCOPE_CERTAINTY_HELP_TEXT: 'Higher certainty reduces outcome range.',
    QUALITY_TOLERANCE_HELP_TEXT: 'Higher tolerance accepts more defects or lower quality.',
    USE_CASE_LABEL: 'Use Case',
    PDF_USE_CASE_WHEN: 'Visualize the likelihood of different outcomes and how adjustments affect the distribution.',
    PDF_USE_CASE_HOW: 'Adjust sliders to see distribution changes.',
    PDF_USE_CASE_BENEFIT: 'Understand the impact of decisions on outcome distribution.',
    CDF_USE_CASE_WHEN: 'Explore cumulative probabilities and how adjustments improve target achievement.',
    CDF_USE_CASE_HOW: 'View baseline and adjusted CDFs to compare outcomes.',
    CDF_USE_CASE_BENEFIT: 'Guides strategic adjustments for better outcomes.',
    SLIDER_COMBINATION_LABEL: 'Slider Combination',
    FILTER_LABEL: 'Filter',
    FILTER_CURRENT_LABEL: 'Current Selection',
    FILTER_ALL_LABEL: 'All',
    FILTER_ABOVE_50_LABEL: 'Above 50%',
    FILTER_ABOVE_75_LABEL: 'Above 75%',
    FILTER_BELOW_50_LABEL: 'Below 50%',
    FILTER_OPTIMIZED_LABEL: 'Optimized',
    FILTER_HELP_TEXT: 'This table shows combinations of slider settings and their probability of achieving the target value. Filter options: \'Current Selection\' shows current settings, \'All\' shows all combinations, \'Above 50%\'/\'Above 75%\' show combinations with probability above 50%/75%, \'Below 50%\' shows below 50%, and \'Optimized\' shows the optimal settings. Use the filter to narrow down results, navigate pages, and adjust sliders to test scenarios.',
    PREV_PAGE_LABEL: 'Prev',
    NEXT_PAGE_LABEL: 'Next',
    PAGE_INFO_DEFAULT_TEXT: 'Page 1',
    INSIGHTS_RECOMMENDATIONS_LABEL: 'Insights & Recommendations',
    RECOMMENDATIONS_HEADER: 'Recommendations',
    STATISTICAL_METRICS_TITLE: 'Statistical Metrics',
    METRIC_HEADER: 'Metric',
    PURPOSE_HEADER: 'Purpose',
    GENERAL_FORMULA_HEADER: 'General Formula',
    DYNAMIC_FORMULA_HEADER: 'Formula with Dynamic Variables',
    RESULT_HEADER: 'Result (Dynamic)',
    PERT_MEAN_LABEL: 'PERT Mean',
    PERT_MEAN_PURPOSE: 'Weighted average emphasizing mode',
    PERT_MEAN_FORMULA: 'E[X] = (a + 4m + b) / 6',
    PERT_MEAN_DYNAMIC_FORMULA: 'E[X] = (<span class="dynamic" id="pert-a"></span> + 4×<span class="dynamic" id="pert-m"></span> + <span class="dynamic" id="pert-b"></span>) / 6',
    TRIANGLE_MEAN_LABEL: 'Triangle Mean',
    TRIANGLE_MEAN_PURPOSE: 'Simple average of estimates',
    TRIANGLE_MEAN_FORMULA: 'E[X] = (a + m + b) / 3',
    TRIANGLE_MEAN_DYNAMIC_FORMULA: 'E[X] = (<span class="dynamic" id="tri-a"></span> + <span class="dynamic" id="tri-m"></span> + <span class="dynamic" id="tri-b"></span>) / 3',
    BETA_MEAN_LABEL: 'Beta Mean',
    BETA_MEAN_PURPOSE: 'Scaled mean of beta distribution',
    BETA_MEAN_FORMULA: 'E[X] = a + (b - a) × α / (α + β)',
    BETA_MEAN_DYNAMIC_FORMULA: 'E[X] = <span class="dynamic" id="beta-a"></span> + (<span class="dynamic" id="beta-b"></span> - <span class="dynamic" id="beta-a"></span>) × 2 / (2 + 5)',
    MC_UNSMOOTHED_MEAN_LABEL: 'MC Unsmoothed Mean',
    MC_UNSMOOTHED_MEAN_PURPOSE: 'Average of sampled MC values',
    MC_UNSMOOTHED_MEAN_FORMULA: 'E[X] = Σ(xᵢ·yᵢ) / Σ(yᵢ)',
    MC_UNSMOOTHED_MEAN_DYNAMIC_FORMULA: 'Sum(xᵢ·yᵢ)/Sum(yᵢ), from raw MC samples',
    MC_SMOOTHED_MEAN_LABEL: 'MC Smoothed Mean',
    MC_SMOOTHED_MEAN_PURPOSE: 'KDE-weighted mean',
    MC_SMOOTHED_MEAN_FORMULA: 'E[X] = Σ(xᵢ·yᵢ·Δx) / Σ(yᵢ·Δx)',
    MC_SMOOTHED_MEAN_DYNAMIC_FORMULA: 'μ = <span class="dynamic" id="mc-smoothed-mean-value"></span> from smoothed KDE distribution',
    MC_SMOOTHED_MEDIAN_LABEL: 'MC Smoothed Median',
    MC_SMOOTHED_MEDIAN_PURPOSE: '50th percentile of smoothed curve',
    MC_SMOOTHED_MEDIAN_FORMULA: 'Median where CDF = 0.5',
    MC_SMOOTHED_MEDIAN_DYNAMIC_FORMULA: 'x such that Σ(yᵢ·Δx) = 0.5 (smoothed CDF midpoint)',
    STD_DEV_LABEL: 'Std Dev (MC Smoothed)',
    STD_DEV_PURPOSE: 'Spread of values around mean',
    STD_DEV_FORMULA: 'σ = √(Σ((xᵢ - μ)²·yᵢ·Δx)/Σ(yᵢ·Δx))',
    STD_DEV_DYNAMIC_FORMULA: 'σ = √(Σ((xᵢ - <span class="dynamic" id="std-mu"></span>)²·yᵢ·Δx)/Σ(yᵢ·Δx))',
    VARIANCE_LABEL: 'Variance (MC Smoothed)',
    VARIANCE_PURPOSE: 'Dispersion measure',
    VARIANCE_FORMULA: 'Var = Σ((xᵢ - μ)²·yᵢ·Δx)/Σ(yᵢ·Δx)',
    VARIANCE_DYNAMIC_FORMULA: 'Var = Σ((xᵢ - <span class="dynamic" id="var-mu"></span>)²·yᵢ·Δx)/Σ(yᵢ·Δx)',
    SKEWNESS_LABEL: 'Skewness (MC Smoothed)',
    SKEWNESS_PURPOSE: 'Asymmetry of distribution',
    SKEWNESS_FORMULA: 'Skew = (Σ((xᵢ - μ)³·yᵢ·Δx)/Σ(yᵢ·Δx)) / σ³',
    SKEWNESS_DYNAMIC_FORMULA: 'Skew = (Σ((xᵢ - <span class="dynamic" id="skew-mu"></span>)³·yᵢ·Δx)/Σ(yᵢ·Δx)) / (<span class="dynamic" id="skew-sigma"></span>)³',
    CV_LABEL: 'Coefficient of Variation',
    CV_PURPOSE: 'Relative standard deviation',
    CV_FORMULA: 'CV = σ / μ',
    CV_DYNAMIC_FORMULA: 'CV = <span class="dynamic" id="cv-sigma"></span> / <span class="dynamic" id="cv-mu"></span>',
    CI_LABEL: '95% Confidence Interval',
    CI_PURPOSE: 'Range with 95% certainty around mean',
    CI_FORMULA: 'CI = μ ± 1.96 × (σ / √n)',
    CI_DYNAMIC_FORMULA: 'CI = <span class="dynamic" id="ci-mu"></span> ± 1.96 × (<span class="dynamic" id="ci-sigma"></span> / √1000)',
    VAR_LABEL: 'Value at Risk (VaR @ 95%)',
    VAR_PURPOSE: 'Risk threshold at 95%',
    VAR_FORMULA: 'VaR = x where P(X > x) = 5%',
    VAR_DYNAMIC_FORMULA: 'VaR = <span class="dynamic" id="var-value"></span> (smoothed CDF where tail = 5%)',
    CVAR_LABEL: 'Conditional VaR (CVaR @ 95%)',
    CVAR_PURPOSE: 'Expected tail loss beyond VaR',
    CVAR_FORMULA: 'CVaR = E[X | X > VaR]',
    CVAR_DYNAMIC_FORMULA: 'Mean of xᵢ > <span class="dynamic" id="cvar-var"></span> from smoothed distribution',
    RECOMMENDATIONS_OVERVIEW_HEADER: 'Overview',
    RECOMMENDATIONS_OVERVIEW_TEXT: 'Starting with your initial estimates (Optimistic: <span class="dynamic">${CONFIG.DEFAULT_BEST_CASE.toFixed(2)}</span>, Most Likely: <span class="dynamic">${CONFIG.DEFAULT_MOST_LIKELY.toFixed(2)}</span>, Pessimistic: <span class="dynamic">${CONFIG.DEFAULT_WORST_CASE.toFixed(2)}</span>), we’ve converted them into a probability model to calculate your <strong>risk profile</strong>, which reflects the likelihood of meeting your target or achieving a value at your confidence level:',
    RECOMMENDATIONS_BASELINE_TEXT: 'Baseline Risk Profile',
    RECOMMENDATIONS_CURRENT_TEXT: 'Current Risk Profile',
    RECOMMENDATIONS_OPTIMIZED_TEXT: 'Optimized Risk Profile',
    RECOMMENDATIONS_SLIDERS_INTRO: 'The sliders enable you to manage these risks. The list below details each slider’s individual impact, with their combined effect driving the probability or value at confidence, as shown in the <strong>Slider Combination Table</strong>.',
    RECOMMENDATIONS_SLIDERS_HEADER: 'Why Sliders Are Powerful for Risk Management',
    RECOMMENDATIONS_SLIDERS_TEXT: 'Your project estimates are <strong>unitless</strong>—they could represent cost, duration, risk, quality, or another metric. The sliders start at <strong>0%</strong>, assuming no tolerance for overruns, delays, scope changes, or quality issues beyond your initial estimates. By <strong>increasing</strong> or <strong>decreasing</strong> the sliders, you can:',
    RECOMMENDATIONS_CONTROLLED_OVERRUNS_TEXT: 'Tolerate Controlled Overruns',
    RECOMMENDATIONS_SCOPE_QUALITY_TEXT: 'Manage Scope and Quality',
    RECOMMENDATIONS_RISK_SCENARIOS_TEXT: 'Test Risk Scenarios',
    RECOMMENDATIONS_SLIDER_TABLE_TEXT: 'Leverage the Slider Combination Table',
    RECOMMENDATIONS_OPTIMIZE_TEXT: 'Optimize Decisions',
    RECOMMENDATIONS_MITIGATION_HEADER: 'How Sliders Mitigate Project Risks',
    RECOMMENDATIONS_EXAMPLE_HEADER: 'Practical Example',
    RECOMMENDATIONS_EXAMPLE_TEXT: 'For your project with estimates and a target at confidence level:',
    RECOMMENDATIONS_EXAMPLE_BASELINE: 'Baseline Risk Profile',
    RECOMMENDATIONS_EXAMPLE_CURRENT: 'Current Risk Profile',
    RECOMMENDATIONS_EXAMPLE_IMPROVE: 'To improve',
    RECOMMENDATIONS_EXAMPLE_CHECK: 'Check',
    RISK_LEVEL_VERY_LOW: 'very low risk',
    RISK_LEVEL_LOW: 'low risk',
    RISK_LEVEL_MODERATE: 'moderate risk',
    RISK_LEVEL_HIGH: 'high risk',
    BUDGET_FLEXIBILITY_DOES_TEXT: 'Tolerates <strong>cost overruns</strong> (e.g., budget, personnel). At 100%, you can overrun the project cost by double the Pessimistic estimate.',
    BUDGET_FLEXIBILITY_IMPACT_TEXT: 'Increasing shifts outcomes toward lower values, reducing <strong>cost overruns</strong>.',
    BUDGET_FLEXIBILITY_DISTRIBUTION_TEXT: 'Increasing shifts the distribution left, lowering the mean, individually increasing the <strong>target probability</strong> or lowering the value at confidence.',
    BUDGET_FLEXIBILITY_FORMULA: '\\(\\mu\' = \\mu - f \\cdot (P - M) \\cdot (BF/100)\\), where \\(\\mu\\) = original mean, \\(P\\) = pessimistic, \\(M\\) = most likely, \\(BF\\) = budget flexibility, \\(f\\) = 0.5.',
    BUDGET_FLEXIBILITY_HELPS_TEXT: 'Mitigates <strong>cost overruns</strong>, helping achieve target if units are cost-related.',
    BUDGET_FLEXIBILITY_NEXT_STEP: 'Increase to 50–60% and check the <strong>PDF chart</strong> for a left-shifted curve.',
    SCHEDULE_FLEXIBILITY_DOES_TEXT: 'Tolerates <strong>schedule delays</strong>. At 100%, you can delay the project by double the Pessimistic estimate.',
    SCHEDULE_FLEXIBILITY_IMPACT_TEXT: 'Increasing shifts outcomes left, minimizing <strong>schedule variance</strong>.',
    SCHEDULE_FLEXIBILITY_DISTRIBUTION_TEXT: 'Increasing shifts the distribution left, reducing the mean, individually increasing the <strong>target probability</strong> or reducing the value at confidence.',
    SCHEDULE_FLEXIBILITY_FORMULA: '\\(\\mu\' = \\mu - f \\cdot (P - M) \\cdot (SF/100)\\), where \\(\\mu\\) = original mean, \\(P\\) = pessimistic, \\(M\\) = most likely, \\(SF\\) = schedule flexibility, \\(f\\) = 0.5.',
    SCHEDULE_FLEXIBILITY_HELPS_TEXT: 'Reduces <strong>schedule delays</strong>, aiding target for time-based estimates.',
    SCHEDULE_FLEXIBILITY_NEXT_STEP: 'Increase to 50–60% and check the <strong>CDF chart</strong> for higher confidence.',
    SCOPE_CERTAINTY_DOES_TEXT: 'Reduces <strong>probability of scope creep</strong> by defining deliverables. At 100%, no <strong>scope creep</strong> anticipated.',
    SCOPE_CERTAINTY_IMPACT_TEXT: 'Increasing narrows outcome range, focusing on target.',
    SCOPE_CERTAINTY_DISTRIBUTION_TEXT: 'Increasing narrows the distribution, reducing variance, individually increasing the <strong>target probability</strong> by concentrating outcomes.',
    SCOPE_CERTAINTY_FORMULA: 'Scales variance: \\(\\sigma\'^2 = \\sigma^2 \\cdot (1 - SC/100)\\), where \\(\\sigma^2\\) = original variance, \\(SC\\) = scope certainty.',
    SCOPE_CERTAINTY_HELPS_TEXT: 'Prevents <strong>scope creep</strong>, ensuring predictability.',
    SCOPE_CERTAINTY_NEXT_STEP: 'Increase to 75% for reduced scope creep risk and check the <strong>PDF chart</strong> for a narrower distribution.',
    QUALITY_TOLERANCE_DOES_TEXT: 'Manages <strong>defects</strong> or <strong>quality trade-offs</strong>. At 100%, allows maximum <strong>defects</strong> or <strong>quality trade-offs</strong>; at 0%, prioritizes <strong>quality assurance</strong>.',
    QUALITY_TOLERANCE_IMPACT_TEXT: 'Increasing shifts outcomes right; decreasing reduces extreme outcomes.',
    QUALITY_TOLERANCE_DISTRIBUTION_TEXT: 'Increasing shifts the distribution right, increasing skewness or upper bound, individually decreasing the <strong>target probability</strong>. Decreasing reduces the right tail, increasing <strong>target probability</strong>.',
    QUALITY_TOLERANCE_FORMULA: 'Adjusts upper bound or skewness: \\(b\' = b + (P - M) \\cdot (QT/100)\\), where \\(b\\) = pessimistic, \\(QT\\) = quality tolerance, \\(P\\) = pessimistic, \\(M\\) = most likely.',
    QUALITY_TOLERANCE_HELPS_TEXT: 'Minimizes <strong>defects</strong> and overruns, ensuring reliable target.',
    QUALITY_TOLERANCE_NEXT_STEP: 'Decrease to 40–50% for <strong>quality assurance</strong> and check the <strong>CDF chart</strong> for reduced right tail.',
    COMBINED_EFFECT_DOES_TEXT: 'Collectively adjusts the distribution based on all slider settings.',
    COMBINED_EFFECT_IMPACT_TEXT: 'Combines individual shifts and narrowing to achieve target probability or value at confidence.',
    COMBINED_EFFECT_DISTRIBUTION_TEXT: 'Combines all sliders’ effects, adjusting the mean, variance, and shape.',
    COMBINED_EFFECT_FORMULA: 'Final mean and variance: \\(\\mu_{\\text{final}} = \\mu - f \\cdot (P - M) \\cdot (BF/100 + SF/100)\\), \\(\\sigma_{\\text{final}}^2 = \\sigma^2 \\cdot (1 - SC/100)\\), adjusted by \\(QT\\)-scaled upper bound.',
    COMBINED_EFFECT_HELPS_TEXT: 'Delivers target probability, improving the risk profile.',
    COMBINED_EFFECT_NEXT_STEP: 'Adjust all sliders as recommended and check the <strong>Slider Combination Table</strong> (filter “Above 75%” or “Optimized”) for the final probability or value.',
    COMBINATION_TABLE_COL_COMBINATION: 'Combination',
    COMBINATION_TABLE_COL_BALANCED: 'Balanced',
    COMBINATION_TABLE_COL_UNBALANCED: 'Unbalanced',
    COMBINATION_TABLE_SUCCESS_TEXT: 'success',
    COMBINATION_TABLE_FAILURE_TEXT: 'failure',
    MAX_TASKS: 100,
    EXPLORE_MODE_DEFAULT_TITLE_PREFIX: 'Adjust Sliders to Explore',
    EXPLORE_MODE_DEFAULT_TITLE_SUFFIX: 'Value at Confidence Level',
    EXPLORE_MODE_OPTIMIZED_TITLE: 'View Optimized Settings for Maximum Outcome',
    PDF_CHART_TITLE: 'Interactive Probability Simulator - PDF',
    PDF_X_AXIS_LABEL: 'Value',
    PDF_Y_AXIS_LABEL: 'Probability Density',
    PDF_ORIGINAL_LABEL: 'Original PDF',
    PDF_ADJUSTED_LABEL: 'Slider Adjusted PDF',
    PDF_OPTIMIZED_ADJUSTED_LABEL: 'Optimized Adjusted PDF',
    PDF_ORIGINAL_TOOLTIP: 'Original',
    PDF_ADJUSTED_TOOLTIP: 'Adjusted',
    PDF_OPTIMIZED_TOOLTIP: 'Optimized Adjusted',
    PDF_ORIGINAL_TARGET_LABEL: 'Original Target',
    PDF_ADJUSTED_TARGET_LABEL: 'Adjusted Target',
    CDF_CHART_TITLE: 'Interactive Probability Simulator - CDF',
    CDF_X_AXIS_LABEL: 'Value',
    CDF_Y_AXIS_LABEL: 'Cumulative Probability',
    CDF_ORIGINAL_LABEL: 'Original CDF',
    CDF_ADJUSTED_LABEL: 'Slider Adjusted CDF',
    CDF_OPTIMIZED_ADJUSTED_LABEL: 'Optimized Adjusted CDF',
    CDF_ORIGINAL_TOOLTIP: 'Original',
    CDF_ADJUSTED_TOOLTIP: 'Adjusted',
    CDF_OPTIMIZED_TOOLTIP: 'Optimized Adjusted',
    CDF_ORIGINAL_TARGET_LABEL: 'Original Target',
    CDF_ADJUSTED_TARGET_LABEL: 'Adjusted Target',
    SHOW_EXECUTING_USER: true,
    BACK_TO_TOP_LABEL: 'Back to Top',
    SUBMIT_PAGE_TITLE: 'Submit Tasks'
};
const ESTIMATION_DATA_SHEET_NAME = 'Estimation Data';
const ESTIMATE_CALCULATIONS_SHEET_NAME = 'Estimate Calculations';
const ADDON_CALCULATIONS_SHEET_NAME = 'Estimate Calculations Addon';
const DEFAULT_PROJECT_NAME = 'Untitled Project';
const DEFAULT_ROW_INDEX = 2;
const MIN_RANGE_MULTIPLIER = 0.1;
const DOGET_TIMEOUT_MS = 15000;
const SERVICE_ACCOUNT_KEY_NAME = 'SERVICE_ACCOUNT_KEY';
const API_URL = 'https://us-central1-pmc-estimator.cloudfunctions.net/pmcEstimatorAPI';
const TOKEN_ENDPOINT_URL = 'https://oauth2.googleapis.com/token';
const API_TIMEOUT_MS = 30000;
const SESSION_ID_PREFIX = 'Session_';
const DEPLOYMENT_ID_PROPERTY = 'DEPLOYMENT_ID';

/**
 * SECTION 2: Deployment ID Management
 * Handles dynamic retrieval of the deployment ID for web app URLs, supporting development, web app, and add-on modes.
 */
function getDeploymentId() {
    const scriptProperties = PropertiesService.getScriptProperties();
    let deploymentId = scriptProperties.getProperty(DEPLOYMENT_ID_PROPERTY);
    
    if (deploymentId === 'AKfycbyYNTqfEyeQ6hhdu1OVJAA9voM4d0SURRewZQ1QMYDCHRYg-Hg') {
        Logger.log('Outdated deployment ID detected, clearing cache.');
        scriptProperties.deleteProperty(DEPLOYMENT_ID_PROPERTY);
        deploymentId = null;
    }
    
    if (!deploymentId) {
        try {
            const url = ScriptApp.getService().getUrl();
            Logger.log('Retrieved web app URL: ' + url);
            if (url.includes('/dev')) {
                Logger.log('Running in development mode (/dev URL). Using latest deployment ID.');
                deploymentId = 'AKfycbxPMikpb1W7qHCYwuIfx1696rU-rsnZka_SRhdSL6x8r8EnhRVbwQ1Kofdjm8jIFcaL';
                scriptProperties.setProperty(DEPLOYMENT_ID_PROPERTY, deploymentId);
                Logger.log('Stored deployment ID: ' + deploymentId);
            } else {
                const match = url.match(/\/s\/([^/]+)\/exec/);
                if (match && match[1]) {
                    deploymentId = match[1];
                    scriptProperties.setProperty(DEPLOYMENT_ID_PROPERTY, deploymentId);
                    Logger.log('Stored deployment ID from URL: ' + deploymentId);
                } else {
                    Logger.log('Error: Could not parse deployment ID from URL: ' + url);
                    deploymentId = 'AKfycbxPMikpb1W7qHCYwuIfx1696rU-rsnZka_SRhdSL6x8r8EnhRVbwQ1Kofdjm8jIFcaL';
                    scriptProperties.setProperty(DEPLOYMENT_ID_PROPERTY, deploymentId);
                    Logger.log('Stored default deployment ID: ' + deploymentId);
                }
            }
        } catch (error) {
            Logger.log('Error retrieving deployment ID: ' + error.message);
            deploymentId = 'AKfycbxPMikpb1W7qHCYwuIfx1696rU-rsnZka_SRhdSL6x8r8EnhRVbwQ1Kofdjm8jIFcaL';
            scriptProperties.setProperty(DEPLOYMENT_ID_PROPERTY, deploymentId);
            Logger.log('Stored default deployment ID due to error: ' + deploymentId);
        }
    }
    Logger.log('Returning deployment ID: ' + deploymentId);
    return deploymentId;
}

function clearDeploymentId() {
    PropertiesService.getScriptProperties().deleteProperty('DEPLOYMENT_ID');
    Logger.log('Cleared DEPLOYMENT_ID_PROPERTY');
}

/**
 * SECTION 3: Context and Persona Configuration
 * Determines the execution context (dev, add-on, or web) and generates configuration for subsequent functions.
 */
function personas(e, context) {
    Logger.log('personas called with event: ' + JSON.stringify(e || 'null') + ', context: ' + context);
    const config = {
        mode: 'addon',
        sheetId: null,
        sheetName: null,
        defaultTask: null,
        rowIndex: DEFAULT_ROW_INDEX,
        isWebAppContext: false,
        errorHandler: 'alert',
        userEmail: Session.getEffectiveUser().getEmail() || 'anonymous_' + new Date().getTime(),
        sessionId: SESSION_ID_PREFIX + Utilities.getUuid()
    };
    try {
        const scriptProperties = PropertiesService.getScriptProperties();
        const serviceUrl = ScriptApp.getService().getUrl();
        const isDevMode = serviceUrl.includes('/dev');

        if (e && e.parameter && e.parameter.sheetId) {
            config.mode = 'web';
            config.isWebAppContext = true;
            config.errorHandler = 'confirm';
            config.sheetId = e.parameter.sheetId;
            config.sessionId = e.parameter.sessionId || config.sessionId;
            Logger.log('Web app mode - sheetId: ' + config.sheetId + ', sessionId: ' + config.sessionId);
            const ss = SpreadsheetApp.openById(config.sheetId);
            scriptProperties.setProperty('LAST_SPREADSHEET_ID', config.sheetId);
            const createdBy = scriptProperties.getProperty('createdBy');
            if (createdBy && createdBy !== config.userEmail) {
                Logger.log('Warning: Spreadsheet created by ' + createdBy + ', current user: ' + config.userEmail);
            }
            config.sheetName = ESTIMATION_DATA_SHEET_NAME;
        } else if (isDevMode || context === 'dev') {
            config.mode = 'dev';
            Logger.log('Development mode - running from Apps Script editor or dev URL');
            let ss = SpreadsheetApp.getActiveSpreadsheet();
            if (!ss) {
                Logger.log('Error: No active spreadsheet found in dev mode, attempting to use last known sheet ID');
                const lastSheetId = scriptProperties.getProperty('LAST_SPREADSHEET_ID') || '1VAIlRRqiIOdWe6wwIdKqNeQKfWlbIIEdjLA8ZzIxOqI';
                try {
                    ss = SpreadsheetApp.openById(lastSheetId);
                    Logger.log('Successfully opened spreadsheet by ID: ' + lastSheetId);
                } catch (fallbackError) {
                    Logger.log('Error: Failed to open last known spreadsheet: ' + fallbackError.message);
                    throw new Error('No active spreadsheet found. Please run the script from within a Google Sheet.');
                }
            }
            config.sheetId = ss.getId();
            scriptProperties.setProperty('LAST_SPREADSHEET_ID', config.sheetId);
            Logger.log('Spreadsheet ID: ' + config.sheetId);
            const activeSheet = SpreadsheetApp.getActiveSheet();
            if (!activeSheet) {
                Logger.log('Error: No active sheet found');
                throw new Error('No active sheet found. Please select a sheet with task data.');
            }
            config.sheetName = activeSheet.getName();
            Logger.log('Active Sheet: ' + config.sheetName);
        } else {
            config.mode = 'addon';
            Logger.log('Add-on mode - running from Google Sheets add-on');
            let ss = SpreadsheetApp.getActiveSpreadsheet();
            if (!ss) {
                Logger.log('Error: No active spreadsheet found in add-on mode, attempting to use last known sheet ID');
                const lastSheetId = scriptProperties.getProperty('LAST_SPREADSHEET_ID') || '1VAIlRRqiIOdWe6wwIdKqNeQKfWlbIIEdjLA8ZzIxOqI';
                try {
                    ss = SpreadsheetApp.openById(lastSheetId);
                    Logger.log('Successfully opened spreadsheet by ID: ' + lastSheetId);
                } catch (fallbackError) {
                    Logger.log('Error: Failed to open last known spreadsheet: ' + fallbackError.message);
                    throw new Error('No active spreadsheet found. Please run the script from within a Google Sheet.');
                }
            }
            config.sheetId = ss.getId();
            scriptProperties.setProperty('LAST_SPREADSHEET_ID', config.sheetId);
            Logger.log('Spreadsheet ID: ' + config.sheetId);
            const activeSheet = SpreadsheetApp.getActiveSheet();
            if (!activeSheet) {
                Logger.log('Error: No active sheet found');
                throw new Error('No active sheet found. Please select a sheet with task data.');
            }
            config.sheetName = activeSheet.getName();
            Logger.log('Active Sheet: ' + config.sheetName);
        }

        if (context === 'showPlot' || context === 'showPlotWeb' || context === 'dev' || context === 'addon') {
            const ss = SpreadsheetApp.openById(config.sheetId);
            let activeSheet = SpreadsheetApp.getActiveSheet();
            let activeRowIndex = DEFAULT_ROW_INDEX;
            let taskName = null;
            let bestCase, mostLikely, worstCase;

            if (activeSheet && (activeSheet.getName() === ESTIMATION_DATA_SHEET_NAME || activeSheet.getName() === ESTIMATE_CALCULATIONS_SHEET_NAME)) {
                const activeRange = activeSheet.getActiveRange();
                activeRowIndex = activeRange ? activeRange.getRow() : DEFAULT_ROW_INDEX;
                if (activeRowIndex < DEFAULT_ROW_INDEX) activeRowIndex = DEFAULT_ROW_INDEX;
                const activeRowData = activeSheet.getRange(activeRowIndex, 1, 1, 4).getValues()[0];
                taskName = activeRowData[0]?.toString().trim();
                bestCase = parseFloat(activeRowData[1]);
                mostLikely = parseFloat(activeRowData[2]);
                worstCase = parseFloat(activeRowData[3]);
                if (taskName && Number.isFinite(bestCase) && Number.isFinite(mostLikely) && Number.isFinite(worstCase) &&
                    bestCase < mostLikely && mostLikely < worstCase) {
                    config.defaultTask = taskName;
                    config.rowIndex = activeRowIndex;
                    Logger.log(`Selected valid task from active row ${activeRowIndex}: ${taskName}`);
                }
            }

            if (!config.defaultTask) {
                const estimationSheet = ss.getSheetByName(ESTIMATION_DATA_SHEET_NAME) || ss.getSheets()[0];
                const data = estimationSheet.getDataRange().getValues();
                for (let i = 1; i < data.length; i++) {
                    const row = data[i];
                    taskName = row[0]?.toString().trim();
                    bestCase = parseFloat(row[1]);
                    mostLikely = parseFloat(row[2]);
                    worstCase = parseFloat(row[3]);
                    if (taskName && Number.isFinite(bestCase) && Number.isFinite(mostLikely) && Number.isFinite(worstCase) &&
                        bestCase < mostLikely && mostLikely < worstCase) {
                        config.defaultTask = taskName;
                        config.rowIndex = i + 1;
                        Logger.log(`Defaulted to first viable task at row ${i + 1}: ${taskName}`);
                        break;
                    }
                }
                if (!config.defaultTask) {
                    Logger.log('Warning: No viable tasks found in Estimation Data sheet');
                    config.defaultTask = null;
                    config.rowIndex = DEFAULT_ROW_INDEX;
                }
            }
            config.sheetName = ESTIMATION_DATA_SHEET_NAME;
        }
        Logger.log('Config returned: ' + JSON.stringify(config));
        return config;
    } catch (error) {
        Logger.log('Error in personas: ' + error.message + '\nStack: ' + error.stack);
        throw error;
    }
}

/**
 * SECTION 4: Menu Setup
 * Creates the custom menu in Google Sheets for add-on functionality and validates sheet columns.
 */
function onOpen(e) {
    try {
        const ui = SpreadsheetApp.getUi();
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const activeSheet = SpreadsheetApp.getActiveSheet();
        const hasRequiredColumns = activeSheet && checkSheetColumns(activeSheet);
        const menu = ui.createAddonMenu();
        if (hasRequiredColumns) {
            menu.addItem('PERT', 'addPertColumnsWrapper')
                .addItem('PLOT', 'showPlotWrapper');
        } else {
            menu.addItem('PERT', 'showNoSheetError')
                .addItem('PLOT', 'showNoSheetError');
        }
        menu.addToUi();
        Logger.log('onOpen completed: Menu created with ' + (hasRequiredColumns ? 'PERT and PLOT options' : 'error options'));
    } catch (error) {
        Logger.log('Error in onOpen: ' + error.message + '\nStack: ' + error.stack);
    }
}

function checkSheetColumns(sheet) {
    try {
        const columnHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(h => h.toString().trim().toLowerCase());
        Logger.log(`checkSheetColumns: Sheet "${sheet.getName()}" headers: ${JSON.stringify(columnHeaders)}`);
        const requiredColumns = ['name', 'best case', 'best_case', 'most likely', 'most_likely', 'worst case', 'worst_case'];
        const foundColumns = requiredColumns.filter(col => columnHeaders.includes(col));
        const missingColumns = requiredColumns.filter(col => !columnHeaders.includes(col));
        const hasRequiredColumns = columnHeaders.includes('name') &&
                                  (columnHeaders.includes('best case') || columnHeaders.includes('best_case')) &&
                                  (columnHeaders.includes('most likely') || columnHeaders.includes('most_likely')) &&
                                  (columnHeaders.includes('worst case') || columnHeaders.includes('worst_case'));
        Logger.log(`checkSheetColumns: Found columns: ${JSON.stringify(foundColumns)}, Missing columns: ${JSON.stringify(missingColumns)}, Has required columns: ${hasRequiredColumns}`);
        if (!hasRequiredColumns) {
            Logger.log(`Error: Missing required columns. Expected: ${JSON.stringify(requiredColumns)}, Found: ${JSON.stringify(columnHeaders)}`);
        }
        return hasRequiredColumns;
    } catch (error) {
        Logger.log('Error in checkSheetColumns: ' + error.message + '\nStack: ' + error.stack);
        return false;
    }
}

function showNoSheetError() {
    try {
        SpreadsheetApp.getUi().alert('Error', `The active sheet must have columns: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case). Please ensure these columns exist with valid data.`, SpreadsheetApp.getUi().ButtonSet.OK);
    } catch (error) {
        Logger.log('Error in showNoSheetError: ' + error.message);
    }
}

/**
 * SECTION 5: PERT Calculations
 * Handles PERT calculations and sheet updates for the Add-on and Web Personas.
 */

/**
 * SECTION 5.1: Sidebar Management
 * Functions to display and update the status sidebar for user feedback during PERT calculations.
 */
function showStatusSidebar() {
    try {
        const html = HtmlService.createHtmlOutputFromFile('StatusSidebar')
            .setTitle('Processing Status')
            .setWidth(300);
        SpreadsheetApp.getUi().showSidebar(html);
        Logger.log('Displayed status sidebar');
        PropertiesService.getScriptProperties().setProperty('PERT_STATUS', JSON.stringify({ message: 'Initializing...', details: '', progress: 0 }));
    } catch (e) {
        Logger.log(`Error displaying sidebar: ${e.message}`);
        try {
            const ss = SpreadsheetApp.getActiveSpreadsheet();
            const sheet = ss.getSheetByName(ESTIMATION_DATA_SHEET_NAME) || ss.getSheets()[0];
            sheet.getRange('A1').setValue('Error: Failed to display status sidebar. Check logs for details.')
                .setFontColor('#ff0000')
                .setBackground('#f5f7fa');
            Logger.log('Wrote fallback error status to sheet');
        } catch (fallbackError) {
            Logger.log(`Error writing fallback status to sheet: ${fallbackError.message}`);
        }
    }
}

function updateSidebarStatus(message, details = '', progress = 0) {
    try {
        PropertiesService.getScriptProperties().setProperty('PERT_STATUS', JSON.stringify({ message, details, progress }));
        Logger.log(`Stored status: ${message}, Details: ${details}, Progress: ${progress}%`);
    } catch (e) {
        Logger.log(`Error storing status: ${e.message}`);
        try {
            const ss = SpreadsheetApp.getActiveSpreadsheet();
            const sheet = ss.getSheetByName(ESTIMATION_DATA_SHEET_NAME) || ss.getSheets()[0];
            sheet.getRange('A1').setValue(`${message}: ${details}`)
                .setFontColor('#333333')
                .setBackground('#f5f7fa');
            Logger.log('Wrote fallback status to sheet');
        } catch (fallbackError) {
            Logger.log(`Error writing fallback status to sheet: ${fallbackError.message}`);
        }
    }
}

function getStatus() {
    const scriptProperties = PropertiesService.getScriptProperties();
    const status = scriptProperties.getProperty('PERT_STATUS') || '{}';
    try {
        return JSON.parse(status);
    } catch (e) {
        Logger.log(`Error parsing status: ${e.message}`);
        return { message: 'Error', details: 'Failed to fetch status', progress: 0 };
    }
}

/**
 * SECTION 5.2: PERT Calculation Wrapper
 * Initializes and orchestrates PERT calculations by calling addPertColumns with the appropriate configuration.
 */
function addPertColumnsWrapper() {
    Logger.log('addPertColumnsWrapper called');
    try {
        const config = personas(null, 'addPertColumnsWrapper');
        if (!config) {
            Logger.log('Error: personas returned null or undefined config');
            showStatusSidebar();
            updateSidebarStatus('Error', 'Failed to initialize configuration. Please ensure you are running the script from a Google Sheet with valid data.', 0);
            return;
        }
        config.sheetName = ESTIMATION_DATA_SHEET_NAME;
        Logger.log('addPertColumnsWrapper config: ' + JSON.stringify(config));
        if (!config.sheetId) {
            Logger.log('Error: No active spreadsheet found in addPertColumnsWrapper');
            showStatusSidebar();
            updateSidebarStatus('Error', 'No active spreadsheet found. Please open a spreadsheet with task data.', 0);
            return;
        }
        showStatusSidebar();
        updateSidebarStatus('Processing...', 'Starting PERT calculations...', 0);
        const result = addPertColumns(config);
        if (result.status === 'error') {
            Logger.log('addPertColumnsWrapper errors: ' + result.errors.join('; '));
            updateSidebarStatus('Completed with Errors', result.message + '\nCheck the "Error Log" sheet for details.', 100);
        } else {
            Logger.log('addPertColumnsWrapper completed successfully');
            updateSidebarStatus('Completed', 'PERT calculations completed successfully.', 100);
        }
    } catch (error) {
        Logger.log('Error in addPertColumnsWrapper: ' + error.message + '\nStack: ' + error.stack);
        showStatusSidebar();
        updateSidebarStatus('Error', 'Failed to process PERT calculations: ' + error.message + '\nCheck the "Error Log" sheet for details.', 100);
    }
}

/**
/**
 * SECTION 5.3: Core PERT Calculations
 * Performs data validation, API calls, and sheet updates for PERT calculations.
 */
function addPertColumns(config) {
    Logger.log('addPertColumns called with config: ' + JSON.stringify(config || 'undefined'));
    if (typeof config === 'undefined') {
        Logger.log('Error: addPertColumns called directly without config. Please use the "PERT" menu item in the Google Sheet.');
        throw new Error('addPertColumns must be called via the "PERT" menu item. Please run the script from a Google Sheet with valid data.');
    }
    const startTime = Date.now();
    const EXECUTION_TIMEOUT_MS = 300000;
    const RETRY_DELAY_MS = 5000; // Increased from 3000ms to reduce timeout risk
    const errors = [];
    let output = { status: 'success', errors: [], message: '' };
    let errorRows = [];
    let ss;
    let calcSheet;
    try {
        if (!config || typeof config !== 'object') {
            errors.push('Invalid or missing config object');
            Logger.log('Error: Invalid or missing config object');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: Invalid or missing config object';
            updateSidebarStatus('Error', output.message, 0);
            return output;
        }
        if (!config.sheetId) {
            errors.push('No spreadsheet ID provided');
            Logger.log('Error: No spreadsheet ID provided');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: No spreadsheet ID provided';
            updateSidebarStatus('Error', output.message, 0);
            return output;
        }

        updateSidebarStatus('Processing...', 'Accessing spreadsheet...', 10);
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                ss = SpreadsheetApp.openById(config.sheetId);
                Logger.log('Successfully accessed spreadsheet: ' + config.sheetId);
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to access spreadsheet: ${e.message}`);
                if (attempt === 3) {
                    throw new Error(`Failed to access spreadsheet after 3 attempts: ${e.message}`);
                }
                Utilities.sleep(RETRY_DELAY_MS);
            }
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while accessing spreadsheet');
            }
        }

        const sheet = ss.getSheetByName(config.sheetName) || ss.getSheets()[0];
        if (!sheet) {
            errors.push(`Sheet "${config.sheetName}" not found`);
            Logger.log(`Error: Sheet "${config.sheetName}" not found`);
            output.status = 'error';
            output.errors = errors;
            output.message = `Failed to process: Sheet "${config.sheetName}" not found`;
            updateSidebarStatus('Error', output.message, 10);
            return output;
        }
        if (!checkSheetColumns(sheet)) {
            errors.push('Sheet must have columns: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case)');
            Logger.log('Error: Sheet missing required columns');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: Sheet must have columns: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case)';
            updateSidebarStatus('Error', output.message, 10);
            return output;
        }

        updateSidebarStatus('Processing...', 'Reading sheet data...', 20);
        const data = sheet.getDataRange().getValues();
        Logger.log(`Sheet data (first two rows): ${JSON.stringify(data.slice(0, 2))}`);
        if (data.length < 2) {
            errors.push('No task data found in sheet');
            Logger.log('Error: No task data found in sheet');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: No task data found in sheet';
            updateSidebarStatus('Error', output.message, 20);
            return output;
        }

        const columnHeaders = data[0].map(h => h.toString().trim().toLowerCase());
        Logger.log(`addPertColumns: Column headers: ${JSON.stringify(columnHeaders)}`);
        const nameCol = columnHeaders.indexOf('name');
        const bestCaseCol = columnHeaders.indexOf('best case') !== -1 ? columnHeaders.indexOf('best case') : columnHeaders.indexOf('best_case');
        const mostLikelyCol = columnHeaders.indexOf('most likely') !== -1 ? columnHeaders.indexOf('most likely') : columnHeaders.indexOf('most_likely');
        const worstCaseCol = columnHeaders.indexOf('worst case') !== -1 ? columnHeaders.indexOf('worst case') : columnHeaders.indexOf('worst_case');
        const selectedCol = columnHeaders.indexOf('selected for plot') !== -1 ? columnHeaders.indexOf('selected for plot') : -1;
        if (nameCol === -1 || bestCaseCol === -1 || mostLikelyCol === -1 || worstCaseCol === -1) {
            errors.push(`Required columns missing: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case). Found: ${JSON.stringify(columnHeaders)}`);
            Logger.log('Error: Required columns missing');
            output.status = 'error';
            output.errors = errors;
            output.message = `Failed to process: Required columns missing: Name, Best Case (or best_case), Most Likely (or most_likely), Worst Case (or worst_case). Found: ${JSON.stringify(columnHeaders)}`;
            updateSidebarStatus('Error', output.message, 20);
            return output;
        }

        const tasks = [];
        let selectedForPlotCount = 0;
        let selectedTaskIndex = -1;
        updateSidebarStatus('Processing...', 'Validating tasks...', 30);
        for (let i = 1; i < data.length; i++) {
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while validating tasks');
            }
            const progress = 30 + ((i / (data.length - 1)) * 30);
            updateSidebarStatus('Processing...', `Validating task ${i} of ${data.length - 1}...`, progress);
            const row = data[i];
            const name = row[nameCol]?.toString().trim();
            const bestCase = parseFloat(row[bestCaseCol]);
            const mostLikely = parseFloat(row[mostLikelyCol]);
            const worstCase = parseFloat(row[worstCaseCol]);
            const selectedForPlot = selectedCol !== -1 ? (row[selectedCol] === true || row[selectedCol] === 'TRUE') : false;
            if (!name && (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase))) {
                Logger.log(`Row ${i + 1} is empty, skipping`);
                continue;
            }
            if (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase)) {
                errors.push(`Invalid numeric inputs at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([i + 1, `Invalid numeric inputs: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Invalid numeric inputs at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            if (bestCase >= mostLikely || mostLikely >= worstCase) {
                errors.push(`Invalid estimate order at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([i + 1, `Invalid estimate order: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Invalid estimate order at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            if (bestCase === mostLikely || mostLikely === worstCase) {
                errors.push(`Estimates too close at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([i + 1, `Estimates too close: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Estimates too close at row ${i + 1}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            const range = worstCase - bestCase;
            const minRange = mostLikely * MIN_RANGE_MULTIPLIER;
            if (range < minRange) {
                errors.push(`Estimate range too small at row ${i + 1}: range=${range}, minRange=${minRange}`);
                errorRows.push([i + 1, `Estimate range too small: range=${range}, minRange=${minRange}`]);
                Logger.log(`Error: Estimate range too small at row ${i + 1}: range=${range}, minRange=${minRange}`);
                continue;
            }
            tasks.push({
                task: name || `Task_${i}`,
                optimistic: bestCase * 1.0,
                mostLikely: mostLikely * 1.0,
                pessimistic: worstCase * 1.0,
                budgetFlexibility: 0.0,
                scheduleFlexibility: 0.0,
                scopeCertainty: 0.0,
                qualityTolerance: 0.0,
                targetValue: bestCase * 1.0,
                confidenceLevel: 0.9,
                targetProbabilityOnly: false,
                optimizeFor: 'target'
            });
            if (selectedForPlot) {
                selectedForPlotCount++;
                selectedTaskIndex = i;
            }
        }
        if (selectedForPlotCount > 1) {
            errors.push('Only one task can be selected for plotting');
            Logger.log('Error: Multiple tasks selected for plotting');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: Only one task can be selected for plotting';
            updateSidebarStatus('Error', output.message, 60);
            return output;
        }
        if (tasks.length === 0) {
            errors.push('No valid tasks found after validation');
            Logger.log('Error: No valid tasks found');
            output.status = 'error';
            output.errors = errors;
            output.message = 'Failed to process: No valid tasks found';
            updateSidebarStatus('Error', output.message, 60);
            return output;
        }

        updateSidebarStatus('Processing...', 'Calling API for calculations...', 60);
        let apiResponse;
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                apiResponse = callEstimatorAPI(tasks);
                if (!apiResponse || !apiResponse.results || !Array.isArray(apiResponse.results)) {
                    throw new Error('API response missing or invalid "results" array');
                }
                Logger.log('API response data received with ' + apiResponse.results.length + ' results');
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to call API: ${e.message}`);
                if (attempt === 3) {
                    errors.push('API call failed after 3 attempts: ' + e.message);
                    output.status = 'error';
                    output.errors = errors;
                    output.message = 'Failed to process: API call failed after 3 attempts';
                    updateSidebarStatus('Error', output.message, 60);
                    return output;
                }
                Utilities.sleep(RETRY_DELAY_MS);
            }
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while calling API');
            }
        }

        updateSidebarStatus('Processing...', 'Creating calculation sheet...', 70);
        calcSheet = ss.getSheetByName(ESTIMATE_CALCULATIONS_SHEET_NAME);
        if (calcSheet) {
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    // Instead of deleting, clear the sheet to reduce API calls
                    calcSheet.clear();
                    Logger.log('Cleared existing "Estimate Calculations" sheet');
                    break;
                } catch (e) {
                    Logger.log(`Attempt ${attempt} failed to clear "Estimate Calculations" sheet: ${e.message}`);
                    if (attempt === 3) {
                        throw new Error(`Failed to clear "Estimate Calculations" sheet after 3 attempts: ${e.message}`);
                    }
                    Utilities.sleep(RETRY_DELAY_MS);
                }
                if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                    throw new Error('Operation timed out while clearing calculation sheet');
                }
            }
        } else {
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    calcSheet = ss.insertSheet(ESTIMATE_CALCULATIONS_SHEET_NAME);
                    Logger.log('Created new "Estimate Calculations" sheet');
                    break;
                } catch (e) {
                    Logger.log(`Attempt ${attempt} failed to create "Estimate Calculations" sheet: ${e.message}`);
                    if (attempt === 3) {
                        throw new Error(`Failed to create "Estimate Calculations" sheet after 3 attempts: ${e.message}`);
                    }
                    Utilities.sleep(RETRY_DELAY_MS);
                }
                if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                    throw new Error('Operation timed out while creating calculation sheet');
                }
            }
        }

        updateSidebarStatus('Processing...', 'Writing headers to calculation sheet...', 80);
        // Define all possible headers, but only write Name, PERT Mean, and MC On Beta Smoothed 90th Percentile Confidence
        const allCalcHeaders = [
            'Name',
            'PERT Mean',
            'MC On Beta Smoothed 90th Percentile Confidence',
            // Commented out headers (not written to sheet but preserved in code)
            // 'Triangle Mean',
            // 'Triangle Variance',
            // 'Triangle Std Dev',
            // 'Triangle Skewness',
            // 'Triangle Kurtosis',
            // 'Triangle Median'
        ];
        const calcHeaders = [
            'Name',
            'PERT Mean',
            'MC On Beta Smoothed 90th Percentile Confidence'
        ];
        const allHeaderDescriptions = [
            'Task name or identifier.',
            'Weighted average (PERT).',
            'Smoothed Monte Carlo 90th Percentile Confidence Interval: The range within which the task value (e.g., cost, duration) is expected to fall with 90% confidence, based on smoothed Monte Carlo simulations using a Beta distribution. Use the lower bound for conservative planning and the upper bound for worst-case budgeting to manage risks.',
            // Commented out descriptions (not written to sheet but preserved in code)
            // 'Simple average of estimates.',
            // 'Triangle distribution variance.',
            // 'Triangle distribution standard deviation.',
            // 'Triangle distribution skewness.',
            // 'Triangle distribution kurtosis.',
            // 'Triangle distribution median.'
        ];
        const headerDescriptions = [
            allHeaderDescriptions[0], // Name
            allHeaderDescriptions[1], // PERT Mean
            allHeaderDescriptions[2]  // MC On Beta Smoothed 90th Percentile Confidence
        ];

        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                // Batch write headers and descriptions
                calcSheet.getRange(1, 1, 2, calcHeaders.length).setValues([calcHeaders, headerDescriptions]);
                calcSheet.getRange(1, 2, 1, 2).setBackground('#d1e7dd');
                calcSheet.getRange(2, 1, 1, calcHeaders.length)
                    .setFontColor('#666666')
                    .setWrap(true)
                    .setVerticalAlignment('top');
                calcSheet.setRowHeight(2, 100);
                calcSheet.setColumnWidth(1, 340);
                calcSheet.setColumnWidth(2, 340);
                calcSheet.setColumnWidth(3, 340);
                Logger.log('Successfully wrote headers and descriptions with word-wrap, set row height to 100 pixels, and set first three columns to 340 pixels');
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to write headers to "Estimate Calculations" sheet: ${e.message}`);
                if (attempt === 3) {
                    // Fallback to minimal header write
                    try {
                        calcSheet.getRange(1, 1, 1, calcHeaders.length).setValues([calcHeaders]);
                        calcSheet.setColumnWidth(1, 340);
                        calcSheet.setColumnWidth(2, 340);
                        calcSheet.setColumnWidth(3, 340);
                        Logger.log('Wrote minimal headers and set first three columns to 340 pixels as fallback');
                    } catch (fallbackError) {
                        Logger.log(`Fallback header write failed: ${fallbackError.message}`);
                    }
                    errors.push(`Failed to write headers to "Estimate Calculations" sheet after 3 attempts: ${e.message}`);
                    output.status = 'error';
                    output.errors = errors;
                    output.message = 'Failed to process: Unable to write headers due to timeout. Please try again.';
                    updateSidebarStatus('Error', output.message, 80);
                    return output;
                }
                Utilities.sleep(RETRY_DELAY_MS);
            }
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while writing headers');
            }
        }

        updateSidebarStatus('Processing...', 'Writing data to calculation sheet...', 90);
        const dataRows = [];
        for (let i = 1; i < data.length; i++) {
            if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                throw new Error('Operation timed out while processing data rows');
            }
            const progress = 90 + ((i / (data.length - 1)) * 5);
            updateSidebarStatus('Processing...', `Processing task ${i} of ${data.length - 1}...`, progress);
            const originalRowIndex = i + 1;
            const row = data[i];
            const name = row[nameCol]?.toString().trim();
            const bestCase = parseFloat(row[bestCaseCol]);
            const mostLikely = parseFloat(row[mostLikelyCol]);
            const worstCase = parseFloat(row[worstCaseCol]);
            if (!name && (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase))) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                Logger.log(`Row ${originalRowIndex} is empty, filling with N/A`);
                continue;
            }
            if (!Number.isFinite(bestCase) || !Number.isFinite(mostLikely) || !Number.isFinite(worstCase)) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`Invalid numeric inputs at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([originalRowIndex, `Invalid numeric inputs: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Invalid numeric inputs at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            if (bestCase >= mostLikely || mostLikely >= worstCase) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`Invalid estimate order at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([originalRowIndex, `Invalid estimate order: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Invalid estimate order at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            if (bestCase === mostLikely || mostLikely === worstCase) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`Estimates too close at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                errorRows.push([originalRowIndex, `Estimates too close: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`]);
                Logger.log(`Error: Estimates too close at row ${originalRowIndex}: bestCase=${bestCase}, mostLikely=${mostLikely}, worstCase=${worstCase}`);
                continue;
            }
            const range = worstCase - bestCase;
            const minRange = mostLikely * MIN_RANGE_MULTIPLIER;
            if (range < minRange) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`Estimate range too small at row ${originalRowIndex}: range=${range}, minRange=${minRange}`);
                errorRows.push([originalRowIndex, `Estimate range too small: range=${range}, minRange=${minRange}`]);
                Logger.log(`Error: Estimate range too small at row ${originalRowIndex}: range=${range}, minRange=${minRange}`);
                continue;
            }
            const resultIndex = tasks.findIndex(task => task.task === (name || `Task_${i}`));
            if (resultIndex === -1 || !apiResponse.results[resultIndex]) {
                dataRows.push([name || `Task_${i}`, 'N/A', 'N/A']);
                errors.push(`No API results for task at row ${originalRowIndex}: ${name || `Task_${i}`}`);
                errorRows.push([originalRowIndex, `No API results for task: ${name || `Task_${i}`}`]);
                Logger.log(`Error: No API results for task at row ${originalRowIndex}`);
                continue;
            }
            const result = apiResponse.results[resultIndex];
            const rowData = [
                result.task?.value || name || `Task_${i}`,
                result.pertMean?.value || 'N/A',
                result.mcSmoothedConfidenceInterval?.value ? `[${result.mcSmoothedConfidenceInterval.value.lower.toFixed(2)}, ${result.mcSmoothedConfidenceInterval.value.upper.toFixed(2)}]` : 'N/A'
                // Commented out columns (not written to sheet but preserved in code)
                // result.triangleMean?.value || 'N/A',
                // result.triangleVariance?.value || 'N/A',
                // result.triangleStdDev?.value || 'N/A',
                // result.triangleSkewness?.value || 'N/A',
                // result.triangleKurtosis?.value || 'N/A',
                // result.triangleMedian?.value || 'N/A'
            ];
            dataRows.push(rowData);
            Logger.log(`Processed row ${originalRowIndex} with data: ${JSON.stringify(rowData)}`);
        }

        if (dataRows.length > 0) {
            updateSidebarStatus('Processing...', 'Writing data to calculation sheet...', 95);
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    // Batch write data rows
                    calcSheet.getRange(3, 1, dataRows.length, calcHeaders.length).setValues(dataRows);
                    calcSheet.getRange(3, 2, dataRows.length, 2).setBackground('#d1e7dd');
                    calcSheet.getRange(3, 1, dataRows.length, calcHeaders.length).setWrap(true);
                    Logger.log('Successfully wrote data rows');
                    break;
                } catch (e) {
                    Logger.log(`Attempt ${attempt} failed to write data to "Estimate Calculations" sheet: ${e.message}`);
                    if (attempt === 3) {
                        errors.push(`Failed to write data to "Estimate Calculations" sheet after 3 attempts: ${e.message}`);
                        output.status = 'error';
                        output.errors = errors;
                        output.message = 'Failed to process: Unable to write data due to timeout. Please try again.';
                        updateSidebarStatus('Error', output.message, 95);
                        return output;
                    }
                    Utilities.sleep(RETRY_DELAY_MS);
                }
                if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                    throw new Error('Operation timed out while writing data rows');
                }
            }
        }

        if (errorRows.length > 0) {
            updateSidebarStatus('Processing...', 'Writing error log...', 98);
            let errorSheet = ss.getSheetByName('Error Log');
            if (errorSheet) {
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        errorSheet.clear();
                        Logger.log('Cleared existing "Error Log" sheet');
                        break;
                    } catch (e) {
                        Logger.log(`Attempt ${attempt} failed to clear "Error Log" sheet: ${e.message}`);
                        if (attempt === 3) {
                            throw new Error(`Failed to clear "Error Log" sheet after 3 attempts: ${e.message}`);
                        }
                        Utilities.sleep(RETRY_DELAY_MS);
                    }
                    if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                        throw new Error('Operation timed out while clearing error log sheet');
                    }
                }
            } else {
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        errorSheet = ss.insertSheet('Error Log');
                        Logger.log('Created new "Error Log" sheet');
                        break;
                    } catch (e) {
                        Logger.log(`Attempt ${attempt} failed to create "Error Log" sheet: ${e.message}`);
                        if (attempt === 3) {
                            throw new Error(`Failed to create "Error Log" sheet after 3 attempts: ${e.message}`);
                        }
                        Utilities.sleep(RETRY_DELAY_MS);
                    }
                    if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                        throw new Error('Operation timed out while creating error log sheet');
                    }
                }
            }
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    errorSheet.getRange(1, 1, 1, 2).setValues([['Row', 'Error Message']]).setFontWeight('bold');
                    errorSheet.getRange(2, 1, errorRows.length, 2).setValues(errorRows);
                    errorSheet.getRange(1, 1, errorRows.length + 1, 2).setWrap(true);
                    Logger.log('Successfully wrote error log');
                    break;
                } catch (e) {
                    Logger.log(`Attempt ${attempt} failed to write to "Error Log" sheet: ${e.message}`);
                    if (attempt === 3) {
                        throw new Error(`Failed to write to "Error Log" sheet after 3 attempts: ${e.message}`);
                    }
                    Utilities.sleep(RETRY_DELAY_MS);
                }
                if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                    throw new Error('Operation timed out while writing error log');
                }
            }
        }

        output.message = 'Successfully processed PERT calculations';
        if (errors.length > 0) {
            output.status = 'error';
            output.errors = errors;
            output.message = 'Processed with errors: ' + errors.join('; ');
            updateSidebarStatus('Completed with Errors', output.message + '\nCheck the "Error Log" sheet for details.', 100);
        } else {
            updateSidebarStatus('Completed', 'PERT calculations completed successfully.', 100);
        }
        if (config.isWebAppContext && errors.length > 0) {
            Logger.log('Web app context with errors: ' + errors.join('; '));
            output.message += '\nSome rows were invalid and marked as N/A. Check the "Error Log" sheet.';
            updateSidebarStatus('Completed with Errors', output.message, 100);
        }
        Logger.log('addPertColumns completed: ' + output.message);
        return output;
    } catch (error) {
        Logger.log('Error in addPertColumns: ' + error.message + '\nStack: ' + error.stack);
        output.status = 'error';
        output.errors.push(error.message);
        output.message = 'Failed to process PERT calculations: ' + error.message + '. Please check spreadsheet access and try again.';
        if (errorRows.length > 0 && ss) {
            let errorSheet = ss.getSheetByName('Error Log');
            if (errorSheet) {
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        errorSheet.clear();
                        Logger.log('Cleared existing "Error Log" sheet due to error');
                        break;
                    } catch (e) {
                        Logger.log(`Attempt ${attempt} failed to clear "Error Log" sheet: ${e.message}`);
                        if (attempt === 3) {
                            throw new Error(`Failed to clear "Error Log" sheet after 3 attempts: ${e.message}`);
                        }
                        Utilities.sleep(RETRY_DELAY_MS);
                    }
                    if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                        throw new Error('Operation timed out while clearing error log sheet due to error');
                    }
                }
            } else {
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        errorSheet = ss.insertSheet('Error Log');
                        Logger.log('Created new "Error Log" sheet due to error');
                        break;
                    } catch (e) {
                        Logger.log(`Attempt ${attempt} failed to create "Error Log" sheet: ${e.message}`);
                        if (attempt === 3) {
                            throw new Error(`Failed to create "Error Log" sheet after 3 attempts: ${e.message}`);
                        }
                        Utilities.sleep(RETRY_DELAY_MS);
                    }
                    if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                        throw new Error('Operation timed out while creating error log sheet due to error');
                    }
                }
            }
            if (errorSheet) {
                for (let attempt = 1; attempt <= 3; attempt++) {
                    try {
                        errorSheet.getRange(1, 1, 1, 2).setValues([['Row', 'Error Message']]).setFontWeight('bold');
                        errorRows.push([0, `General error: ${error.message}`]);
                        errorSheet.getRange(2, 1, errorRows.length, 2).setValues(errorRows);
                        errorSheet.getRange(1, 1, errorRows.length + 1, 2).setWrap(true);
                        Logger.log('Successfully wrote error log due to error');
                        break;
                    } catch (e) {
                        Logger.log(`Attempt ${attempt} failed to write to "Error Log" sheet: ${e.message}`);
                        if (attempt === 3) {
                            throw new Error(`Failed to write to "Error Log" sheet after 3 attempts: ${e.message}`);
                        }
                        Utilities.sleep(RETRY_DELAY_MS);
                    }
                    if (Date.now() - startTime > EXECUTION_TIMEOUT_MS) {
                        throw new Error('Operation timed out while writing error log due to error');
                    }
                }
            } else {
                Logger.log('Error: ErrorSheet object not defined, cannot write to Error Log sheet');
            }
        }
        updateSidebarStatus('Error', output.message + '\nCheck the "Error Log" sheet for details if available.', 100);
        return output;
    } finally {
        PropertiesService.getScriptProperties().deleteProperty('PERT_STATUS');
        if (calcSheet) {
            try {
                SpreadsheetApp.getActiveSpreadsheet().setActiveSheet(calcSheet);
                SpreadsheetApp.flush();
                Logger.log('Activated "Estimate Calculations" sheet and applied changes');
            } catch (e) {
                Logger.log(`Error activating "Estimate Calculations" sheet: ${e.message}`);
            }
        }
    }
}

/**
 * SECTION 6: API Interaction
 * Handles secure API calls to pmcEstimatorAPI with JWT authentication.
 */
function callEstimatorAPI(tasks) {
    const startTime = Date.now();
    const lock = LockService.getScriptLock();
    try {
        if (!lock.tryLock(10000)) {
            Logger.log('Error: API is busy, please try again later.');
            throw new Error('API is busy, please try again later.');
        }
        if (!Array.isArray(tasks) || tasks.length === 0) {
            Logger.log('Error: tasks must be a non-empty array');
            throw new Error('Tasks must be a non-empty array');
        }
        tasks.forEach((task, i) => {
            if (!task.task || 
                typeof task.optimistic !== 'number' || !isFinite(task.optimistic) ||
                typeof task.mostLikely !== 'number' || !isFinite(task.mostLikely) ||
                typeof task.pessimistic !== 'number' || !isFinite(task.pessimistic) ||
                (task.targetValue !== undefined && (typeof task.targetValue !== 'number' || !isFinite(task.targetValue)))) {
                Logger.log(`Invalid task data at index ${i}: ${JSON.stringify(task)}`);
                throw new Error(`Invalid task data at index ${i}: All task estimates and targetValue (if provided) must be finite numbers`);
            }
        });
        const keyJsonString = PropertiesService.getScriptProperties().getProperty(SERVICE_ACCOUNT_KEY_NAME);
        if (!keyJsonString) {
            Logger.log('Error: Script property "' + SERVICE_ACCOUNT_KEY_NAME + '" not found. Please set it in Project Settings > Script Properties with your service account key JSON.');
            throw new Error('Script property "' + SERVICE_ACCOUNT_KEY_NAME + '" not found. Please set it in Project Settings > Script Properties with your service account key JSON.');
        }
        let keyJson;
        try {
            keyJson = JSON.parse(keyJsonString);
        } catch (e) {
            Logger.log('Error parsing ' + SERVICE_ACCOUNT_KEY_NAME + ': ' + e.message);
            throw new Error('Failed to parse ' + SERVICE_ACCOUNT_KEY_NAME + ': ' + e.message);
        }
        if (!keyJson.client_email || !keyJson.private_key) {
            Logger.log('Error: Invalid ' + SERVICE_ACCOUNT_KEY_NAME + ' JSON; missing client_email or private_key');
            throw new Error('Invalid ' + SERVICE_ACCOUNT_KEY_NAME + ' JSON; missing client_email or private_key');
        }
        const now = Math.floor(Date.now() / 1000);
        const claimSet = {
            iss: keyJson.client_email,
            aud: TOKEN_ENDPOINT_URL,
            exp: now + 3600,
            iat: now,
            target_audience: API_URL
        };
        const header = { alg: 'RS256', typ: 'JWT' };
        const toSign = Utilities.base64EncodeWebSafe(JSON.stringify(header)) + '.' +
                       Utilities.base64EncodeWebSafe(JSON.stringify(claimSet));
        let token;
        try {
            const signature = Utilities.computeRsaSha256Signature(toSign, keyJson.private_key);
            const jwt = toSign + '.' + Utilities.base64EncodeWebSafe(signature);
            Logger.log('Generated JWT: [Redacted]');
            const response = UrlFetchApp.fetch(TOKEN_ENDPOINT_URL, {
                method: 'POST',
                contentType: 'application/x-www-form-urlencoded',
                payload: {
                    grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                    assertion: jwt
                },
                muteHttpExceptions: true,
                timeout: API_TIMEOUT_MS
            });
            if (Date.now() - startTime > API_TIMEOUT_MS) {
                Logger.log('Error: Token request timed out');
                throw new Error('Token request timed out');
            }
            Logger.log('Token endpoint response code: ' + response.getResponseCode());
            Logger.log('Token endpoint response: [Redacted]');
            if (response.getResponseCode() !== 200) {
                Logger.log('Token request failed: ' + response.getContentText());
                throw new Error('Failed to obtain token: ' + response.getContentText());
            }
            const tokenData = JSON.parse(response.getContentText());
            token = tokenData.id_token;
            Logger.log('Generated Token: [Redacted]');
        } catch (e) {
            Logger.log('Token generation failed: ' + e.message);
            throw new Error('Failed to obtain token: ' + e.message);
        }
        const options = {
            method: 'POST',
            contentType: 'application/json',
            headers: {
                'Authorization': 'Bearer ' + token
            },
            payload: JSON.stringify(tasks),
            muteHttpExceptions: true,
            timeout: API_TIMEOUT_MS
        };
        Logger.log('Calling API with ' + tasks.length + ' tasks');
        Logger.log('Payload: ' + JSON.stringify(tasks));
        const response = UrlFetchApp.fetch(API_URL, options);
        if (Date.now() - startTime > API_TIMEOUT_MS) {
            Logger.log('Error: API request timed out');
            throw new Error('API request timed out');
        }
        Logger.log('API response code: ' + response.getResponseCode());
        Logger.log('Full API response: ' + JSON.stringify(response.getContentText()));
        if (response.getResponseCode() !== 200) {
            Logger.log('API request failed: ' + response.getContentText());
            throw new Error('API request failed: ' + response.getContentText());
        }
        const responseData = JSON.parse(response.getContentText());
        Logger.log('API response data received with ' + (responseData.results ? responseData.results.length : 0) + ' results');
        return responseData;
    } catch (error) {
        Logger.log('Error in callEstimatorAPI: ' + error.message + '\nStack: ' + error.stack);
        throw error;
    } finally {
        if (lock.hasLock()) {
            lock.releaseLock();
        }
    }
}

/**
 * SECTION 7: Task Retrieval
 * Retrieves valid tasks from a specified sheet for processing or plotting.
 */
function getAllTasks(sheetId) {
    try {
        Logger.log('getAllTasks called with sheetId: ' + sheetId);
        if (!sheetId) {
            Logger.log('Error: No sheetId provided to getAllTasks');
            throw new Error('No spreadsheet ID provided');
        }
        const ss = SpreadsheetApp.openById(sheetId);
        const sheet = ss.getSheetByName(ESTIMATION_DATA_SHEET_NAME) || ss.getSheets()[0];
        Logger.log('Accessing sheet: ' + sheet.getName());
        const data = sheet.getDataRange().getValues();
        const tasks = [];
        let defaultTaskIndex = -1;
        for (let i = 1; i < data.length; i++) {
            const taskName = data[i][0]?.toString().trim();
            const optimistic = parseFloat(data[i][1]);
            const mostLikely = parseFloat(data[i][2]);
            const pessimistic = parseFloat(data[i][3]);
            if (taskName && Number.isFinite(optimistic) && Number.isFinite(mostLikely) && Number.isFinite(pessimistic) &&
                optimistic < mostLikely && mostLikely < pessimistic) {
                tasks.push({
                    task: taskName,
                    optimistic: optimistic,
                    mostLikely: mostLikely,
                    pessimistic: pessimistic,
                    selectedForPlot: i === DEFAULT_ROW_INDEX - 1
                });
                if (i === DEFAULT_ROW_INDEX - 1) {
                    defaultTaskIndex = tasks.length - 1;
                }
            }
        }
        Logger.log('Tasks retrieved: ' + JSON.stringify(tasks));
        return { tasks: tasks, defaultTaskIndex: defaultTaskIndex };
    } catch (error) {
        Logger.log('Error in getAllTasks: ' + error.message + '\nStack: ' + error.stack);
        return { error: error.message, tasks: [], defaultTaskIndex: -1 };
    }
}

/**
 * SECTION 8: Plot Data Fetching
 * Retrieves data for the Plot.html dashboard and opens the dashboard.
 */
function showPlotWrapper() {
    Logger.log('showPlotWrapper called');
    let config = null;
    try {
        config = personas(null, 'dev');
        Logger.log('showPlotWrapper config: ' + JSON.stringify(config));
        const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
        if (!spreadsheet) {
            Logger.log('Error: No active spreadsheet found in showPlotWrapper');
            throw new Error('No active spreadsheet found');
        }
        config.sheetId = config.sheetId || spreadsheet.getId();
        Logger.log('Successfully accessed spreadsheet in showPlotWrapper: ' + config.sheetId);
        const sheetName = spreadsheet.getActiveSheet().getName();
        config.sheetName = sheetName;
        Logger.log('Active Sheet: ' + sheetName);
        const tasksData = getAllTasks(config.sheetId);
        Logger.log('Tasks retrieved: ' + JSON.stringify(tasksData));
        
        let tasks = Array.isArray(tasksData) ? tasksData : tasksData.tasks;
        if (!Array.isArray(tasks)) {
            Logger.log('Error: getAllTasks did not return a valid array');
            throw new Error('Invalid task data: expected an array');
        }
        if (tasks.length === 0) {
            Logger.log('Error: No tasks retrieved from getAllTasks');
            throw new Error('No tasks found in spreadsheet');
        }
        let defaultTaskIndex = tasks.findIndex(task => task.selectedForPlot);
        if (defaultTaskIndex === -1) {
            defaultTaskIndex = tasks.findIndex(task => isValidTask(task));
            if (defaultTaskIndex === -1) {
                Logger.log('Error: No valid tasks found');
                throw new Error('No valid tasks found in spreadsheet');
            }
            Logger.log('Defaulted to first viable task at row ' + (defaultTaskIndex + 2) + ': ' + tasks[defaultTaskIndex].task);
        }
        config.defaultTask = tasks[defaultTaskIndex].task;
        config.rowIndex = defaultTaskIndex + 2;
        const plotUrl = showPlot(config);
        Logger.log('showPlotWrapper received plotUrl: ' + plotUrl);
        if (config.mode === 'dev') {
            const html = HtmlService.createHtmlOutputFromFile('Plot')
                .setWidth(1200)
                .setHeight(900);
            html.setContent(
                '<script>' +
                'window.sheetId = ' + JSON.stringify(config.sheetId) + ';' +
                'window.sessionId = ' + JSON.stringify(config.sessionId) + ';' +
                'window.defaultTask = ' + JSON.stringify(config.defaultTask) + ';' +
                'window.GOOGLE_FONTS_URL = "' + CONFIG.GOOGLE_FONTS_URL + '";' +
                'window.GOOGLE_CHARTS_URL = "' + CONFIG.GOOGLE_CHARTS_URL + '";' +
                'window.MATHJAX_URL = "' + CONFIG.MATHJAX_URL + '";' +
                'window.CONFIG = ' + JSON.stringify(CONFIG) + ';' +
                'var link = document.createElement("link");' +
                'link.rel = "stylesheet";' +
                'link.href = window.GOOGLE_FONTS_URL;' +
                'link.onerror = () => console.error("Failed to load Google Fonts", { url: window.GOOGLE_FONTS_URL });' +
                'document.head.appendChild(link);' +
                'var script1 = document.createElement("script");' +
                'script1.src = window.GOOGLE_CHARTS_URL;' +
                'script1.async = true;' +
                'script1.onerror = () => console.error("Failed to load Google Charts", { url: window.GOOGLE_CHARTS_URL });' +
                'document.head.appendChild(script1);' +
                'var script2 = document.createElement("script");' +
                'script2.src = window.MATHJAX_URL;' +
                'script2.async = true;' +
                'script2.onerror = () => console.error("Failed to load MathJax", { url: window.MATHJAX_URL });' +
                'document.head.appendChild(script2);' +
                '</script>' + html.getContent()
            );
            Logger.log('dev mode: Displayed Plot.html as modal dialog with injected variables');
            SpreadsheetApp.getUi().showModalDialog(html, CONFIG.PAGE_TITLE);
        } else {
            const html = HtmlService.createHtmlOutput(
                '<p>Probability Simulator Dashboard ready. <a href="' + plotUrl + '" target="_blank">Click here to open the dashboard</a>.</p>'
            );
            SpreadsheetApp.getUi().showModalDialog(html, 'Open Probability Simulator Dashboard');
        }
        return plotUrl;
    } catch (error) {
        Logger.log('Error in showPlotWrapper: ' + error.message + '\nStack: ' + error.stack);
        if (config && config.errorHandler === 'alert') {
            SpreadsheetApp.getUi().alert('Error', 'Failed to load dashboard: ' + error.message, SpreadsheetApp.getUi().ButtonSet.OK);
        } else {
            SpreadsheetApp.getUi().alert('Error', 'Failed to load dashboard: ' + error.message, SpreadsheetApp.getUi().ButtonSet.OK);
        }
        throw error;
    }
}

function logClientError(errorMessage) {
    Logger.log('Client-side error: ' + errorMessage);
}

function showPlot(config) {
    try {
        Logger.log('showPlot called with config: ' + JSON.stringify(config));
        if (!config || !config.sheetId) {
            throw new Error('No active spreadsheet found. Please open a spreadsheet with task data.');
        }
        const deploymentId = getDeploymentId();
        if (!deploymentId) {
            throw new Error('No deployment ID available. Please deploy the script as a web app to use the dashboard.');
        }
        const sessionId = SESSION_ID_PREFIX + Utilities.getUuid();
        const plotUrl = `https://script.google.com/macros/s/${deploymentId}/exec?sheetId=${config.sheetId}&sessionId=${sessionId}`;
        Logger.log('Generated plot URL: ' + plotUrl);
        
        if (config.mode === 'web') {
            Logger.log('Web mode: Dashboard URL: ' + plotUrl);
        }
        return plotUrl;
    } catch (error) {
        Logger.log('Error in showPlot: ' + error.message + '\nStack: ' + error.stack);
        throw error;
    }
}

/**
 * SECTION 9: Web App Integration
 * Serves Plot.html or submit.html based on URL parameters and handles task submission for the Web Persona.
 */
function doGet(e) {
    try {
        Logger.log('doGet called with params: ' + JSON.stringify(e));
        const config = personas(e, 'web');
        Logger.log('doGet config: ' + JSON.stringify(config));
        if (!config.sheetId) {
            Logger.log('Error: No spreadsheet ID provided in doGet');
            return HtmlService.createHtmlOutput(
                '<p>Error: No spreadsheet ID provided. Please access this web app from the add-on or ensure a valid sheetId parameter is included.</p>'
            );
        }
        const template = HtmlService.createHtmlOutputFromFile('Plot');
        template.setContent(
            '<script>' +
            'window.sheetId = ' + JSON.stringify(config.sheetId) + ';' +
            'window.sessionId = ' + JSON.stringify(config.sessionId) + ';' +
            'window.defaultTask = ' + JSON.stringify(config.defaultTask) + ';' +
            'window.GOOGLE_FONTS_URL = "' + CONFIG.GOOGLE_FONTS_URL + '";' +
            'window.GOOGLE_CHARTS_URL = "' + CONFIG.GOOGLE_CHARTS_URL + '";' +
            'window.MATHJAX_URL = "' + CONFIG.MATHJAX_URL + '";' +
            'window.CONFIG = ' + JSON.stringify(CONFIG) + ';' +
            'var link = document.createElement("link");' +
            'link.rel = "stylesheet";' +
            'link.href = window.GOOGLE_FONTS_URL;' +
            'link.onerror = () => console.error("Failed to load Google Fonts", { url: window.GOOGLE_FONTS_URL });' +
            'document.head.appendChild(link);' +
            'var script1 = document.createElement("script");' +
            'script1.src = window.GOOGLE_CHARTS_URL;' +
            'script1.async = true;' +
            'script1.onerror = () => console.error("Failed to load Google Charts", { url: window.GOOGLE_CHARTS_URL });' +
            'document.head.appendChild(script1);' +
            'var script2 = document.createElement("script");' +
            'script2.src = window.MATHJAX_URL;' +
            'script2.async = true;' +
            'script2.onerror = () => console.error("Failed to load MathJax", { url: window.MATHJAX_URL });' +
            'document.head.appendChild(script2);' +
            '</script>' + template.getContent()
        );
        return template
            .setTitle(CONFIG.PAGE_TITLE)
            .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    } catch (error) {
        Logger.log('Error in doGet: ' + error.message + '\nStack: ' + error.stack);
        return HtmlService.createHtmlOutput(
            '<p>Error: Failed to load dashboard: ' + error.message + '</p>'
        );
    }
}

function doPost(e) {
    Logger.log('doPost called with parameters: ' + JSON.stringify(e?.parameter));
    try {
        if (!e || !e.parameter || !e.parameter.data) {
            throw new Error('Missing data parameter.');
        }
        const tasks = JSON.parse(e.parameter.data);
        if (!Array.isArray(tasks) || tasks.length === 0) {
            throw new Error('Invalid or empty tasks array.');
        }
        return ContentService.createTextOutput(
            JSON.stringify(createEstimateSheet(tasks))
        ).setMimeType(ContentService.MimeType.JSON);
    } catch (error) {
        Logger.log('Error in doPost: ' + error.message + '\nStack: ' + error.stack);
        return ContentService.createTextOutput(
            JSON.stringify({ error: error.message })
        ).setMimeType(ContentService.MimeType.JSON);
    }
}

function createEstimateSheet(tasks) {
    Logger.log('createEstimateSheet called with tasks: ' + JSON.stringify(tasks));
    try {
        if (!Array.isArray(tasks) || tasks.length === 0) {
            throw new Error('Invalid or empty tasks array');
        }
        if (tasks.length > CONFIG.MAX_TASKS) {
            throw new Error(`Too many tasks provided: ${tasks.length}, max allowed: ${CONFIG.MAX_TASKS}`);
        }
        let selectedTask = null;
        const userEmail = Session.getEffectiveUser().getEmail() || 'anonymous_' + new Date().getTime();
        const sessionId = SESSION_ID_PREFIX + Utilities.getUuid();
        tasks.forEach((task, i) => {
            task.taskName = (task.taskName || '').replace(/[^a-zA-Z0-9_]/g, '_').substring(0, 50) || `Task_${i + 1}`;
            if (!task.taskName || 
                typeof task.bestCase !== 'number' || !isFinite(task.bestCase) || task.bestCase < 0 ||
                typeof task.mostLikely !== 'number' || !isFinite(task.mostLikely) || task.mostLikely < 0 ||
                typeof task.worstCase !== 'number' || !isFinite(task.worstCase) || task.worstCase < 0) {
                throw new Error(`Invalid task data at index ${i}: ${JSON.stringify(task)}`);
            }
            if (task.bestCase >= task.mostLikely || task.mostLikely >= task.worstCase) {
                throw new Error(`Invalid estimate order at index ${i}`);
            }
            if (task.bestCase === task.mostLikely || task.mostLikely === task.worstCase) {
                throw new Error(`Estimates must be distinct at index ${i}`);
            }
            const range = task.worstCase - task.bestCase;
            const minRange = task.mostLikely * MIN_RANGE_MULTIPLIER;
            if (range < minRange) {
                throw new Error(`Estimate range too small at index ${i}`);
            }
            if (task.selectedForPlot) {
                if (selectedTask) {
                    throw new Error('Only one task can be selected for plotting');
                }
                selectedTask = task.taskName;
            }
        });
        if (!selectedTask && tasks.length > 0) {
            tasks[0].selectedForPlot = true;
            selectedTask = tasks[0].taskName;
        }
        const timestamp = new Date().toISOString().replace(/[-:T.]/g, '');
        let ss;
        for (let attempt = 1; attempt <= 3; attempt++) {
            try {
                ss = SpreadsheetApp.create(`PERT Estimates ${timestamp}_${userEmail.split('@')[0]}_${sessionId}`);
                Logger.log('Successfully created spreadsheet: ' + ss.getId());
                break;
            } catch (e) {
                Logger.log(`Attempt ${attempt} failed to create spreadsheet: ${e.message}`);
                if (attempt === 3) {
                    throw new Error(`Failed to create spreadsheet after 3 attempts: ${e.message}`);
                }
                Utilities.sleep(1000);
            }
        }
        const scriptProperties = PropertiesService.getScriptProperties();
        scriptProperties.setProperty('createdBy', userEmail);
        scriptProperties.setProperty('sessionId', sessionId);
        const sheet = ss.getSheets()[0];
        sheet.setName(ESTIMATION_DATA_SHEET_NAME);
        const data = tasks.map(task => [
            task.taskName,
            task.bestCase,
            task.mostLikely,
            task.worstCase,
            task.selectedForPlot ? 'TRUE' : 'FALSE'
        ]);
        sheet.getRange(1, 1, 1, 5).setValues([['Name', 'Best Case', 'Most Likely', 'Worst Case', 'Selected for Plot']]).setFontWeight('bold');
        sheet.getRange(2, 1, data.length, 5).setValues(data);
        const config = {
            sheetId: ss.getId(),
            sheetName: ESTIMATION_DATA_SHEET_NAME,
            isWebAppContext: true,
            errorHandler: 'confirm',
            userEmail: userEmail,
            sessionId: sessionId
        };
        const result = addPertColumns(config);
        const sheetUrl = ss.getUrl();
        const deploymentId = getDeploymentId();
        let plotUrl = '';
        if (deploymentId) {
            plotUrl = `https://script.google.com/macros/s/${deploymentId}/exec?sheetId=${ss.getId()}&sessionId=${sessionId}`;
            Logger.log('Generated plotUrl: ' + plotUrl);
        } else {
            Logger.log('Warning: No deployment ID available. Dashboard URL will be empty.');
            plotUrl = '';
        }
        return {
            status: result.status,
            sheetUrl: sheetUrl,
            plotUrl: plotUrl,
            message: deploymentId ? result.message : result.message + ' Note: Dashboard unavailable without a valid deployment ID; please deploy as a web app.',
            errors: result.errors,
            selectedTask: selectedTask
        };
    } catch (error) {
        Logger.log('Error in createEstimateSheet: ' + error.message + '\nStack: ' + error.stack);
        throw new Error('Failed to create estimate sheet: ' + error.message);
    }
}

function getTargetProbabilityData(params) {
    Logger.log('getTargetProbabilityData called with params: ' + JSON.stringify(params));
    try {
        if (!params || typeof params !== 'object') {
            throw new Error('Invalid or missing parameters');
        }
        if (!params.task || typeof params.task !== 'string') {
            throw new Error('Task must be a non-empty string');
        }
        if (!Number.isFinite(params.optimistic) || !Number.isFinite(params.mostLikely) || !Number.isFinite(params.pessimistic)) {
            throw new Error('Optimistic, mostLikely, and pessimistic must be finite numbers');
        }
        if (params.optimistic >= params.mostLikely || params.mostLikely >= params.pessimistic) {
            throw new Error('Invalid estimate order: optimistic < mostLikely < pessimistic required');
        }
        if (params.optimistic === params.mostLikely || params.mostLikely === params.pessimistic) {
            throw new Error('Estimates must be distinct');
        }
        const range = params.pessimistic - params.optimistic;
        const minRange = params.mostLikely * MIN_RANGE_MULTIPLIER;
        if (range < minRange) {
            throw new Error(`Estimate range too small: range=${range}, minRange=${minRange}`);
        }
        if (!params.sliderValues || typeof params.sliderValues !== 'object') {
            throw new Error('sliderValues must be an object');
        }
        const { budgetFlexibility, scheduleFlexibility, scopeCertainty, qualityTolerance } = params.sliderValues;
        if (!Number.isFinite(budgetFlexibility) || budgetFlexibility < 0 || budgetFlexibility > 100 ||
            !Number.isFinite(scheduleFlexibility) || scheduleFlexibility < 0 || scheduleFlexibility > 100 ||
            !Number.isFinite(scopeCertainty) || scopeCertainty < 0 || scopeCertainty > 100 ||
            !Number.isFinite(qualityTolerance) || qualityTolerance < 0 || qualityTolerance > 100) {
            throw new Error('Slider values must be numbers between 0 and 100');
        }
        if (params.mode === 'target' && (!Number.isFinite(params.targetValue) || params.targetValue < params.optimistic || params.targetValue > params.pessimistic)) {
            throw new Error(`Target value must be a number between ${params.optimistic} and ${params.pessimistic}`);
        }
        if (params.mode === 'confidence' && (!Number.isFinite(params.confidenceLevel) || params.confidenceLevel <= 0 || params.confidenceLevel >= 1)) {
            throw new Error('Confidence level must be a number between 0 and 1');
        }
        if (params.isOptimizeMode && (!params.previousOptimalSliderSettings || typeof params.previousOptimalSliderSettings !== 'object')) {
            Logger.log('Warning: previousOptimalSliderSettings missing or invalid in optimize mode; proceeding without previous settings');
        }

        const tasks = [{
            task: params.task,
            optimistic: params.optimistic,
            mostLikely: params.mostLikely,
            pessimistic: params.pessimistic,
            budgetFlexibility: budgetFlexibility / 100,
            scheduleFlexibility: scheduleFlexibility / 100,
            scopeCertainty: scopeCertainty / 100,
            qualityTolerance: qualityTolerance / 100,
            targetValue: params.mode === 'target' ? params.targetValue : params.mostLikely,
            confidenceLevel: params.mode === 'confidence' ? params.confidenceLevel : 0.9,
            targetProbabilityOnly: true,
            optimizeFor: params.isOptimizeMode ? params.mode : 'none'
        }];
        Logger.log('Calling API with task: ' + JSON.stringify(tasks[0]));
        const apiResponse = callEstimatorAPI(tasks);
        if (!apiResponse || !apiResponse.results || !Array.isArray(apiResponse.results) || apiResponse.results.length === 0) {
            throw new Error('API response missing or invalid "results" array');
        }
        const result = apiResponse.results[0];
        Logger.log('API result for task: ' + result.task?.value);

        // Ensure compatibility with old UI's data structure
        return {
            task: result.task || { value: params.task },
            targetProbability: result.targetProbability || { value: { original: CONFIG.DEFAULT_ORIGINAL_PROBABILITY / 100, adjusted: CONFIG.DEFAULT_ADJUSTED_PROBABILITY / 100 } },
            targetProbabilityOriginalPdf: result.targetProbabilityOriginalPdf || { value: [] },
            targetProbabilityAdjustedPdf: result.targetProbabilityAdjustedPdf || { value: [] },
            targetProbabilityOriginalCdf: result.targetProbabilityOriginalCdf || { value: [] },
            targetProbabilityAdjustedCdf: result.targetProbabilityAdjustedCdf || { value: [] },
            valueAtConfidence: result.valueAtConfidence || { value: { original: CONFIG.DEFAULT_ORIGINAL_VALUE_AT_CONFIDENCE, adjusted: CONFIG.DEFAULT_VALUE_AT_CONFIDENCE } },
            optimalData: result.optimalData || { value: { optimalObjective: params.targetValue || params.mostLikely, probability: CONFIG.DEFAULT_OPTIMAL_PROBABILITY / 100, optimalSliderSettings: {} } },
            sliderCombinations: result.sliderCombinations || { value: [] },
            decisionOptimizerMetrics: result.decisionOptimizerMetrics || { value: { varianceScale: CONFIG.DEFAULT_VARIANCE_SCALE } },
            pertMean: result.pertMean || { value: (params.optimistic + 4 * params.mostLikely + params.pessimistic) / 6 },
            triangleMean: result.triangleMean || { value: (params.optimistic + params.mostLikely + params.pessimistic) / 3 },
            betaMean: result.betaMean || { value: params.optimistic + (params.pessimistic - params.optimistic) * 2 / (2 + 5) },
            mcMean: result.mcMean || { value: params.mostLikely },
            mcSmoothedMean: result.mcSmoothedMean || { value: CONFIG.DEFAULT_ADJUSTED_MEAN },
            mcSmoothedMedian: result.mcSmoothedMedian || { value: CONFIG.DEFAULT_ADJUSTED_MEAN },
            mcSmoothedStdDev: result.mcSmoothedStdDev || { value: CONFIG.DEFAULT_STD_DEV },
            mcSmoothedVariance: result.mcSmoothedVariance || { value: CONFIG.DEFAULT_VARIANCE },
            mcSmoothedSkewness: result.mcSmoothedSkewness || { value: CONFIG.DEFAULT_SKEWNESS },
            mcSmoothedCoefficientOfVariation: result.mcSmoothedCoefficientOfVariation || { value: CONFIG.DEFAULT_CV },
            mcSmoothedConfidenceInterval: result.mcSmoothedConfidenceInterval || { value: { lower: CONFIG.DEFAULT_CI.split(',')[0].replace('[', ''), upper: CONFIG.DEFAULT_CI.split(',')[1].replace(']', '') } },
            mcSmoothedVaR95: result.mcSmoothedVaR95 || { value: CONFIG.DEFAULT_VAR },
            mcSmoothedCVaR95: result.mcSmoothedCVaR95 || { value: CONFIG.DEFAULT_CVAR }
        };
    } catch (error) {
        Logger.log('Error in getTargetProbabilityData: ' + error.message + '\nStack: ' + error.stack);
        throw new Error('Failed to fetch target probability data: ' + error.message);
    }
}


// baseline/coordinator.gs â€” Baseline generation (pure Apps Script - global)
// Force sync - Jan 16 2026 - Node.js removed

console.log('coordinator.gs: Starting module initialization');

/**
 * Generates baseline distributions and metrics. v1.9.24
 *
 * Policy:
 *  - ALWAYS generate Triangle (needed for KL).
 *  - Monte Carlo *smoothed* (active baseline) is always generated.
 *  - If `suppressOtherDistros` is true: skip PERT/Beta/MC-raw (perf).
 *  - All returned CDFs are hygiene-checked (sorted/monotone/clamped).
 */
function generateBaseline(params) {
  console.log('generateBaseline: Starting', { params });
  try {
    const {
      optimistic, mostLikely, pessimistic,
      numSamples = 200,
      suppressOtherDistros = false
    } = params;

    // Validation
    if (![optimistic, mostLikely, pessimistic].every(Number.isFinite)) {
      throw new Error('Invalid estimates: must be finite numbers');
    }
    if (!(optimistic <= mostLikely && mostLikely <= pessimistic)) {
      throw new Error('Estimates must satisfy optimistic <= mostLikely <= pessimistic');
    }
    if (!Number.isFinite(numSamples) || numSamples < 100) {
      throw new Error('Invalid numSamples: must be a number >= 100');
    }

    // Beta params (shared)
    const { alpha, beta } = computeBetaMoments({ optimistic, mostLikely, pessimistic });
    if (!(alpha > 0 && beta > 0 && Number.isFinite(alpha) && Number.isFinite(beta))) {
      throw new Error('Invalid beta parameters');
    }

    // Triangle (always)
    const trianglePoints = generateTrianglePoints({ optimistic, mostLikely, pessimistic, numSamples });
    if (trianglePoints.error ||
        !isValidPdfArray(trianglePoints.pdfPoints) ||
        !isValidCdfArray(trianglePoints.cdfPoints)) {
      throw new Error('Invalid triangle points');
    }
    trianglePoints.cdfPoints = ensureSortedMonotoneCdf(trianglePoints.cdfPoints);

    // Optionals (PERT/Beta/MC-raw)
    let pertPoints, betaPoints, monteCarloRawPoints;
    if (!suppressOtherDistros) {
      pertPoints = generatePertPoints({ optimistic, mostLikely, pessimistic, numSamples });
      if (pertPoints.error ||
          !isValidPdfArray(pertPoints.pdfPoints) ||
          !isValidCdfArray(pertPoints.cdfPoints)) {
        throw new Error('Invalid PERT points');
      }
      pertPoints.cdfPoints = ensureSortedMonotoneCdf(pertPoints.cdfPoints);

      betaPoints = generateBetaPoints({ optimistic, mostLikely, pessimistic, numSamples, alpha, beta });
      if (betaPoints.error ||
          !isValidPdfArray(betaPoints.pdfPoints) ||
          !isValidCdfArray(betaPoints.cdfPoints)) {
        throw new Error('Invalid beta points');
      }
      betaPoints.cdfPoints = ensureSortedMonotoneCdf(betaPoints.cdfPoints);

      monteCarloRawPoints = generateMonteCarloRawPoints({ optimistic, mostLikely, pessimistic, numSamples, alpha, beta });
      if (monteCarloRawPoints.error ||
          !isValidPdfArray(monteCarloRawPoints.pdfPoints) ||
          !isValidCdfArray(monteCarloRawPoints.cdfPoints)) {
        throw new Error('Invalid Monte Carlo raw points');
      }
      monteCarloRawPoints.cdfPoints = ensureSortedMonotoneCdf(monteCarloRawPoints.cdfPoints);
    } else {
      console.log('generateBaseline: suppressOtherDistros=true (PERT/Beta/MC-raw skipped; Triangle kept)');
    }

    // Monte Carlo smoothed (active baseline)
    const smoothedParams = { optimistic, mostLikely, pessimistic, numSamples };
    if (monteCarloRawPoints?.samples?.length) smoothedParams.samples = monteCarloRawPoints.samples;

    const monteCarloSmoothedPoints = generateMonteCarloSmoothedPoints(smoothedParams);
    if (monteCarloSmoothedPoints.error ||
        !isValidPdfArray(monteCarloSmoothedPoints.pdfPoints) ||
        !isValidCdfArray(monteCarloSmoothedPoints.cdfPoints)) {
      throw new Error('Invalid Monte Carlo smoothed points');
    }
    monteCarloSmoothedPoints.cdfPoints = ensureSortedMonotoneCdf(monteCarloSmoothedPoints.cdfPoints);

    // Metrics
    const metrics = calculateMetrics({
      optimistic, mostLikely, pessimistic,
      triangle: trianglePoints,
      monteCarloSmoothed: {
        pdfPoints: monteCarloSmoothedPoints.pdfPoints,
        cdfPoints: monteCarloSmoothedPoints.cdfPoints
      }
    });

    const ciLower = metrics?.monteCarloSmoothed?.ci?.lower;
    const ciUpper = metrics?.monteCarloSmoothed?.ci?.upper;

    // KL divergence (diagnostic)
    const klObj = computeKLDivergence({
      distributions: {
        triangle: trianglePoints,
        monteCarloSmoothed: monteCarloSmoothedPoints
      },
      task: 'baseline'
    });
    const kld = klObj && klObj['triangle-monteCarloSmoothed'];

    console.log('generateBaseline: Completed', {
      ciLower, ciUpper, kld,
      mcPdf: monteCarloSmoothedPoints.pdfPoints.length,
      mcCdf: monteCarloSmoothedPoints.cdfPoints.length
    });

    return {
      trianglePoints,
      pertPoints,
      betaPoints,
      monteCarloRawPoints,
      monteCarloSmoothedPoints,

      metrics: {
        monteCarloSmoothed: { ci: { lower: ciLower, upper: ciUpper } },
        klDivergenceToTriangle: kld
      },

      ci: { monteCarloSmoothed: { lower: ciLower, upper: ciUpper } },
      confidenceInterval: { lower: ciLower, upper: ciUpper },
      pert: { mean: (optimistic + 4 * mostLikely + pessimistic) / 6 },
      monteCarloSmoothed: {
        pdfPoints: monteCarloSmoothedPoints.pdfPoints,
        cdfPoints: monteCarloSmoothedPoints.cdfPoints
      },

      alpha, beta,
      error: null
    };
  } catch (error) {
    console.error('generateBaseline: Error', { message: error.message, stack: error.stack });
    return { error: `Failed to generate baseline: ${error.message || 'Unknown error'}` };
  }
}

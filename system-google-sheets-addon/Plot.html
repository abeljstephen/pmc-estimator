<!-- SECTION 1: HTML HEAD AND STYLES -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Estimation Tool</title>
    <script src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background: #f5f7fa;
            margin: 0;
            padding: 0;
            transition: all 0.3s ease-in-out;
        }
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 18px;
            color: #333;
        }
        #control-header {
            position: sticky;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to bottom, #e8ecef, #f8f9fa);
            padding: 4px 0;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }
        #chartType-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 4px;
            padding: 4px 8px;
            max-width: 1200px;
            width: 100%;
            overflow-x: auto;
        }
        #slider-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            background: #ffffff;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            display: none;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        .decision-table-active #slider-container { display: none; }
        #confidence-container, #probability-container {
            display: none;
            flex: 1;
            justify-content: center;
            align-items: center;
            flex-direction: row;
            flex-wrap: nowrap;
            width: 100%;
            gap: 10px;
        }
        #confidence-slider, #probability-slider {
            width: 500px;
            margin: 0 10px;
        }
        .help-icon {
            margin-left: 10px;
            cursor: help;
        }
        #slider, #probability-slider {
            flex-grow: 1;
            border: 1px solid #4a90e2;
            border-radius: 4px;
            padding: 2px;
            background: #ffffff;
            transition: all 0.3s ease-in-out;
            min-width: 0;
        }
        #slider:hover, #probability-slider:hover {
            border-color: #0056b3;
            background: #f0f0f0;
        }
        #slider-value, #probability-result {
            margin-left: 8px;
            font-weight: bold;
            font-size: 14px;
            color: #333;
            flex-shrink: 0;
        }
        .slider-labels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 10px;
            color: #666;
        }
        .chart-button {
            padding: 6px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #e8ecef;
            color: #333;
            transition: background-color 0.3s, color 0.3s, transform 0.3s;
            font-size: 12px;
            font-weight: 600;
            min-width: 100px;
            max-width: 160px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.5;
            height: 40px;
            position: relative;
        }
        .chart-button:hover {
            background-color: #d8dfe6;
            transform: scale(1.02);
        }
        .chart-button.active {
            background-color: #007bff;
            color: white;
            transform: scale(1.02);
            border: 2px solid #0056b3;
        }
        .chart-button.glowing {
            box-shadow: 0 0 8px 1px rgba(74, 144, 226, 0.6);
            animation: glowPulse 1.5s infinite;
        }
        .chart-button[data-type="basic"] { background-color: #e8ecef; }
        .chart-button[data-type="monte-carlo"] { background-color: #e6f4ea; }
        .chart-button[data-type="optimizer"] { background-color: #fff3e6; }
        .chart-button[data-type="explorer"] { background-color: #f2e8f9; }
        @media (max-width: 768px) {
            .chart-button {
                padding: 4px 12px;
                font-size: 10px;
                min-width: 80px;
                max-width: 140px;
                height: 36px;
            }
            #slider-container {
                width: 100%;
                flex-direction: column;
                gap: 10px;
                padding: 5px;
            }
            #confidence-container, #probability-container {
                width: 100%;
                flex-direction: row;
                flex-wrap: nowrap;
                min-width: 0;
            }
            #confidence-container label, #probability-container label,
            #confidence-container span, #probability-container span {
                flex-shrink: 0;
            }
            #confidence-slider, #probability-slider {
                width: 300px;
            }
        }
        .plot-instruction {
            font-size: 12px;
            color: #666;
            text-align: center;
            max-width: 1200px;
            width: 100%;
            padding: 2px 0;
            margin-bottom: 5px;
            font-style: italic;
        }
        #chart-container {
            display: block;
            width: 100%;
            max-width: 1200px;
            margin: 10px auto;
            padding: 15px;
        }
        #plot-wrapper {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        #triangle-div, #pert-div, #beta-div, #mc-unsmoothed-div {
            width: 100%;
            height: 400px;
            display: none;
        }
        #mc-smoothed-wrapper {
            display: none;
            flex-direction: row;
            width: 100%;
            gap: 15px;
        }
        #mc-smoothed-div, #cdf-div {
            width: 50%;
            height: 400px;
            display: block;
        }
        @media (max-width: 768px) {
            #mc-smoothed-wrapper {
                flex-direction: column;
            }
            #mc-smoothed-div, #cdf-div {
                width: 100%;
                height: 400px;
            }
        }
        /* Updated styles for table containers within summary sections */
        [id$="-table-container"] {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            padding: 15px;
            background: #f8f9fa; /* Light gray for tables */
            border-radius: 6px;
            box-sizing: border-box;
        }
        [id$="-table-container"] table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            margin: 0;
            overflow-x: auto;
        }
        [id$="-table-container"] th, [id$="-table-container"] td {
            border: 1px solid #ddd;
            padding: 14px; /* Increased padding */
            text-align: left;
            font-size: 14px;
            transition: background-color 0.3s ease-in-out;
            color: #333;
        }
        [id$="-table-container"] th {
            background-color: #4a90e2;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            padding: 14px;
            border-bottom: 2px solid #357abd;
            position: sticky;
            top: 60px;
            z-index: 10;
            font-size: 14px;
        }
        [id$="-table-container"] td:hover {
            background-color: #f7f7f7;
        }
        [id$="-table-container"] tr:nth-child(even) {
            background: #f8f9fa; /* Alternating row colors */
        }
        .table-title {
            font-size: 16px; /* Increased for clarity */
            font-weight: bold;
            margin-bottom: 10px;
            text-align: left; /* Left-aligned for readability */
            color: #4a90e2;
            background-color: #e8ecef; /* Darker gray */
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            cursor: default;
        }
        .decision-section {
            margin-bottom: 15px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fafafa;
            width: 100%;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }
        .decision-question {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #4a90e2;
            cursor: pointer;
        }
        .decision-balanced { border-left: 3px solid #28a745; }
        #scenario-customizer {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
            width: 100%;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }
        .customizer-select {
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 0;
        }
        #back-to-top {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 6px 10px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 12px;
        }
        #back-to-top.visible { opacity: 0.8; }
        #back-to-top:hover { background: #0056b3; opacity: 1; }
        #decision-table-wrapper {
            display: block;
            max-width: 1200px;
            margin: 0 auto;
            padding: 5px;
        }
        .optimized-recommendation-glow {
            animation: optimizedGlowPulse 2s infinite ease-in-out;
        }
        @keyframes optimizedGlowPulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 204, 0, 0.7); }
            50% { box-shadow: 0 0 10px 5px rgba(0, 204, 0, 0.7); }
            100% { box-shadow: 0 0 0 0 rgba(0, 204, 0, 0.7); }
        }
        @media (max-width: 768px) {
            #decision-table-wrapper { display: block; }
            #chartType-container { gap: 2px; padding: 2px 6px; }
            [id$="-table-container"] {
                padding: 10px;
            }
            [id$="-table-container"] table {
                font-size: 12px;
            }
            [id$="-table-container"] th, [id$="-table-container"] td {
                padding: 10px;
            }
        }
        .use-case {
            font-size: 12px;
            color: #666;
            padding: 10px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            margin: 10px auto;
            max-width: 1200px;
            width: 100%;
            position: relative;
            z-index: 1;
            text-align: left;
        }
        .use-case-content {
            display: none;
            font-size: 12px;
            color: #666;
            margin: 5px 0;
            padding: 10px;
            text-align: left;
            line-height: 1.6;
        }
        .use-case-content p {
            margin: 0 0 15px 0;
            padding: 0;
        }
        .use-case-content strong em {
            color: #4a90e2;
            font-style: italic;
            font-weight: bold;
        }
        .help-tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
            color: #4a90e2;
            font-size: 14px;
            margin-left: 5px;
        }
        .help-tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }
        .help-tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .analysis-report {
            font-size: 14px;
            text-align: left;
            color: #333;
            line-height: 1.5;
        }
        .analysis-report h3 {
            font-size: 18px;
            color: #4a90e2;
            margin-bottom: 10px;
            text-align: center;
        }
        .analysis-report h4 {
            font-size: 16px;
            color: #4a90e2;
            margin: 15px 0 5px;
        }
        .analysis-report h5 {
            font-size: 14px;
            color: #4a90e2;
            margin: 10px 0;
        }
        .analysis-report p, .analysis-report ul {
            margin: 0 0 10px;
            padding-left: 0;
        }
        .analysis-report ul {
            padding-left: 20px;
        }
        .analysis-report strong {
            color: #333;
        }
        .analysis-report .dynamic {
            color: blue;
        }
        .analysis-report pre {
            font-size: 12px;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .analysis-report table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-bottom: 15px;
        }
        .analysis-report th, .analysis-report td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: left;
        }
        .analysis-report th {
            background: #4a90e2;
            color: white;
        }
        .analysis-report tr:nth-child(even) {
            background: #f8f9fa;
        }
        /* Updated styles for summary sections below use cases */
        .summary-section-container {
            width: 100%; /* Ensure it spans the full width */
            margin: 15px auto;
            padding: 15px;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: none;
        }
        .summary-section {
            display: none;
            font-size: 14px;
            color: #333;
            line-height: 1.5;
            width: 100%; /* Full width */
        }
        .summary-section.active {
            display: block;
        }
        .toggle-summary {
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            background: #4a90e2;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%; /* Full width */
            text-align: left;
            transition: background 0.3s;
            box-sizing: border-box; /* Include padding in width */
        }
        .summary-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 15px;
            width: 100%; /* Full width */
            box-sizing: border-box; /* Ensure padding is included in width */
        }
        /* Updated styles for recommendation sections */
        [id$="-recommendation-section"] {
            background: #e6f4ea; /* Light green background */
            border: 1px solid #ddd;
            border-left: 3px solid #28a745; /* Green accent */
            border-radius: 6px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            order: -1; /* Ensure it’s first */
        }
        [id$="-recommendation-section"] h4 {
            font-size: 20px; /* Larger title */
            color: #4a90e2;
            margin-bottom: 10px;
        }
        [id$="-recommendation-section"] p, [id$="-recommendation-section"] div {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            margin: 10px 0;
        }
        /* Updated styles for analysis sections */
        .analysis-wrapper {
            background: #ffffff; /* White background */
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            margin: 0; /* No extra margin */
            box-sizing: border-box;
        }
        .analysis-wrapper h4 {
            font-size: 18px; /* Slightly smaller than recommendation */
            color: #4a90e2;
            margin-bottom: 10px;
        }
        .analysis-wrapper p {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            margin: 10px 0;
        }
        /* Style for subsections within analysis-wrapper (e.g., PDF/CDF, Original/Optimized) */
        .analysis-wrapper > div {
            margin-bottom: 15px; /* Space between subsections */
        }
        .analysis-wrapper > div:last-child {
            margin-bottom: 0; /* No margin for last subsection */
        }
        /* New styles for side-by-side layout */
        .side-by-side {
            display: flex;
            flex-direction: row;
            gap: 20px;
        }
        .side-by-side > div {
            flex: 1;
            background: #f8f9fa; /* Light gray background for distinct boxes */
            border: 1px solid #ddd; /* Border to separate boxes */
            border-radius: 4px; /* Rounded corners */
            padding: 10px; /* Internal padding for content */
        }
        @media (max-width: 768px) {
            .side-by-side {
                flex-direction: column; /* Stack vertically on smaller screens */
            }
            .side-by-side > div {
                flex: none; /* Reset flex growth on smaller screens */
            }
        }
        /* Remove side-by-side layouts for consistency */
        .pdf-cdf-wrapper, .cdf-wrapper, .dist-wrapper {
            display: flex;
            flex-direction: column; /* Stack vertically */
            gap: 0; /* No gap, handled by analysis-wrapper */
            width: 100%;
            margin-bottom: 0;
        }
        .pdf-cdf-wrapper > div, .cdf-wrapper > div, .dist-wrapper > div {
            border: none; /* Remove borders, handled by analysis-wrapper */
            padding: 0; /* Remove padding, handled by analysis-wrapper */
            background: none; /* No background, handled by analysis-wrapper */
            border-radius: 0;
            min-width: 0;
        }
        /* Ensure main-analysis-wrapper matches analysis-wrapper */
        .main-analysis-wrapper {
            background: #ffffff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            margin: 0;
            width: 100%;
            box-sizing: border-box;
        }
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .summary-content {
                padding: 10px;
            }
            [id$="-recommendation-section"] {
                padding: 15px;
            }
            [id$="-recommendation-section"] h4 {
                font-size: 18px;
            }
            [id$="-recommendation-section"] p, [id$="-recommendation-section"] div {
                font-size: 13px;
            }
            .analysis-wrapper, .main-analysis-wrapper {
                padding: 10px;
            }
            .analysis-wrapper h4, .main-analysis-wrapper h4 {
                font-size: 16px;
            }
            .analysis-wrapper p, .main-analysis-wrapper p {
                font-size: 13px;
            }
            [id$="-table-container"] {
                padding: 10px;
            }
            [id$="-table-container"] table {
                font-size: 12px;
            }
            [id$="-table-container"] th, [id$="-table-container"] td {
                padding: 10px;
            }
            .table-title {
                font-size: 14px;
                padding: 8px;
            }
        }
        @media (max-width: 480px) {
            [id$="-recommendation-section"] h4 {
                font-size: 16px;
            }
            [id$="-recommendation-section"] p, [id$="-recommendation-section"] div {
                font-size: 12px;
            }
            .analysis-wrapper h4, .main-analysis-wrapper h4 {
                font-size: 14px;
            }
            .analysis-wrapper p, .main-analysis-wrapper p {
                font-size: 12px;
            }
            [id$="-table-container"] table {
                font-size: 11px;
            }
            [id$="-table-container"] th, [id$="-table-container"] td {
                padding: 8px;
            }
            .table-title {
                font-size: 13px;
            }
        }
        /* New styles for pagination and interactive links */
        #pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        #pagination-controls button {
            padding: 5px 10px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #pagination-controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #page-info {
            font-size: 14px;
            color: #333;
        }
        .parameter-link {
            color: #4a90e2;
            text-decoration: none;
        }
        .parameter-link:hover {
            text-decoration: underline;
        }
        #parameter-filter {
            font-size: 14px;
            color: #666;
            margin-left: 20px;
        }
        /* Ensure highlighted row style */
        .highlighted {
            background-color: #d1e7dd !important;
        }
        /* Mobile adjustments for pagination */
        @media (max-width: 768px) {
            #pagination-controls {
                flex-direction: column;
                gap: 5px;
            }
            #pagination-controls button {
                width: 100%;
                max-width: 200px;
            }
        }
        /* New styles for vertical stacking in Target Probability tab */
        #slider-impact-reference-guide {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #slider-impact-reference-guide > div {
            width: 100%;
            max-width: none;
        }
        /* Added style for select elements to ensure consistent dropdown styling */
        select {
            padding: 5px;
            font-size: 14px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        /* Added style to stack Parameter Reference above Combination Explorer */
        #decision-slider-impact-reference-guide {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1200px;
            margin-top: 10px;
            padding: 15px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        /* New styles for Parameter Reference layout */
        .parameter-reference-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        .parameter-column {
            flex: 1;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
        }
        /* Ensure dual values don’t wrap and fit comfortably */
        .dual-value-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin: 0 auto;
            table-layout: auto;
        }
        .dual-value-table th, .dual-value-table td {
            padding: 6px 8px;
            font-size: 11px;
            font-family: Arial, sans-serif;
            border: 1px solid #ddd;
            text-align: center;
        }
        .dual-value-table th {
            background: #4a90e2;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        .dual-value-table td:last-child {
            white-space: normal;
            word-wrap: break-word;
            text-align: left; /* Maintain left alignment for Expected Outcome */
        }
        #decision-combination-table-body td {
            white-space: nowrap; /* Prevent wrapping of dual values */
            padding: 6px 8px; /* Slightly reduce padding to accommodate more columns */
            font-size: 11px; /* Smaller font for compact display */
            font-family: Arial, sans-serif;
        }
        /* Adjust for mobile screens */
        @media (max-width: 768px) {
            #decision-combination-table-body td {
                font-size: 10px; /* Even smaller font on mobile */
                padding: 4px 6px; /* Further reduced padding */
            }
        }
        /* Updated styles to ensure visibility for Monte Carlo Smoothed tab */
        #mc-smoothed-table-container {
            display: block !important; /* Ensures table container visibility */
            margin-top: 10px;
        }
        #mc-smoothed-use-case {
            display: block !important; /* Ensures toggle container visibility */
        }
        .toggle-use-case {
            display: inline-block !important; /* Ensures toggle button visibility */
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            cursor: pointer; /* Indicates interactivity */
        }
        /* New class for white box container */
        .white-box-container {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 10px;
            margin-top: 15px;
            text-align: center;
        }
        /* New styles for Target Probability Combination Explorer table */
        #combination-table-body td {
            white-space: nowrap; /* Prevent wrapping of dual values */
            padding: 6px 8px; /* Match Decision Optimizer’s compact layout */
            font-size: 11px; /* Smaller font for compact display */
            font-family: Arial, sans-serif;
        }
        /* Adjust for mobile screens */
        @media (max-width: 768px) {
            #combination-table-body td {
                font-size: 10px; /* Even smaller font on mobile */
                padding: 4px 6px; /* Further reduced padding */
            }
        }
    </style>
</head>

 
<!-- SECTION 2: HTML BODY -->
<body>
    <!-- Loading indicator added at the start of the body -->
    <div id="loading-overlay">Loading, please wait...</div>

    <!-- Chart Type Buttons -->
    <div id="chartType-container" style="text-align: center; margin-bottom: 10px;">
        <button id="trianglePlot" class="chart-button" data-type="basic" title="Quick estimates for project start"><strong>Triangular</strong><br>Start</button>
        <span class="tab-separator">|</span>
        <button id="pertPlot" class="chart-button" data-type="basic" title="Structured planning with weighted estimates"><strong>PERT</strong><br>Structure</button>
        <span class="tab-separator">|</span>
        <button id="betaPlot" class="chart-button" data-type="basic" title="Precise mid-project refinements"><strong>Beta</strong><br>Precision</button>
        <span class="tab-separator">|</span>
        <button id="mcBetaUnsmoothedPlot" class="chart-button" data-type="monte-carlo" title="Raw risk assessment via simulation"><strong>Monte Carlo</strong><br>Risks</button>
        <button id="mcBetaSmoothedPlot" class="chart-button" data-type="monte-carlo" title="Stable trends from smoothed simulations"><strong>Monte Carlo</strong><br>Trends</button>
        <span class="tab-separator">|</span>
        <button id="optimizedDecisionInsights" class="chart-button" data-type="optimizer" title="Optimize project decisions with parameter adjustments"><strong>Decision Optimizer</strong><br>Adjust Parameters</button>
        <button id="targetProbabilityExplorer" class="chart-button" data-type="explorer" title="Explore probabilities for specific project targets"><strong>Target Probability Explorer</strong><br>Set Targets</button>
    </div>

    <!-- Updated Slider Container with Dynamic Value Displays (Removed stray "Diameter" text) -->
    <div id="slider-container">
        <div id="confidence-container" class="slider-container">
            <label for="confidence-slider" class="slider-text" style="font-size: 12px; font-family: Arial, sans-serif; color: #333;">Set Target Confidence Level:</label>
            <input type="range" min="1" max="100" value="50" id="confidence-slider" aria-label="Adjust Confidence Level">
            <span id="confidence-help-icon" class="help-icon" title="Slide to set how sure you want to be about your project estimates (e.g., cost or time ranges).">?</span>
            <!-- This span will display both confidence % and value (e.g., "50%: 2368.39") once updated by JavaScript -->
            <span id="confidence-value" class="slider-text" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50%: (Calculating...)</span>
        </div>
        <div id="probability-container" class="slider-container">
            <label for="probability-slider" class="slider-text" style="font-size: 12px; font-family: Arial, sans-serif; color: #333;">Set Target Value:</label>
            <input type="range" min="0" max="100" value="50" id="probability-slider" aria-label="Adjust Probability Value">
            <span id="probability-help-icon" class="help-icon" title="Slide to see the odds of hitting specific project targets based on smoothed Monte Carlo results.">?</span>
            <span id="probability-result" class="slider-text" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">(Calculating...)</span>
        </div>
    </div>

    <div id="chart-container" style="display: block;">
        <div id="plot-wrapper">
            <div class="plot-container" data-tab="triangle" style="display: block; clear: both; position: relative;">
                <div id="triangle-div" style="display: block; min-height: 400px;"></div>
                <div id="triangle-use-case" class="use-case">
                    <button class="toggle-use-case" data-target="triangle-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                    <div id="triangle-use-case-content" class="use-case-content">
                        <p><strong><em>When to Use:</em></strong> Start here with your initial guesses for project variables like cost or time. This step creates a simple range to visualize uncertainty, helping you set a baseline for your project’s budget or timeline.</p>
                        <p><strong><em>How to Use:</em></strong> Input your best, most likely, and worst-case estimates into the Google Sheet to see a basic range.</p>
                        <p><strong><em>How It Helps:</em></strong> Provides a quick, intuitive view of possible outcomes, ideal for early planning when data is limited.</p>
                        <p><strong>Example Use Case:</strong> For a new product launch, input $1,000 (best), $1,500 (most likely), and $2,000 (worst). The plot shows a range, helping you propose a $1,600 budget as a starting point.</p>
                        <p><strong>Progression Rationale:</strong> This step uses a simple model to kick off the process, setting the stage for more refined estimates in later steps.</p>
                    </div>
                </div>
                <div id="triangle-summary-container" class="summary-section-container">
                    <div class="summary-section" data-tab="triangle">
                        <button class="toggle-summary" data-target="triangle-summary-content" aria-expanded="false">▼ Explore Summary Analysis - Triangle</button>
                        <div id="triangle-summary-content" class="summary-content" style="display: none;">
                            <div id="triangle-recommendation-section">
                                <h4>Recommendation</h4>
                                <p id="triangle-recommendation-content">[Recommendation content will be updated here]</p>
                            </div>
                            <div class="analysis-wrapper">
                                <div id="triangle-main-section">
                                    <h4>Step 1: Visualize Initial Estimates with the Triangular Distribution</h4>
                                    <p id="triangle-main-content">[Main content will be updated here]</p>
                                </div>
                            </div>
                            <div id="triangle-table-container">
                                <div class="table-title">Current Metrics</div>
                                <table id="triangle-metrics-table">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Value</th>
                                            <th>Description</th>
                                            <th>Calculation</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                                <div class="table-title">Recommendations</div>
                                <table id="triangle-recommendations-table">
                                    <thead>
                                        <tr>
                                            <th>Recommendation</th>
                                            <th>Value</th>
                                            <th>Why</th>
                                            <th>When to Use</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="plot-container" data-tab="pert" style="display: block; clear: both; position: relative;">
                <div id="pert-div" style="display: none; min-height: 400px;"></div>
                <div id="pert-use-case" class="use-case">
                    <button class="toggle-use-case" data-target="pert-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                    <div id="pert-use-case-content" class="use-case-content">
                        <p><strong><em>When to Use:</em></strong> Use this step during planning to refine your estimates with a structured approach. It balances optimism and caution by giving more weight to the most likely value, improving accuracy.</p>
                        <p><strong><em>How to Use:</em></strong> Enter optimistic, most likely, and pessimistic estimates in the Sheet to compute a weighted average.</p>
                        <p><strong><em>How It Helps:</em></strong> Offers a realistic starting point for your project’s schedule or budget, reducing bias in your estimates.</p>
                        <p><strong>Example Use Case:</strong> For a software project, input 2 weeks (optimistic), 4 weeks (most likely), and 6 weeks (pessimistic). The plot yields a 4-week mean, aiding realistic scheduling.</p>
                        <p><strong>Progression Rationale:</strong> This step enhances your initial guesses with a proven method, preparing you for more advanced analysis.</p>
                    </div>
                </div>
                <div id="pert-summary-container" class="summary-section-container">
                    <div class="summary-section" data-tab="pert">
                        <button class="toggle-summary" data-target="pert-summary-content" aria-expanded="false">▼ Explore Summary Analysis - PERT</button>
                        <div id="pert-summary-content" class="summary-content" style="display: none;">
                            <div id="pert-recommendation-section">
                                <h4>Recommendation</h4>
                                <p id="pert-recommendation-content">[Recommendation content will be updated here]</p>
                            </div>
                            <div class="analysis-wrapper">
                                <div id="pert-main-section">
                                    <h4>Step 2: Structure Estimates with the PERT Distribution</h4>
                                    <p id="pert-main-content">[Main content will be updated here]</p>
                                </div>
                            </div>
                            <div id="pert-table-container">
                                <div class="table-title">Current Metrics</div>
                                <table id="pert-metrics-table">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Value</th>
                                            <th>Description</th>
                                            <th>Calculation</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                                <div class="table-title">Recommendations</div>
                                <table id="pert-recommendations-table">
                                    <thead>
                                        <tr>
                                            <th>Recommendation</th>
                                            <th>Value</th>
                                            <th>Why</th>
                                            <th>When to Use</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="plot-container" data-tab="beta" style="display: block; clear: both; position: relative;">
                <div id="beta-div" style="display: none; min-height: 400px;"></div>
                <div id="beta-use-case" class="use-case">
                    <button class="toggle-use-case" data-target="beta-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                    <div id="beta-use-case-content" class="use-case-content">
                        <p><strong><em>When to Use:</em></strong> Use this step mid-project to refine estimates with emerging data. It creates a flexible curve that captures real-world variability, sharpening your understanding of uncertainty.</p>
                        <p><strong><em>How to Use:</em></strong> Input your current best, most likely, and worst-case estimates; the tool auto-calculates a precise probability curve.</p>
                        <p><strong><em>How It Helps:</em></strong> Adapts to new data, reducing risk and preparing you for simulations.</p>
                        <p><strong>Example Use Case:</strong> In construction, update to 50 days (best), 60 days (most likely), and 80 days (worst). The plot refines to a 62-day mean, adjusting the schedule.</p>
                        <p><strong>Progression Rationale:</strong> This step models uncertainty more accurately, setting the stage for simulation-based risk analysis.</p>
                    </div>
                </div>
                <div id="beta-summary-container" class="summary-section-container">
                    <div class="summary-section" data-tab="beta">
                        <button class="toggle-summary" data-target="beta-summary-content" aria-expanded="false">▼ Explore Summary Analysis - Beta</button>
                        <div id="beta-summary-content" class="summary-content" style="display: none;">
                            <div id="beta-recommendation-section">
                                <h4>Recommendation</h4>
                                <p id="beta-recommendation-content">[Recommendation content will be updated here]</p>
                            </div>
                            <div class="analysis-wrapper">
                                <div id="beta-main-section">
                                    <h4>Step 3: Refine Estimates with the Beta Distribution</h4>
                                    <p id="beta-main-content">[Main content will be updated here]</p>
                                </div>
                            </div>
                            <div id="beta-table-container">
                                <div class="table-title">Current Metrics</div>
                                <table id="beta-metrics-table">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Value</th>
                                            <th>Description</th>
                                            <th>Calculation</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                                <div class="table-title">Recommendations</div>
                                <table id="beta-recommendations-table">
                                    <thead>
                                        <tr>
                                            <th>Recommendation</th>
                                            <th>Value</th>
                                            <th>Why</th>
                                            <th>When to Use</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="plot-container" data-tab="mc-unsmoothed" style="display: block; clear: both; position: relative;">
                <div id="mc-unsmoothed-div" style="display: none; min-height: 400px;"></div>
                <div id="mc-unsmoothed-use-case" class="use-case">
                    <button class="toggle-use-case" data-target="mc-unsmoothed-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                    <div id="mc-unsmoothed-use-case-content" class="use-case-content">
                        <p><strong><em>When to Use:</em></strong> Use this step to assess patients’ risk exposure by simulating thousands of scenarios. It reveals the full range of possible outcomes, helping you prepare for best- and worst-case scenarios.</p>
                        <p><strong><em>How to Use:</em></strong> Provide input ranges in the Sheet; the plot shows a histogram of simulated outcomes.</p>
                        <p><strong><em>How It Helps:</em></strong> Highlights potential risks, such as cost overruns or delays, by showing the likelihood of extreme outcomes.</p>
                        <p><strong>Example Use Case:</strong> For a marketing campaign, input $10,000–$20,000. The plot shows a 90% chance of staying under $18,000, highlighting overspend risks.</p>
                        <p><strong>Progression Rationale:</strong> This step tests your estimates with random sampling, preparing you for trend analysis in the next step.</p>
                    </div>
                </div>
                <div id="mc-unsmoothed-summary-container" class="summary-section-container">
                    <div class="summary-section" data-tab="mcBetaUnsmoothed">
                        <button class="toggle-summary" data-target="mcbetaunsmoothed-summary-content" aria-expanded="false">▼ Explore Summary Analysis - Monte Carlo Unsmoothed</button>
                        <div id="mcbetaunsmoothed-summary-content" class="summary-content" style="display: none;">
                            <div id="mcbetaunsmoothed-recommendation-section">
                                <h4>Recommendation</h4>
                                <p id="mcbetaunsmoothed-recommendation-content">[Recommendation content will be updated here]</p>
                            </div>
                            <div class="analysis-wrapper">
                                <div id="mcbetaunsmoothed-main-section">
                                    <h4>Step 4: Simulate Risks with Monte Carlo (Unsmoothed)</h4>
                                    <p id="mcbetaunsmoothed-main-content">[Main content will be updated here]</p>
                                </div>
                            </div>
                            <div id="mc-unsmoothed-table-container">
                                <div class="table-title">Current Metrics</div>
                                <table id="mc-unsmoothed-metrics-table">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Value</th>
                                            <th>Description</th>
                                            <th>Calculation</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                                <div class="table-title">Recommendations</div>
                                <table id="mc-unsmoothed-recommendations-table">
                                    <thead>
                                        <tr>
                                            <th>Recommendation</th>
                                            <th>Value</th>
                                            <th>Why</th>
                                            <th>When to Use</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="mc-smoothed-wrapper" style="display: flex; justify-content: space-between; max-width: 1200px; margin: 0 auto;">
            <div class="plot-container" data-tab="mc-smoothed" style="display: block; clear: both; flex: 1; min-width: 0; margin-right: 10px;">
                <div id="mc-smoothed-div" style="display: none; width: 100%; height: 400px;"></div>
                <div id="mc-smoothed-use-case" class="use-case">
                    <button class="toggle-use-case" data-target="mc-smoothed-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                    <div id="mc-smoothed-use-case-content" class="use-case-content">
                        <p><strong><em>When to Use:</em></strong> Use this step to smooth the simulation results, focusing on key trends and probabilities. It makes the data easier to interpret for decision-making.</p>
                        <p><strong><em>How to Use:</em></strong> Input ranges in the Sheet; view the smoothed density plot and CDF to assess trends.</p>
                        <p><strong><em>How It Helps:</em></strong> Provides a clear view of likely outcomes, helping you plan for your project’s cost or time.</p>
                        <p><strong>Example Use Case:</strong> For a sales forecast, input $1M–$2M. The plot shows a $1.6M mean with a 95% interval, aiding inventory planning.</p>
                        <p><strong>Progression Rationale:</strong> This step refines the raw simulation data, preparing it for optimization in the next steps.</p>
                    </div>
                </div>
            </div>
            <div class="plot-container" data-tab="cdf" style="display: block; clear: both; flex: 1; min-width: 0; margin-left: 10px;">
                <div id="cdf-div" style="display: none; width: 100%; height: 400px;"></div>
                <div id="cdf-use-case" class="use-case">
                    <button class="toggle-use-case" data-target="cdf-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                    <div id="cdf-use-case-content" class="use-case-content">
                        <p><strong><em>When to Use:</em></strong> Use this step to see the cumulative likelihood of meeting specific targets, like staying under budget or on time.</p>
                        <p><strong><em>How to Use:</em></strong> Adjust the probability slider to explore different thresholds.</p>
                        <p><strong><em>How It Helps:</em></strong> Quantifies the odds of achieving your goals, enhancing target-focused planning.</p>
                        <p><strong>Example Use Case:</strong> In a construction project, you set a target budget of $2 million. The CDF plot indicates a 75% probability that the total cost will be $2 million or less, helping you assess whether the budget is realistic.</p>
                        <p><strong>Progression Rationale:</strong> This step enhances the smoothed Monte Carlo simulation by providing cumulative probabilities, enabling you to evaluate the likelihood of meeting specific project targets and make data-driven decisions.</p>
                    </div>
                </div>
            </div>
        </div>
        <!-- Summary Section for Monte Carlo Smoothed Tab -->
        <div id="mc-smoothed-summary-container" class="summary-section-container">
            <div class="summary-section" data-tab="mcBetaSmoothed">
                <button class="toggle-summary" data-target="mcbetasmoothed-summary-content" aria-expanded="false">▼ Explore Summary Analysis - Monte Carlo Smoothed</button>
                <div id="mcbetasmoothed-summary-content" class="summary-content" style="display: none;">
                    <div id="mc-smoothed-recommendation-section">
                        <div id="mc-smoothed-recommendation-content" style="display: block;">[Recommendation content will be updated here]</div>
                    </div>
                    <div class="analysis-wrapper side-by-side">
                        <div class="pdf-section">
                            <h4>PDF (Probability Density Function)</h4>
                            <p id="mc-smoothed-pdf-content">[PDF content will be updated here]</p>
                        </div>
                        <div class="cdf-section">
                            <h4>CDF (Cumulative Distribution Function)</h4>
                            <p id="mc-smoothed-cdf-content">[CDF content will be updated here]</p>
                        </div>
                    </div>
                    <div id="mc-smoothed-table-container">
                        <div class="table-title">Current Metrics</div>
                        <table id="mc-smoothed-metrics-table">
                            <thead>
                                <tr>
                                    <th>Metric</th>
                                    <th>Value</th>
                                    <th>Description</th>
                                    <th>Calculation</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Populated dynamically via JavaScript -->
                            </tbody>
                        </table>
                        <div class="table-title">Recommendations</div>
                        <table id="mc-smoothed-recommendations-table">
                            <thead>
                                <tr>
                                    <th>Recommendation</th>
                                    <th>Value</th>
                                    <th>Why</th>
                                    <th>When to Use</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Populated dynamically via JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Decision Optimizer Tab with Sliders -->
    <div id="decision-table-container" style="display: none;">
        <div style="width: 100%; max-width: 1200px; margin: 0 auto; padding: 15px;">
            <div class="decision-grid-container" style="display: flex; justify-content: space-evenly; margin-bottom: 15px;">
                <div class="decision-grid">
                    <label for="decisionBudgetFlexibility" style="display: block; text-align: center; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Budget Flexibility (%)</label>
                    <input type="range" id="decisionBudgetFlexibility" min="0" max="100" step="0.1" value="50" aria-label="Adjust Budget Flexibility">
                    <span id="decisionBudgetFlexibilityValue" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50% (50.0%)</span>
                    <span class="help-icon" title="Higher flexibility allows for a larger budget buffer, reducing cost overrun risks but increasing initial costs;">?</span>
                </div>
                <div class="decision-grid">
                    <label for="decisionScheduleFlexibility" style="display: block; text-align: center; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Schedule Flexibility (%)</label>
                    <input type="range" id="decisionScheduleFlexibility" min="0" max="100" step="0.1" value="50" aria-label="Adjust Schedule Flexibility">
                    <span id="decisionScheduleFlexibilityValue" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50% (50.0%)</span>
                    <span class="help-icon" title="Higher flexibility extends the timeline, reducing delay risks but potentially increasing costs;">?</span>
                </div>
                <div class="decision-grid">
                    <label for="decisionScopeUncertainty" style="display: block; text-align: center; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Scope Uncertainty (%)</label>
                    <input type="range" id="decisionScopeUncertainty" min="0" max="100" step="0.1" value="50" aria-label="Adjust Scope Uncertainty">
                    <span id="decisionScopeUncertaintyValue" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50% (50.0%)</span>
                    <span class="help-icon" title="Higher uncertainty increases the range of possible outcomes, reflecting less confidence in project requirements;">?</span>
                </div>
                <div class="decision-grid">
                    <label for="decisionRiskTolerance" style="display: block; text-align: center; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Risk Tolerance (%)</label>
                    <input type="range" id="decisionRiskTolerance" min="0" max="100" step="0.1" value="50" aria-label="Adjust Risk Tolerance">
                    <span id="decisionRiskToleranceValue" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50% (50.0%)</span>
                    <span class="help-icon" title="Higher tolerance allows for bolder decisions, accepting greater variability in outcomes;">?</span>
                </div>
            </div>
            <div id="decision-annotation-display" style="font-size: 12px; color: #666; text-align: center; margin-top: 5px;"></div>
            <div id="recommendation-output" class="decision-section decision-balanced">
                <div id="decision-overlay-chart" style="width: 100%; height: 400px; margin-top: 20px;"></div>
                <div id="decision-use-case" class="use-case">
                    <button class="toggle-use-case" data-target="decision-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                    <div id="decision-use-case-content" class="use-case-content">
                        <p><strong><em>When to Use:</em></strong> Use this step to optimize your project decisions by adjusting parameters such as budget flexibility, schedule flexibility, scope uncertainty, and risk tolerance. It’s ideal for tailoring data to your project’s specific priorities.</p>
                        <p><strong><em>How to Use:</em></strong> Adjust the sliders for Budget Flexibility, Schedule Flexibility, Scope Uncertainty, and Risk Tolerance; the plot updates to reflect your settings and provides an optimized recommendation.</p>
                        <p><strong><em>How It Helps:</em></strong> Recommends an optimal value (e.g., budget or timeline) based on your inputs, balancing cost, time, and risk to align with your goals.</p>
                        <p><strong>Example Use Case:</strong> For a product launch, set Budget Flexibility to 50% and Schedule Flexibility to 25%. The plot suggests an optimized budget and timeline, helping you finalize resource plans.</p>
                        <p><strong>Progression Rationale:</strong> This step refines simulation data with your preferences, preparing you for target-specific analysis in the next step.</p>
                    </div>
                </div>
                <div id="decision-summary-container" class="summary-section-container">
                    <div class="summary-section" data-tab="optimizedDecisionInsights">
                        <button class="toggle-summary" data-target="optimizeddecisioninsights-summary-content" aria-expanded="false">▼ Explore Summary Analysis - Decision Optimizer</button>
                        <div id="optimizeddecisioninsights-summary-content" class="summary-content" style="display: none;">
                            <div id="optimizeddecisioninsights-recommendation-section">
                                <h4>Recommendation</h4>
                                <p id="optimizeddecisioninsights-recommendation-content">[Recommendation content will be updated here]</p>
                            </div>
                            <div class="analysis-wrapper side-by-side">
                                <div id="optimizeddecisioninsights-original-section">
                                    <h4>Original Distribution</h4>
                                    <p id="optimizeddecisioninsights-original-content">[Original Distribution content will be updated here]</p>
                                </div>
                                <div id="optimizeddecisioninsights-optimized-section">
                                    <h4>Optimized Distribution</h4>
                                    <p id="optimizeddecisioninsights-optimized-content">[Optimized Distribution content will be updated here]</p>
                                </div>
                            </div>
                            <div id="decision-table-container-metrics">
                                <div class="table-title">Current Metrics</div>
                                <table id="decision-metrics-table">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Value</th>
                                            <th>Description</th>
                                            <th>Calculation</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                                <div class="table-title">Recommendations</div>
                                <table id="decision-recommendations-table">
                                    <thead>
                                        <tr>
                                            <th>Recommendation</th>
                                            <th>Value</th>
                                            <th>Why</th>
                                            <th>When to Use</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Populated dynamically via JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Existing decision-table-wrapper with Analysis Report and Updated Slider Impact Section -->
            <div id="decision-table-wrapper-existing">
                <!-- Analysis Report Toggle for Decision Optimizer -->
                <div class="white-box-container">
                    <button class="toggle-summary" data-target="decision-analysis-report" aria-expanded="false">▼ Analysis Report</button>
                    <div id="decision-analysis-report" style="display: none; width: 100%; max-width: 1200px; margin-top: 10px; padding: 15px; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Content will be dynamically populated via JavaScript -->
                </div>
                </div>
                <!-- Updated Slider Impact and Reference Guide Toggle for Decision Optimizer -->
                <div class="white-box-container">
                    <button class="toggle-summary" data-target="decision-slider-impact-reference-guide" aria-expanded="true">▼ Slider Combination Explorer</button>
                    <div id="decision-slider-impact-reference-guide" style="display: block; width: 100%; max-width: 1200px; margin-top: 10px; padding: 15px; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <!-- Updated Combination Explorer Section with Dropdown and Pagination -->
                        <div id="decision-combination-explorer-section">
                            <div style="margin-bottom: 10px; text-align: center;">
                                <label for="decision-median-filter" style="font-size: 14px; margin-right: 10px;">Filter Combinations:</label>
                                <select id="decision-median-filter">
                                    <option value="all">All</option>
                                    <option value="current">Current Selection</option>
                                    <option value="belowMedian">Below Original Median</option>
                                    <option value="aboveMedian">Above Original Median</option>
                                    <option value="highFlexibility">High Flexibility (BF + SF ≥ 100%)</option>
                                    <option value="lowUncertainty">Low Uncertainty (SU ≤ 25%)</option>
                                </select>
                                <span id="decision-parameter-filter" style="font-size: 14px; color: #666; margin-left: 20px;"></span>
                            </div>
                            <!-- Decision Optimizer Combination Explorer table, displaying rounded and precise slider values -->
                            <table id="decision-combination-table" style="width: 100%; overflow-x: auto;" class="dual-value-table">
                                <tbody id="decision-combination-table-body">
                                    <!-- Rows will be inserted here -->
                                </tbody>
                            </table>
                            <div id="decision-pagination-controls" style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 10px;">
                                <button id="decision-prev-page">Previous</button>
                                <span id="decision-page-info">Page 1</span>
                                <button id="decision-next-page">Next</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Target Probability Explorer Tab with Sliders -->
    <div id="target-probability-container" style="display: none;" class="debug-target">
        <div style="width: 100%; max-width: 1200px; margin: 0 auto; padding: 15px;">
            <div style="text-align: center; margin-bottom: 10px; width: 100%;">
                <div class="slider-container target" id="target-slider-container" style="width: 100%; max-width: 1200px; display: flex; justify-content: center; align-items: center; gap: 10px;">
                    <label for="target-value-slider" style="font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Set Target Value:</label>
                    <input type="range" id="target-value-slider" style="flex-grow: 1; width: 100%;" aria-label="Set Target Value">
                    <span id="target-help-icon" class="help-icon" title="Slide to set your target value (e.g., cost, time). Adjust settings below to explore your chances of hitting it. Expand the report for a full plan;">?</span>
                    <span id="target-value-display" style="margin-left: 8px; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: blue;"></span>
                </div>
                <div id="target-annotation-display" style="font-size: 12px; color: #666; text-align: center; margin-top: 5px;"></div>
            </div>
            <div class="decision-grid-container" style="display: flex; justify-content: space-evenly; margin-bottom: 15px;">
                <div class="decision-grid">
                    <label for="targetBudgetFlexibility" style="display: block; text-align: center; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Budget Flexibility (%)</label>
                    <input type="range" id="targetBudgetFlexibility" min="0" max="100" step="1" value="50" aria-label="Adjust Budget Flexibility">
                    <span id="targetBudgetFlexibilityValue" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50% (50%)</span>
                    <span class="help-icon" title="Higher flexibility allows for a larger budget buffer, reducing cost overrun risks but increasing initial costs;">?</span>
                </div>
                <div class="decision-grid">
                    <label for="targetScheduleFlexibility" style="display: block; text-align: center; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Schedule Flexibility (%)</label>
                    <input type="range" id="targetScheduleFlexibility" min="0" max="100" step="1" value="50" aria-label="Adjust Schedule Flexibility">
                    <span id="targetScheduleFlexibilityValue" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50% (50%)</span>
                    <span class="help-icon" title="Higher flexibility extends the timeline, reducing delay risks but potentially increasing costs;">?</span>
                </div>
                <div class="decision-grid">
                    <label for="targetScopeUncertainty" style="display: block; text-align: center; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Scope Uncertainty (%)</label>
                    <input type="range" id="targetScopeUncertainty" min="0" max="100" step="1" value="50" aria-label="Adjust Scope Uncertainty">
                    <span id="targetScopeUncertaintyValue" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50% (50%)</span>
                    <span class="help-icon" title="Higher uncertainty increases the range of possible outcomes, reflecting less confidence in project requirements;">?</span>
                </div>
                <div class="decision-grid">
                    <label for="targetRiskTolerance" style="display: block; text-align: center; font-weight: bold; font-size: 12px; font-family: Arial, sans-serif; color: #333;">Risk Tolerance (%)</label>
                    <input type="range" id="targetRiskTolerance" min="0" max="100" step="1" value="50" aria-label="Adjust Risk Tolerance">
                    <span id="targetRiskToleranceValue" style="font-size: 12px; font-family: Arial, sans-serif; color: blue;">50% (50%)</span>
                    <span class="help-icon" title="Higher tolerance allows for bolder decisions, accepting greater variability in outcomes;">?</span>
                </div>
            </div>
            <div style="display: flex; gap: 20px; justify-content: space-between; max-width: 1200px; margin: 0 auto;">
                <div class="plot-container" data-tab="original-cdf" style="display: block; clear: both; flex: 1; min-width: 0;">
                    <div id="original-cdf-chart" style="width: 100%; height: 400px;"></div>
                    <div id="original-cdf-use-case" class="use-case">
                        <button class="toggle-use-case" data-target="original-cdf-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                        <div id="original-cdf-use-case-content" class="use-case-content">
                            <p><strong><em>When to Use:</em></strong> Use this to see your project’s baseline chances of meeting targets without adjustments.</p>
                            <p><strong><em>How to Use:</em></strong> View the original CDF plot to understand current probabilities.</p>
                            <p><strong><em>How It Helps:</em></strong> Sets a reference point for optimization, showing where you stand now.</p>
                            <p><strong>Example Use Case:</strong> For a software development project, the original CDF shows a 60% probability of completing the project within 6 months. This baseline helps you understand the initial risk before applying any optimizations.</p>
                            <p><strong>Progression Rationale:</strong> This step establishes the starting point for probability analysis, allowing you to compare the original scenario with optimized versions and measure the impact of adjustments.</p>
                        </div>
                    </div>
                </div>
                <div class="plot-container" data-tab="optimized-cdf" style="display: block; clear: both; flex: 1; min-width: 0;">
                    <div id="optimized-cdf-chart" style="width: 100%; height: 400px;"></div>
                    <div id="optimized-cdf-use-case" class="use-case">
                        <button class="toggle-use-case" data-target="optimized-cdf-use-case-content" style="font-size: 14px; font-weight: bold; color: #4a90e2; background: none; border: none; cursor: pointer;" aria-expanded="false">▼ Use Case</button>
                        <div id="optimized-cdf-use-case-content" class="use-case-content">
                            <p><strong><em>When to Use:</em></strong> Use this to explore how adjustments improve your chances of meeting a specific target (e.g., budget or timeline).</p>
                            <p><strong><em>How to Use:</em></strong> Set a target value with the slider and adjust flexibility and risk settings; the plot shows updated probabilities.</p>
                            <p><strong><em>How It Helps:</em></strong> Helps you understand the impact of temperature changes on achieving your target, guiding strategic adjustments.</p>
                            <p><strong>Example Use Case:</strong> For a $2M construction budget, see how increasing flexibility boosts your odds of staying on target.</p>
                            <p><strong>Progression Rationale:</strong> This step finalizes your analysis by showing target success probabilities based on your settings.</p>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Summary Section for Target Probability Explorer Tab -->
            <div id="target-summary-container" class="summary-section-container">
                <div class="summary-section" data-tab="targetProbabilityExplorer">
                    <button class="toggle-summary" data-target="targetprobabilityexplorer-summary-content" aria-expanded="false">▼ Explore Summary Analysis - Target Probability</button>
                    <div id="targetprobabilityexplorer-summary-content" class="summary-content" style="display: none;">
                        <div id="targetprobabilityexplorer-recommendation-section">
                            <h4>Recommendation</h4>
                            <p id="targetprobabilityexplorer-recommendation-content">[Recommendation content will be updated here]</p>
                        </div>
                        <div class="analysis-wrapper side-by-side">
                            <div id="targetprobabilityexplorer-original-cdf-section">
                                <h4>Original CDF (Cumulative Distribution Function)</h4>
                                <p id="targetprobabilityexplorer-original-cdf-content">[Original CDF content will be updated here]</p>
                            </div>
                            <div id="targetprobabilityexplorer-optimized-cdf-section">
                                <h4>Optimized CDF (Cumulative Distribution Function)</h4>
                                <p id="targetprobabilityexplorer-optimized-cdf-content">[Optimized CDF content will be updated here]</p>
                            </div>
                        </div>
                        <div id="target-table-container-metrics">
                            <div class="table-title">Current Metrics</div>
                            <table id="target-metrics-table">
                                <thead>
                                    <tr>
                                        <th>Metric</th>
                                        <th>Value</th>
                                        <th>Description</th>
                                        <th>Calculation</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- Populated dynamically via JavaScript -->
                                </tbody>
                            </table>
                            <div class="table-title">Recommendations</div>
                            <table id="target-recommendations-table">
                                <thead>
                                    <tr>
                                        <th>Recommendation</th>
                                        <th>Value</th>
                                        <th>Why</th>
                                        <th>When to Use</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- Populated dynamically via JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Updated target-table-wrapper-existing for Target Probability Explorer with combined toggle -->
            <div id="target-table-wrapper-existing" style="display: flex; flex-direction: column; gap: 15px; margin-top: 15px; width: 100%;">
                <div class="white-box-container">
                    <button class="toggle-summary" data-target="target-report" aria-expanded="false">▼ Analysis Report</button>
                    <div id="target-report" style="display: none; width: 100%; max-width: 1200px; margin-top: 10px; padding: 15px; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);" class="use-case-content analysis-report">
                        <!-- Content will be dynamically populated via JavaScript -->
                    </div>
                </div>
                <div class="white-box-container">
                    <button class="toggle-summary" data-target="slider-impact-reference-guide" aria-expanded="true">▲ Slider Combination Explorer</button>
                    <div id="slider-impact-reference-guide" style="display: block; width: 100%; background: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <!-- Combination Explorer Section -->
                        <div id="combination-explorer-section">
                            <div style="margin-bottom: 10px; text-align: center;">
                                <label for="probability-filter" style="font-size: 14px; margin-right: 10px;">Filter Combinations:</label>
                                <select id="probability-filter" style="padding: 5px; font-size: 14px; border-radius: 4px; border: 1px solid #ddd;">
                                    <option value="all">All</option>
                                    <option value="above50">Above 50%</option>
                                    <option value="above75">Above 75%</option>
                                    <option value="below50">Below 50%</option>
                                    <option value="current">Current Selection</option>
                                </select>
                                <span id="parameter-filter" style="font-size: 14px; color: #666; margin-left: 20px;"></span>
                            </div>
                            <table id="combination-table" style="width: 100%; overflow-x: auto;" class="dual-value-table">
                                <tbody id="combination-table-body">
                                    <!-- Rows will be inserted here -->
                                </tbody>
                            </table>
                            <div id="pagination-controls" style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 10px;">
                                <button id="prev-page">Previous</button>
                                <span id="page-info">Page 1</span>
                                <button id="next-page">Next</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Back to Top Button -->
    <button id="back-to-top">Back to Top</button>

    <!-- New styles for Target Probability Combination Explorer table -->
    <style>
        #combination-table-body td {
            padding: 6px 8px; /* Match Decision Optimizer’s compact layout */
            font-size: 11px; /* Smaller font for compact display */
            font-family: Arial, sans-serif;
        }
        #combination-table-body td:last-child {
            white-space: normal; /* Allow wrapping for Expected Outcome */
            word-wrap: break-word;
        }
        /* Adjust for mobile screens */
        @media (max-width: 768px) {
            #combination-table-body td {
                font-size: 10px; /* Even smaller font on mobile */
                padding: 4px 6px; /* Further reduced padding */
            }
        }
    </style>
</body>

<!-- SECTION 3.a: JAVASCRIPT - GLOBAL SETUP AND EVENT LISTENERS -->
<script type="text/javascript">
    // Define restoreToggleStates globally to ensure it's available immediately
    window.restoreToggleStates = function() {
        // Initialize toggleStates for slider-impact-reference-guide if not set
        if (!toggleStates['slider-impact-reference-guide']) {
            toggleStates['slider-impact-reference-guide'] = true;
        }
        document.querySelectorAll('.use-case-content, [id$="-table-content"], [id$="-recommendation-content"], #slider-impact-reference-guide').forEach(target => {
            const id = target.id;
            if (toggleStates[id]) {
                target.style.display = 'block';
                const button = document.querySelector(`[data-target="${id}"]`);
                if (button) {
                    button.textContent = '▲ ' + button.textContent.slice(2);
                    button.setAttribute('aria-expanded', 'true');
                }
            } else {
                target.style.display = 'none';
                const button = document.querySelector(`[data-target="${id}"]`);
                if (button) {
                    button.textContent = '▼ ' + button.textContent.slice(2);
                    button.setAttribute('aria-expanded', 'false');
                }
            }
        });
        console.log('Toggle states restored:', toggleStates);
    };

    // Define setupToggleListeners to attach event listeners to toggle buttons
    function setupToggleListeners() {
        // Handle .toggle-use-case buttons (e.g., Use Case)
        document.querySelectorAll('.toggle-use-case').forEach(button => {
            button.addEventListener('click', () => {
                const targetId = button.getAttribute('data-target');
                const target = document.getElementById(targetId);
                if (!target) {
                    console.warn(`Toggle target not found: ${targetId}`);
                    return;
                }
                const isExpanded = button.getAttribute('aria-expanded') === 'true';
                const newExpanded = !isExpanded;
                target.style.display = newExpanded ? 'block' : 'none';
                button.setAttribute('aria-expanded', newExpanded ? 'true' : 'false');
                button.textContent = (newExpanded ? '▲ ' : '▼ ') + button.textContent.slice(2);
                toggleStates[targetId] = newExpanded;
                console.log(`Toggled ${targetId} to ${newExpanded ? 'expanded' : 'collapsed'}`);
            }, { passive: true });
        });

        // Handle .toggle-summary buttons with Monte Carlo Smoothed and Slider Combination Explorer special cases
        document.querySelectorAll('.toggle-summary').forEach(button => {
            button.addEventListener('click', () => {
                const targetId = button.getAttribute('data-target');
                const target = document.getElementById(targetId);
                if (!target) {
                    console.warn(`Toggle target not found: ${targetId}`);
                    return;
                }
                const isExpanded = button.getAttribute('aria-expanded') === 'true';
                const newExpanded = !isExpanded;
                target.style.display = newExpanded ? (targetId.endsWith('-summary-content') || targetId === 'decision-slider-impact-reference-guide' || targetId === 'slider-impact-reference-guide' ? 'flex' : 'block') : 'none';
                button.setAttribute('aria-expanded', newExpanded ? 'true' : 'false');
                button.textContent = (newExpanded ? '▲ ' : '▼ ') + button.textContent.slice(2);
                toggleStates[targetId] = newExpanded;

                // Special handling for Monte Carlo Smoothed summary
                if (targetId === 'mcbetasmoothed-summary-content') {
                    const recommendationContent = document.getElementById('mc-smoothed-recommendation-content');
                    if (recommendationContent) {
                        recommendationContent.style.display = newExpanded ? 'block' : 'none';
                        console.log(`Synchronized mc-smoothed-recommendation-content display to ${newExpanded ? 'block' : 'none'}`);
                    }
                }

                console.log(`Toggled ${targetId} to ${newExpanded ? 'expanded' : 'collapsed'}`);
            }, { passive: true });
        });
    }

    // Load Google Charts and initialize the application once the DOM is fully loaded
   document.addEventListener('DOMContentLoaded', function() {
    // Set up toggle listeners and restore states
    setupToggleListeners();
    window.restoreToggleStates();

    // Load Google Charts and initialize the application
    google.charts.load('current', { packages: ['corechart', 'line'] });
    google.charts.setOnLoadCallback(() => {
        console.log('Google Charts loaded');
        // Check if all required global variables are defined
        if (typeof sheetId === 'undefined' || typeof sheetName === 'undefined' || typeof rowIndex === 'undefined') {
            console.error('Required variables not defined:', { sheetId, sheetName, rowIndex });
            showError('Error: sheetId, sheetName, or rowIndex not defined');
        } else {
            initialize(); // Call initialize directly with global variables
        }
    });
});
</script>
 

<!-- SECTION 3.b: JAVASCRIPT - GLOBAL VARIABLES AND STATE -->
<script type="text/javascript">
    // Global variables for managing plot data and state
    let adjustedPoints = []; // Stores adjusted points for the optimized CDF
    let isInitialized = false; // Tracks whether initialization is complete
    let pendingTabAction = null; // Stores pending tab actions if initialization is not complete
    let useSnapping = false; // Controls whether sliders snap to discrete values

    // Global variables for distribution parameters and plot data
    var min, max, mostLikely, triangleMean, triangleVariance, triangleStdDev, triangleSkewness, triangleKurtosis, triangleVaR, triangleCVaR, triangleMAD;
    var pertMean, pertVariance, pertStd, pertSkewness, pertKurtosis, pertVaR, pertCVaR, pertMAD;
    var betaMean, betaMode, betaVariance, betaStdDev, betaSkewness, betaKurtosis, betaVaR, betaCVaR, betaMAD, alpha, beta;
    var mcUnsmoothedMean, mcUnsmoothedVariance, mcUnsmoothedStdDev, mcUnsmoothedSkewness, mcUnsmoothedKurtosis, mcUnsmoothedVaR, mcUnsmoothedCVaR, mcUnsmoothedMAD;
    var mcSmoothedMean, mcSmoothedVariance, mcSmoothedStdDev, mcSmoothedSkewness, mcSmoothedKurtosis, mcSmoothedVaR, mcSmoothedCVaR, mcSmoothedMAD;
    var weightedConservative, weightedNeutral, weightedOptimistic;
    var triangleData, triangleChart, triangleOptions;
    var pertData, pertChart, pertOptions;
    var betaData, betaChart, betaOptions;
    var mcUnsmoothedData, mcUnsmoothedChart, mcUnsmoothedOptions;
    var mcSmoothedData, mcSmoothedChart, mcSmoothedOptions;
    var cdfData, cdfChart, cdfOptions;

    // Arrays to store points for each distribution type
    var TRIANGLE_POINTS = [];
    var PERT_POINTS = [];
    var BETA_POINTS = [];
    var MC_UNSMOOTHED_POINTS = [];
    var MC_SMOOTHED_POINTS = [];
    var CDF_POINTS = [];

    // Object to store toggle states for use case sections
    const toggleStates = {};

    // Initial slider state with default values
    window.sliderState = {
        'budgetFlexibility': '50',
        'scheduleFlexibility': '50',
        'scopeUncertainty': '50',
        'riskTolerance': '50'
    };

    /**
     * Interpolates between two points to find the x, y coordinates for a given confidence level.
     * @param {Array} points - Array of points [{x, y, confidence}].
     * @param {number} confidence - Desired confidence level (0-100).
     * @returns {Object} - Interpolated point {x, y, confidence}.
     */
    function interpolatePoint(points, confidence) {
        if (!points || points.length < 2) {
            return points[0] || { x: 0, y: 0, confidence: confidence };
        }

        // Find the two points that bracket the confidence level
        let lowerPoint = points[0];
        let upperPoint = points[points.length - 1];
        for (let i = 0; i < points.length - 1; i++) {
            if (points[i].confidence <= confidence && points[i + 1].confidence >= confidence) {
                lowerPoint = points[i];
                upperPoint = points[i + 1];
                break;
            }
        }

        // Handle edge cases
        if (confidence <= points[0].confidence) {
            return { ...points[0], confidence };
        }
        if (confidence >= points[points.length - 1].confidence) {
            return { ...points[points.length - 1], confidence };
        }

        // Linear interpolation
        const fraction = (confidence - lowerPoint.confidence) / (upperPoint.confidence - lowerPoint.confidence);
        const x = lowerPoint.x + fraction * (upperPoint.x - lowerPoint.x);
        const y = lowerPoint.y + fraction * (upperPoint.y - lowerPoint.y);

        return { x, y, confidence };
    }

    /**
     * Initializes the application with properties fetched from the API via Code.gs.
     * Sets up global variables, event listeners, and initial plot rendering.
     * @param {string} sheetId - The ID of the Google Sheet.
     */
function initialize(sheetId) {
    console.log('Initializing with sheetId:', sheetId);
    try {
        // **Remove duplicate confidence sliders**
        const sliders = document.querySelectorAll('#confidence-slider');
        if (sliders.length > 1) {
            console.warn('Multiple confidence sliders found; removing duplicates');
            for (let i = 1; i < sliders.length; i++) {
                sliders[i].parentElement.remove();
            }
        }

        // **Reset slider state if corrupted or uninitialized**
        if (!window.sliderState || Object.keys(window.sliderState).length !== 4) {
            console.warn('sliderState corrupted or uninitialized, resetting to defaults');
            window.sliderState = {
                budgetFlexibility: '50',
                scheduleFlexibility: '50',
                scopeUncertainty: '50',
                riskTolerance: '50'
            };
        }

        // **Validate that sheetName and rowIndex are defined**
        if (typeof sheetName === 'undefined' || typeof rowIndex === 'undefined') {
            throw new Error('sheetName or rowIndex not provided');
        }

        // **Fetch properties from the server using Google Apps Script**
        google.script.run
            .withSuccessHandler(props => {
                // **Validate received properties**
                if (!props || typeof props !== 'object') {
                    throw new Error('Invalid properties received from server');
                }
                console.log('Properties loaded:', props);

                // **Assign basic parameters**
                min = props.MIN || 0;
                max = props.MAX || 100;
                mostLikely = props.MOST_LIKELY || 50;

                // **Triangle distribution properties**
                triangleMean = props.TRIANGLE_MEAN || 0;
                triangleVariance = props.TRIANGLE_VARIANCE || 0;
                triangleStdDev = props.TRIANGLE_STD || 0;
                triangleSkewness = props.TRIANGLE_SKEWNESS || 0;
                triangleKurtosis = props.TRIANGLE_KURTOSIS || 0;
                triangleVaR = props.TRIANGLE_VAR || 0;
                triangleCVaR = props.TRIANGLE_CVAR || 0;
                triangleMAD = props.TRIANGLE_MAD || 0;

                // **PERT distribution properties**
                pertMean = props.PERT_MEAN || 0;
                pertVariance = props.PERT_VARIANCE || 0;
                pertStd = props.PERT_STD || 0;
                pertSkewness = props.PERT_SKEWNESS || 0;
                pertKurtosis = props.PERT_KURTOSIS || 0;
                pertVaR = props.PERT_VAR || 0;
                pertCVaR = props.PERT_CVAR || 0;
                pertMAD = props.PERT_MAD || 0;

                // **Beta distribution properties**
                betaMean = props.BETA_MEAN || 0;
                betaMode = props.BETA_MODE || 0;
                betaVariance = props.BETA_VARIANCE || 0;
                betaStdDev = props.BETA_STD || 0;
                betaSkewness = props.BETA_SKEWNESS || 0;
                betaKurtosis = props.BETA_KURTOSIS || 0;
                betaVaR = props.BETA_VAR || 0;
                betaCVaR = props.BETA_CVAR || 0;
                betaMAD = props.BETA_MAD || 0;
                alpha = props.ALPHA || 0;
                beta = props.BETA || 0;

                // **Monte Carlo unsmoothed properties**
                mcUnsmoothedMean = props.MC_UNSMOOTHED_MEAN || 0;
                mcUnsmoothedVariance = props.MC_UNSMOOTHED_VARIANCE || 0;
                mcUnsmoothedStdDev = props.MC_UNSMOOTHED_STD || 0;
                mcUnsmoothedSkewness = props.MC_UNSMOOTHED_SKEWNESS || 0;
                mcUnsmoothedKurtosis = props.MC_UNSMOOTHED_KURTOSIS || 0;
                mcUnsmoothedVaR = props.MC_UNSMOOTHED_VAR || 0;
                mcUnsmoothedCVaR = props.MC_UNSMOOTHED_CVAR || 0;
                mcUnsmoothedMAD = props.MC_UNSMOOTHED_MAD || 0;

                // **Monte Carlo smoothed properties**
                mcSmoothedMean = props.MC_SMOOTHED_MEAN || 0;
                mcSmoothedVariance = props.MC_SMOOTHED_VARIANCE || 0;
                mcSmoothedStdDev = props.MC_SMOOTHED_STD || 0;
                mcSmoothedSkewness = props.MC_SMOOTHED_SKEWNESS || 0;
                mcSmoothedKurtosis = props.MC_SMOOTHED_KURTOSIS || 0;
                mcSmoothedVaR = props.MC_SMOOTHED_VAR || 0;
                mcSmoothedCVaR = props.MC_SMOOTHED_CVAR || 0;
                mcSmoothedMAD = props.MC_SMOOTHED_MAD || 0;

                // **Weighted estimates**
                weightedConservative = props.WEIGHTED_CONSERVATIVE || 0;
                weightedNeutral = props.WEIGHTED_NEUTRAL || 0;
                weightedOptimistic = props.WEIGHTED_OPTIMISTIC || 0;

                // **Load point arrays and assign confidence levels**
                TRIANGLE_POINTS = (props.TRIANGLE_POINTS || []).map((p, i) => ({ ...p, confidence: (i + 1) }));
                PERT_POINTS = (props.PERT_POINTS || []).map((p, i) => ({ ...p, confidence: (i + 1) }));
                BETA_POINTS = (props.BETA_POINTS || []).map((p, i) => ({ ...p, confidence: (i + 1) }));
                MC_UNSMOOTHED_POINTS = (props.MC_UNSMOOTHED_POINTS || []).map((p, i) => ({ ...p, confidence: (i + 1) }));
                MC_SMOOTHED_POINTS = (props.MC_SMOOTHED_POINTS || []).map((p, i) => ({ ...p, confidence: (i + 1) }));
                CDF_POINTS = (props.CDF_POINTS || []).map((p, i) => ({ ...p, confidence: (i + 1) }));

                // **Load skewness values into global object**
                window.originalSkewness = {
                    triangle: props.TRIANGLE_SKEWNESS || 0,
                    pert: props.PERT_SKEWNESS || 0,
                    beta: props.BETA_SKEWNESS || 0,
                    mcUnsmoothed: props.MC_UNSMOOTHED_SKEWNESS || 0,
                    mcSmoothed: props.MC_SMOOTHED_SKEWNESS || 0
                };
                console.log('Original skewness loaded:', window.originalSkewness);

                console.log('MC_SMOOTHED_POINTS initialized:', MC_SMOOTHED_POINTS);
                isInitialized = true;

                // **Initialize UI components**
                console.log('Setting up chart type buttons');
                createChartTypeButtons();
                console.log('Creating confidence slider');
                createConfidenceSlider();
                console.log('Creating probability slider');
                createProbabilitySlider();

                // **Set initial confidence value and trigger update**
                const initialValue = window.lastConfidence || 50;
                const confidenceSlider = document.getElementById('confidence-slider');
                if (confidenceSlider) {
                    confidenceSlider.value = initialValue;
                    confidenceSlider.dispatchEvent(new Event('input')); // Trigger initial update
                }

                // **Draw initial plot and set active button**
                console.log('Drawing initial plot: trianglePlot');
                drawSelectedPlot('trianglePlot');
                document.querySelectorAll('.chart-button').forEach(btn => btn.classList.remove('active'));
                const triangleBtn = document.getElementById('trianglePlot');
                if (triangleBtn) triangleBtn.classList.add('active');

                // **Update plot with a slight delay**
                setTimeout(() => {
                    console.log('Updating plot with initial confidence');
                    updatePlot('trianglePlot', initialValue);
                }, 100);

                // **Update tables and recommendations**
                console.log('Updating tables and recommendations');
                updateTablesAndRecommendations('trianglePlot');

                // **Set up slider interactions**
                console.log('Setting up slider listeners');
                setupSliderListeners();
                console.log('Synchronizing sliders');
                synchronizeSliders();
                console.log('Restoring sliders');
                restoreSliders();

                // **Handle pending tab actions**
                if (pendingTabAction) {
                    console.log('Executing pending tab action after initialization');
                    pendingTabAction();
                    pendingTabAction = null;
                }

                // **Hide loading overlay**
                document.getElementById('loading-overlay').style.display = 'none';
            })
            .withFailureHandler(error => {
                showError(`Initialization failed: ${error.message}`);
                isInitialized = false;
                document.getElementById('loading-overlay').style.display = 'none';
            })
            .getProperties(sheetId, sheetName, rowIndex); // Updated to include sheetName and rowIndex
    } catch (error) {
        showError(`Initialization failed: ${error.message}`);
        isInitialized = false;
        document.getElementById('loading-overlay').style.display = 'none';
    }
}
</script>

 
<!-- SECTION 3.c: JAVASCRIPT - TARGET PROBABILITY EXPLORER AND CDF UTILITIES -->
<script type="text/javascript">
    /**
     * Displays the Target Probability Explorer tab, showing original and optimized CDF plots.
     * Handles initialization checks and error states.
     */
    function showScenarioTargets() {
        const container = document.getElementById('target-probability-container');
        if (!container) {
            console.error('Target Probability Explorer container not found');
            return;
        }

        container.style.display = 'block';
        const originalCdfUseCase = document.getElementById('original-cdf-use-case');
        const optimizedCdfUseCase = document.getElementById('optimized-cdf-use-case');
        if (originalCdfUseCase) {
            originalCdfUseCase.style.display = 'block';
            console.log('Showing original-cdf-use-case');
        } else {
            console.warn('original-cdf-use-case not found');
        }
        if (optimizedCdfUseCase) {
            optimizedCdfUseCase.style.display = 'block';
            console.log('Showing optimized-cdf-use-case');
        } else {
            console.warn('optimized-cdf-use-case not found');
        }

        if (!isInitialized) {
            console.log('Not initialized yet, waiting for initialization');
            pendingTabAction = () => showScenarioTargets();
            container.innerHTML = '<p style="color: #666; text-align: center;">Loading data, please wait...</p>';
            return;
        }

        if (!MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length || !CDF_POINTS || !CDF_POINTS.length) {
            console.error('MC_SMOOTHED_POINTS or CDF_POINTS is empty');
            container.innerHTML = '<p style="color: red; text-align: center;">Error: Data unavailable.</p>';
            return;
        }

        // Set the filter dropdown to "Current Selection"
        const filterDropdown = document.getElementById('probability-filter');
        if (filterDropdown) {
            filterDropdown.value = 'current';
            console.log('Set probability-filter to "current"');
        } else {
            console.warn('probability-filter not found');
        }

        try {
            restoreSliders();  // Ensure window.sliderState is updated
            drawScenarioCdfPlots();  // Draws plots and populates tables
        } catch (error) {
            console.error('Error drawing Target Probability Explorer CDF plots:', error);
            container.innerHTML = '<p style="color: red; text-align: center;">Error: Failed to load Target Probability Explorer plots.</p>';
        }
    }

    /**
     * Computes an optimized CDF based on user-defined parameters for the Target Probability Explorer tab.
     * @param {number} budgetFlex - Budget Flexibility (0 to 1)
     * @param {number} scheduleFlex - Schedule Flexibility (0 to 1)
     * @param {number} scopeUncert - Scope Uncertainty (0 to 1)
     * @param {number} riskTol - Risk Tolerance (0 to 1)
     * @param {number} targetValue - The target value to evaluate
     * @returns {Array} Array of {x, y} objects representing the adjusted CDF
     */
    function computeTargetOptimizedCdf(budgetFlex, scheduleFlex, scopeUncert, riskTol, targetValue) {
        const BF = budgetFlex;
        const SF = scheduleFlex;
        const SU = scopeUncert;
        const RT = riskTol;

        let optPoints = JSON.parse(JSON.stringify(MC_SMOOTHED_POINTS));

        // Use API-provided mean and standard deviation
        const originalMean = mcSmoothedMean;
        const originalStdDev = mcSmoothedStdDev;

        // Define transformation parameters consistent with Decision Optimizer
        const shiftFactor = 0.2;
        const varianceFactor = 2.0;
        const skewFactorRT = -0.05;
        const skewFactorSU = 0.2;

        // Calculate transformation values
        const meanShift = shiftFactor * originalStdDev * (-BF - SF + 0.5 * SU);
        const varianceScale = 1 + varianceFactor * SU;
        const skewAdjustment = skewFactorRT * RT + skewFactorSU * SU;

        // Check if all sliders are zero with tolerance
        const tolerance = 0.0001;
        const allZero = Math.abs(BF) < tolerance && Math.abs(SF) < tolerance && Math.abs(SU) < tolerance && Math.abs(RT) < tolerance;

        if (allZero) {
            // Return original CDF from API
            const cdfPoints = JSON.parse(JSON.stringify(CDF_POINTS));
            let probAtTarget = 0;
            for (let i = 0; i < cdfPoints.length; i++) {
                if (cdfPoints[i].x >= targetValue) {
                    probAtTarget = cdfPoints[i].y * 100;
                    break;
                }
            }
            window.lastOptimizedProb = probAtTarget.toFixed(1);
            window.lastOptimizedSkew = mcSmoothedSkewness.toFixed(2);
            return cdfPoints;
        }

        // Transform points
        const shiftedMean = originalMean + meanShift;
        optPoints.forEach(p => {
            p.x = varianceScale * (p.x - originalMean) + originalMean + meanShift;
            p.y /= varianceScale;
        });

        // Apply skew adjustment if RT > 0 or SU > 0
        if (RT > 0 || SU > 0) {
            const skewFactors = optPoints.map(p => Math.exp(skewAdjustment * (p.x - shiftedMean) / originalStdDev));
            optPoints.forEach((p, i) => p.y *= skewFactors[i]);
        }

        // Normalize the PDF
        const step = optPoints.length > 1 ? optPoints[1].x - optPoints[0].x : 1;
        const totalDensityAdjusted = optPoints.reduce((sum, p) => sum + p.y * step, 0);
        if (totalDensityAdjusted > 0) {
            optPoints.forEach(p => p.y /= totalDensityAdjusted);
        }

        // Compute CDF using trapezoidal rule
        const sortedPoints = optPoints.slice().sort((a, b) => a.x - b.x);
        let cumulative = 0;
        const cdf = [0];
        for (let i = 1; i < sortedPoints.length; i++) {
            const dx = sortedPoints[i].x - sortedPoints[i - 1].x;
            const avgY = (sortedPoints[i - 1].y + sortedPoints[i].y) / 2;
            cumulative += avgY * dx;
            cdf.push(cumulative);
        }

        // Normalize CDF to 1
        const maxCdf = cdf[cdf.length - 1];
        if (maxCdf > 0) {
            cdf.forEach((_, i) => cdf[i] /= maxCdf);
        }
        const cdfPoints = sortedPoints.map((p, i) => ({ x: p.x, y: cdf[i], confidence: (i + 1) }));

        // Find optimized median
        let optimizedMedian;
        for (let i = 0; i < cdfPoints.length; i++) {
            if (cdfPoints[i].y >= 0.5) {
                optimizedMedian = cdfPoints[i].x;
                break;
            }
        }
        window.lastOptimizedValue = optimizedMedian ? optimizedMedian.toFixed(2) : 'N/A';

        // Find probability at target value
        let probAtTarget = 0;
        for (let i = 0; i < cdfPoints.length; i++) {
            if (cdfPoints[i].x >= targetValue) {
                probAtTarget = cdfPoints[i].y * 100;
                break;
            }
        }
        window.lastOptimizedProb = probAtTarget.toFixed(1);

        // Calculate optimized skewness
        const totalWeight = sortedPoints.reduce((sum, p) => sum + p.y * step, 0);
        const optMean = totalWeight > 0 ? sortedPoints.reduce((sum, p) => sum + p.x * p.y * step, 0) / totalWeight : 0;
        const optVariance = totalWeight > 0 ? sortedPoints.reduce((sum, p) => sum + p.y * step * Math.pow(p.x - optMean, 2), 0) / totalWeight : 0;
        const optStdDev = Math.sqrt(optVariance);
        const optThirdMoment = totalWeight > 0 ? sortedPoints.reduce((sum, p) => sum + p.y * step * Math.pow(p.x - optMean, 3), 0) / totalWeight : 0;
        const optSkew = optStdDev > 0 ? optThirdMoment / Math.pow(optStdDev, 3) : 0;
        window.lastOptimizedSkew = optSkew.toFixed(2);

        return cdfPoints;
    }

    /**
     * Computes the CDF for the Monte Carlo Smoothed data for the Monte Carlo Trends tab.
     * Uses precomputed CDF_POINTS from the API.
     * @returns {Array} Array of {x, y, confidence} objects representing the CDF
     */
    function computeMonteCarloCdf() {
        if (!CDF_POINTS || !CDF_POINTS.length) {
            console.error('CDF_POINTS is empty');
            return [];
        }
        return JSON.parse(JSON.stringify(CDF_POINTS));
    }
</script>

 

<!-- SECTION 3.d: JAVASCRIPT - SLIDER MANAGEMENT FUNCTIONS -->

<script type="text/javascript">

    /**

     * Restores the values of decision and target sliders from the global sliderState.

     * Updates the corresponding value spans to reflect the restored values.

     */

    function restoreSliders() {

        const decisionSliders = ['decisionBudgetFlexibility', 'decisionScheduleFlexibility', 'decisionScopeUncertainty', 'decisionRiskTolerance']; // Updated

        const targetSliders = ['targetBudgetFlexibility', 'targetScheduleFlexibility', 'targetScopeUncertainty', 'targetRiskTolerance']; // Updated

 

        decisionSliders.forEach(id => {

            const slider = document.getElementById(id);

            const key = id.replace(/^decision/, '').replace(/^./, c => c.toLowerCase());

            if (slider && window.sliderState[key]) {

                slider.value = window.sliderState[key];

                const valueSpan = document.getElementById(id + 'Value');

                if (valueSpan) valueSpan.textContent = `${slider.value}%`;

                console.log(`Restored decision slider ${id} to: ${slider.value}`);

            }

        });

 

        targetSliders.forEach(id => {

            const slider = document.getElementById(id);

            const key = id.replace(/^target/, '').replace(/^./, c => c.toLowerCase());

            if (slider && window.sliderState[key]) {

                slider.value = window.sliderState[key];

                const valueSpan = document.getElementById(id + 'Value');

                if (valueSpan) valueSpan.textContent = `${slider.value}%`;

                console.log(`Restored target slider ${id} to: ${slider.value}`);

            }

        });

    }

 

    /**

     * Synchronizes decision and target sliders, ensuring their values stay in sync.

     * Updates the plot and summary box when sliders change, with debouncing to prevent flicker.

     * Prevents redundant updates by tracking the last processed slider values.

     */

    function synchronizeSliders() {

        const decisionSliders = ['decisionBudgetFlexibility', 'decisionScheduleFlexibility', 'decisionScopeUncertainty', 'decisionRiskTolerance']; // Updated

        const targetSliders = ['targetBudgetFlexibility', 'targetScheduleFlexibility', 'targetScopeUncertainty', 'targetRiskTolerance']; // Updated

 

        // Debounce function to limit redraw frequency

        const debounce = (func, wait) => {

            let timeout;

            return function (...args) {

                clearTimeout(timeout);

                timeout = setTimeout(() => func.apply(this, args), wait);

            };

        };

 

        // Store the last processed slider values to prevent redundant updates

        const lastSliderValues = {

            decisionBudgetFlexibility: null,

            decisionScheduleFlexibility: null,

            decisionScopeUncertainty: null, // Updated

            decisionRiskTolerance: null,

            targetBudgetFlexibility: null,

            targetScheduleFlexibility: null,

            targetScopeUncertainty: null, // Updated

            targetRiskTolerance: null

        };

 

        decisionSliders.forEach((decisionId, index) => {

            const decisionSlider = document.getElementById(decisionId);

            const targetSlider = document.getElementById(targetSliders[index]);

            const decisionValueSpan = document.getElementById(decisionId + 'Value');

            const targetValueSpan = document.getElementById(targetSliders[index] + 'Value');

 

            if (!decisionSlider || !targetSlider || !decisionValueSpan || !targetValueSpan) {

                console.error(`Sliders or value spans missing: decisionId=${decisionId}, targetId=${targetSliders[index]}`);

                return;

            }

 

            decisionSlider.removeEventListener('input', decisionSlider._inputHandler);

            targetSlider.removeEventListener('input', targetSlider._inputHandler);

            decisionSlider.removeEventListener('change', decisionSlider._inputHandler);

            targetSlider.removeEventListener('change', targetSlider._inputHandler);

 

            decisionSlider._inputHandler = debounce(function() {

                const value = this.value || '50'; // Fallback to '50' if value is undefined

                const key = decisionId.replace(/^decision/, '').replace(/^./, c => c.toLowerCase());

 

                // Skip update if the value hasn't changed

                if (lastSliderValues[decisionId] === value) {

                    console.log(`Skipping redundant update for ${decisionId}: ${value}`);

                    return;

                }

                lastSliderValues[decisionId] = value;

 

                console.log(`Decision slider ${decisionId} changed to: ${value}`);

                targetSlider.value = value;

                decisionValueSpan.textContent = `${value}%`;

                targetValueSpan.textContent = `${value}%`;

                window.sliderState[key] = value;

                const activeTab = document.querySelector('.chart-button.active')?.id;

                if (activeTab === 'optimizedDecisionInsights') {

                    console.log(`Triggering update for Decision Optimizer tab with value: ${value}`);

                    const optimalConfidence = calculateOptimalConfidence(MC_SMOOTHED_POINTS);

                    showDecisionTable(true, optimalConfidence);

                    updateSummaryBox(activeTab);

                }

            }, 100).bind(decisionSlider);

 

            targetSlider._inputHandler = debounce(function() {

                const value = this.value || '50'; // Fallback to '50' if value is undefined

                const key = targetSliders[index].replace(/^target/, '').replace(/^./, c => c.toLowerCase());

 

                // Skip update if the value hasn't changed

                if (lastSliderValues[targetSliders[index]] === value) {

                    console.log(`Skipping redundant update for ${targetSliders[index]}: ${value}`);

                    return;

                }

                lastSliderValues[targetSliders[index]] = value;

 

                console.log(`Target slider ${targetSliders[index]} changed to: ${value}`);

                decisionSlider.value = value;

                decisionValueSpan.textContent = `${value}%`;

                targetValueSpan.textContent = `${value}%`;

                window.sliderState[key] = value;

                const activeTab = document.querySelector('.chart-button.active')?.id;

                if (activeTab === 'targetProbabilityExplorer') {

                    console.log(`Triggering update for Target Probability Explorer tab with value: ${value}`);

                    drawScenarioCdfPlots();

                    updateSummaryBox(activeTab);

                }

            }, 100).bind(targetSlider);

 

            // Use 'change' event instead of 'input' to update only on slider release

            decisionSlider.addEventListener('change', decisionSlider._inputHandler);

            targetSlider.addEventListener('change', targetSlider._inputHandler);

        });

    }

</script>

 

<!-- SECTION 3.e: JAVASCRIPT - INITIALIZATION AND ERROR HANDLING -->

<script type="text/javascript">

  /**
 * Initializes the application with properties fetched from the server.
 * Sets up global variables, event listeners, and initial plot rendering.
 * @param {Object} props - Properties fetched from the server.
 */
function initialize(props) {
    console.log('Initializing with props:', props);
    try {
        // Remove duplicate confidence sliders
        const sliders = document.querySelectorAll('#confidence-slider');
        if (sliders.length > 1) {
            console.warn('Multiple confidence sliders found; removing duplicates');
            for (let i = 1; i < sliders.length; i++) {
                sliders[i].parentElement.remove();
            }
        }

        if (!window.sliderState || Object.keys(window.sliderState).length !== 4) {
            console.warn('sliderState corrupted or uninitialized, resetting to defaults');
            window.sliderState = {
                budgetFlexibility: '50',
                scheduleFlexibility: '50',
                scopeUncertainty: '50',
                riskTolerance: '50'
            };
        }

        // Load basic parameters
        min = props.MIN || 0;
        max = props.MAX || 100;
        mostLikely = props.MOST_LIKELY || 50;
        triangleMean = props.TRIANGLE_MEAN || 0;
        pertMean = props.PERT_MEAN || 0;
        pertStd = props.PERT_STD || 0;
        betaMean = props.BETA_MEAN || 0;
        alpha = props.ALPHA || 0;
        beta = props.BETA || 0;
        betaMode = props.BETA_MODE || 0;
        mcUnsmoothedMean = props.MC_UNSMOOTHED_MEAN || 0;
        mcSmoothedMean = props.MC_SMOOTHED_MEAN || 0;
        weightedConservative = props.WEIGHTED_CONSERVATIVE || 0;
        weightedNeutral = props.WEIGHTED_NEUTRAL || 0;
        weightedOptimistic = props.WEIGHTED_OPTIMISTIC || 0;

        // Load point arrays
        TRIANGLE_POINTS = props.TRIANGLE_POINTS || [];
        PERT_POINTS = props.PERT_POINTS || [];
        BETA_POINTS = props.BETA_POINTS || [];
        MC_UNSMOOTHED_POINTS = props.MC_UNSMOOTHED_POINTS || [];
        MC_SMOOTHED_POINTS = props.MC_SMOOTHED_POINTS || [];
        CDF_POINTS = props.CDF_POINTS || [];

        // Load skewness values from code.gs for preservation
        window.originalSkewness = {
            triangle: props.TRIANGLE_SKEWNESS || 0,
            pert: props.PERT_SKEWNESS || 0,
            beta: props.BETA_SKEWNESS || 0,
            mcUnsmoothed: props.MC_UNSMOOTHED_SKEWNESS || 0,
            mcSmoothed: props.MC_SMOOTHED_SKEWNESS || 0
        };
        console.log('Original skewness loaded:', window.originalSkewness);

        console.log('MC_SMOOTHED_POINTS initialized:', MC_SMOOTHED_POINTS);
        isInitialized = true;
        createChartTypeButtons();
        createConfidenceSlider(); // Updated from createSlider
        createProbabilitySlider();
        const initialValue = window.lastConfidence || 50;
        const confidenceSlider = document.getElementById('confidence-slider');
        if (confidenceSlider) {
            confidenceSlider.value = initialValue;
            confidenceSlider.dispatchEvent(new Event('input')); // Trigger initial update
        }
        drawSelectedPlot('trianglePlot');
        document.querySelectorAll('.chart-button').forEach(btn => btn.classList.remove('active'));
        const triangleBtn = document.getElementById('trianglePlot');
        if (triangleBtn) triangleBtn.classList.add('active');
        setTimeout(() => updatePlot('trianglePlot', initialValue), 100);
        updateTablesAndRecommendations('trianglePlot');
        setupSliderListeners();
        synchronizeSliders();
        restoreSliders();

        if (pendingTabAction) {
            console.log('Executing pending tab action after initialization');
            pendingTabAction();
            pendingTabAction = null;
        }

        // Hide the loading indicator after successful initialization
        document.getElementById('loading-overlay').style.display = 'none';
    } catch (error) {
        showError(`Initialization failed: ${error.message}`);
        isInitialized = false;
        // Hide the loading indicator even if initialization fails
        document.getElementById('loading-overlay').style.display = 'none';
    }
}

 

    /**

     * Displays an error message in the UI if an error occurs during initialization or operation.

     * Creates an error div if it doesn’t exist and sets the error message.

     * @param {Error|string} error - The error object or message to display.

     */

    function showError(error) {

        let errorDiv = document.getElementById('error-message');

        if (!errorDiv) {

            errorDiv = document.createElement('div');

            errorDiv.id = 'error-message';

            errorDiv.style.color = 'red';

            errorDiv.style.textAlign = 'center';

            errorDiv.style.marginTop = '20px';

            errorDiv.style.fontSize = '14px';

            document.body.appendChild(errorDiv);

        }

        errorDiv.textContent = `Error: ${error.message || error}`;

        errorDiv.style.display = 'block';

    }

</script>

 

<!-- SECTION 3.f: JAVASCRIPT - CHART TYPE BUTTONS AND CONFIDENCE SLIDER -->
<script type="text/javascript">

   /**
    * Retrieves the value corresponding to a given confidence level for the specified plot type.
    * Uses interpolation for all plot types to ensure smooth movement of the annotated circle.
    * @param {string} plotType - The type of plot (e.g., 'trianglePlot').
    * @param {number} confidence - The confidence level (percentile, 0-100).
    * @returns {number|null} The value at the specified confidence level or null if not found.
    */
   function getValueForConfidence(plotType, confidence) {
       let points;
       switch (plotType) {
           case 'trianglePlot': points = TRIANGLE_POINTS; break;
           case 'pertPlot': points = PERT_POINTS; break;
           case 'betaPlot': points = BETA_POINTS; break;
           case 'mcBetaUnsmoothedPlot': points = MC_UNSMOOTHED_POINTS; break;
           case 'mcBetaSmoothedPlot': points = MC_SMOOTHED_POINTS; break;
           default: return null;
       }

       if (!points || !points.length) return null;

       // Use interpolation to find the x-value
       const interpolatedPoint = interpolatePoint(points, confidence);
       return interpolatedPoint.x;
   }

   /**
    * Sets up event listeners for chart type buttons (tabs) to switch between different plot types.
    * Manages visibility of containers and updates the UI based on the selected tab.
    */
   function createChartTypeButtons() {
       const container = document.getElementById('chartType-container');
       if (!container) {
           console.error('chartType-container not found');
           return;
       }

       // Container references for managing visibility
       const chartContainer = document.getElementById('chart-container');
       const sliderContainer = document.getElementById('slider-container');
       const confidenceContainer = document.getElementById('confidence-container');
       const probabilityContainer = document.getElementById('probability-container');
       const decisionTable = document.getElementById('decision-table-container');
       const targetContainer = document.getElementById('target-probability-container');

       if (!chartContainer || !sliderContainer || !confidenceContainer || !probabilityContainer || !decisionTable || !targetContainer) {
           console.error('One or more containers missing');
           return;
       }

       // Mapping of button IDs to summary tab data-tab values
       const tabToSummaryMap = {
           'trianglePlot': 'triangle',
           'pertPlot': 'pert',
           'betaPlot': 'beta',
           'mcBetaUnsmoothedPlot': 'mcBetaUnsmoothed',
           'mcBetaSmoothedPlot': 'mcBetaSmoothed',
           'optimizedDecisionInsights': 'optimizedDecisionInsights',
           'targetProbabilityExplorer': 'targetProbabilityExplorer'
       };

       // Function to update summary section visibility based on the active tab
       const updateSummaryVisibility = (activeTabId) => {
           const summaryTab = tabToSummaryMap[activeTabId] || null;
           document.querySelectorAll('.summary-section').forEach(section => {
               const container = section.closest('.summary-section-container');
               if (!container) {
                   console.warn(`Parent .summary-section-container not found for summary section with data-tab: ${section.getAttribute('data-tab')}`);
                   return;
               }
               if (summaryTab && section.getAttribute('data-tab') === summaryTab) {
                   container.style.display = 'block';
                   section.style.display = 'block';
                   console.log(`Showing summary section container for ${summaryTab}`);
               } else {
                   container.style.display = 'none';
                   section.style.display = 'none';
                   console.log(`Hiding summary section container for ${section.getAttribute('data-tab')}`);
               }
               // Reset summary content to collapsed state
               const content = section.querySelector('.summary-content');
               if (content && content.style.display !== 'none') {
                   content.style.display = 'none';
                   const toggle = section.querySelector('.toggle-summary');
                   if (toggle) {
                       toggle.textContent = `▼ ${toggle.textContent.slice(2)}`;
                       toggle.setAttribute('aria-expanded', 'false');
                   }
               }
           });
       };

       document.querySelectorAll('.chart-button').forEach(button => {
           button.addEventListener('click', function() {
               console.log('Switching to tab:', this.id);
               document.querySelectorAll('.chart-button').forEach(btn => btn.classList.remove('active'));
               this.classList.add('active');

               // Reset all container visibilities
               chartContainer.style.display = 'none';
               sliderContainer.style.display = 'none';
               decisionTable.style.display = 'none';
               targetContainer.style.display = 'none';
               document.body.classList.remove('decision-table-active');

               // Reset use case toggle states
               document.querySelectorAll('.use-case-content').forEach(content => {
                   toggleStates[content.id] = false;
               });

               updateSummaryVisibility(this.id);

               const buttonId = this.id;
               const confidenceValue = window.lastConfidence || 50; // Use last value or default

               if (buttonId === 'optimizedDecisionInsights') {
                   decisionTable.style.display = 'block';
                   sliderContainer.style.display = 'none';
                   document.body.classList.add('decision-table-active');
                   showDecisionTable();
                   restoreSliders();
                   updateSummaryBox(buttonId);
                   updateTablesAndRecommendations(buttonId);
               } else if (buttonId === 'targetProbabilityExplorer') {
                   targetContainer.style.display = 'block';
                   sliderContainer.style.display = 'none';
                   showScenarioTargets();
                   const targetSlider = document.getElementById('target-value-slider');
                   if (targetSlider) {
                       targetSlider.dispatchEvent(new Event('input')); // Trigger initial plot update
                   }
                   if (google.visualization && google.visualization.LineChart) {
                       drawScenarioCdfPlots();
                   } else {
                       google.charts.setOnLoadCallback(drawScenarioCdfPlots);
                   }
                   restoreSliders();
                   updateSummaryBox(buttonId);
                   updateTablesAndRecommendations(buttonId);
               } else {
                   chartContainer.style.display = 'block';
                   sliderContainer.style.display = 'flex';
                   confidenceContainer.style.display = 'flex';
                   probabilityContainer.style.display = buttonId === 'mcBetaSmoothedPlot' ? 'flex' : 'none';

                   // Set confidence slider value
                   const confidenceSlider = document.getElementById('confidence-slider');
                   if (confidenceSlider) {
                       confidenceSlider.value = confidenceValue;
                       const confidenceDisplay = document.getElementById('confidence-value');
                       if (confidenceDisplay) {
                           const selectedValue = getValueForConfidence(buttonId, confidenceValue);
                           if (selectedValue !== null) {
                               confidenceDisplay.innerText = `${confidenceValue}%: ${selectedValue.toFixed(2)}`;
                           } else {
                               confidenceDisplay.innerText = `${confidenceValue}%: (Calculating...)`;
                           }
                       }
                   }

                   drawSelectedPlot(buttonId); // Draw the initial plot
                   setTimeout(() => updatePlot(buttonId, confidenceValue), 100); // Update with confidence value
                   updateTablesAndRecommendations(buttonId);
                   updateSummaryBox(buttonId);
               }
               setTimeout(() => window.restoreToggleStates && window.restoreToggleStates(), 200);
           }, { passive: true });
       });

       const defaultTab = document.getElementById('trianglePlot');
       if (defaultTab) {
           console.log('Setting initial state by simulating click on trianglePlot');
           defaultTab.click();
       } else {
           console.warn('Default tab (trianglePlot) not found; manually setting summary visibility');
           updateSummaryVisibility('trianglePlot');
       }
   }

   /**
    * Sets up the confidence slider for non-parameterized tabs.
    * Updates the plot, summary box, and display with debouncing.
    */
   function createConfidenceSlider() {
       const slider = document.getElementById('confidence-slider');
       const valueSpan = document.getElementById('confidence-value');
       if (!slider || !valueSpan) {
           console.error('Confidence slider or value span not found');
           return;
       }

       // Initialize with last known value or default to 50%
       const initialValue = window.lastConfidence || 50;
       slider.value = initialValue;
       valueSpan.innerText = `${initialValue}%`;
       console.log('Initialized confidence slider to:', initialValue);

       // Remove existing listener to prevent duplicates
       if (slider._inputHandler) {
           slider.removeEventListener('input', slider._inputHandler);
       }

       // Add input event handler with debouncing
       const debounce = (func, wait) => {
           let timeout;
           return function (...args) {
               clearTimeout(timeout);
               timeout = setTimeout(() => func.apply(this, args), wait);
           };
       };

       slider._inputHandler = debounce(function() {
           const value = parseFloat(this.value);
           valueSpan.innerText = `${value}%`;
           window.lastConfidence = value; // Update global state
           console.log('Confidence slider updated to:', value);
           const activeTab = document.querySelector('.chart-button.active')?.id;
           if (activeTab && activeTab !== 'optimizedDecisionInsights' && activeTab !== 'targetProbabilityExplorer') {
               const selectedValue = getValueForConfidence(activeTab, value);
               if (selectedValue !== null) {
                   valueSpan.innerText = `${value}%: ${selectedValue.toFixed(2)}`;
               } else {
                   valueSpan.innerText = `${value}%: (Calculating...)`;
               }
               updatePlot(activeTab, value); // Update plot with new confidence value
               updateTablesAndRecommendations(activeTab);
               updateSummaryBox(activeTab);
           }
       }, 100);

       slider.addEventListener('input', slider._inputHandler, { passive: true });
   }

   /**
    * Updates the plot for the specified plot type with the given confidence level.
    * Calls the appropriate update function based on the plot type.
    * @param {string} plotType - The type of plot (e.g., 'trianglePlot').
    * @param {number} confidence - The confidence level to update the plot with.
    */
   function updatePlot(plotType, confidence) {
       switch (plotType) {
           case 'trianglePlot':
               updateTrianglePlot(confidence);
               break;
           case 'pertPlot':
               updatePertPlot(confidence);
               break;
           case 'betaPlot':
               updateBetaPlot(confidence);
               break;
           case 'mcBetaUnsmoothedPlot':
               updateMcBetaUnsmoothedPlot(confidence);
               break;
           case 'mcBetaSmoothedPlot':
               updateMcBetaSmoothedPlot(confidence);
               break;
           default:
               console.warn('No update function for plot type:', plotType);
       }
   }

</script>

 

<!-- SECTION 3.g: JAVASCRIPT - PROBABILITY AND TARGET SLIDER SETUP -->

<script type="text/javascript">

    /**

     * Sets up the probability and target value sliders for the Monte Carlo Smoothed and Target Probability Explorer tabs.

     * Configures slider ranges and initial values based on the data range.

     * Updates the plot and summary box when slider values change.

     */

    function createProbabilitySlider() {

        const slider = document.getElementById('probability-slider');

        const targetSlider = document.getElementById('target-value-slider');

        const defaultMin = 0;

        const defaultMax = 100;

        const sliderMin = min !== undefined ? min : defaultMin;

        const sliderMax = max !== undefined ? max : defaultMax;

        const initialValue = (sliderMin + sliderMax) / 2;

 

        if (slider) {

            slider.min = sliderMin;

            slider.max = sliderMax;

            slider.value = initialValue;

            const resultSpan = document.getElementById('probability-result');

            if (resultSpan) {

                resultSpan.innerText = min !== undefined ? `${initialValue.toFixed(2)}` : '(Calculating...)';

            }

            slider.addEventListener('input', function() {

                const value = parseFloat(this.value);

                const active = document.querySelector('.chart-button.active')?.id;

                if (active === 'mcBetaSmoothedPlot') {

                    updateCdfPlot(value);

                    updateSummaryBox(active);

                }

            }, { passive: true });

        }

 

        if (targetSlider) {

            const dataList = document.createElement('datalist');

            dataList.id = 'target-slider-values';

            MC_SMOOTHED_POINTS.sort((a, b) => a.x - b.x).forEach(point => {

                const option = document.createElement('option');

                option.value = point.x;

                dataList.appendChild(option);

            });

            targetSlider.parentElement.appendChild(dataList);

 

            targetSlider.min = sliderMin;

            targetSlider.max = sliderMax;

            targetSlider.step = useSnapping ? 'any' : (sliderMax - sliderMin) / 100;

            targetSlider.value = initialValue;

            if (useSnapping) {

                targetSlider.setAttribute('list', 'target-slider-values');

            }

 

            targetSlider.addEventListener('input', function() {

                const value = parseFloat(this.value);

                drawScenarioCdfPlots();

                updateSummaryBox('targetProbabilityExplorer');

            }, { passive: true });

        }

    }

</script>

<!-- SECTION 3.h: JAVASCRIPT - DECISION SLIDER LISTENERS AND OPTIMAL CONFIDENCE CALCULATION -->
<script type="text/javascript">
    /**
     * Sets up event listeners for decision sliders in the Decision Optimizer tab.
     * Updates the plot, summary box, and Combination Explorer table when sliders change, with debouncing.
     */
    function setupSliderListeners() {
        const sliders = ['decisionBudgetFlexibility', 'decisionScheduleFlexibility', 'decisionScopeUncertainty', 'decisionRiskTolerance'];

        // Initialize window.sliderState with current slider values
        sliders.forEach(id => {
            const slider = document.getElementById(id);
            if (slider) {
                const stateKey = id.replace('decision', '').toLowerCase();
                window.sliderState[stateKey] = parseFloat(slider.value || '50').toFixed(1);
                console.log(`Initialized window.sliderState.${stateKey} to: ${window.sliderState[stateKey]}`);
                const valueSpan = document.getElementById(id + 'Value');
                if (valueSpan) {
                    valueSpan.textContent = `${Math.round(parseFloat(slider.value))}% (${parseFloat(slider.value).toFixed(1)}%)`;
                }
            }
        });

        const debounce = (func, wait) => {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        const lastSliderValues = {
            decisionBudgetFlexibility: null,
            decisionScheduleFlexibility: null,
            decisionScopeUncertainty: null,
            decisionRiskTolerance: null
        };

        sliders.forEach(id => {
            const slider = document.getElementById(id);
            if (slider) {
                console.log(`Setting up listener for slider: ${id}`);
                slider.removeEventListener('input', slider._inputHandler);
                slider.removeEventListener('change', slider._inputHandler);

                slider._inputHandler = debounce(function() {
                    const value = parseFloat(this.value || '50').toFixed(1);
                    if (lastSliderValues[id] === value) {
                        console.log(`Skipping redundant update for ${id}: ${value}`);
                        return;
                    }
                    lastSliderValues[id] = value;

                    const stateKey = id.replace('decision', '').toLowerCase();
                    window.sliderState[stateKey] = value;
                    console.log(`Updated window.sliderState.${stateKey} to: ${value}`);

                    const valueSpan = document.getElementById(id + 'Value');
                    if (valueSpan) {
                        valueSpan.textContent = `${Math.round(parseFloat(value))}% (${parseFloat(value).toFixed(1)}%)`;
                    }

                    const decisionTable = document.getElementById('decision-table-container');
                    if (decisionTable && decisionTable.style.display === 'block') {
                        const optimalConfidence = MC_SMOOTHED_POINTS && MC_SMOOTHED_POINTS.length ?
                            calculateOptimalConfidence(MC_SMOOTHED_POINTS) : 50;
                        window.lastOptimizedConfidence = optimalConfidence;
                        console.log(`Calculated optimal confidence: ${optimalConfidence}`);

                        const recommendationOutput = document.getElementById('recommendation-output');
                        if (recommendationOutput) {
                            try {
                                generateRecommendation(recommendationOutput, optimalConfidence);
                            } catch (e) {
                                console.error(`Error in generateRecommendation: ${e.message}`);
                            }
                        }

                        updateSummaryBox('optimizedDecisionInsights');
                        showDecisionTable(true, optimalConfidence);
                        populateDecisionCombinationTable();
                    }

                    const targetContainer = document.getElementById('target-probability-container');
                    if (targetContainer && targetContainer.style.display === 'block') {
                        try {
                            drawScenarioCdfPlots();
                            updateSummaryBox('targetProbabilityExplorer');
                        } catch (e) {
                            console.error(`Error in drawScenarioCdfPlots: ${e.message}`);
                        }
                    }
                }, 100).bind(slider);

                slider.addEventListener('input', slider._inputHandler, { passive: true });
                slider.addEventListener('change', slider._inputHandler, { passive: true });
            }
        });

        const filterDropdown = document.getElementById('decision-median-filter');
        if (filterDropdown && !filterDropdown._hasListener) {
            filterDropdown.addEventListener('change', () => {
                console.log('decision-median-filter changed to:', filterDropdown.value);
                populateDecisionCombinationTable();
            });
            filterDropdown._hasListener = true;
        }

        const prevButton = document.getElementById('decision-prev-page');
        const nextButton = document.getElementById('decision-next-page');
        if (prevButton && !prevButton._hasListener) {
            prevButton.addEventListener('click', () => {
                console.log('Previous page clicked');
                populateDecisionCombinationTable(window.currentPage - 1);
            });
            prevButton._hasListener = true;
        }
        if (nextButton && !nextButton._hasListener) {
            nextButton.addEventListener('click', () => {
                console.log('Next page clicked');
                populateDecisionCombinationTable(window.currentPage + 1);
            });
            nextButton._hasListener = true;
        }
    }

    /**
     * Calculates the optimal confidence level for the Decision Optimizer tab.
     */
    function calculateOptimalConfidence(points) {
        if (!points || !points.length) {
            console.warn('No points provided to calculateOptimalConfidence, returning default 50');
            return 50;
        }

        const sliderState = window.sliderState || {
            budgetFlexibility: 50,
            scheduleFlexibility: 50,
            scopeUncertainty: 50,
            riskTolerance: 50
        };

        const budgetFlex = parseFloat(sliderState.budgetFlexibility || 50) / 100;
        const scheduleFlex = parseFloat(sliderState.scheduleFlexibility || 50) / 100;
        const scopeUncert = parseFloat(sliderState.scopeUncertainty || 50) / 100;
        const riskTol = parseFloat(sliderState.riskTolerance || 50) / 100;

        const c_U = Math.pow(2, 2 * (1 - scheduleFlex) + (1 - riskTol) + scopeUncert);
        const c_O = Math.pow(2, 2 * (1 - budgetFlex));

        let minLoss = Infinity;
        let optimalPercentile = 50;

        const sortedPoints = points.slice().sort((a, b) => a.x - b.x);
        for (let percentile = 1; percentile <= 100; percentile++) {
            const point = interpolatePoint(sortedPoints, percentile);
            const value = point.x;
            let underLoss = 0, overLoss = 0;

            sortedPoints.forEach(point => {
                if (point.x > value) underLoss += (point.x - value) * (point.confidence / 100);
                if (point.x < value) overLoss += (value - point.x) * (point.confidence / 100);
            });

            const expectedLoss = c_U * underLoss + c_O * overLoss;
            if (expectedLoss < minLoss) {
                minLoss = expectedLoss;
                optimalPercentile = percentile;
            }
        }

        const totalFlex = (budgetFlex + scheduleFlex + scopeUncert + riskTol) / 4;
        const finalConfidence = Math.max(50, Math.min(100, Math.round(50 + 50 * totalFlex)));
        console.log(`Optimal confidence calculated: ${finalConfidence}`);
        return finalConfidence;
    }

    /**
     * Computes adjusted points based on slider values.
     * @returns {Array} Adjusted points
     */
    function computeAdjustedPoints(bf, sf, su, rt) {
        if (!MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length) {
            console.error('MC_SMOOTHED_POINTS is missing or empty');
            return [];
        }

        let points = JSON.parse(JSON.stringify(MC_SMOOTHED_POINTS));
        const step = points.length > 1 ? points[1].x - points[0].x : 1;
        let totalWeightOrig = points.reduce((sum, p) => sum + p.y * step, 0);
        if (totalWeightOrig > 0) points.forEach(p => p.y /= totalWeightOrig);

        const originalMean = mcSmoothedMean;
        const originalStdDev = mcSmoothedStdDev;

        const shiftFactor = 0.2;
        const varianceFactor = 2.0;
        const skewFactorRT = -0.05;
        const skewFactorSU = 0.2;

        const meanShift = shiftFactor * originalStdDev * (-bf - sf + 0.5 * su);
        const varianceScale = 1 + varianceFactor * su;
        const skewAdjustment = skewFactorRT * rt + skewFactorSU * su;

        const allZero = bf === 0 && sf === 0 && su === 0 && rt === 0;
        if (!allZero) {
            const shiftedMean = originalMean + meanShift;
            points.forEach(p => {
                p.x = varianceScale * (p.x - originalMean) + originalMean + meanShift;
                p.y /= varianceScale;
            });
            if (rt > 0 || su > 0) {
                const skewFactors = points.map(p => Math.exp(skewAdjustment * (p.x - shiftedMean) / originalStdDev));
                points.forEach((p, i) => p.y *= skewFactors[i]);
            }
            const totalDensityAdjusted = points.reduce((sum, p) => sum + p.y * step, 0);
            if (totalDensityAdjusted > 0) points.forEach(p => p.y /= totalDensityAdjusted);
        }

        return points;
    }

    /**
     * Computes the median from a set of points.
     * @returns {number} Median value
     */
    function computeMedian(points) {
        const sortedPoints = points.slice().sort((a, b) => a.x - b.x);
        let cumulative = 0;
        const step = sortedPoints.length > 1 ? sortedPoints[1].x - sortedPoints[0].x : 1;
        for (let i = 0; i < sortedPoints.length; i++) {
            if (cumulative >= 0.5) return sortedPoints[i].x;
            if (i < sortedPoints.length - 1) {
                const dx = sortedPoints[i + 1].x - sortedPoints[i].x;
                const avgY = (sortedPoints[i].y + sortedPoints[i + 1].y) / 2;
                cumulative += avgY * dx;
            }
        }
        return sortedPoints[sortedPoints.length - 1].x;
    }

    /**
     * Interpolates the y-value for a given x in a set of points.
     * @returns {number} Interpolated y-value
     */
    function getYForX(points, x) {
        const sortedPoints = points.slice().sort((a, b) => a.x - b.x);
        for (let i = 0; i < sortedPoints.length - 1; i++) {
            if (sortedPoints[i].x <= x && x <= sortedPoints[i + 1].x) {
                const x1 = sortedPoints[i].x;
                const y1 = sortedPoints[i].y;
                const x2 = sortedPoints[i + 1].x;
                const y2 = sortedPoints[i + 1].y;
                if (x1 === x2) return y1;
                const slope = (y2 - y1) / (x2 - x1);
                return y1 + slope * (x - x1);
            }
        }
        if (x < sortedPoints[0].x) return sortedPoints[0].y;
        return sortedPoints[sortedPoints.length - 1].y;
    }

    /**
     * Computes the optimized median for the Decision Optimizer tab.
     */
    function computeOptimizedMedian(bf, sf, su, rt) {
        const adjustedPoints = computeAdjustedPoints(bf, sf, su, rt);
        return computeMedian(adjustedPoints);
    }
</script>
 

<!-- SECTION 3.i: JAVASCRIPT - PLOT UPDATING AND ACTIVATION FUNCTIONS -->
<script type="text/javascript">
    /**
     * Draws the selected plot type by managing visibility of plot containers and use case sections.
     * Updates tables, recommendations, and the summary box accordingly.
     * @param {string} plotType - The type of plot to draw (e.g., 'trianglePlot').
     */
    function drawSelectedPlot(plotType) {
        console.log(`Drawing plot for ${plotType}`);
        const plotWrapper = document.getElementById('plot-wrapper');
        const mcSmoothedWrapper = document.getElementById('mc-smoothed-wrapper');
        const sliderContainer = document.getElementById('slider-container');
        const confidenceContainer = document.getElementById('confidence-container');
        const probabilityContainer = document.getElementById('probability-container');

        // Mapping of button IDs to plot div IDs
        const plotDivs = {
            'trianglePlot': 'triangle-div',
            'pertPlot': 'pert-div',
            'betaPlot': 'beta-div',
            'mcBetaUnsmoothedPlot': 'mc-unsmoothed-div',
            'mcBetaSmoothedPlot': ['mc-smoothed-div', 'cdf-div']
        };

        // List of all plot divs and use case divs to manage visibility
        const allPlotDivs = ['triangle-div', 'pert-div', 'beta-div', 'mc-unsmoothed-div', 'mc-smoothed-div', 'cdf-div'];
        const useCaseDivs = [
            'triangle-use-case', 'pert-use-case', 'beta-use-case', 'mc-unsmoothed-use-case', 'mc-smoothed-use-case', 'cdf-use-case',
            'triangle-summary-container', 'pert-summary-container', 'beta-summary-container', 'mc-unsmoothed-summary-container', 'mc-smoothed-summary-container'
        ];

        // Hide all plot divs and use case sections initially
        allPlotDivs.forEach(divId => {
            const div = document.getElementById(divId);
            if (div) {
                div.style.display = 'none';
                console.log(`Hiding ${divId}`);
            }
        });
        useCaseDivs.forEach(divId => {
            const div = document.getElementById(divId);
            if (div) {
                div.style.display = 'none';
                console.log(`Hiding ${divId}`);
            }
        });

        // Set default wrapper visibility
        if (plotWrapper) plotWrapper.style.display = 'none';
        if (mcSmoothedWrapper) mcSmoothedWrapper.style.display = 'none';
        if (sliderContainer) sliderContainer.style.display = 'flex';

        // Handle the selected plot type
        const selectedDivIds = plotDivs[plotType];
        if (!selectedDivIds && plotType !== 'optimizedDecisionInsights' && plotType !== 'targetProbabilityExplorer') {
            console.error(`No plot div mapped for ${plotType}`);
            return;
        }

        // Define use case ID explicitly for each plot type
        let useCaseDivId;
        switch (plotType) {
            case 'trianglePlot':
                useCaseDivId = 'triangle-use-case';
                if (plotWrapper) plotWrapper.style.display = 'block';
                document.getElementById(selectedDivIds).style.display = 'block';
                document.getElementById('triangle-summary-container').style.display = 'block';
                if (confidenceContainer) confidenceContainer.style.display = 'flex';
                if (probabilityContainer) probabilityContainer.style.display = 'none';
                drawTrianglePlot();
                break;
            case 'pertPlot':
                useCaseDivId = 'pert-use-case';
                if (plotWrapper) plotWrapper.style.display = 'block';
                document.getElementById(selectedDivIds).style.display = 'block';
                document.getElementById('pert-summary-container').style.display = 'block';
                if (confidenceContainer) confidenceContainer.style.display = 'flex';
                if (probabilityContainer) probabilityContainer.style.display = 'none';
                drawPertPlot();
                break;
            case 'betaPlot':
                useCaseDivId = 'beta-use-case';
                if (plotWrapper) plotWrapper.style.display = 'block';
                document.getElementById(selectedDivIds).style.display = 'block';
                document.getElementById('beta-summary-container').style.display = 'block';
                if (confidenceContainer) confidenceContainer.style.display = 'flex';
                if (probabilityContainer) probabilityContainer.style.display = 'none';
                drawBetaPlot();
                break;
            case 'mcBetaUnsmoothedPlot':
                useCaseDivId = 'mc-unsmoothed-use-case';
                if (plotWrapper) plotWrapper.style.display = 'block';
                document.getElementById(selectedDivIds).style.display = 'block';
                document.getElementById('mc-unsmoothed-summary-container').style.display = 'block';
                if (confidenceContainer) confidenceContainer.style.display = 'flex';
                if (probabilityContainer) probabilityContainer.style.display = 'none';
                drawMcBetaUnsmoothedPlot();
                break;
            case 'mcBetaSmoothedPlot':
                useCaseDivId = '-mc-smoothed-use-case';
                if (mcSmoothedWrapper) mcSmoothedWrapper.style.display = 'flex';
                selectedDivIds.forEach(divId => document.getElementById(divId).style.display = 'block');
                document.getElementById('mc-smoothed-use-case').style.display = 'block';
                document.getElementById('cdf-use-case').style.display = 'block';
                document.getElementById('mc-smoothed-summary-container').style.display = 'block';
                if (confidenceContainer) confidenceContainer.style.display = 'flex';
                if (probabilityContainer) probabilityContainer.style.display = 'flex';
                drawMcBetaSmoothedPlot();
                if (typeof google.visualization !== 'undefined') drawCdfPlot();
                break;
            case 'optimizedDecisionInsights':
            case 'targetProbabilityExplorer':
                // Handled elsewhere, no action needed here
                return;
            default:
                console.warn(`Unknown plot type: ${plotType}`);
                return;
        }

        // Show the specific use case section
        const useCaseDiv = document.getElementById(useCaseDivId);
        if (useCaseDiv) {
            useCaseDiv.style.display = 'block';
            console.log(`Showing ${useCaseDivId}`);
        } else {
            console.error(`Use case div not found: ${useCaseDivId}`);
        }

        // Update additional UI elements and states
        updateTablesAndRecommendations(plotType);
        updateSummaryBox(plotType);
        setTimeout(() => window.restoreToggleStates && window.restoreToggleStates(), 200);
    }
</script>

 

<!-- SECTION 3.j: JAVASCRIPT - PLOT SELECTION AND RENDERING -->
<script type="text/javascript">
    /**
     * Updates the tables and recommendations based on the selected plot type and confidence level.
     * Populates the specific metrics and recommendations tables for each plot type, including parameterized tabs.
     * @param {string} plotType - The type of plot to update tables for (e.g., 'trianglePlot', 'optimizedDecisionInsights').
     */
    function updateTablesAndRecommendations(plotType) {
        console.log(`[updateTablesAndRecommendations] Called with plotType: ${plotType}`);

        // Define mappings for metrics and recommendations table IDs based on plotType
        const tableIdMap = {
            'trianglePlot': { metrics: 'triangle-metrics-table', recommendations: 'triangle-recommendations-table' },
            'pertPlot': { metrics: 'pert-metrics-table', recommendations: 'pert-recommendations-table' },
            'betaPlot': { metrics: 'beta-metrics-table', recommendations: 'beta-recommendations-table' },
            'mcBetaUnsmoothedPlot': { metrics: 'mc-unsmoothed-metrics-table', recommendations: 'mc-unsmoothed-recommendations-table' },
            'mcBetaSmoothedPlot': { metrics: 'mc-smoothed-metrics-table', recommendations: 'mc-smoothed-recommendations-table' },
            'optimizedDecisionInsights': { metrics: 'decision-metrics-table', recommendations: 'decision-recommendations-table' },
            'targetProbabilityExplorer': { metrics: 'target-probability-metrics-table', recommendations: 'target-probability-recommendations-table' }
        };

        // Get the table IDs for the current plot type
        const metricsTableId = tableIdMap[plotType]?.metrics;
        const recommendationsTableId = tableIdMap[plotType]?.recommendations;

        if (!metricsTableId || !recommendationsTableId) {
            console.error(`[updateTablesAndRecommendations] No table IDs found for plotType: ${plotType}`);
            return;
        }

        // Get table elements
        const metricsTable = document.getElementById(metricsTableId);
        const recommendationsTable = document.getElementById(recommendationsTableId);

        if (!metricsTable || !recommendationsTable) {
            console.error(`[updateTablesAndRecommendations] Table elements not found for plotType: ${plotType}`);
            return;
        }

        // Clear existing table content
        metricsTable.innerHTML = '<tr><th>Metric</th><th>Value</th><th>Description</th><th>Formula</th></tr>';
        recommendationsTable.innerHTML = '<tr><th>Recommendation</th><th>Details</th></tr>';

        let metricsRows = [];
        let recommendationsRows = [];

        switch (plotType) {
            case 'mcBetaSmoothedPlot':
                metricsRows = [
                    ['Confidence', `<span style="color: blue;">${confidenceLevel}%</span>`, 'Selected confidence level', 'User input'],
                    ['Value at Confidence', `<span style="color: blue;">${valueAtConfidence.toFixed(2)}</span>`, 'Value at the confidence level', 'Percentile'],
                    ['Target Probability', `<span style="color: blue;">${(targetProbability * 100).toFixed(2)}%</span>`, 'Probability of meeting target', 'P(X ≥ target)'],
                    ['Mean', `<span style="color: blue;">${mean.toFixed(2)}</span>`, 'Average of the smoothed data', 'μ'],
                    ['Standard Deviation', `<span style="color: blue;">${stdDev.toFixed(2)}</span>`, 'Spread of the smoothed data', 'σ'],
                    ['Skewness', `<span style="color: blue;">${skewness.toFixed(2)}</span>`, 'Asymmetry of the distribution', 'γ₁']
                ];
                recommendationsRows = [
                    ['Use Median', 'Consider the median for a robust central tendency measure.'],
                    ['95th Percentile', 'Use the 95th percentile for conservative estimates.'],
                    ['Adjust Target', `Adjust target value to ${(mean + stdDev).toFixed(2)} for higher probability.`]
                ];
                break;
            case 'optimizedDecisionInsights':
                metricsRows = [
                    ['Confidence', `<span style="color: blue;">${confidenceLevel}%</span>`, 'Selected confidence level', 'User input'],
                    ['Optimized Value', `<span style="color: blue;">${optimizedValue.toFixed(2)}</span>`, 'Value at optimized decision point', 'Optimized percentile'],
                    ['Mean Shift', `<span style="color: blue;">${meanShift.toFixed(2)}</span>`, 'Adjustment to mean based on flexibility', '0.2 × stdDev × (-BF - SF + 0.5 × SU)']
                ];
                // Note: This section may be incomplete in the original code
                break;
            case 'targetProbabilityExplorer':
                metricsRows = [
                    ['Target Probability', `<span style="color: blue;">${(targetProbability * 100).toFixed(2)}%</span>`, 'Probability of meeting target', 'P(X ≥ target)'],
                    ['Adjusted Target', `<span style="color: blue;">${adjustedTarget.toFixed(2)}</span>`, 'Target adjusted for probability', 'Inverse CDF']
                ];
                // Note: This section may be incomplete in the original code
                break;
            // Additional cases for other plot types can be added here
            default:
                console.warn(`[updateTablesAndRecommendations] Unhandled plotType: ${plotType}`);
                break;
        }

        // Populate metrics table
        metricsRows.forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${row[0]}</td><td>${row[1]}</td><td>${row[2]}</td><td>${row[3]}</td>`;
            metricsTable.appendChild(tr);
        });

        // Populate recommendations table
        recommendationsRows.forEach(row => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${row[0]}</td><td>${row[1]}</td>`;
            recommendationsTable.appendChild(tr);
        });
    }
</script>

 

<!-- SECTION 3.k: JAVASCRIPT - SUMMARY BOX UPDATE FUNCTION -->

<script type="text/javascript">

/**
 * Updates the summary content for the active tab below the plots.
 * Shows recommendations first, followed by key metrics and other sections.
 * @param {string} plotType - The active plot or tab (e.g., 'trianglePlot').
 */
function updateSummaryBox(plotType) {
    const contentId = `${plotType.replace('Plot', '').toLowerCase()}-summary-content`;
    const summaryContent = document.getElementById(contentId);
    if (!summaryContent) {
        console.error(`${contentId} not found`);
        return;
    }

    // Verify the parent summary container
    const summaryContainer = summaryContent.closest('.summary-section-container');
    if (!summaryContainer) {
        console.warn(`Parent .summary-section-container not found for ${contentId}`);
    } else {
        console.log(`Updating summary content in ${summaryContainer.id}`);
    }

    // Map plot types to their full toggle titles
    const toggleTitles = {
        'trianglePlot': 'Explore Summary Analysis - Triangle',
        'pertPlot': 'Explore Summary Analysis - PERT',
        'betaPlot': 'Explore Summary Analysis - Beta',
        'mcBetaUnsmoothedPlot': 'Explore Summary Analysis - Monte Carlo Unsmoothed',
        'mcBetaSmoothedPlot': 'Explore Summary Analysis - Monte Carlo Smoothed',
        'optimizedDecisionInsights': 'Explore Summary Analysis - Decision Optimizer',
        'targetProbabilityExplorer': 'Explore Summary Analysis - Target Probability'
    };

    // Update toggle button text to maintain full title
    const toggleButton = document.querySelector(`.toggle-summary[data-target="${contentId}"]`);
    if (toggleButton) {
        const isExpanded = summaryContent.style.display === 'block' || summaryContent.style.display === 'flex';
        toggleButton.textContent = isExpanded ? `▲ ${toggleTitles[plotType]}` : `▼ ${toggleTitles[plotType]}`;
        toggleButton.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
    }

    switch (plotType) {
        case 'trianglePlot':
            const triangleConfidence = window.lastConfidence || 50;
            const triangleIndex = Math.floor((triangleConfidence / 100) * (TRIANGLE_POINTS.length - 1));
            const triangleValue = TRIANGLE_POINTS[triangleIndex]?.x || triangleMean;
            const triangle90th = TRIANGLE_POINTS[Math.floor(0.9 * (TRIANGLE_POINTS.length - 1))]?.x || triangleMean;
            // Use API-provided standard deviation instead of calculating it
            const triangleStdDev = window.triangleStdDev; // Assumed to be set from API (e.g., TRIANGLE_STD) during initialization

            let triangleConfidenceDescriptor = '';
            if (triangleConfidence <= 25) {
                triangleConfidenceDescriptor = `optimistic target with a ${triangleConfidence}-to-${100 - triangleConfidence} chance of staying at or below this value`;
            } else if (triangleConfidence >= 75) {
                triangleConfidenceDescriptor = `conservative target with a ${triangleConfidence}-to-${100 - triangleConfidence} chance of staying at or below this value`;
            } else if (triangleConfidence >= 45 && triangleConfidence <= 55) {
                triangleConfidenceDescriptor = `balanced target with a ${triangleConfidence}-to-${100 - triangleConfidence} chance of staying at or below this value`;
            } else {
                triangleConfidenceDescriptor = `near-balanced target with a ${triangleConfidence}-to-${100 - triangleConfidence} chance of staying at or below this value`;
            }

            const triangleRecommendation = document.getElementById('triangle-recommendation-section');
            if (triangleRecommendation) {
                triangleRecommendation.innerHTML = `
                    <p><strong>Recommendation:</strong></p>
                    <p>For a balanced estimate, aim for the value at <span style="color: blue;">50% confidence</span>, which is <span style="color: blue;">${TRIANGLE_POINTS.find(p => p.confidence === 50)?.x.toFixed(2) || 'N/A'}</span> units.</p>
                    <p>For a more cautious estimate, use the <span style="color: blue;">90% confidence</span> value of <span style="color: blue;">${TRIANGLE_POINTS.find(p => p.confidence === 90)?.x.toFixed(2) || 'N/A'}</span> units.</p>
                    <p>Adjust the confidence slider to explore other confidence levels that fit your planning needs.</p>
                    <p>See the 'Triangular Distribution Metrics and Recommendation' table below for details.</p>
                `;
            }

            const triangleMain = document.getElementById('triangle-main-section');
            if (triangleMain) {
                triangleMain.innerHTML = `
                    <p><strong>Step 1: Visualize Initial Estimates with the Triangular Distribution</strong></p>
                    <p><strong>Range:</strong> <span style="color: blue;">${min}</span> to <span style="color: blue;">${max}</span> units | <strong>Mean:</strong> <span style="color: blue;">${triangleMean.toFixed(2)}</span> units<br>
                    <strong>Mode:</strong> <span style="color: blue;">${mostLikely.toFixed(2)}</span> units (most likely estimate)<br>
                    <strong>Standard Deviation:</strong> <span style="color: blue;">${triangleStdDev.toFixed(2)}</span> units (measure of variability)<br>
                    <strong>At <span style="color: blue;">${triangleConfidence}</span>% Confidence:</strong> <span style="color: blue;">${triangleValue.toFixed(2)}</span> units | <strong>90th Percentile:</strong> <span style="color: blue;">${triangle90th.toFixed(2)}</span> units</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    For this project or task, with your estimates of <span style="color: blue;">${min} (best case), ${mostLikely} (most likely), and ${max} (worst case) units</span>, the triangular distribution creates a simple probability curve—visualized below. This model uses your three inputs to map possible outcomes and their likelihoods, ideal for quick, early-stage planning. The mean of <span style="color: blue;">${triangleMean.toFixed(2)} units</span> is your average expectation—great for budgeting or scheduling—while the mode of <span style="color: blue;">${mostLikely.toFixed(2)} units</span> reflects the most likely outcome. The standard deviation of <span style="color: blue;">${triangleStdDev.toFixed(2)} units</span> shows variability. At <span style="color: blue;">${triangleConfidence}% confidence</span>, <span style="color: blue;">${triangleValue.toFixed(2)} units</span> offers a ${triangleConfidenceDescriptor}. The 90th percentile at <span style="color: blue;">${triangle90th.toFixed(2)} units</span> ensures a 90% chance of staying under, perfect for cautious planning.</p>
                    <p><strong>Why It’s Useful:</strong> With just three inputs, it provides a fast, clear picture of uncertainty, a stepping stone to more detailed models.</p>
                `;
            }

            const triangleTableBody = document.querySelector('#triangle-table tbody');
            if (triangleTableBody) {
                triangleTableBody.innerHTML = `
                    <tr>
                        <td>Mean</td>
                        <td>${triangleMean.toFixed(2)} units</td>
                        <td>Use as a baseline for budgeting or scheduling.</td>
                    </tr>
                    <tr>
                        <td>Mode</td>
                        <td>${mostLikely.toFixed(2)} units</td>
                        <td>Reflects the most likely outcome; ideal for quick estimates.</td>
                    </tr>
                    <tr>
                        <td>Standard Deviation</td>
                        <td>${triangleStdDev.toFixed(2)} units</td>
                        <td>Indicates variability; higher values suggest more uncertainty.</td>
                    </tr>
                    <tr>
                        <td>90th Percentile</td>
                        <td>${triangle90th.toFixed(2)} units</td>
                        <td>Plan for this value to cover 90% of scenarios, reducing risk.</td>
                    </tr>
                `;
            }
            break;

        case 'pertPlot':
            const pertConfidence = window.lastConfidence || 50;
            const pertIndex = Math.floor((pertConfidence / 100) * (PERT_POINTS.length - 1));
            const pertValue = PERT_POINTS[pertIndex]?.x || pertMean;
            const pert95th = PERT_POINTS[Math.floor(0.95 * (PERT_POINTS.length - 1))]?.x || pertMean;
            const pertStdDev = pertStd;

            let pertConfidenceDescriptor = '';
            if (pertConfidence <= 25) {
                pertConfidenceDescriptor = `optimistic target with a ${pertConfidence}-to-${100 - pertConfidence} chance of staying at or below this value`;
            } else if (pertConfidence >= 75) {
                pertConfidenceDescriptor = `conservative target with a ${pertConfidence}-to-${100 - pertConfidence} chance of staying at or below this value`;
            } else if (pertConfidence >= 45 && pertConfidence <= 55) {
                pertConfidenceDescriptor = `balanced target with a ${pertConfidence}-to-${100 - pertConfidence} chance of staying at or below this value`;
            } else {
                pertConfidenceDescriptor = `near-balanced target with a ${pertConfidence}-to-${100 - pertConfidence} chance of staying at or below this value`;
            }

            const pertRecommendation = document.getElementById('pert-recommendation-section');
            if (pertRecommendation) {
                pertRecommendation.innerHTML = `
                    <p><strong>Recommendation:</strong></p>
                    <p>For a realistic plan, use the value at <span style="color: blue;">50% confidence</span>, which is <span style="color: blue;">${PERT_POINTS.find(p => p.confidence === 50)?.x.toFixed(2) || 'N/A'}</span> units.</p>
                    <p>For a more conservative approach, consider the <span style="color: blue;">95% confidence</span> value of <span style="color: blue;">${PERT_POINTS.find(p => p.confidence === 95)?.x.toFixed(2) || 'N/A'}</span> units.</p>
                    <p>Adjust the confidence slider to find a confidence level that matches your risk tolerance.</p>
                    <p>See the 'PERT Distribution Metrics and Recommendation' table below for details.</p>
                `;
            }

            const pertMain = document.getElementById('pert-main-section');
            if (pertMain) {
                pertMain.innerHTML = `
                    <p><strong>Step 2: Structure Estimates with the PERT Distribution</strong></p>
                    <p><strong>Range:</strong> <span style="color: blue;">${min}</span> to <span style="color: blue;">${max}</span> units | <strong>Mean:</strong> <span style="color: blue;">${pertMean.toFixed(2)}</span> units<br>
                    <strong>Mode:</strong> <span style="color: blue;">${mostLikely.toFixed(2)}</span> units (most likely estimate)<br>
                    <strong>Standard Deviation:</strong> <span style="color: blue;">${pertStdDev.toFixed(2)}</span> units (measure of variability)<br>
                    <strong>At <span style="color: blue;">${pertConfidence}</span>% Confidence:</strong> <span style="color: blue;">${pertValue.toFixed(2)}</span> units | <strong>95th Percentile:</strong> <span style="color: blue;">${pert95th.toFixed(2)}</span> units</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    Using your estimates of <span style="color: blue;">${min} (optimistic), ${mostLikely} (most likely), and ${max} (pessimistic) units</span>, the PERT distribution refines planning by weighting the most likely outcome, visualized below. The mean of <span style="color: blue;">${pertMean.toFixed(2)} units</span> balances optimism and caution—ideal for scheduling or budgeting—while the mode of <span style="color: blue;">${mostLikely.toFixed(2)} units</span> highlights peak likelihood. The standard deviation of <span style="color: blue;">${pertStdDev.toFixed(2)} units</span> indicates variability. At <span style="color: blue;">${pertConfidence}% confidence</span>, <span style="color: blue;">${pertValue.toFixed(2)} units</span> offers a ${pertConfidenceDescriptor}. The 95th percentile at <span style="color: blue;">${pert95th.toFixed(2)} units</span> ensures a 95% chance of staying under, great for firm commitments.</p>
                    <p><strong>Why It’s Useful:</strong> PERT improves accuracy over the triangular model by emphasizing the most likely scenario.</p>
                `;
            }

            const pertTableBody = document.querySelector('#pert-table tbody');
            if (pertTableBody) {
                pertTableBody.innerHTML = `
                    <tr>
                        <td>Mean</td>
                        <td>${pertMean.toFixed(2)} units</td>
                        <td>Use as a balanced estimate for planning.</td>
                    </tr>
                    <tr>
                        <td>Mode</td>
                        <td>${mostLikely.toFixed(2)} units</td>
                        <td>Reflects the most likely outcome; good for setting expectations.</td>
                    </tr>
                    <tr>
                        <td>Standard Deviation</td>
                        <td>${pertStdDev.toFixed(2)} units</td>
                        <td>Shows variability; higher values indicate greater uncertainty.</td>
                    </tr>
                    <tr>
                        <td>95th Percentile</td>
                        <td>${pert95th.toFixed(2)} units</td>
                        <td>Plan for this value to cover 95% of scenarios, minimizing risk.</td>
                    </tr>
                `;
            }
            break;

        case 'betaPlot':
            const betaConfidence = window.lastConfidence || 50;
            const betaIndex = Math.floor((betaConfidence / 100) * (BETA_POINTS.length - 1));
            const betaValue = BETA_POINTS[betaIndex]?.x || betaMean;
            const beta90th = BETA_POINTS[Math.floor(0.9 * (BETA_POINTS.length - 1))]?.x || betaMean;
            const betaStdDev = Math.sqrt((alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1)));

            let betaConfidenceDescriptor = '';
            if (betaConfidence <= 25) {
                betaConfidenceDescriptor = `optimistic target with a ${betaConfidence}-to-${100 - betaConfidence} chance of staying at or below this value`;
            } else if (betaConfidence >= 75) {
                betaConfidenceDescriptor = `conservative target with a ${betaConfidence}-to-${100 - betaConfidence} chance of staying at or below this value`;
            } else if (betaConfidence >= 45 && betaConfidence <= 55) {
                betaConfidenceDescriptor = `balanced target with a ${betaConfidence}-to-${100 - betaConfidence} chance of staying at or below this value`;
            } else {
                betaConfidenceDescriptor = `near-balanced target with a ${betaConfidence}-to-${100 - betaConfidence} chance of staying at or below this value`;
            }

            const betaRecommendation = document.getElementById('beta-recommendation-section');
            if (betaRecommendation) {
                betaRecommendation.innerHTML = `
                    <p><strong>Recommendation:</strong></p>
                    <p>For a balanced approach, use the value at <span style="color: blue;">50% confidence</span>, which is <span style="color: blue;">${BETA_POINTS.find(p => p.confidence === 50)?.x.toFixed(2) || 'N/A'}</span> units.</p>
                    <p>For a more conservative plan, consider the <span style="color: blue;">90% confidence</span> value of <span style="color: blue;">${BETA_POINTS.find(p => p.confidence === 90)?.x.toFixed(2) || 'N/A'}</span> units.</p>
                    <p>Adjust the confidence slider to explore other confidence levels that suit your project’s needs.</p>
                    <p>See the 'Beta Distribution Metrics and Recommendation' table below for details.</p>
                `;
            }

            const betaMain = document.getElementById('beta-main-section');
            if (betaMain) {
                betaMain.innerHTML = `
                    <p><strong>Step 3: Refine Estimates with the Beta Distribution</strong></p>
                    <p><strong>Range:</strong> <span style="color: blue;">${min}</span> to <span style="color: blue;">${max}</span> units | <strong>Mean:</strong> <span style="color: blue;">${betaMean.toFixed(2)}</span> units<br>
                    <strong>Mode:</strong> <span style="color: blue;">${betaMode.toFixed(2)}</span> units (most likely estimate)<br>
                    <strong>Standard Deviation:</strong> <span style="color: blue;">${betaStdDev.toFixed(2)}</span> units (measure of variability)<br>
                    <strong>At <span style="color: blue;">${betaConfidence}</span>% Confidence:</strong> <span style="color: blue;">${betaValue.toFixed(2)}</span> units | <strong>90th Percentile:</strong> <span style="color: blue;">${beta90th.toFixed(2)}</span> units</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    With estimates of <span style="color: blue;">${min} (best case), ${mostLikely} (most likely), and ${max} (worst case) units</span>, the beta distribution offers a flexible curve—shown below—adapting to real-world variability mid-project. The mean of <span style="color: blue;">${betaMean.toFixed(2)} units</span> updates your average as data emerges, while the mode of <span style="color: blue;">${betaMode.toFixed(2)} units</span> pinpoints peak likelihood. The standard deviation of <span style="color: blue;">${betaStdDev.toFixed(2)} units</span> measures spread. At <span style="color: blue;">${betaConfidence}% confidence</span>, <span style="color: blue;">${betaValue.toFixed(2)} units</span> offers a ${betaConfidenceDescriptor}. The 90th percentile at <span style="color: blue;">${beta90th.toFixed(2)} units</span> offers a 90% chance of staying under, ideal for cautious adjustments.</p>
                    <p><strong>Why It’s Useful:</strong> Its adaptability refines plans as you gather data, setting the stage for simulations.</p>
                `;
            }

            const betaTableBody = document.querySelector('#beta-table tbody');
            if (betaTableBody) {
                betaTableBody.innerHTML = `
                    <tr>
                        <td>Mean</td>
                        <td>${betaMean.toFixed(2)} units</td>
                        <td>Use as an updated average for mid-project planning.</td>
                    </tr>
                    <tr>
                        <td>Mode</td>
                        <td>${betaMode.toFixed(2)} units</td>
                        <td>Reflects the most likely outcome; adjust plans accordingly.</td>
                    </tr>
                    <tr>
                        <td>Standard Deviation</td>
                        <td>${betaStdDev.toFixed(2)} units</td>
                        <td>Shows spread; higher values indicate more variability.</td>
                    </tr>
                    <tr>
                        <td>90th Percentile</td>
                        <td>${beta90th.toFixed(2)} units</td>
                        <td>Plan for this value to cover 90% of scenarios, reducing risk.</td>
                    </tr>
                `;
            }
            break;

        case 'mcBetaUnsmoothedPlot':
            const mcUnsmoothedConfidence = window.lastConfidence || 50;
            const mcUnsmoothedIndex = Math.floor((mcUnsmoothedConfidence / 100) * (MC_UNSMOOTHED_POINTS.length - 1));
            const mcUnsmoothedValue = MC_UNSMOOTHED_POINTS[mcUnsmoothedIndex]?.x || mcUnsmoothedMean;
            const mcUnsmoothed90th = MC_UNSMOOTHED_POINTS[Math.floor(0.9 * (MC_UNSMOOTHED_POINTS.length - 1))]?.x || mcUnsmoothedMean;
            const mcUnsmoothedStdDev = MC_UNSMOOTHED_POINTS.reduce((sum, p) => sum + Math.pow(p.x - mcUnsmoothedMean, 2), 0) / MC_UNSMOOTHED_POINTS.length;

            let mcUnsmoothedConfidenceDescriptor = '';
            if (mcUnsmoothedConfidence <= 25) {
                mcUnsmoothedConfidenceDescriptor = `optimistic target with a ${mcUnsmoothedConfidence}-to-${100 - mcUnsmoothedConfidence} chance of staying at or below this value`;
            } else if (mcUnsmoothedConfidence >= 75) {
                mcUnsmoothedConfidenceDescriptor = `conservative target with a ${mcUnsmoothedConfidence}-to-${100 - mcUnsmoothedConfidence} chance of staying at or below this value`;
            } else if (mcUnsmoothedConfidence >= 45 && mcUnsmoothedConfidence <= 55) {
                mcUnsmoothedConfidenceDescriptor = `balanced target with a ${mcUnsmoothedConfidence}-to-${100 - mcUnsmoothedConfidence} chance of staying at or below this value`;
            } else {
                mcUnsmoothedConfidenceDescriptor = `near-balanced target with a ${mcUnsmoothedConfidence}-to-${100 - mcUnsmoothedConfidence} chance of staying at or below this value`;
            }

            const mcUnsmoothedRecommendation = document.getElementById('mcbetaunsmoothed-recommendation-section');
            if (mcUnsmoothedRecommendation) {
                mcUnsmoothedRecommendation.innerHTML = `
                    <p><strong>Recommendation:</strong></p>
                    <p>For a balanced approach, target the median at <span style="color: blue;">50% confidence</span>, which is <span style="color: blue;">${MC_UNSMOOTHED_POINTS.find(p => p.confidence === 50)?.x.toFixed(2) || 'N/A'}</span> units.</p>
                    <p>For greater risk coverage, consider the <span style="color: blue;">90% confidence</span> value of <span style="color: blue;">${MC_UNSMOOTHED_POINTS.find(p => p.confidence === 90)?.x.toFixed(2) || 'N/A'}</span> units.</p>
                    <p>Adjust the confidence slider to explore other confidence levels that align with your risk tolerance.</p>
                    <p>See the 'Monte Carlo Unsmoothed Metrics and Recommendation' table below for details.</p>
                `;
            }

            const mcUnsmoothedMain = document.getElementById('mcbetaunsmoothed-main-section');
            if (mcUnsmoothedMain) {
                mcUnsmoothedMain.innerHTML = `
                    <p><strong>Step 4: Simulate Risks with Monte Carlo (Unsmoothed)</strong></p>
                    <p><strong>Range:</strong> <span style="color: blue;">${min}</span> to <span style="color: blue;">${max}</span> units | <strong>Mean:</strong> <span style="color: blue;">${mcUnsmoothedMean.toFixed(2)}</span> units<br>
                    <strong>Standard Deviation:</strong> <span style="color: blue;">${Math.sqrt(mcUnsmoothedStdDev).toFixed(2)}</span> units (measure of variability)<br>
                    <strong>At <span style="color: blue;">${mcUnsmoothedConfidence}</span>% Confidence:</strong> <span style="color: blue;">${mcUnsmoothedValue.toFixed(2)}</span> units | <strong>90th Percentile:</strong> <span style="color: blue;">${mcUnsmoothed90th.toFixed(2)}</span> units</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    Based on your range of <span style="color: blue;">${min} to ${max} units</span>, this Monte Carlo simulation runs thousands of scenarios—plotted below—showing raw outcomes without smoothing. The mean of <span style="color: blue;">${mcUnsmoothedMean.toFixed(2)} units</span> is your average across simulations, a baseline for risk assessment. The standard deviation of <span style="color: blue;">${Math.sqrt(mcUnsmoothedStdDev).toFixed(2)} units</span> highlights variability. At <span style="color: blue;">${mcUnsmoothedConfidence}% confidence</span>, <span style="color: blue;">${mcUnsmoothedValue.toFixed(2)} units</span> offers a ${mcUnsmoothedConfidenceDescriptor}, while the 90th percentile at <span style="color: blue;">${mcUnsmoothed90th.toFixed(2)} units</span> covers 90% of outcomes, exposing extremes like cost overruns or delays.</p>
                    <p><strong>Why It’s Useful:</strong> It reveals the full range of risks, helping you prepare for worst-case scenarios.</p>
                `;
            }

            const mcUnsmoothedTableBody = document.querySelector('#mc-unsmoothed-table tbody');
            if (mcUnsmoothedTableBody) {
                mcUnsmoothedTableBody.innerHTML = `
                    <tr>
                        <td>Mean</td>
                        <td>${mcUnsmoothedMean.toFixed(2)} units</td>
                        <td>Use as a baseline for risk assessment across simulations.</td>
                    </tr>
                    <tr>
                        <td>Standard Deviation</td>
                        <td>${Math.sqrt(mcUnsmoothedStdDev).toFixed(2)} units</td>
                        <td>Highlights variability; higher values indicate more risk.</td>
                    </tr>
                    <tr>
                        <td>90th Percentile</td>
                        <td>${mcUnsmoothed90th.toFixed(2)} units</td>
                        <td>Plan for this value to cover 90% of outcomes, addressing extremes.</td>
                    </tr>
                `;
            }
            break;

        case 'mcBetaSmoothedPlot':
            console.log('Updating Monte Carlo Smoothed summary...');
            const mcSmoothedConfidence = window.lastConfidence || 50;
            const mcSmoothedValue = getValueForConfidence('mcBetaSmoothedPlot', mcSmoothedConfidence);
            const mcSmoothed95th = getValueForConfidence('mcBetaSmoothedPlot', 95);
            const mcSmoothedStdDev = MC_SMOOTHED_POINTS?.reduce((sum, p) => sum + Math.pow(p.x - mcSmoothedMean, 2), 0) / MC_SMOOTHED_POINTS?.length || 'N/A';
            const probabilitySlider = document.getElementById('probability-slider');
            const probabilityValue = probabilitySlider ? parseFloat(probabilitySlider.value) : (min + max) / 2;
            const probabilityResult = document.getElementById('probability-result');
            const probabilityText = probabilityResult ? probabilityResult.textContent : '(Calculating...)';
            const probabilityPercent = parseFloat(probabilityText.split(': ')[1]) || 50;

            const mcSmoothedRecommendationContent = document.getElementById('mc-smoothed-recommendation-content');
            if (mcSmoothedRecommendationContent) {
                console.log('Populating mc-smoothed-recommendation-content');
                mcSmoothedRecommendationContent.innerHTML = `
                    <p><strong>Recommendation:</strong></p>
                    <p>When examining your project’s data, you have two effective options using PDF and CDF plots, each offering a unique perspective depending on whether you prioritize confidence or a specific target value.</p>
                    <p>With the PDF plot, you begin by selecting a desired confidence level to determine the value you’re likely to stay below. For instance, choosing a confidence level of <span style="color: blue;">${mcSmoothedConfidence}%</span> yields a value of <span style="color: blue;">${mcSmoothedValue ? mcSmoothedValue.toFixed(2) : 'Calculating...'}</span> units, meaning there’s a <span style="color: blue;">${mcSmoothedConfidence}%</span> chance your project’s cost, time, or other metric will be at or below that figure. If you prefer greater certainty, adjusting to a <span style="color: blue;">95%</span> confidence level could increase the value to <span style="color: blue;">${mcSmoothed95th ? mcSmoothed95th.toFixed(2) : 'Calculating...'}</span> units, indicating a 95% likelihood of staying under that higher threshold.</p>
                    <p>On the other hand, the CDF plot allows you to start with a target value and assess the confidence of staying at or below it. For example, selecting a target of <span style="color: blue;">${probabilityValue.toFixed(2)} units</span> shows a confidence of <span style="color: blue;">${probabilityPercent}%</span>, suggesting a <span style="color: blue;">${probabilityPercent}%</span> probability of keeping your metric under that amount. If you test a lower target like <span style="color: blue;">${(probabilityValue * 0.95).toFixed(2)} units</span>, the confidence might drop to <span style="color: blue;">${(probabilityPercent * 0.75).toFixed(1)}%</span>, reflecting a reduced chance of meeting that goal.</p>
                    <p>To make the most of these tools together, you can start with the PDF plot if confidence drives your decisions—pick a level like <span style="color: blue;">50%</span> or <span style="color: blue;">95%</span> and note the corresponding values (<span style="color: blue;">${mcSmoothedValue ? mcSmoothedValue.toFixed(2) : 'Calculating...'} units</span> or <span style="color: blue;">${mcSmoothed95th ? mcSmoothed95th.toFixed(2) : 'Calculating...'} units</span>) as your expected thresholds. Alternatively, if a specific target is your focus, use the CDF plot to set a value like <span style="color: blue;">${probabilityValue.toFixed(2)} units</span> and check its confidence (<span style="color: blue;">${probabilityPercent}%</span>). If the confidence feels too low, adjust the target downward in the CDF plot, or switch to the PDF plot to find a safer threshold at a higher confidence level.</p>
                    <p>By toggling between these approaches and adjusting sliders, you can strike the right balance between risk and your project’s objectives, tailoring your analysis to either maximize certainty or hit a precise goal.</p>
                    <p>See the 'Monte Carlo - Trend Metrics and Recommendation' table below for details.</p>
                `;
            } else {
                console.error('mc-smoothed-recommendation-content element not found');
            }

            const mcSmoothedPdfContent = document.getElementById('mc-smoothed-pdf-content');
            if (mcSmoothedPdfContent) {
                console.log('Populating mc-smoothed-pdf-content');
                mcSmoothedPdfContent.innerHTML = `
                    <p><strong>Range:</strong> <span style="color: blue;">${min}</span> to <span style="color: blue;">${max}</span> units</p>
                    <p><strong>Mean:</strong> <span style="color: blue;">${mcSmoothedMean?.toFixed(2) || 'N/A'}</span> units</p>
                    <p><strong>Standard Deviation:</strong> <span style="color: blue;">${mcSmoothedStdDev !== 'N/A' ? Math.sqrt(mcSmoothedStdDev).toFixed(2) : 'N/A'}</span> units (measure of variability)</p>
                    <p><strong>At <span style="color: blue;">${mcSmoothedConfidence}</span>% Confidence:</strong> <span style="color: blue;">${mcSmoothedValue ? mcSmoothedValue.toFixed(2) : 'Calculating...'}</span> units</p>
                    <p><strong>95th Percentile:</strong> <span style="color: blue;">${mcSmoothed95th ? mcSmoothed95th.toFixed(2) : 'Calculating...'}</span> units</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    This smoothed Monte Carlo simulation visualizes the probability density of outcomes across your range of <span style="color: blue;">${min} to ${max} units</span>. The mean of <span style="color: blue;">${mcSmoothedMean?.toFixed(2) || 'N/A'} units</span> represents the average expected outcome, offering a solid starting point for planning. The standard deviation of <span style="color: blue;">${mcSmoothedStdDev !== 'N/A' ? Math.sqrt(mcSmoothedStdDev).toFixed(2) : 'N/A'} units</span> shows the spread of possible results—use it to gauge uncertainty or risk. At <span style="color: blue;">${mcSmoothedConfidence}% confidence</span>, you’d need <span style="color: blue;">${mcSmoothedValue ? mcSmoothedValue.toFixed(2) : 'Calculating...'} units</span> to have a ${mcSmoothedConfidence}% chance of staying under, while the 95th percentile at <span style="color: blue;">${mcSmoothed95th ? mcSmoothed95th.toFixed(2) : 'Calculating...'} units</span> covers 95% of outcomes, ideal for risk-averse planning.</p>
                    <p><strong>Why It’s Useful:</strong> Smoothing reduces noise, helping you identify probable outcomes and assess variability for cost, time, or other metrics.</p>
                `;
            } else {
                console.error('mc-smoothed-pdf-content element not found');
            }

            const mcSmoothedCdfContent = document.getElementById('mc-smoothed-cdf-content');
            if (mcSmoothedCdfContent) {
                console.log('Populating mc-smoothed-cdf-content');
                mcSmoothedCdfContent.innerHTML = `
                    <p><strong>Range:</strong> <span style="color: blue;">${min}</span> to <span style="color: blue;">${max}</span> units</p>
                    <p><strong>Mean:</strong> <span style="color: blue;">${mcSmoothedMean?.toFixed(2) || 'N/A'}</span> units</p>
                    <p><strong>At Target <span style="color: blue;">${probabilityValue.toFixed(2)} units</span>:</strong> <span style="color: blue;">${probabilityPercent}%</span> probability</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    The CDF shows the likelihood of staying at or below a value within <span style="color: blue;">${min} to ${max} units</span>. At your selected target of <span style="color: blue;">${probabilityValue.toFixed(2)} units</span>, there’s a <span style="color: blue;">${probabilityPercent}%</span> chance of staying under, based on the smoothed Monte Carlo simulation. Adjust the target value using the slider to explore different thresholds and their associated probabilities, helping you set realistic goals for budgets, timelines, or other metrics.</p>
                    <p><strong>Why It’s Useful:</strong> It simplifies setting targets and understanding probabilities for goals like budgets or schedules, making it easier to communicate risks and plan effectively.</p>
                `;
            } else {
                console.error('mc-smoothed-cdf-content element not found');
            }

            const mcSmoothedTableBody = document.querySelector('#mc-smoothed-table tbody');
            if (mcSmoothedTableBody) {
                console.log('Populating mc-smoothed-table');
                mcSmoothedTableBody.innerHTML = `
                    <tr>
                        <td>Mean (PDF)</td>
                        <td>${mcSmoothedMean?.toFixed(2) || 'N/A'} units</td>
                        <td>Use as the average expected outcome for planning.</td>
                    </tr>
                    <tr>
                        <td>Standard Deviation (PDF)</td>
                        <td>${mcSmoothedStdDev !== 'N/A' ? Math.sqrt(mcSmoothedStdDev).toFixed(2) : 'N/A'} units</td>
                        <td>Assess uncertainty; higher values indicate more variability.</td>
                    </tr>
                    <tr>
                        <td>95th Percentile (PDF)</td>
                        <td>${mcSmoothed95th ? mcSmoothed95th.toFixed(2) : 'Calculating...'} units</td>
                        <td>Plan for this value to cover 95% of outcomes, reducing risk.</td>
                    </tr>
                    <tr>
                        <td>Target Probability (CDF)</td>
                        <td>${probabilityPercent}% at ${probabilityValue.toFixed(2)} units</td>
                        <td>Adjust target to increase confidence if probability is too low.</td>
                    </tr>
                `;
            } else {
                console.error('mc-smoothed-table tbody not found');
            }
            console.log('Monte Carlo Smoothed summary update complete');
            break;

        case 'optimizedDecisionInsights':
            const origMedian = window.decisionOptimizerOrigMedian || 2400;
            const newConfidence = window.decisionOptimizerNewConfidence || 50;
            const optimizedValue = window.lastOptimizedValue || origMedian.toFixed(2);
            const percentageChange = ((optimizedValue - origMedian) / origMedian * 100).toFixed(2);
            const changeDirection = percentageChange > 0 ? 'increase' : 'decrease';

            const optimizedRecommendation = document.getElementById('optimizeddecisioninsights-recommendation-section');
            if (optimizedRecommendation) {
                optimizedRecommendation.innerHTML = `
                    <p><strong>Recommendation:</strong></p>
                    <p>Use the adjusted median of <span style="color: blue;">${optimizedValue}</span> units for planning, as it reflects your current settings for Budget Flexibility (<span style="color: blue;">${window.sliderState.budgetFlexibility}%</span>), Schedule Flexibility (<span style="color: blue;">${window.sliderState.scheduleFlexibility}%</span>), Scope Uncertainty (<span style="color: blue;">${window.sliderState.scopeUncertainty}%</span>), and Risk Tolerance (<span style="color: blue;">${window.sliderState.riskTolerance}%</span>).</p>
                    <p>Alternatively, if you prefer the original median of <span style="color: blue;">${origMedian.toFixed(2)}</span> units, note that it now has a <span style="color: blue;">${newConfidence}%</span> confidence level.</p>
                    <p>To increase confidence in meeting the original median, consider increasing Budget Flexibility (e.g., to <span style="color: blue;">75%</span>) or Schedule Flexibility.</p>
                    <p>To align with a more aggressive target, reduce the median further by lowering Scope Uncertainty or Risk Tolerance. For example, adjusting Risk Tolerance to <span style="color: blue;">25%</span> might shift the median closer to <span style="color: blue;">${(optimizedValue * 0.95).toFixed(2)}</span> units.</p>
                    <p>Use the sliders to explore settings that balance risk and your project objectives.</p>
                    <p>See the 'Decision Optimizer Metrics and Recommendation' table below for details.</p>
                `;
            }

            const optimizedOriginal = document.getElementById('optimizeddecisioninsights-original-section');
            if (optimizedOriginal) {
                optimizedOriginal.innerHTML = `
                    <h4>Original Distribution</h4>
                    <p><strong>Median:</strong> <span style="color: blue;">${origMedian.toFixed(2)}</span> units at 50% Confidence</p>
                    <p><strong>Settings:</strong> Budget Flexibility: <span style="color: blue;">${window.sliderState.budgetFlexibility}</span>% | Schedule Flexibility: <span style="color: blue;">${window.sliderState.scheduleFlexibility}</span>% | Scope Uncertainty: <span style="color: blue;">${window.sliderState.scopeUncertainty}</span>% | Risk Tolerance: <span style="color: blue;">${window.sliderState.riskTolerance}</span>%</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    The Original Distribution represents the baseline smoothed Monte Carlo simulation, with a median of <span style="color: blue;">${origMedian.toFixed(2)}</span> units at 50% confidence. This reflects the expected central tendency of your project’s cost, time, or other metric before applying any adjustments. Use this as a reference to understand your starting point and compare it to the optimized outcomes.</p>
                    <p><strong>Why It’s Useful:</strong> It provides a clear benchmark for evaluating how changes in flexibility and risk settings impact your project’s outcomes.</p>
                `;
            }

            const optimizedOptimized = document.getElementById('optimizeddecisioninsights-optimized-section');
            if (optimizedOptimized) {
                optimizedOptimized.innerHTML = `
                    <h4>Optimized Distribution</h4>
                    <p><strong>Median:</strong> <span style="color: blue;">${optimizedValue}</span> units at 50% Confidence</p>
                    <p><strong>New Confidence for Original Median:</strong> <span style="color: blue;">${newConfidence}</span>% for <span style="color: blue;">${origMedian.toFixed(2)}</span> units</p>
                    <p><strong>Median Shift:</strong> <span style="color: blue;">${percentageChange}%</span> (<span style="color: blue;">${changeDirection}</span>)</p>
                    <p><strong>Settings:</strong> Budget Flexibility: <span style="color: blue;">${window.sliderState.budgetFlexibility}</span>% | Schedule Flexibility: <span style="color: blue;">${window.sliderState.scheduleFlexibility}</span>% | Scope Uncertainty: <span style="color: blue;">${window.sliderState.scopeUncertainty}</span>% | Risk Tolerance: <span style="color: blue;">${window.sliderState.riskTolerance}</span>%</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    The Optimized Distribution reflects the adjusted Monte Carlo simulation after applying your settings, with a median of <span style="color: blue;">${optimizedValue}</span> units at 50% confidence. The original median of <span style="color: blue;">${origMedian.toFixed(2)}</span> units now has a <span style="color: blue;">${newConfidence}%</span> confidence level, and the median has shifted by <span style="color: blue;">${percentageChange}%</span> (<span style="color: blue;">${changeDirection}</span>). Adjust the sliders for Budget Flexibility, Schedule Flexibility, Scope Uncertainty, and Risk Tolerance to fine-tune the distribution to meet your project goals.</p>
                    <p><strong>Why It’s Useful:</strong> It shows how your priorities reshape the distribution, helping you balance trade-offs and optimize planning.</p>
                `;
            }

            const decisionTableBody = document.querySelector('#decision-optimizer-table tbody');
            if (decisionTableBody) {
                decisionTableBody.innerHTML = `
                    <tr>
                        <td>Original Median</td>
                        <td>${origMedian.toFixed(2)} units</td>
                        <td>Use as a baseline for comparison with optimized values.</td>
                    </tr>
                    <tr>
                        <td>Optimized Median</td>
                        <td>${optimizedValue} units</td>
                        <td>Plan using this value based on current settings.</td>
                    </tr>
                    <tr>
                        <td>Median Shift</td>
                        <td>${percentageChange}% (${changeDirection})</td>
                        <td>Adjust settings to control the direction and magnitude of the shift.</td>
                    </tr>
                    <tr>
                        <td>New Confidence for Original Median</td>
                        <td>${newConfidence}%</td>
                        <td>Increase Budget or Schedule Flexibility to boost confidence.</td>
                    </tr>
                `;
            }
            break;

        case 'targetProbabilityExplorer':
            const targetValue = parseFloat(document.getElementById('target-value-slider')?.value) || 2466.46;
            const origProb = window.lastOrigProb || '0.0';
            const optProb = window.lastOptProb || '0.0';
            const probDifference = (optProb - origProb).toFixed(1);
            const changeDirectionProb = probDifference > 0 ? 'increased' : 'decreased';

            let probabilityRiskDescriptor = '';
            if (optProb <= 25) {
                probabilityRiskDescriptor = 'indicating a high risk of exceeding your target';
            } else if (optProb >= 75) {
                probabilityRiskDescriptor = 'indicating a low risk of exceeding your target';
            } else if (optProb >= 45 && optProb <= 55) {
                probabilityRiskDescriptor = 'indicating a balanced risk of meeting or exceeding your target';
            } else {
                probabilityRiskDescriptor = `indicating a ${optProb < 50 ? 'moderate' : 'relatively low'} risk of exceeding your target`;
            }

            const targetRecommendation = document.getElementById('targetprobabilityexplorer-recommendation-section');
            if (targetRecommendation) {
                targetRecommendation.innerHTML = `
                    <p><strong>Recommendation:</strong></p>
                    <p>Your target of <span style="color: blue;">${targetValue.toFixed(2)}</span> units has an adjusted probability of <span style="color: blue;">${optProb}%</span>, compared to the original probability of <span style="color: blue;">${origProb}%</span>, based on your current settings for Budget Flexibility (<span style="color: blue;">${window.sliderState.budgetFlexibility}%</span>), Schedule Flexibility (<span style="color: blue;">${window.sliderState.scheduleFlexibility}%</span>), Scope Uncertainty (<span style="color: blue;">${window.sliderState.scopeUncertainty}%</span>), and Risk Tolerance (<span style="color: blue;">${window.sliderState.riskTolerance}%</span>), <span style="color: blue;">${probabilityRiskDescriptor}</span>.</p>
                    <p>To reduce risk, increase the target value (e.g., to <span style="color: blue;">${(targetValue * 1.05).toFixed(2)}</span> units) or adjust sliders to boost probability (e.g., increase Budget Flexibility to <span style="color: blue;">75%</span>).</p>
                    <p>To accept more risk, decrease the target (e.g., to <span style="color: blue;">${(targetValue * 0.95).toFixed(2)}</span> units) or lower flexibility settings, aligning with your risk tolerance.</p>
                    <p>Toggle between the Original and Optimized CDF plots and adjust sliders to balance risk and objectives.</p>
                    <p>See the 'Target Probability Metrics and Recommendation' table below for details.</p>
                `;
            }

            const targetOriginalCdf = document.getElementById('targetprobabilityexplorer-original-cdf-section');
            if (targetOriginalCdf) {
                targetOriginalCdf.innerHTML = `
                    <h4>Original CDF (Cumulative Distribution Function)</h4>
                    <p><strong>Target:</strong> <span style="color: blue;">${targetValue.toFixed(2)}</span> units</p>
                    <p><strong>Original Probability:</strong> <span style="color: blue;">${origProb}</span>%</p>
                    <p><strong>Settings:</strong> Budget Flexibility: <span style="color: blue;">${window.sliderState.budgetFlexibility}</span>% | Schedule Flexibility: <span style="color: blue;">${window.sliderState.scheduleFlexibility}</span>% | Scope Uncertainty: <span style="color: blue;">${window.sliderState.scopeUncertainty}</span>% | Risk Tolerance: <span style="color: blue;">${window.sliderState.riskTolerance}</span>%</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    The Original CDF visualizes the baseline likelihood of achieving your target of <span style="color: blue;">${targetValue.toFixed(2)}</span> units before any adjustments. At this target, there’s a <span style="color: blue;">${origProb}%</span> chance of staying at or below it, based on the initial Monte Carlo simulation. Use this as a reference to understand your project’s starting point without modifications to flexibility or risk settings.</p>
                    <p><strong>Why It’s Useful:</strong> It establishes a clear baseline, helping you compare how adjustments impact your probability of success.</p>
                `;
            }

            const targetOptimizedCdf = document.getElementById('targetprobabilityexplorer-optimized-cdf-section');
            if (targetOptimizedCdf) {
                targetOptimizedCdf.innerHTML = `
                    <h4>Optimized CDF (Cumulative Distribution Function)</h4>
                    <p><strong>Target:</strong> <span style="color: blue;">${targetValue.toFixed(2)}</span> units</p>
                    <p><strong>Adjusted Probability:</strong> <span style="color: blue;">${optProb}</span>%</p>
                    <p><strong>Probability Change:</strong> <span style="color: blue;">${changeDirectionProb}</span> by <span style="color: blue;">${Math.abs(probDifference)}%</span></p>
                    <p><strong>Settings:</strong> Budget Flexibility: <span style="color: blue;">${window.sliderState.budgetFlexibility}</span>% | Schedule Flexibility: <span style="color: blue;">${window.sliderState.scheduleFlexibility}</span>% | Scope Uncertainty: <span style="color: blue;">${window.sliderState.scopeUncertainty}</span>% | Risk Tolerance: <span style="color: blue;">${window.sliderState.riskTolerance}</span>%</p>
                    <p><strong>What It Shows and How to Use It:</strong><br>
                    The Optimized CDF reflects the adjusted likelihood of achieving your target of <span style="color: blue;">${targetValue.toFixed(2)}</span> units after applying your settings. The probability has <span style="color: blue;">${changeDirectionProb}</span> to <span style="color: blue;">${optProb}%</span>, a change of <span style="color: blue;">${Math.abs(probDifference)}%</span>. Adjust the sliders for Budget Flexibility, Schedule Flexibility, Scope Uncertainty, and Risk Tolerance to optimize the probability of meeting your target.</p>
                    <p><strong>Why It’s Useful:</strong> It shows how strategic adjustments improve or alter your chances, guiding decisions to align with project goals.</p>
                `;
            }

            const targetTableBody = document.querySelector('#target-probability-table tbody');
            if (targetTableBody) {
                targetTableBody.innerHTML = `
                    <tr>
                        <td>Target Value</td>
                        <td>${targetValue.toFixed(2)} units</td>
                        <td>Adjust target to balance risk and objectives.</td>
                    </tr>
                    <tr>
                        <td>Original Probability</td>
                        <td>${origProb}%</td>
                        <td>Use as a baseline to compare with adjusted probability.</td>
                    </tr>
                    <tr>
                        <td>Adjusted Probability</td>
                        <td>${optProb}%</td>
                        <td>${probabilityRiskDescriptor}; adjust settings to improve if needed.</td>
                    </tr>
                    <tr>
                        <td>Probability Change</td>
                        <td>${changeDirectionProb} by ${Math.abs(probDifference)}%</td>
                        <td>Increase flexibility to boost probability, or accept more risk.</td>
                    </tr>
                `;
            }
            break;

        default:
            const defaultRecommendation = document.querySelector(`#${contentId} .recommendation-section`);
            if (defaultRecommendation) {
                defaultRecommendation.innerHTML = '<p>Pick a tab to see metrics and tips.</p>';
            }
    }

    console.log(`Summary updated for ${plotType}`);
}

</script>

<!-- SECTION 4: JAVASCRIPT - TRIANGULAR DISTRIBUTION PLOTTING -->
<script type="text/javascript">
    function drawTrianglePlot() {
        triangleData = new google.visualization.DataTable();
        triangleData.addColumn('number', 'X');
        triangleData.addColumn('number', 'Curve');
        triangleData.addColumn('number', 'Selected');
        triangleData.addColumn({ type: 'string', role: 'annotation' });
        triangleData.addColumn({ type: 'string', role: 'annotationText' });
        triangleData.addColumn({ type: 'string', role: 'tooltip' });

        let maxDensity = 0;
        TRIANGLE_POINTS.forEach(point => {
            // Enhanced tooltip with distribution type and skewness
            const tooltip = `Distribution: Triangular Distribution\nSkewness: ${window.originalSkewness.triangle.toFixed(2)}\nValue: ${point.x.toFixed(2)}\nDensity: ${point.y.toFixed(3)}\nConfidence: ${point.confidence}%`;
            triangleData.addRow([point.x, point.y, null, null, null, tooltip]);
            maxDensity = Math.max(maxDensity, point.y);
        });

        triangleOptions = {
            hAxis: { title: 'Value', viewWindow: { min: min - 0.05 * (max - min), max: max + 0.05 * (max - min) }, titleTextStyle: { fontSize: 12 } },
            vAxis: { title: 'Probability Density', minValue: 0, maxValue: maxDensity * 1.2, titleTextStyle: { fontSize: 12 } },
            title: 'Triangular: Start with Estimates',
            titleTextStyle: { fontSize: 14 },
            series: { 0: { lineWidth: 2, color: '#1f77b4' }, 1: { lineWidth: 0, pointSize: 10, color: '#00cc00', pointShape: 'circle' } },
            pointsVisible: true,
            legend: { position: 'none' },
            annotations: { textStyle: { fontSize: 10, color: '#000' }, alwaysOutside: true } // Prevent annotation overlap
        };

        triangleChart = new google.visualization.LineChart(document.getElementById('triangle-div'));
        triangleChart.draw(triangleData, triangleOptions);
        updateTrianglePlot(50); // Initial call with default confidence
    }

    function updateTrianglePlot(value) {
        if (!triangleData || !triangleChart || !TRIANGLE_POINTS || !TRIANGLE_POINTS.length) {
            console.error("triangleData, triangleChart, or TRIANGLE_POINTS is undefined or empty");
            return;
        }

        // Interpolate to find the point for the given confidence value
        const point = interpolatePoint(TRIANGLE_POINTS, value);
        const x = point.x;
        const y = point.y;
        const annot = `${value}%`;
        const tooltip = `Distribution: Triangular Distribution\nSkewness: ${(window.originalSkewness?.triangle || 0).toFixed(2)}\nConfidence: ${value}%\nValue: ${x.toFixed(2)}\nDensity: ${y.toFixed(3)}`;

        // Reset all rows to clear previous annotations
        const rows = triangleData.getNumberOfRows();
        for (let i = 0; i < rows; i++) {
            triangleData.setValue(i, 2, null); // Selected
            triangleData.setValue(i, 3, null); // annotation
            triangleData.setValue(i, 4, null); // annotationText
            const generalTooltip = `Distribution: Triangular Distribution\nSkewness: ${(window.originalSkewness?.triangle || 0).toFixed(2)}\nValue: ${triangleData.getValue(i, 0).toFixed(2)}\nDensity: ${triangleData.getValue(i, 1).toFixed(3)}\nConfidence: ${TRIANGLE_POINTS[i]?.confidence || 'N/A'}%`;
            triangleData.setValue(i, 5, generalTooltip); // tooltip
        }

        // Add a new row for the interpolated point if it doesn't exist
        let existingRowIndex = -1;
        for (let i = 0; i < rows; i++) {
            if (Math.abs(triangleData.getValue(i, 0) - x) < 0.001) {
                existingRowIndex = i;
                break;
            }
        }

        if (existingRowIndex >= 0) {
            // Update existing row
            triangleData.setValue(existingRowIndex, 2, y);      // Selected
            triangleData.setValue(existingRowIndex, 3, annot);  // annotation
            triangleData.setValue(existingRowIndex, 4, annot);  // annotationText
            triangleData.setValue(existingRowIndex, 5, tooltip); // tooltip
        } else {
            // Add new row for the interpolated point
            triangleData.addRow([x, null, y, annot, annot, tooltip]);
            // Sort rows by x to maintain curve integrity
            triangleData.sort([{column: 0}]);
        }

        // Redraw the chart
        triangleChart.draw(triangleData, triangleOptions);
    }
</script>
 
<!-- SECTION 5: JAVASCRIPT - PERT DISTRIBUTION PLOTTING -->
<script type="text/javascript">
    function drawPertPlot() {
        pertData = new google.visualization.DataTable();
        pertData.addColumn('number', 'X');
        pertData.addColumn('number', 'Curve');
        pertData.addColumn('number', 'Selected');
        pertData.addColumn({ type: 'string', role: 'annotation' });
        pertData.addColumn({ type: 'string', role: 'annotationText' });
        pertData.addColumn({ type: 'string', role: 'tooltip' });

        let maxDensity = 0;
        PERT_POINTS.forEach(point => {
            // Enhanced tooltip with distribution type and skewness
            const tooltip = `Distribution: PERT Distribution\nSkewness: ${window.originalSkewness.pert.toFixed(2)}\nValue: ${point.x.toFixed(2)}\nDensity: ${point.y.toFixed(3)}\nConfidence: ${point.confidence}%`;
            pertData.addRow([point.x, point.y, null, null, null, tooltip]);
            maxDensity = Math.max(maxDensity, point.y);
        });

        pertOptions = {
            hAxis: { title: 'Value', viewWindow: { min: min - 0.05 * (max - min), max: max + 0.05 * (max - min) }, titleTextStyle: { fontSize: 12 } },
            vAxis: { title: 'Probability Density', minValue: 0, maxValue: maxDensity * 1.2, titleTextStyle: { fontSize: 12 } },
            title: 'PERT: Structure Estimates',
            titleTextStyle: { fontSize: 14 },
            series: { 0: { lineWidth: 2, color: '#ff7f0e' }, 1: { lineWidth: 0, pointSize: 10, color: '#00cc00', pointShape: 'circle' } },
            pointsVisible: true,
            legend: { position: 'none' },
            annotations: { textStyle: { fontSize: 10, color: '#000' }, alwaysOutside: true }, // Prevent annotation overlap
            curveType: 'function'
        };

        pertChart = new google.visualization.LineChart(document.getElementById('pert-div'));
        pertChart.draw(pertData, pertOptions);
        updatePertPlot(50);
    }

    function updatePertPlot(value) {
        if (!pertData || !pertChart || !PERT_POINTS || !PERT_POINTS.length) {
            console.error("pertData, pertChart, or PERT_POINTS is undefined or empty");
            return;
        }

        // Interpolate to find the point for the given confidence value
        const point = interpolatePoint(PERT_POINTS, value);
        const x = point.x;
        const y = point.y;
        const annot = `${value}%`;
        const tooltip = `Distribution: PERT Distribution\nSkewness: ${(window.originalSkewness?.pert || 0).toFixed(2)}\nConfidence: ${value}%\nValue: ${x.toFixed(2)}\nDensity: ${y.toFixed(3)}`;

        // Reset all rows to clear previous annotations
        const rows = pertData.getNumberOfRows();
        for (let i = 0; i < rows; i++) {
            pertData.setValue(i, 2, null); // Selected
            pertData.setValue(i, 3, null); // annotation
            pertData.setValue(i, 4, null); // annotationText
            const generalTooltip = `Distribution: PERT Distribution\nSkewness: ${(window.originalSkewness?.pert || 0).toFixed(2)}\nValue: ${pertData.getValue(i, 0).toFixed(2)}\nDensity: ${pertData.getValue(i, 1).toFixed(3)}\nConfidence: ${PERT_POINTS[i]?.confidence || 'N/A'}%`;
            pertData.setValue(i, 5, generalTooltip); // tooltip
        }

        // Add a new row for the interpolated point if it doesn't exist
        let existingRowIndex = -1;
        for (let i = 0; i < rows; i++) {
            if (Math.abs(pertData.getValue(i, 0) - x) < 0.001) {
                existingRowIndex = i;
                break;
            }
        }

        if (existingRowIndex >= 0) {
            // Update existing row
            pertData.setValue(existingRowIndex, 2, y);      // Selected
            pertData.setValue(existingRowIndex, 3, annot);  // annotation
            pertData.setValue(existingRowIndex, 4, annot);  // annotationText
            pertData.setValue(existingRowIndex, 5, tooltip); // tooltip
        } else {
            // Add new row for the interpolated point
            pertData.addRow([x, null, y, annot, annot, tooltip]);
            // Sort rows by x to maintain curve integrity
            pertData.sort([{column: 0}]);
        }

        // Redraw the chart
        pertChart.draw(pertData, pertOptions);
    }
</script>

<!-- SECTION 6: JAVASCRIPT - BETA DISTRIBUTION PLOTTING -->
<script type="text/javascript">
    function drawBetaPlot() {
        betaData = new google.visualization.DataTable();
        betaData.addColumn('number', 'X');
        betaData.addColumn('number', 'Curve');
        betaData.addColumn('number', 'Selected');
        betaData.addColumn({ type: 'string', role: 'annotation' });
        betaData.addColumn({ type: 'string', role: 'annotationText' });
        betaData.addColumn({ type: 'string', role: 'tooltip' });

        let maxDensity = 0;
        BETA_POINTS.forEach(point => {
            // Enhanced tooltip with distribution type and skewness
            const tooltip = `Distribution: Beta Distribution\nSkewness: ${window.originalSkewness.beta.toFixed(2)}\nValue: ${point.x.toFixed(2)}\nDensity: ${point.y.toFixed(3)}\nConfidence: ${point.confidence}%`;
            betaData.addRow([point.x, point.y, null, null, null, tooltip]);
            maxDensity = Math.max(maxDensity, point.y);
        });

        betaOptions = {
            hAxis: { title: 'Value', viewWindow: { min: min - 0.05 * (max - min), max: max + 0.05 * (max - min) }, titleTextStyle: { fontSize: 12 } },
            vAxis: { title: 'Probability Density', minValue: 0, maxValue: maxDensity * 1.2, titleTextStyle: { fontSize: 12 } },
            title: 'Beta: Enhance Precision',
            titleTextStyle: { fontSize: 14 },
            series: { 0: { lineWidth: 2, color: '#2ca02c' }, 1: { lineWidth: 0, pointSize: 10, color: '#00cc00', pointShape: 'circle' } },
            pointsVisible: true,
            legend: { position: 'none' },
            annotations: { textStyle: { fontSize: 10, color: '#000' }, alwaysOutside: true }, // Prevent annotation overlap
            curveType: 'function'
        };

        betaChart = new google.visualization.LineChart(document.getElementById('beta-div'));
        betaChart.draw(betaData, betaOptions);
        updateBetaPlot(50);
    }

    function updateBetaPlot(value) {
        if (!betaData || !betaChart || !BETA_POINTS || !BETA_POINTS.length) {
            console.error("betaData, betaChart, or BETA_POINTS is undefined or empty");
            return;
        }

        // Interpolate to find the point for the given confidence value
        const point = interpolatePoint(BETA_POINTS, value);
        const x = point.x;
        const y = point.y;
        const annot = `${value}%`;
        const tooltip = `Distribution: Beta Distribution\nSkewness: ${(window.originalSkewness?.beta || 0).toFixed(2)}\nConfidence: ${value}%\nValue: ${x.toFixed(2)}\nDensity: ${y.toFixed(3)}`;

        // Reset all rows to clear previous annotations
        const rows = betaData.getNumberOfRows();
        for (let i = 0; i < rows; i++) {
            betaData.setValue(i, 2, null); // Selected
            betaData.setValue(i, 3, null); // annotation
            betaData.setValue(i, 4, null); // annotationText
            const generalTooltip = `Distribution: Beta Distribution\nSkewness: ${(window.originalSkewness?.beta || 0).toFixed(2)}\nValue: ${betaData.getValue(i, 0).toFixed(2)}\nDensity: ${betaData.getValue(i, 1).toFixed(3)}\nConfidence: ${BETA_POINTS[i]?.confidence || 'N/A'}%`;
            betaData.setValue(i, 5, generalTooltip); // tooltip
        }

        // Add a new row for the interpolated point if it doesn't exist
        let existingRowIndex = -1;
        for (let i = 0; i < rows; i++) {
            if (Math.abs(betaData.getValue(i, 0) - x) < 0.001) {
                existingRowIndex = i;
                break;
            }
        }

        if (existingRowIndex >= 0) {
            // Update existing row
            betaData.setValue(existingRowIndex, 2, y);      // Selected
            betaData.setValue(existingRowIndex, 3, annot);  // annotation
            betaData.setValue(existingRowIndex, 4, annot);  // annotationText
            betaData.setValue(existingRowIndex, 5, tooltip); // tooltip
        } else {
            // Add new row for the interpolated point
            betaData.addRow([x, null, y, annot, annot, tooltip]);
            // Sort rows by x to maintain curve integrity
            betaData.sort([{column: 0}]);
        }

        // Redraw the chart
        betaChart.draw(betaData, betaOptions);
    }
</script>
 
<!-- SECTION 7: JAVASCRIPT - MONTE CARLO UNSMOOTHED PLOTTING -->
<script type="text/javascript">
    function drawMcBetaUnsmoothedPlot() {
        mcUnsmoothedData = new google.visualization.DataTable();
        mcUnsmoothedData.addColumn('number', 'X');
        mcUnsmoothedData.addColumn('number', 'Curve');
        mcUnsmoothedData.addColumn('number', 'Selected');
        mcUnsmoothedData.addColumn({ type: 'string', role: 'annotation' });
        mcUnsmoothedData.addColumn({ type: 'string', role: 'annotationText' });
        mcUnsmoothedData.addColumn({ type: 'string', role: 'tooltip' });

        let maxDensity = 0;
        MC_UNSMOOTHED_POINTS.forEach(point => {
            // Enhanced tooltip with distribution type and skewness
            const tooltip = `Distribution: Monte Carlo Unsmoothed Distribution\nSkewness: ${window.originalSkewness.mcUnsmoothed.toFixed(2)}\nValue: ${point.x.toFixed(2)}\nDensity: ${point.y.toFixed(3)}\nConfidence: ${point.confidence}%`;
            mcUnsmoothedData.addRow([point.x, point.y, null, null, null, tooltip]);
            maxDensity = Math.max(maxDensity, point.y);
        });

        mcUnsmoothedOptions = {
            hAxis: { title: 'Value', viewWindow: { min: min - 0.05 * (max - min), max: max + 0.05 * (max - min) }, titleTextStyle: { fontSize: 12 } },
            vAxis: { title: 'Probability Density', minValue: 0, maxValue: maxDensity * 1.2, titleTextStyle: { fontSize: 12 } },
            title: 'Monte Carlo On Beta Unsmoothed: Simulate Risks',
            titleTextStyle: { fontSize: 14 },
            series: { 0: { lineWidth: 2, color: '#d62728' }, 1: { lineWidth: 0, pointSize: 10, color: '#00cc00', pointShape: 'circle' } },
            pointsVisible: true,
            legend: { position: 'none' },
            annotations: { textStyle: { fontSize: 10, color: '#000' }, alwaysOutside: true } // Prevent annotation overlap
        };

        mcUnsmoothedChart = new google.visualization.LineChart(document.getElementById('mc-unsmoothed-div'));
        mcUnsmoothedChart.draw(mcUnsmoothedData, mcUnsmoothedOptions);
        updateMcBetaUnsmoothedPlot(50);
    }

    function updateMcBetaUnsmoothedPlot(value) {
        if (!mcUnsmoothedData || !mcUnsmoothedChart || !MC_UNSMOOTHED_POINTS || !MC_UNSMOOTHED_POINTS.length) {
            console.error("mcUnsmoothedData, mcUnsmoothedChart, or MC_UNSMOOTHED_POINTS is undefined or empty");
            return;
        }

        // Interpolate to find the point for the given confidence value
        const point = interpolatePoint(MC_UNSMOOTHED_POINTS, value);
        const x = point.x;
        const y = point.y;
        const annot = `${value}%`;
        const tooltip = `Distribution: Monte Carlo Unsmoothed Distribution\nSkewness: ${(window.originalSkewness?.mcUnsmoothed || 0).toFixed(2)}\nConfidence: ${value}%\nValue: ${x.toFixed(2)}\nDensity: ${y.toFixed(3)}`;

        // Reset all rows to clear previous annotations
        const rows = mcUnsmoothedData.getNumberOfRows();
        for (let i = 0; i < rows; i++) {
            mcUnsmoothedData.setValue(i, 2, null); // Selected
            mcUnsmoothedData.setValue(i, 3, null); // annotation
            mcUnsmoothedData.setValue(i, 4, null); // annotationText
            const generalTooltip = `Distribution: Monte Carlo Unsmoothed Distribution\nSkewness: ${(window.originalSkewness?.mcUnsmoothed || 0).toFixed(2)}\nValue: ${mcUnsmoothedData.getValue(i, 0).toFixed(2)}\nDensity: ${mcUnsmoothedData.getValue(i, 1).toFixed(3)}\nConfidence: ${MC_UNSMOOTHED_POINTS[i]?.confidence || 'N/A'}%`;
            mcUnsmoothedData.setValue(i, 5, generalTooltip); // tooltip
        }

        // Add a new row for the interpolated point if it doesn't exist
        let existingRowIndex = -1;
        for (let i = 0; i < rows; i++) {
            if (Math.abs(mcUnsmoothedData.getValue(i, 0) - x) < 0.001) {
                existingRowIndex = i;
                break;
            }
        }

        if (existingRowIndex >= 0) {
            // Update existing row
            mcUnsmoothedData.setValue(existingRowIndex, 2, y);      // Selected
            mcUnsmoothedData.setValue(existingRowIndex, 3, annot);  // annotation
            mcUnsmoothedData.setValue(existingRowIndex, 4, annot);  // annotationText
            mcUnsmoothedData.setValue(existingRowIndex, 5, tooltip); // tooltip
        } else {
            // Add new row for the interpolated point
            mcUnsmoothedData.addRow([x, null, y, annot, annot, tooltip]);
            // Sort rows by x to maintain curve integrity
            mcUnsmoothedData.sort([{column: 0}]);
        }

        // Redraw the chart
        mcUnsmoothedChart.draw(mcUnsmoothedData, mcUnsmoothedOptions);
    }
</script> 

<!-- SECTION 8: JAVASCRIPT - MONTE CARLO SMOOTHED PLOTTING -->
<script type="text/javascript">

/**
 * Draws the Monte Carlo Smoothed plot using the provided data points.
 * Displays the smoothed probability density curve with an initial confidence marker.
 */
function drawMcBetaSmoothedPlot() {
    mcSmoothedData = new google.visualization.DataTable();
    mcSmoothedData.addColumn('number', 'X');
    mcSmoothedData.addColumn('number', 'Curve');
    mcSmoothedData.addColumn('number', 'Selected');
    mcSmoothedData.addColumn({ type: 'string', role: 'annotation' });
    mcSmoothedData.addColumn({ type: 'string', role: 'annotationText' });
    mcSmoothedData.addColumn({ type: 'string', role: 'tooltip' });

    if (!MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length) {
        const div = document.getElementById('mc-smoothed-div');
        if (div) div.innerHTML = '<p style="color: red; text-align: center;">Error: Smoothed data unavailable.</p>';
        return;
    }

    let maxDensity = 0;
    MC_SMOOTHED_POINTS.forEach(point => {
        // Enhanced tooltip with distribution type and skewness
        const tooltip = `Distribution: Monte Carlo Smoothed Distribution\nSkewness: ${window.originalSkewness.mcSmoothed.toFixed(2)}\nValue: ${point.x.toFixed(2)}\nDensity: ${point.y.toFixed(3)}\nConfidence: ${point.confidence}%`;
        mcSmoothedData.addRow([point.x, point.y, null, null, null, tooltip]);
        maxDensity = Math.max(maxDensity, point.y);
    });

    mcSmoothedOptions = {
        hAxis: {
            title: 'Value',
            viewWindow: { min: min - 0.05 * (max - min), max: max + 0.05 * (max - min) },
            titleTextStyle: { fontSize: 12, fontName: 'Arial' }
        },
        vAxis: {
            title: 'Probability Density',
            minValue: 0,
            maxValue: maxDensity * 1.2,
            titleTextStyle: { fontSize: 12, fontName: 'Arial' }
        },
        title: `Monte Carlo On Beta Smoothed: Stabilize Trends (Skewness: ${window.originalSkewness.mcSmoothed.toFixed(2)})`,
        titleTextStyle: { fontSize: 14, fontName: 'Arial' },
        series: {
            0: { lineWidth: 2, color: '#9467bd', lineDashStyle: [4, 4] },
            1: { lineWidth: 0, pointSize: 10, color: '#00cc00', pointShape: 'circle' }
        },
        pointsVisible: true,
        legend: { position: 'none' },
        annotations: { textStyle: { fontSize: 10, color: '#000' }, alwaysOutside: true }, // Prevent annotation overlap
        curveType: 'function'
    };

    mcSmoothedChart = new google.visualization.LineChart(document.getElementById('mc-smoothed-div'));
    mcSmoothedChart.draw(mcSmoothedData, mcSmoothedOptions);
    updateMcBetaSmoothedPlot(50);
}

function updateMcBetaSmoothedPlot(value) {
    if (!mcSmoothedData || !mcSmoothedChart || !MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length) {
        console.error("mcSmoothedData, mcSmoothedChart, or MC_SMOOTHED_POINTS is undefined:", { mcSmoothedData, mcSmoothedChart, MC_SMOOTHED_POINTS });
        return;
    }

    // Interpolate to find the point for the given confidence value
    const point = interpolatePoint(MC_SMOOTHED_POINTS, value);
    const x = point.x;
    const y = point.y;
    const annot = `${value}%`;
    const tooltip = `Distribution: Monte Carlo Smoothed Distribution\nSkewness: ${(window.originalSkewness?.mcSmoothed || 0).toFixed(2)}\nConfidence: ${value}%\nValue: ${x.toFixed(2)}\nDensity: ${y.toFixed(3)}`;

    // Reset all rows to clear previous annotations
    const rows = mcSmoothedData.getNumberOfRows();
    for (let i = 0; i < rows; i++) {
        mcSmoothedData.setValue(i, 2, null); // Selected
        mcSmoothedData.setValue(i, 3, null); // annotation
        mcSmoothedData.setValue(i, 4, null); // annotationText
        const generalTooltip = `Distribution: Monte Carlo Smoothed Distribution\nSkewness: ${(window.originalSkewness?.mcSmoothed || 0).toFixed(2)}\nValue: ${mcSmoothedData.getValue(i, 0).toFixed(2)}\nDensity: ${mcSmoothedData.getValue(i, 1).toFixed(3)}\nConfidence: ${MC_SMOOTHED_POINTS[i]?.confidence || 'N/A'}%`;
        mcSmoothedData.setValue(i, 5, generalTooltip); // tooltip
    }

    // Add a new row for the interpolated point if it doesn't exist
    let existingRowIndex = -1;
    for (let i = 0; i < rows; i++) {
        if (Math.abs(mcSmoothedData.getValue(i, 0) - x) < 0.001) {
            existingRowIndex = i;
            break;
        }
    }

    if (existingRowIndex >= 0) {
        // Update existing row
        mcSmoothedData.setValue(existingRowIndex, 2, y);      // Selected
        mcSmoothedData.setValue(existingRowIndex, 3, annot);  // annotation
        mcSmoothedData.setValue(existingRowIndex, 4, annot);  // annotationText
        mcSmoothedData.setValue(existingRowIndex, 5, tooltip); // tooltip
    } else {
        // Add new row for the interpolated point
        mcSmoothedData.addRow([x, null, y, annot, annot, tooltip]);
        // Sort rows by x to maintain curve integrity
        mcSmoothedData.sort([{column: 0}]);
    }

    // Redraw the chart
    mcSmoothedChart.draw(mcSmoothedData, mcSmoothedOptions);
}

</script>

 

<!-- Section 9.a.i: CSS Styles -->

<style>

    .slider-container {

        display: flex;

        align-items: center;

        gap: 10px;

        margin: 10px 0;

        flex-wrap: nowrap; /* Prevent wrapping of child elements */

        min-width: 0; /* Allow shrinking to prevent wrapping */

    }

 

    .slider-container input[type="range"] {

        flex-grow: 1;

        width: 100%;

        min-width: 0; /* Prevent slider from forcing wrapping */

    }

 

    .help-icon {

        font-size: 16px;

        color: #4a90e2;

        cursor: help;

        padding: 2px 6px;

        background-color: #f0f0f0;

        border-radius: 50%;

        order: 2; /* Position after slider, before value */

        flex-shrink: 0; /* Prevent the help icon from shrinking */

    }

 

    .dynamic {

        color: #0000FF; /* Blue for dynamic numbers/values */

    }

 

    /* Ensure slider-container remains a row on smaller screens */

    @media (max-width: 768px) {

        .slider-container {

            flex-direction: row; /* Explicitly keep row layout */

            width: 100%; /* Use full width */

            flex-wrap: nowrap; /* Reinforce no wrapping */

        }

 

        .slider-container input[type="range"] {

            width: 100%; /* Ensure slider takes available space */

            min-width: 0; /* Prevent wrapping */

        }

 

        .slider-container label, .slider-container span {

            flex-shrink: 0; /* Prevent label and spans from shrinking */

        }

    }

</style>

 

<!-- Section 9.a.ii: JavaScript Initial Setup -->

<script type="text/javascript">

    // Pre-declare functions globally to avoid undefined errors

    window.drawScenarioCdfPlots = function() {};

    window.updateScenarioCdfPlots = function() {};

    window.drawCdfPlot = function() {};

    window.updateCdfPlot = function() {};

 

    // Define help icon configurations with updated slider IDs

    const helpIconsConfig = {

        'confidence-slider': {

            id: 'confidence-help-icon',

            tooltip: 'Slide to set how sure you want to be about your project estimates (e.g., cost or time ranges).'

        },

        'target-value-slider': { // Updated from 'scenario-value-slider' for consistency

            id: 'target-help-icon',

            tooltip: 'Slide to set your target value (e.g., cost, time). Adjust settings below to boost your chances of hitting it. Expand the report for a full plan.'

        },

        'probability-slider': {

            id: 'probability-help-icon',

            tooltip: 'Slide to see the odds of hitting specific project targets based on smoothed Monte Carlo results.'

        }

    };

 

    function setupHelpIcon(sliderId) {

        const config = helpIconsConfig[sliderId];

        if (!config) return;

 

        const slider = document.getElementById(sliderId);

        if (!slider) return;

 

        let container = slider.parentElement;

        if (!container.classList.contains('slider-container')) {

            container = document.createElement('div');

            container.className = 'slider-container';

            slider.parentElement.insertBefore(container, slider);

            container.appendChild(slider);

            const valueResult = document.getElementById('target-value-result');

            if (valueResult && !container.contains(valueResult)) {

                container.appendChild(valueResult);

            }

        }

 

        let helpIcon = document.getElementById(config.id);

        if (!helpIcon) {

            helpIcon = document.createElement('span');

            helpIcon.id = config.id;

            helpIcon.className = 'help-icon';

            helpIcon.textContent = '?';

            const valueResult = document.getElementById('target-value-result');

            if (valueResult && valueResult.parentElement === container) {

                valueResult.insertAdjacentElement('afterend', helpIcon);

            } else {

                container.appendChild(helpIcon);

            }

        }

        helpIcon.title = config.tooltip;

    }

 

    function resetTabVisibility(activeTabId) {

        const chartContainer = document.getElementById('chart-container');

        const sliderContainer = document.getElementById('slider-container');

        const tableWrapper = document.getElementById('table-wrapper');

        const decisionTable = document.getElementById('decision-table-container');

        const scenarioTargetsContainer = document.getElementById('target-probability-container'); // Updated for consistency

 

        chartContainer.style.display = 'none';

        sliderContainer.style.display = 'none';

        tableWrapper.style.display = 'none';

        decisionTable.style.display = 'none';

        scenarioTargetsContainer.style.display = 'none';

 

        if (activeTabId === 'targetProbabilityExplorer') { // Updated from 'scenarioTargets'

            scenarioTargetsContainer.style.display = 'block';

            console.log('Target Probability Explorer container set to visible');

        } else if (activeTabId === 'optimizedDecisionInsights') {

            decisionTable.style.display = 'block';

        } else {

            chartContainer.style.display = 'block';

            sliderContainer.style.display = 'block';

            tableWrapper.style.display = 'block';

        }

    }

 

    document.addEventListener('DOMContentLoaded', () => {

        Object.keys(helpIconsConfig).forEach(sliderId => setupHelpIcon(sliderId));

        // Defer loading of Scenario plots until DOM is ready

        setTimeout(() => {

            if (typeof drawScenarioCdfPlots === 'function') {

                const activeTab = document.querySelector('.chart-button.active')?.id;

                if (activeTab === 'targetProbabilityExplorer') { // Updated from 'scenarioTargets'

                    drawScenarioCdfPlots();

                }

            } else {

                console.error('drawScenarioCdfPlots still not defined after DOM load');

            }

        }, 1000); // Delay to ensure all scripts are loaded

    });

</script>

 

<!-- SECTION 9.b: CDF Functions - Main Logic -->

 

<!-- Section 9.b.i: CDF Computation -->

<script type="text/javascript">

/**

 * Computes an optimized CDF based on user-defined parameters for the Target Probability Explorer tab.

 * Aligns with the transformation logic used in the Decision Optimizer tab.

 * @param {number} budgetFlex - Budget Flexibility (0 to 1)

 * @param {number} scheduleFlex - Schedule Flexibility (0 to 1)

 * @param {number} scopeUncert - Scope Uncertainty (0 to 1)

 * @param {number} riskTol - Risk Tolerance (0 to 1)

 * @param {number} targetValue - The target value to evaluate

 * @returns {Array} Array of {x, y} objects representing the adjusted CDF

 */

function computeTargetOptimizedCdf(budgetFlex, scheduleFlex, scopeUncert, riskTol, targetValue) {

    const BF = budgetFlex;    // Budget Flexibility (0 to 1)

    const SF = scheduleFlex;  // Schedule Flexibility (0 to 1)

    const SU = scopeUncert;   // Scope Uncertainty (0 to 1)

    const RT = riskTol;       // Risk Tolerance (0 to 1)

 

    let optPoints = JSON.parse(JSON.stringify(MC_SMOOTHED_POINTS));

 

    // Calculate original mean, variance, and standard deviation

    const step = optPoints.length > 1 ? optPoints[1].x - optPoints[0].x : 1;

    const totalWeightOrig = optPoints.reduce((sum, p) => sum + p.y * step, 0);

    const originalMean = totalWeightOrig > 0 ? optPoints.reduce((sum, p) => sum + p.x * p.y * step, 0) / totalWeightOrig : optPoints[0].x;

    const originalVariance = totalWeightOrig > 0 ? optPoints.reduce((sum, p) => sum + p.y * step * Math.pow(p.x - originalMean, 2), 0) / totalWeightOrig : 0;

    const originalStdDev = Math.sqrt(originalVariance);

 

    // Define transformation parameters consistent with Decision Optimizer

    const shiftFactor = 0.2;

    const varianceFactor = 2.0;

    const skewFactorRT = -0.05;

    const skewFactorSU = 0.2;

 

    // Calculate transformation values

    const meanShift = shiftFactor * originalStdDev * (-BF - SF + 0.5 * SU);

    const varianceScale = 1 + varianceFactor * SU;

    const skewAdjustment = skewFactorRT * RT + skewFactorSU * SU;

 

    // Check if all sliders are zero with tolerance

    const tolerance = 0.0001;

    const allZero = Math.abs(BF) < tolerance && Math.abs(SF) < tolerance && Math.abs(SU) < tolerance && Math.abs(RT) < tolerance;

 

    if (allZero) {

        // Return original CDF

        const sortedPoints = optPoints.slice().sort((a, b) => a.x - b.x);

        let cumulative = 0;

        const cdf = [0];

        for (let i = 1; i < sortedPoints.length; i++) {

            const dx = sortedPoints[i].x - sortedPoints[i - 1].x;

            const avgY = (sortedPoints[i - 1].y + sortedPoints[i].y) / 2;

            cumulative += avgY * dx;

            cdf.push(cumulative);

        }

        // Normalize CDF to 1

        const maxCdf = cdf[cdf.length - 1];

        if (maxCdf > 0) {

            cdf.forEach((_, i) => cdf[i] /= maxCdf);

        }

        const cdfPoints = sortedPoints.map((p, i) => ({ x: p.x, y: cdf[i] }));

        // Find median

        let originalMedian;

        for (let i = 0; i < cdfPoints.length; i++) {

            if (cdfPoints[i].y >= 0.5) {

                originalMedian = cdfPoints[i].x;

                break;

            }

        }

        window.lastOptimizedValue = originalMedian ? originalMedian.toFixed(2) : 'N/A';

        // Find probability at target value

        let probAtTarget = 0;

        for (let i = 0; i < cdfPoints.length; i++) {

            if (cdfPoints[i].x >= targetValue) {

                probAtTarget = cdfPoints[i].y * 100;

                break;

            }

        }

        window.lastOptimizedProb = probAtTarget.toFixed(1);

        window.lastOptimizedSkew = window.originalSkewness.mcSmoothed.toFixed(2);

        return cdfPoints;

    }

 

    // Transform points

    const shiftedMean = originalMean + meanShift;

    optPoints.forEach(p => {

        p.x = varianceScale * (p.x - originalMean) + originalMean + meanShift;

        p.y /= varianceScale;

    });

 

    // Apply skew adjustment if RT > 0 or SU > 0

    if (RT > 0 || SU > 0) {

        const skewFactors = optPoints.map(p => Math.exp(skewAdjustment * (p.x - shiftedMean) / originalStdDev));

        optPoints.forEach((p, i) => p.y *= skewFactors[i]);

    }

 

    // Normalize the PDF

    const totalDensityAdjusted = optPoints.reduce((sum, p) => sum + p.y * step, 0);

    if (totalDensityAdjusted > 0) {

        optPoints.forEach(p => p.y /= totalDensityAdjusted);

    }

 

    // Compute CDF using trapezoidal rule

    const sortedPoints = optPoints.slice().sort((a, b) => a.x - b.x);

    let cumulative = 0;

    const cdf = [0];

    for (let i = 1; i < sortedPoints.length; i++) {

        const dx = sortedPoints[i].x - sortedPoints[i - 1].x;

        const avgY = (sortedPoints[i - 1].y + sortedPoints[i].y) / 2;

        cumulative += avgY * dx;

        cdf.push(cumulative);

    }

    // Normalize CDF to 1

    const maxCdf = cdf[cdf.length - 1];

    if (maxCdf > 0) {

        cdf.forEach((_, i) => cdf[i] /= maxCdf);

    }

    const cdfPoints = sortedPoints.map((p, i) => ({ x: p.x, y: cdf[i] }));

 

    // Find optimized median

    let optimizedMedian;

    for (let i = 0; i < cdfPoints.length; i++) {

        if (cdfPoints[i].y >= 0.5) {

            optimizedMedian = cdfPoints[i].x;

            break;

        }

    }

    window.lastOptimizedValue = optimizedMedian ? optimizedMedian.toFixed(2) : 'N/A';

 

    // Find probability at target value

    let probAtTarget = 0;

    for (let i = 0; i < cdfPoints.length; i++) {

        if (cdfPoints[i].x >= targetValue) {

            probAtTarget = cdfPoints[i].y * 100;

            break;

        }

    }

    window.lastOptimizedProb = probAtTarget.toFixed(1);

 

    // Calculate optimized skewness

    const totalWeight = sortedPoints.reduce((sum, p) => sum + p.y * step, 0);

    const optMean = totalWeight > 0 ? sortedPoints.reduce((sum, p) => sum + p.x * p.y * step, 0) / totalWeight : 0;

    const optVariance = totalWeight > 0 ? sortedPoints.reduce((sum, p) => sum + p.y * step * Math.pow(p.x - optMean, 2), 0) / totalWeight : 0;

    const optStdDev = Math.sqrt(optVariance);

    const optThirdMoment = totalWeight > 0 ? sortedPoints.reduce((sum, p) => sum + p.y * step * Math.pow(p.x - optMean, 3), 0) / totalWeight : 0;

    const optSkew = optStdDev > 0 ? optThirdMoment / Math.pow(optStdDev, 3) : 0;

    window.lastOptimizedSkew = optSkew.toFixed(2);

 

    return cdfPoints;

}

 

/**

 * Computes the CDF for the Monte Carlo Smoothed data for the Monte Carlo Trends tab.

 * Uses the trapezoidal rule to integrate the PDF without any optimization transformations.

 * @returns {Array} Array of {x, y} objects representing the CDF

 */

function computeMonteCarloCdf() {

    if (!MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length) {

        console.error('MC_SMOOTHED_POINTS is empty');

        return [];

    }

 

    const sortedPoints = MC_SMOOTHED_POINTS.slice().sort((a, b) => a.x - b.x);

    const step = sortedPoints.length > 1 ? sortedPoints[1].x - sortedPoints[0].x : 1;

    let cumulative = 0;

    const cdf = [0];

 

    for (let i = 1; i < sortedPoints.length; i++) {

        const dx = sortedPoints[i].x - sortedPoints[i - 1].x;

        const avgY = (sortedPoints[i - 1].y + sortedPoints[i].y) / 2;

        cumulative += avgY * dx;

        cdf.push(Math.min(cumulative, 1));

    }

 

    // Normalize CDF to 1 if necessary

    const maxCdf = cdf[cdf.length - 1];

    if (maxCdf > 0 && Math.abs(maxCdf - 1) > 0.001) {

        cdf.forEach((val, i) => cdf[i] /= maxCdf);

    }

 

    return sortedPoints.map((p, i) => ({ x: p.x, y: cdf[i] }));

}

</script>

 

<!-- SECTION 9.b.ii: Analysis Report Generation -->

<script type="text/javascript">

    /**

     * Generates a dynamic HTML string for the Analysis Report based on the provided data.

     * Supports both 'decisionOptimizer' and 'targetProbability' tabs with a unified structure.

     * @param {Object} data - An object containing the necessary data for the report.

     * @param {string} data.tab - The active tab ('decisionOptimizer' or 'targetProbability').

     * @param {number} [data.targetValue] - Target value for Target Probability tab.

     * @param {number} [data.origProb] - Original probability (%) for Target Probability tab.

     * @param {number} [data.optProb] - Optimized probability (%) for Target Probability tab.

     * @param {number} [data.originalMedian] - Original median value.

     * @param {number} [data.optimizedMedian] - Optimized median value.

     * @param {number} [data.newConfidence] - New confidence level (%) for original median in Decision Optimizer tab.

     * @param {number} data.budgetFlex - Budget Flexibility (0 to 1).

     * @param {number} data.scheduleFlex - Schedule Flexibility (0 to 1).

     * @param {number} data.scopeUncert - Scope Uncertainty (0 to 1).

     * @param {number} data.riskTol - Risk Tolerance (0 to 1).

     * @param {number} data.meanShift - Calculated mean shift of the distribution.

     * @param {number} data.varianceScale - Calculated variance scale factor.

     * @param {number} data.skewAdjustment - Calculated skew adjustment factor.

     * @param {number} data.originalMean - Original distribution mean.

     * @param {number} data.originalStdDev - Original distribution standard deviation.

     * @param {number} data.optimizedMean - Optimized distribution mean.

     * @param {number} data.optimizedStdDev - Optimized distribution standard deviation.

     * @returns {string} - HTML string for the report.

     */

    function generateAnalysisReport(data) {

        const {

            tab,

            targetValue,

            origProb,

            optProb,

            originalMedian,

            optimizedMedian,

            newConfidence,

            budgetFlex,

            scheduleFlex,

            scopeUncert,

            riskTol,

            meanShift,

            varianceScale,

            skewAdjustment,

            originalMean,

            originalStdDev,

            optimizedMean,

            optimizedStdDev

        } = data;

 

        let html = `<div class="analysis-report">`;

 

        // Key Concepts Section (Preserved)

        html += `<h4>Key Concepts</h4>`;

        html += `<ul>`;

        html += `<li><strong>Original Distribution</strong>: Median = <span class="dynamic">${originalMedian.toFixed(2)}</span>, Mean = <span class="dynamic">${originalMean.toFixed(2)}</span>, Std Dev = <span class="dynamic">${originalStdDev.toFixed(2)}</span></li>`;

        html += `<li><strong>Optimized Distribution</strong>: Adjusted based on slider inputs.</li>`;

        if (tab === 'decisionOptimizer') {

            html += `<li><strong>Confidence Level</strong>: Probability that the original median lies within the optimized distribution.</li>`;

        } else {

            html += `<li><strong>Probability</strong>: Probability that the target value lies within the distribution.</li>`;

        }

        html += `</ul>`;

 

        // Transformation Formulas Section (Preserved)

        html += `<h4>Transformation Formulas</h4>`;

        html += `<p>The optimized distribution is created using:</p>`;

        html += `<ul>`;

        html += `<li>Mean Shift: <code>meanShift = 0.2 × σ × (-BF - SF + 0.5 × SU) = <span class="dynamic">${meanShift.toFixed(2)}</span></code></li>`;

        html += `<li>Variance Scaling: <code>varianceScale = 1 + 2.0 × SU = <span class="dynamic">${varianceScale.toFixed(2)}</span></code></li>`;

        html += `<li>Skew Adjustment: <code>skewAdjustment = -0.05 × RT + 0.2 × SU = <span class="dynamic">${skewAdjustment.toFixed(2)}</span></code></li>`;

        html += `<li>New Mean: <code>μ_Y = μ + meanShift = <span class="dynamic">${optimizedMean.toFixed(2)}</span></code></li>`;

        html += `<li>New Std Dev: <code>σ_Y = σ × √(varianceScale) = <span class="dynamic">${optimizedStdDev.toFixed(2)}</span></code></li>`;

        html += `</ul>`;

 

        // Probability and Confidence Calculations Section (New)

        html += `<h4>Probability and Confidence Calculations</h4>`;

 

        if (tab === 'decisionOptimizer') {

            // Generic Confidence Equation Subsection

            html += `<h5>Generic Confidence Equation</h5>`;

            html += `<p>The confidence level is calculated assuming a normal distribution for the optimized distribution:</p>`;

            html += `<p><code>P(Y ≤ m) = Φ((m - μ_Y) / σ_Y)</code></p>`;

            html += `<p>Where:</p>`;

            html += `<ul>`;

            html += `<li><code>m</code> = original median = <span class="dynamic">${originalMedian.toFixed(2)}</span></li>`;

            html += `<li><code>μ_Y</code> = optimized mean = <span class="dynamic">${optimizedMean.toFixed(2)}</span></li>`;

            html += `<li><code>σ_Y</code> = optimized standard deviation = <span class="dynamic">${optimizedStdDev.toFixed(2)}</span></li>`;

            html += `</ul>`;

            html += `<p>Resulting in a confidence level of <span class="dynamic">${newConfidence.toFixed(1)}%</span>.</p>`;

 

            // Comparison of Methods Subsection

            html += `<h5>Comparison of Methods</h5>`;

            html += `<p>The <strong>Generic Confidence Equation</strong> is used here because it provides a quick, high-level assessment of how the optimization affects the confidence in the original median, assuming a normal distribution for simplicity.</p>`;

            html += `<p><strong>Strengths</strong>: Fast and straightforward.</p>`;

            html += `<p><strong>Limitations</strong>: Assumes normality, which may not hold for all distributions.</p>`;

            html += `<p><strong>Best For</strong>: High-level confidence assessments.</p>`;

        } else {

            // Trapezoidal CDF Calculation Subsection

            html += `<h5>Trapezoidal CDF Calculation</h5>`;

            html += `<p>The probability is calculated using the trapezoidal rule to approximate the cumulative distribution function (CDF) for both the original and optimized distributions.</p>`;

            html += `<p><strong>Original Probability</strong>: <code>P(X ≤ ${targetValue.toFixed(2)}) = ∑_{i=1}^{k-1} (y_i + y_{i+1}) / 2 × (x_{i+1} - x_i)</code> = <span class="dynamic">${origProb.toFixed(1)}%</span></p>`;

            html += `<p><strong>Optimized Probability</strong>: <code>P(Y ≤ ${targetValue.toFixed(2)}) = ∑_{i=1}^{k-1} (y_i + y_{i+1}) / 2 × (x_{i+1} - x_i)</code> = <span class="dynamic">${optProb.toFixed(1)}%</span></p>`;

            html += `<p>Where <code>k</code> is the index where <code>x_k ≥ ${targetValue.toFixed(2)}</code>.</p>`;

 

            // Comparison of Methods Subsection

            html += `<h5>Comparison of Methods</h5>`;

            html += `<p>The <strong>Trapezoidal CDF Calculation</strong> is used here because it provides an accurate probability for the specific target value by numerically integrating the PDF, which is essential for non-normal distributions.</p>`;

            html += `<p><strong>Strengths</strong>: High accuracy for any distribution shape.</p>`;

            html += `<p><strong>Limitations</strong>: Computationally intensive for large datasets.</p>`;

            html += `<p><strong>Best For</strong>: Precise probability calculations at specific points.</p>`;

        }

 

        // Parameter Settings, Impacts, and Adjustments Section (Preserved)

        html += `<h4>Parameter Settings, Impacts, and Adjustments</h4>`;

        html += `<table style="width: 100%; border-collapse: collapse; font-size: 14px;">`;

        html += `<thead><tr><th>Parameter</th><th>Setting (%)</th><th>Weight</th><th>Impact</th><th>Rationale</th><th>Business Impact</th></tr></thead>`;

        html += `<tbody>`;

        html += `<tr><td>Budget Flexibility</td><td><span class="dynamic">${(budgetFlex * 100).toFixed(0)}%</span></td><td><span class="dynamic">${budgetFlex.toFixed(2)}</span></td><td>Shifts mean by <span class="dynamic">${(0.2 * originalStdDev * -budgetFlex).toFixed(2)}</span></td><td>Reduces cost overrun risks</td><td>Enhances cost predictability</td></tr>`;

        html += `<tr><td>Schedule Flexibility</td><td><span class="dynamic">${(scheduleFlex * 100).toFixed(0)}%</span></td><td><span class="dynamic">${scheduleFlex.toFixed(2)}</span></td><td>Shifts mean by <span class="dynamic">${(0.2 * originalStdDev * -scheduleFlex).toFixed(2)}</span></td><td>Reduces delay risks</td><td>Improves schedule reliability</td></tr>`;

        html += `<tr><td>Scope Uncertainty</td><td><span class="dynamic">${(scopeUncert * 100).toFixed(0)}%</span></td><td><span class="dynamic">${scopeUncert.toFixed(2)}</span></td><td>Scales variance to <span class="dynamic">${(1 + 2.0 * scopeUncert).toFixed(2)}</span></td><td>Accounts for unknowns</td><td>Adjusts for variability</td></tr>`;

        html += `<tr><td>Risk Tolerance</td><td><span class="dynamic">${(riskTol * 100).toFixed(0)}%</span></td><td><span class="dynamic">${riskTol.toFixed(2)}</span></td><td>Adjusts skew by <span class="dynamic">${skewAdjustment.toFixed(2)}</span></td><td>Balances risk acceptance</td><td>Aligns with risk strategy</td></tr>`;

        html += `</tbody></table>`;

 

        html += `</div>`;

 

        return html;

    }

</script>

 

 

<!-- Section 9.b.iii: CDF Plot Drawing -->

<!-- Section 9.b.iii.1: Dynamic Outcome Generation -->

<script type="text/javascript">

/**

 * Generates a dynamic outcome explanation for a slider combination based on its impact on the optimized probability.

 * Used by the Slider Settings Impact Guide in the Target Probability Explorer tab to provide qualitative insights.

 * @param {number} bf - Budget Flexibility (0 to 1)

 * @param {number} sf - Schedule Flexibility (0 to 1)

 * @param {number} su - Scope Uncertainty (0 to 1)

 * @param {number} rt - Risk Tolerance (0 to 1)

 * @param {number} origProb - Original probability (%) at the target value

 * @param {number} optProb - Optimized probability (%) at the target value

 * @param {number} targetValue - The target value (e.g., cost or time)

 * @param {number} originalMean - Original distribution mean

 * @param {number} originalStdDev - Original distribution standard deviation

 * @returns {string} - A qualitative explanation of the outcome

 */

function generateDynamicOutcome(bf, sf, su, rt, origProb, optProb, targetValue, originalMean, originalStdDev) {

    // Handle special case: all sliders at zero

    if (bf === 0 && sf === 0 && su === 0 && rt === 0) {

        return `Opt Prob equals Orig Prob (${optProb.toFixed(1)}%). No adjustments are applied when all sliders are at 0%, so the distribution remains unchanged.`;

    }

 

    // Calculate transformation parameters

    const meanShift = 0.2 * originalStdDev * (-bf - sf + 0.5 * su);

    const varianceScale = 1 + 2.0 * su;

    const skewAdjustment = -0.05 * rt + 0.2 * su;

    const probChange = optProb - origProb;

 

    // Determine target position relative to mean

    const isBelowMean = targetValue < originalMean - 0.5 * originalStdDev;

    const isNearMean = Math.abs(targetValue - originalMean) <= 0.5 * originalStdDev;

    const targetPosition = isBelowMean ? 'below' : isNearMean ? 'near' : 'above';

 

    // Initialize outcome

    let outcome = `Opt Prob ${probChange > 0 ? 'increases' : probChange < 0 ? 'decreases' : 'remains similar'} by ${Math.abs(probChange).toFixed(1)}% to ${optProb.toFixed(1)}% compared to Orig Prob (${origProb.toFixed(1)}%). `;

 

    // Analyze mean shift

    const totalShift = -bf - sf + 0.5 * su;

    if (totalShift < -0.5) {

        outcome += `High ${bf > 0.5 ? 'Budget' : ''}${bf > 0.5 && sf > 0.5 ? ' and ' : ''}${sf > 0.5 ? 'Schedule' : ''} Flexibility shift${bf > 0.5 && sf > 0.5 ? '' : 's'} the distribution toward lower values, boosting probability for targets ${targetPosition} the mean. `;

    } else if (totalShift > 0.5) {

        outcome += `Low flexibility and high Scope Uncertainty shift the distribution toward higher values, reducing probability for targets ${targetPosition} the mean. `;

    } else {

        outcome += `Balanced flexibility settings result in a moderate shift, with minimal impact on probability unless adjusted further. `;

    }

 

    // Analyze variance

    if (su > 0.5) {

        outcome += `High Scope Uncertainty (${(su * 100).toFixed(0)}%) increases variability, spreading probability and potentially ${isNearMean ? 'reducing' : 'adjusting'} it ${targetPosition} the mean. `;

    } else if (su < 0.3) {

        outcome += `Low Scope Uncertainty (${(su * 100).toFixed(0)}%) reduces variability, concentrating probability and potentially ${isNearMean ? 'increasing' : 'stabilizing'} it ${targetPosition} the mean. `;

    }

 

    // Analyze skew

    if (rt > 0.5) {

        outcome += `High Risk Tolerance (${(rt * 100).toFixed(0)}%) favors riskier outcomes, ${isBelowMean ? 'reducing' : 'enhancing'} probability for targets ${targetPosition} the mean. `;

    } else if (rt < 0.3) {

        outcome += `Low Risk Tolerance (${(rt * 100).toFixed(0)}%) favors safer outcomes, ${isBelowMean ? 'enhancing' : 'reducing'} probability for targets ${targetPosition} the mean. `;

    }

 

    // Add scenario summary

    const sliders = [

        { name: 'BF', value: bf },

        { name: 'SF', value: sf },

        { name: 'SU', value: su },

        { name: 'RT', value: rt }

    ];

    sliders.sort((a, b) => a.value - b.value);

    let summary = '';

    let currentGroup = [sliders[0].name];

    let currentValue = sliders[0].value;

    for (let i = 1; i < sliders.length; i++) {

        if (sliders[i].value === currentValue) {

            currentGroup.push(sliders[i].name);

        } else {

            summary += currentGroup.join(' = ');

            summary += sliders[i].value > currentValue ? ' < ' : ' > ';

            currentGroup = [sliders[i].name];

            currentValue = sliders[i].value;

        }

    }

    summary += currentGroup.join(' = ');

    outcome += `The configuration ${summary} balances these effects, tailoring the probability to your settings.`;

 

    return outcome;

}

</script>

 

<!-- Section 9.b.iii.2: Target Probability Explorer CDF Plotting -->
<script type="text/javascript">
/**
 * Draws CDF plots and populates related tables and report for the Target Probability Explorer tab.
 * Displays both original and optimized CDFs based on slider inputs.
 */
window.drawScenarioCdfPlots = function() {
    try {
        console.log('Drawing Target Probability Explorer CDF Plots');
        console.log('MC_SMOOTHED_POINTS:', MC_SMOOTHED_POINTS);
        console.log('CDF_POINTS:', CDF_POINTS);

        // Verify chart containers exist
        const origDiv = document.getElementById('original-cdf-chart');
        const optDiv = document.getElementById('optimized-cdf-chart');
        if (!origDiv || !optDiv) {
            console.error('Chart divs not found:', { origDiv, optDiv });
            if (origDiv) origDiv.innerHTML = '<p style="color: red; text-align: center;">Error: Chart div not found.</p>';
            if (optDiv) optDiv.innerHTML = '<p style="color: red; text-align: center;">Error: Chart div not found.</p>';
            return;
        }

        // Check if the container is visible
        const container = document.getElementById('target-probability-container');
        if (container && window.getComputedStyle(container).display === 'none') {
            console.warn('Target Probability Explorer container is not visible; chart may not render');
            return;
        }

        // Ensure initialization is complete
        if (!isInitialized) {
            console.log('Not initialized yet, waiting for initialization');
            origDiv.innerHTML = '<p style="color: #666; text-align: center;">Loading data, please wait...</p>';
            optDiv.innerHTML = '<p style="color: #666; text-align: center;">Loading data, please wait...</p>';
            return;
        }

        // Validate data availability
        if (!MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length || !CDF_POINTS || !CDF_POINTS.length) {
            origDiv.innerHTML = '<p style="color: red; text-align: center;">Error: Original data unavailable.</p>';
            optDiv.innerHTML = '<p style="color: red; text-align: center;">Error: Optimized data unavailable.</p>';
            return;
        }

        // Clear existing charts if they exist
        if (window.origChart) window.origChart.clearChart();
        if (window.optChart) window.optChart.clearChart();

        // Prepare original CDF data from API
        const origPoints = JSON.parse(JSON.stringify(CDF_POINTS)).sort((a, b) => a.x - b.x);
        const originalMean = mcSmoothedMean;
        const originalStdDev = mcSmoothedStdDev;

        // Calculate original median
        let originalMedian;
        for (let i = 0; i < origPoints.length; i++) {
            if (origPoints[i].y >= 0.5) {
                originalMedian = origPoints[i].x;
                break;
            }
        }
        originalMedian = originalMedian || origPoints[origPoints.length - 1].x;

        // Set up data table for original CDF
        const originalCdfData = new google.visualization.DataTable();
        originalCdfData.addColumn('number', 'X');
        originalCdfData.addColumn('number', 'Original CDF');
        originalCdfData.addColumn('number', 'Selected');
        originalCdfData.addColumn({ type: 'string', role: 'annotation' });
        originalCdfData.addColumn({ type: 'string', role: 'tooltip' });

        // Add original CDF points and find probability at target value
        const targetValue = parseFloat(document.getElementById('target-value-slider')?.value) || originalMedian;
        let origSelectedX = targetValue;
        let origSelectedProb = 0;
        let closestIndex = -1;
        let minDiff = Infinity;

        origPoints.forEach((point, i) => {
            originalCdfData.addRow([point.x, point.y, null, null, `Original CDF (Monte Carlo Smoothed)\nValue: ${point.x.toFixed(2)}\nCumulative Probability: ${(point.y * 100).toFixed(1)}%`]);
            const diff = Math.abs(point.x - targetValue);
            if (diff < minDiff) {
                minDiff = diff;
                closestIndex = i;
                origSelectedX = point.x;
                origSelectedProb = point.y * 100;
            }
        });

        // Adjust original CDF point based on snapping preference
        if (!useSnapping) {
            let lowerX = null, upperX = null, lowerProb = null, upperProb = null;
            for (let i = 0; i < origPoints.length - 1; i++) {
                if (origPoints[i].x <= targetValue && origPoints[i + 1].x >= targetValue) {
                    lowerX = origPoints[i].x;
                    upperX = origPoints[i + 1].x;
                    lowerProb = origPoints[i].y * 100;
                    upperProb = origPoints[i + 1].y * 100;
                    break;
                }
            }
            if (lowerX !== null && upperX !== null) {
                const fraction = (targetValue - lowerX) / (upperX - lowerX);
                origSelectedProb = lowerProb + fraction * (upperProb - lowerProb);
                origSelectedX = targetValue;
                originalCdfData.addRow([origSelectedX, origSelectedProb / 100, origSelectedProb / 100, `${origSelectedX.toFixed(2)}: ${origSelectedProb.toFixed(1)}%`, `Original CDF (Monte Carlo Smoothed)\nValue: ${origSelectedX.toFixed(2)}\nCumulative Probability: ${origSelectedProb.toFixed(1)}%`]);
                originalCdfData.sort([{column: 0}]);
            } else if (closestIndex !== -1) {
                origSelectedX = origPoints[closestIndex].x;
                origSelectedProb = origPoints[closestIndex].y * 100;
                originalCdfData.setValue(closestIndex, 2, origSelectedProb / 100);
                originalCdfData.setValue(closestIndex, 3, `${origSelectedX.toFixed(2)}: ${origSelectedProb.toFixed(1)}%`);
                originalCdfData.setValue(closestIndex, 4, `Original CDF (Monte Carlo Smoothed)\nValue: ${origSelectedX.toFixed(2)}\nCumulative Probability: ${origSelectedProb.toFixed(1)}%`);
            }
        } else if (closestIndex !== -1) {
            origSelectedX = origPoints[closestIndex].x;
            origSelectedProb = origPoints[closestIndex].y * 100;
            originalCdfData.setValue(closestIndex, 2, origSelectedProb / 100);
            originalCdfData.setValue(closestIndex, 3, `${origSelectedX.toFixed(2)}: ${origSelectedProb.toFixed(1)}%`);
            originalCdfData.setValue(closestIndex, 4, `Original CDF (Monte Carlo Smoothed)\nValue: ${origSelectedX.toFixed(2)}\nCumulative Probability: ${origSelectedProb.toFixed(1)}%`);
        }

        // Retrieve slider values (normalized to 0-1)
        const budgetFlex = parseFloat(window.sliderState.budgetFlexibility) / 100;
        const scheduleFlex = parseFloat(window.sliderState.scheduleFlexibility) / 100;
        const scopeUncert = parseFloat(window.sliderState.scopeUncertainty) / 100;
        const riskTol = parseFloat(window.sliderState.riskTolerance) / 100;
        console.log('Slider values:', { budgetFlex, scheduleFlex, scopeUncert, riskTol });

        // Define transformation factors
        const shiftFactor = 0.2;
        const varianceFactor = 2.0;
        const skewFactorRT = -0.05;
        const skewFactorSU = 0.2;

        // Calculate transformation parameters
        const meanShift = shiftFactor * originalStdDev * (-budgetFlex - scheduleFlex + 0.5 * scopeUncert);
        const varianceScale = 1 + varianceFactor * scopeUncert;
        const skewAdjustment = skewFactorRT * riskTol + skewFactorSU * scopeUncert;

        // Calculate optimized mean and standard deviation
        const optimizedMean = originalMean + meanShift;
        const optimizedStdDev = originalStdDev * Math.sqrt(varianceScale);

        // Generate optimized CDF based on slider inputs
        const optCdf = computeTargetOptimizedCdf(budgetFlex, scheduleFlex, scopeUncert, riskTol, targetValue);

        // Set up data table for optimized CDF
        const optimizedCdfData = new google.visualization.DataTable();
        optimizedCdfData.addColumn('number', 'X');
        optimizedCdfData.addColumn('number', 'Optimized CDF');
        optimizedCdfData.addColumn('number', 'Selected');
        optimizedCdfData.addColumn({ type: 'string', role: 'annotation' });
        optimizedCdfData.addColumn({ type: 'string', role: 'tooltip' });

        // Calculate optimized CDF and find probability at target value
        let optSelectedX = targetValue;
        let optSelectedProb = 0;
        let optClosestIndex = -1;
        let optMinDiff = Infinity;

        optCdf.forEach((point, i) => {
            optimizedCdfData.addRow([point.x, point.y, null, null, `Optimized CDF (Current Settings)\nValue: ${point.x.toFixed(2)}\nCumulative Probability: ${(point.y * 100).toFixed(1)}%`]);
            const diff = Math.abs(point.x - targetValue);
            if (diff < optMinDiff) {
                optMinDiff = diff;
                optClosestIndex = i;
                optSelectedX = point.x;
                optSelectedProb = point.y * 100;
            }
        });

        // Adjust optimized CDF point based on snapping preference or special case
        const allZero = budgetFlex === 0 && scheduleFlex === 0 && scopeUncert === 0 && riskTol === 0;
        if (allZero) {
            optSelectedProb = origSelectedProb;
            window.lastOptimizedProb = origSelectedProb.toFixed(1);
        } else if (!useSnapping) {
            let lowerX = null, upperX = null, lowerProb = null, upperProb = null;
            for (let i = 0; i < optCdf.length - 1; i++) {
                if (optCdf[i].x <= targetValue && optCdf[i + 1].x >= targetValue) {
                    lowerX = optCdf[i].x;
                    upperX = optCdf[i + 1].x;
                    lowerProb = optCdf[i].y * 100;
                    upperProb = optCdf[i + 1].y * 100;
                    break;
                }
            }
            if (lowerX !== null && upperX !== null) {
                const fraction = (targetValue - lowerX) / (upperX - lowerX);
                optSelectedProb = lowerProb + fraction * (upperProb - lowerProb);
                optSelectedX = targetValue;
                optimizedCdfData.addRow([optSelectedX, optSelectedProb / 100, optSelectedProb / 100, `${optSelectedX.toFixed(2)}: ${optSelectedProb.toFixed(1)}%`, `Optimized CDF (Current Settings)\nValue: ${optSelectedX.toFixed(2)}\nCumulative Probability: ${optSelectedProb.toFixed(1)}%`]);
                optimizedCdfData.sort([{column: 0}]);
            } else if (optClosestIndex !== -1) {
                optSelectedX = optCdf[optClosestIndex].x;
                optSelectedProb = optCdf[optClosestIndex].y * 100;
                optimizedCdfData.setValue(optClosestIndex, 2, optSelectedProb / 100);
                optimizedCdfData.setValue(optClosestIndex, 3, `${optSelectedX.toFixed(2)}: ${optSelectedProb.toFixed(1)}%`);
                optimizedCdfData.setValue(optClosestIndex, 4, `Optimized CDF (Current Settings)\nValue: ${optSelectedX.toFixed(2)}\nCumulative Probability: ${optSelectedProb.toFixed(1)}%`);
            }
        } else if (optClosestIndex !== -1) {
            optSelectedX = optCdf[optClosestIndex].x;
            optSelectedProb = optCdf[optClosestIndex].y * 100;
            optimizedCdfData.setValue(optClosestIndex, 2, optSelectedProb / 100);
            optimizedCdfData.setValue(optClosestIndex, 3, `${optSelectedX.toFixed(2)}: ${optSelectedProb.toFixed(1)}%`);
            optimizedCdfData.setValue(optClosestIndex, 4, `Optimized CDF (Current Settings)\nValue: ${optSelectedX.toFixed(2)}\nCumulative Probability: ${optSelectedProb.toFixed(1)}%`);
        }

        // Note: Chart rendering and table population would follow here, but are not included in this section
    } catch (error) {
        console.error('Error in drawScenarioCdfPlots:', error);
        const origDiv = document.getElementById('original-cdf-chart');
        const optDiv = document.getElementById('optimized-cdf-chart');
        if (origDiv) origDiv.innerHTML = '<p style="color: red; text-align: center;">Error rendering chart.</p>';
        if (optDiv) optDiv.innerHTML = '<p style="color: red; text-align: center;">Error rendering chart.</p>';
    }
};
</script>

 

<!-- Section 9.b.iii.3: Monte Carlo Trends CDF Plotting -->

<script type="text/javascript">

/**

 * Draws the CDF plot for the Monte Carlo Trends tab.

 * Renders a single CDF curve with an interactive point based on the probability slider.

 * No updates required for this function as per the current requirements.

 */

window.drawCdfPlot = function() {

    const cdfDiv = document.getElementById('cdf-div');

    if (!cdfDiv) {

        console.error('CDF div not found');

        return;

    }

 

    const cdfPoints = computeMonteCarloCdf();

    if (!cdfPoints.length) {

        cdfDiv.innerHTML = '<p style="color: red; text-align: center;">Error: CDF data unavailable.</p>';

        return;

    }

 

    const data = new google.visualization.DataTable();

    data.addColumn('number', 'X');

    data.addColumn('number', 'CDF');

    data.addColumn('number', 'Selected');

    data.addColumn({ type: 'string', role: 'annotation' });

    data.addColumn({ type: 'string', role: 'tooltip' });

 

    const slider = document.getElementById('probability-slider');

    const sliderValue = slider ? parseFloat(slider.value) : cdfPoints[Math.floor(cdfPoints.length / 2)].x;

 

    let closestIndex = 0;

    let minDiff = Infinity;

    cdfPoints.forEach((point, i) => {

        const diff = Math.abs(point.x - sliderValue);

        if (diff < minDiff) {

            minDiff = diff;

            closestIndex = i;

        }

        data.addRow([point.x, point.y, null, null, `Value: ${point.x.toFixed(2)}\nCumulative Probability: ${(point.y * 100).toFixed(1)}%`]);

    });

 

    const selectedX = cdfPoints[closestIndex].x;

    const selectedProb = cdfPoints[closestIndex].y * 100;

    data.setValue(closestIndex, 2, cdfPoints[closestIndex].y);

    data.setValue(closestIndex, 3, `${selectedX.toFixed(2)}: ${selectedProb.toFixed(1)}%`);

    data.setValue(closestIndex, 4, `Selected Value: ${selectedX.toFixed(2)}\nCumulative Probability: ${selectedProb.toFixed(1)}%`);

 

    const resultSpan = document.getElementById('probability-result');

    if (resultSpan) {

        resultSpan.textContent = `${selectedX.toFixed(2)}: ${selectedProb.toFixed(1)}%`;

    }

 

    const options = {

        title: 'Cumulative Distribution Function',

        hAxis: {

            title: 'Value',

            viewWindow: { min: min - 0.05 * (max - min), max: max + 0.05 * (max - min) },

            titleTextStyle: { fontSize: 12 }

        },

        vAxis: {

            title: 'Cumulative Probability',

            minValue: 0,

            maxValue: 1.1,

            titleTextStyle: { fontSize: 12 }

        },

        series: {

            0: { lineWidth: 2, color: '#ff7f0e' },

            1: { lineWidth: 0, pointSize: 10, color: '#00cc00', pointShape: 'circle' }

        },

        legend: { position: 'none' },

        annotations: { textStyle: { fontSize: 10, color: '#000' }, alwaysOutside: true },

        curveType: 'function'

    };

 

    const chart = new google.visualization.LineChart(cdfDiv);

    chart.draw(data, options);

 

    if (slider && !slider.hasListener) {

        slider.addEventListener('input', () => window.drawCdfPlot());

        slider.hasListener = true;

    }

};

</script>

 

<!-- SECTION 10.a: UI ELEMENT VISIBILITY AND DEPENDENCY CHECKS -->

<script type="text/javascript">

    /**

     * Displays the decision table and initiates recommendation generation.

     * Also populates the Slider Impact and Reference Guide for the Decision Optimizer tab.

     * @param {boolean} updateOnly - If true, updates content without changing container visibility.

     * @param {number} confidence - Optional confidence level for recommendation; defaults to calculated value.

     */

    function showDecisionTable(updateOnly = false, confidence = null) {

        console.log('showDecisionTable called with updateOnly:', updateOnly, 'confidence:', confidence);

        

        // Get the decision table container

        let container = document.getElementById('decision-table-container');

        if (!container) {

            console.error('Decision table container not found');

            return;

        }

        // Show the container unless updateOnly is true

        if (!updateOnly) {

            container.style.display = 'block';

            console.log('Set decision-table-container to display: block');

        }

 

        // Ensure the decision use case element is visible

        const decisionUseCase = document.getElementById('decision-use-case');

        if (decisionUseCase) {

            decisionUseCase.style.display = 'block';

            console.log('Set decision-use-case to display: block');

        } else {

            console.warn('decision-use-case not found');

        }

 

        // Ensure the plot wrapper is visible

        const plotWrapper = document.getElementById('decision-plot-wrapper');

        if (plotWrapper) {

            plotWrapper.style.display = 'block';

            console.log('Set decision-plot-wrapper to display: block');

        } else {

            console.warn('decision-plot-wrapper not found');

        }

 

        // Verify Google Charts library is loaded

        if (!google.visualization || !google.visualization.LineChart) {

            console.error('Google Charts not loaded yet');

            container.innerHTML = '<p style="color: red; text-align: center;">Error: Chart library not loaded. Please refresh.</p>';

            return;

        }

 

        // Get the recommendation output div

        const outputDiv = document.getElementById('recommendation-output');

        if (!outputDiv) {

            console.error('Recommendation output div not found');

            return;

        }

 

        // Check for Monte Carlo data availability

        if (!MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length) {

            console.error('MC_SMOOTHED_POINTS is missing or empty');

            outputDiv.innerHTML = '<p style="color: red; text-align: center;">Error: Plot data unavailable.</p>';

            return;

        }

 

        // Determine the confidence level to use

        const optimalConfidence = confidence || calculateOptimalConfidence(MC_SMOOTHED_POINTS);

        window.lastOptimizedConfidence = optimalConfidence;

        console.log('Optimal confidence set to:', optimalConfidence);

 

        // Initialize window.sliderState if undefined

        if (!window.sliderState) {

            window.sliderState = {

                budgetFlexibility: 50,

                scheduleFlexibility: 50,

                scopeUncertainty: 50,

                riskTolerance: 50

            };

            console.log('Initialized window.sliderState with defaults:', window.sliderState);

        }

 

        // Ensure slider state is updated before populating the table

        restoreSliders();  // This updates window.sliderState with current slider positions

        console.log('Sliders restored, window.sliderState:', window.sliderState);

 

        // Set the filter dropdown to "Current Selection" and trigger table population

        const filterDropdown = document.getElementById('decision-median-filter');

        if (filterDropdown) {

            filterDropdown.value = 'current';

            console.log('Set decision-median-filter to "current"');

            // Remove the redundant event dispatch and directly call the function

            populateDecisionCombinationTable();

            console.log('Explicitly called populateDecisionCombinationTable');

        } else {

            console.warn('decision-median-filter not found');

        }

 

        // Generate the recommendation and draw the plot

        try {

            generateRecommendation(outputDiv, optimalConfidence);

            console.log('generateRecommendation called successfully');

        } catch (e) {

            console.error('Error in generateRecommendation:', e.message);

            outputDiv.innerHTML = '<p style="color: red; text-align: center;">Error generating recommendation.</p>';

        }

 

        // Populate the Slider Impact and Reference Guide content

        try {

            populateDecisionParameterCards();

            console.log('Populated parameter cards');

        } catch (e) {

            console.error('Error populating Slider Impact and Reference Guide:', e.message);

        }

 

        // Removed the call to updatePlotVisibility to prevent the error

        console.log('Decision table rendered successfully');

    }

</script>

 

<!-- SECTION 10.b: DATA VALIDATION AND SLIDER INPUT RETRIEVAL -->

<!-- SECTION 10.b: DATA VALIDATION AND SLIDER INPUT RETRIEVAL -->

<script type="text/javascript">

    /**
     * Generates an optimized recommendation using belief factors from sliders and Monte Carlo data.
     * Populates the Analysis Report for the Decision Optimizer tab.
     * @param {HTMLElement} outputDiv - The div where the recommendation will be displayed.
     * @param {number} confidence - Confidence level for the recommendation (default: 50).
     */
    function generateRecommendation(outputDiv, confidence = 50) {
        console.log('generateRecommendation called with confidence:', confidence);
        
        // Validate Monte Carlo data
        if (!MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length) {
            console.error('MC_SMOOTHED_POINTS is missing or empty');
            outputDiv.innerHTML = '<p style="color: red; text-align: center;">Error: Recommendation data unavailable.</p>';
            return;
        }

        // Retrieve slider values and normalize to 0-1 scale
        const BF = parseFloat(window.sliderState.budgetFlexibility) / 100;    // Budget Flexibility
        const SF = parseFloat(window.sliderState.scheduleFlexibility) / 100;  // Schedule Flexibility
        const SU = parseFloat(window.sliderState.scopeUncertainty) / 100;     // Scope Uncertainty
        const RT = parseFloat(window.sliderState.riskTolerance) / 100;        // Risk Tolerance
        console.log("Slider Values for generateRecommendation:", { BF, SF, SU, RT });

        // Check if all sliders are effectively zero
        const tolerance = 0.0001;
        const allZero = Math.abs(BF) < tolerance && Math.abs(SF) < tolerance && Math.abs(SU) < tolerance && Math.abs(RT) < tolerance;

        // Sort Monte Carlo points by x-value and calculate step size
        const sortedPoints = MC_SMOOTHED_POINTS.slice().sort((a, b) => a.x - b.x);
        const step = sortedPoints.length > 1 ? sortedPoints[1].x - sortedPoints[0].x : 1;

        // Use API-provided mean and standard deviation instead of recalculating
        const originalMean = mcSmoothedMean; // Assumed to be set from API (e.g., MC_SMOOTHED_MEAN) during initialization
        const originalStdDev = mcSmoothedStdDev; // Assumed to be set from API (e.g., MC_SMOOTHED_STD) during initialization

        // Calculate original median (50th percentile) - still computed client-side as it’s not directly provided
        let cumulative = 0;
        let originalMedian;
        for (let i = 0; i < sortedPoints.length; i++) {
            if (cumulative >= 0.5) {
                originalMedian = sortedPoints[i].x;
                break;
            }
            if (i < sortedPoints.length - 1) {
                const dx = sortedPoints[i + 1].x - sortedPoints[i].x;
                const avgY = (sortedPoints[i].y + sortedPoints[i + 1].y) / 2;
                cumulative += avgY * dx;
            }
        }
        originalMedian = originalMedian || sortedPoints[sortedPoints.length - 1].x;
        window.decisionOptimizerOrigMedian = originalMedian;

        // Define transformation parameters for slider impacts
        const shiftFactor = 0.2;
        const varianceFactor = 2.0;
        const skewFactorRT = -0.05;
        const skewFactorSU = 0.2;

        // Calculate transformation values based on sliders
        const meanShift = shiftFactor * originalStdDev * (-BF - SF + 0.5 * SU);
        const varianceScale = 1 + varianceFactor * SU;
        const skewAdjustment = skewFactorRT * RT + skewFactorSU * SU;

        // Apply transformations unless all sliders are zero
        let adjustedPoints;
        if (allZero) {
            adjustedPoints = sortedPoints.map(p => ({ x: p.x, y: p.y }));
        } else {
            const shiftedMean = originalMean + meanShift;
            adjustedPoints = sortedPoints.map(p => ({
                x: varianceScale * (p.x - originalMean) + originalMean + meanShift,
                y: p.y / varianceScale
            }));

            // Apply skew if risk tolerance or scope uncertainty is non-zero
            if (RT > 0 || SU > 0) {
                const skewFactors = adjustedPoints.map(p => Math.exp(skewAdjustment * (p.x - shiftedMean) / originalStdDev));
                adjustedPoints.forEach((p, i) => p.y *= skewFactors[i]);
            }

            // Normalize adjusted distribution
            const totalDensityAdjusted = adjustedPoints.reduce((sum, p) => sum + p.y * step, 0);
            if (totalDensityAdjusted > 0) {
                adjustedPoints.forEach(p => p.y /= totalDensityAdjusted);
            }
        }

        // Calculate optimized mean and standard deviation
        const optimizedMean = adjustedPoints.reduce((sum, p) => sum + p.x * p.y * step, 0);
        const optimizedVariance = adjustedPoints.reduce((sum, p) => sum + p.y * step * Math.pow(p.x - optimizedMean, 2), 0);
        const optimizedStdDev = Math.sqrt(optimizedVariance);

        // Calculate optimized median using computeOptimizedMedian for consistency
        const optimizedMedian = computeOptimizedMedian(BF, SF, SU, RT);
        window.lastOptimizedValue = optimizedMedian.toFixed(2);

        // Compute CDF for confidence level
        const sortedAdjustedPoints = adjustedPoints.slice().sort((a, b) => a.x - b.x);
        const cdf = [0];
        let maxCdf = 0;
        for (let i = 1; i < sortedAdjustedPoints.length; i++) {
            const dx = sortedAdjustedPoints[i].x - sortedAdjustedPoints[i - 1].x;
            const avgY = (sortedAdjustedPoints[i - 1].y + sortedAdjustedPoints[i].y) / 2;
            cdf[i] = cdf[i - 1] + avgY * dx;
            maxCdf = Math.max(maxCdf, cdf[i]);
        }
        if (maxCdf > 0) {
            cdf.forEach((_, i) => cdf[i] /= maxCdf);
        }

        // Calculate new confidence level for original median
        let newConfidence;
        if (allZero) {
            newConfidence = 50;
        } else if (originalMedian <= sortedAdjustedPoints[0].x) {
            newConfidence = 0;
        } else if (originalMedian >= sortedAdjustedPoints[sortedAdjustedPoints.length - 1].x) {
            newConfidence = 100;
        } else {
            let i;
            for (i = 0; i < sortedAdjustedPoints.length - 1; i++) {
                if (sortedAdjustedPoints[i].x <= originalMedian && originalMedian < sortedAdjustedPoints[i + 1].x) break;
            }
            const x0 = sortedAdjustedPoints[i].x;
            const x1 = sortedAdjustedPoints[i + 1].x;
            const cdf0 = cdf[i];
            const cdf1 = cdf[i + 1];
            const fraction = (originalMedian - x0) / (x1 - x0);
            newConfidence = Math.min(100, Math.max(0, (cdf0 + fraction * (cdf1 - cdf0)) * 100));
        }
        window.decisionOptimizerNewConfidence = newConfidence.toFixed(1);

        // Update dynamic annotation display
        const annotationDisplay = document.getElementById('decision-annotation-display');
        if (annotationDisplay) {
            annotationDisplay.textContent = `Original Median: ${originalMedian.toFixed(2)}: 50.0% | Optimized Median: ${optimizedMedian.toFixed(2)}: 50.0%`;
        }

        // Prepare report data
        const reportData = {
            tab: 'decisionOptimizer',
            originalMedian: originalMedian,
            optimizedMedian: optimizedMedian,
            newConfidence: newConfidence,
            budgetFlex: BF,
            scheduleFlex: SF,
            scopeUncert: SU,
            riskTol: RT,
            meanShift: meanShift,
            varianceScale: varianceScale,
            skewAdjustment: skewAdjustment,
            originalMean: originalMean,
            originalStdDev: originalStdDev,
            optimizedMean: optimizedMean,
            optimizedStdDev: optimizedStdDev
        };

        // Generate and display the analysis report
        const reportHtml = generateAnalysisReport(reportData);
        const reportDiv = document.getElementById('decision-analysis-report');
        if (reportDiv) {
            reportDiv.innerHTML = reportHtml;
            console.log('Analysis Report populated for Decision Optimizer tab');
        } else {
            console.error('Analysis Report div not found');
        }

        // Draw the updated plot with original and adjusted distributions
        try {
            drawDecisionOverlayPlot(sortedPoints, adjustedPoints, originalMedian, optimizedMedian, newConfidence);
            console.log('drawDecisionOverlayPlot called successfully');
        } catch (e) {
            console.error('Error in drawDecisionOverlayPlot:', e.message);
            outputDiv.innerHTML = '<p style="color: red; text-align: center;">Error rendering plot.</p>';
        }
    }

    /**
     * Populates parameter cards for the Slider Impact and Reference Guide.
     * Each card details a slider's range, impact, and recommended settings, with clickable links for filtering.
     */
    function populateDecisionParameterCards() {
        const cardsContainer = document.getElementById('decision-parameter-cards');
        if (!cardsContainer) {
            console.error('Decision parameter cards container not found');
            return;
        }

        // Define slider parameters with their properties
        const parameters = [
            {
                name: 'Budget Flexibility',
                range: '0-100%',
                impact: 'Shifts distribution to lower costs, reducing median.',
                recommendations: '50% for balance, 75%+ for cost savings.',
                filterValue: 50
            },
            {
                name: 'Schedule Flexibility',
                range: '0-100%',
                impact: 'Shifts distribution to shorter times, reducing median.',
                recommendations: '50% for typical, 75%+ for urgency.',
                filterValue: 50
            },
            {
                name: 'Scope Uncertainty',
                range: '0-100%',
                impact: 'Increases distribution variance, reflecting uncertainty.',
                recommendations: '25% for defined scope, 75%+ for unknowns.',
                filterValue: 25
            },
            {
                name: 'Risk Tolerance',
                range: '0-100%',
                impact: 'Skews distribution toward riskier outcomes.',
                recommendations: '50% for neutral, 75%+ for high tolerance.',
                filterValue: 50
            }
        ];

        // Generate HTML for parameter cards with clickable links
        cardsContainer.innerHTML = parameters.map(param => `
            <div style="border: 1px solid #ccc; padding: 10px; margin: 5px; border-radius: 5px;">
                <h5><a href="#" class="parameter-link" data-param="${param.name}" data-value="${param.filterValue}">${param.name}</a></h5>
                <p><strong>Range:</strong> ${param.range}</p>
                <p><strong>Impact:</strong> ${param.impact}</p>
                <p><strong>Recommendations:</strong> ${param.recommendations}</p>
            </div>
        `).join('');

        // Add click handlers to parameter links
        document.querySelectorAll('#decision-parameter-cards .parameter-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const param = e.target.getAttribute('data-param');
                const value = parseInt(e.target.getAttribute('data-value'), 10);
                const paramMap = {
                    'Budget Flexibility': 'bf',
                    'Schedule Flexibility': 'sf',
                    'Scope Uncertainty': 'su',
                    'Risk Tolerance': 'rt'
                };
                const filterKey = paramMap[param];
                if (!filterKey) return;

                const filterSpan = document.getElementById('decision-parameter-filter');
                if (filterSpan) {
                    filterSpan.textContent = `${param} = ${value}%`;
                }

                // Apply filter and reset to page 1
                currentPage = 1;
                parameterFilter = { key: filterKey, value: value };
                renderDecisionTable(document.getElementById('decision-median-filter').value, parameterFilter);
            });
        });
    }

    /**
     * Populates the Combination Explorer table in the Decision Optimizer tab.
     * Displays both rounded (e.g., 50%) and precise (e.g., 47.3%) slider values and optimized medians.
     * Supports filtering, pagination, and sorting.
     * @param {number} [page=1] - The page number to display.
     */
    function populateDecisionCombinationTable(page = 1) {
        console.log('populateDecisionCombinationTable called with page:', page);
        const combTable = document.getElementById('decision-combination-table-body');
        if (!combTable) {
            console.error('Decision combination table body not found');
            return;
        }

        // Auto-expand Slider Impact and Reference Guide
        const guide = document.getElementById('decision-slider-impact-reference-guide');
        const toggleButton = document.querySelector('[data-target="decision-slider-impact-reference-guide"]');
        if (guide && toggleButton) {
            guide.style.display = 'block';
            toggleButton.textContent = '▲ ' + toggleButton.textContent.slice(2);
            toggleButton.setAttribute('aria-expanded', 'true');
            toggleStates['decision-slider-impact-reference-guide'] = true;
            console.log('Auto-expanded decision-slider-impact-reference-guide');
        }

        // Validate data
        if (!MC_SMOOTHED_POINTS || !MC_SMOOTHED_POINTS.length) {
            combTable.innerHTML = '<p style="color: red; text-align: center;">Error: Data unavailable.</p>';
            console.error('MC_SMOOTHED_POINTS is missing or empty');
            return;
        }

        // Initialize slider state if undefined
        if (!window.sliderState) {
            window.sliderState = {
                budgetFlexibility: 50,
                scheduleFlexibility: 50,
                scopeUncertainty: 50,
                riskTolerance: 50
            };
            console.warn('window.sliderState was undefined; initialized with defaults');
        }

        // Get filter and slider values with fallbacks
        const filterDropdown = document.getElementById('decision-median-filter');
        const filterValue = filterDropdown ? filterDropdown.value : 'all';
        const currentBF = parseFloat(window.sliderState.budgetFlexibility) || 50;
        const currentSF = parseFloat(window.sliderState.scheduleFlexibility) || 50;
        const currentSU = parseFloat(window.sliderState.scopeUncertainty) || 50;
        const currentRT = parseFloat(window.sliderState.riskTolerance) || 50;

        // Round to nearest discrete step
        const options = [0, 25, 50, 75, 100];
        function roundToNearestDiscrete(value) {
            return options.reduce((prev, curr) => 
                Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev
            );
        }
        const roundedBF = roundToNearestDiscrete(currentBF);
        const roundedSF = roundToNearestDiscrete(currentSF);
        const roundedSU = roundToNearestDiscrete(currentSU);
        const roundedRT = roundToNearestDiscrete(currentRT);

        let filteredCombinations = [];

        if (filterValue === 'current') {
            // Compute median for current slider settings
            const median = computeOptimizedMedian(currentBF / 100, currentSF / 100, currentSU / 100, currentRT / 100);
            filteredCombinations = [{
                bf: roundedBF,
                sf: roundedSF,
                su: roundedSU,
                rt: roundedRT,
                median: median.toFixed(2),
                preciseBF: currentBF.toFixed(1),
                preciseSF: currentSF.toFixed(1),
                preciseSU: currentSU.toFixed(1),
                preciseRT: currentRT.toFixed(1),
                index: 1
            }];
        } else {
            // Use precomputed combinations or generate them
            if (!window.allDecisionCombinations || window.allDecisionCombinations.length === 0) {
                window.allDecisionCombinations = [];
                let index = 0;
                for (let bf of options) {
                    for (let sf of options) {
                        for (let su of options) {
                            for (let rt of options) {
                                const preciseBF = bf === roundedBF ? currentBF : bf;
                                const preciseSF = sf === roundedSF ? currentSF : sf;
                                const preciseSU = su === roundedSU ? currentSU : su;
                                const preciseRT = rt === roundedRT ? currentRT : rt;
                                const median = computeOptimizedMedian(bf / 100, sf / 100, su / 100, rt / 100);
                                window.allDecisionCombinations.push({
                                    bf: bf,
                                    sf: sf,
                                    su: su,
                                    rt: rt,
                                    median: median.toFixed(2),
                                    preciseBF: preciseBF.toFixed(1),
                                    preciseSF: preciseSF.toFixed(1),
                                    preciseSU: preciseSU.toFixed(1),
                                    preciseRT: preciseRT.toFixed(1),
                                    index: ++index
                                });
                            }
                        }
                    }
                }
                console.log('Generated combinations:', window.allDecisionCombinations.length);
            }

            // Apply filters
            filteredCombinations = window.allDecisionCombinations.filter(c => {
                if (filterValue === 'belowMedian') return parseFloat(c.median) < (window.decisionOptimizerOrigMedian || 2400);
                if (filterValue === 'aboveMedian') return parseFloat(c.median) > (window.decisionOptimizerOrigMedian || 2400);
                if (filterValue === 'highFlexibility') return (c.bf + c.sf) >= 100;
                if (filterValue === 'lowUncertainty') return c.su <= 25;
                return true;
            });
        }

        // Sorting
        let sortColumn = window.decisionTableSortColumn || 'median';
        let sortDirection = window.decisionTableSortDirection || 'asc';
        filteredCombinations.sort((a, b) => {
            const valA = sortColumn === 'median' ? parseFloat(a[sortColumn]) : a[sortColumn];
            const valB = sortColumn === 'median' ? parseFloat(b[sortColumn]) : b[sortColumn];
            return sortDirection === 'asc' ? valA - valB : valB - valA;
        });

        // Pagination
        const pageSize = 50;
        const totalPages = Math.ceil(filteredCombinations.length / pageSize);
        const currentPage = Math.max(1, Math.min(page, totalPages)) || 1;
        const start = (currentPage - 1) * pageSize;
        const end = start + pageSize;
        const pageCombinations = filterValue === 'current' ? filteredCombinations : filteredCombinations.slice(start, end);
        const showingLabel = filterValue === 'current' ? 'Showing: Current slider selection' : `Page ${currentPage} of ${totalPages}`;

        // Render table
        let table = combTable.querySelector('table');
        if (!table) {
            table = document.createElement('table');
            table.style.cssText = 'width: 100%; border-collapse: collapse; font-size: 12px;';
            table.className = 'dual-value-table';
            combTable.appendChild(table);
        }

        // Set headers if not present
        let thead = table.querySelector('thead');
        if (!thead) {
            thead = document.createElement('thead');
            thead.innerHTML = `
                <tr style="background: #4a90e2; color: white;">
                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;" data-sort="index" data-original-text="Combination">Combination</th>
                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;" data-sort="bf" data-original-text="Budget Flexibility (%)">Budget Flexibility (%)</th>
                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;" data-sort="sf" data-original-text="Schedule Flexibility (%)">Schedule Flexibility (%)</th>
                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;" data-sort="su" data-original-text="Scope Uncertainty (%)">Scope Uncertainty (%)</th>
                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;" data-sort="rt" data-original-text="Risk Tolerance (%)">Risk Tolerance (%)</th>
                    <th style="padding: 8px; border: 1px solid #ddd; text-align: center;" data-sort="median" data-original-text="Optimized Median">Optimized Median</th>
                </tr>
            `;
            table.appendChild(thead);
        }

        // Remove existing tbody and create new one
        let tbody = table.querySelector('tbody');
        if (tbody) table.removeChild(tbody);
        tbody = document.createElement('tbody');
        table.appendChild(tbody);

        // Populate tbody
        tbody.innerHTML = pageCombinations.length === 0 ? `
            <tr>
                <td colspan="6" style="text-align: center; color: #d32f2f; padding: 20px;">No combinations match the selected filter.</td>
            </tr>
        ` : pageCombinations.map((c, index) => {
            const isCurrent = c.preciseBF === currentBF.toFixed(1) && c.preciseSF === currentSF.toFixed(1) && c.preciseSU === currentSU.toFixed(1) && c.preciseRT === currentRT.toFixed(1);
            return `
                <tr style="background: ${isCurrent ? '#d1e7dd' : (index % 2 === 0 ? '#f8f9fa' : '#fff')};">
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${isCurrent ? '<strong>Current Selection</strong>' : 'Combination ' + c.index}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${c.bf.toFixed(0)}% (${c.preciseBF}%)</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${c.sf.toFixed(0)}% (${c.preciseSF}%)</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${c.su.toFixed(0)}% (${c.preciseSU}%)</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${c.rt.toFixed(0)}% (${c.preciseRT}%)</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${c.median}</td>
                </tr>
            `;
        }).join('');

        // Update page info
        const pageInfo = document.getElementById('decision-page-info');
        if (pageInfo) pageInfo.textContent = showingLabel;

        // Update pagination buttons
        const prevButton = document.getElementById('decision-prev-page');
        const nextButton = document.getElementById('decision-next-page');
        if (prevButton && nextButton) {
            prevButton.disabled = filterValue === 'current' || currentPage === 1;
            nextButton.disabled = filterValue === 'current' || currentPage === totalPages;
        }

        // Add sorting functionality
        const headers = thead.querySelectorAll('th[data-sort]');
        headers.forEach(header => {
            const newHeader = header.cloneNode(true);
            header.parentNode.replaceChild(newHeader, header);
        });
        const newHeaders = thead.querySelectorAll('th[data-sort]');
        newHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const column = header.getAttribute('data-sort');
                if (sortColumn === column) {
                    sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    sortColumn = column;
                    sortDirection = 'asc';
                }
                window.decisionTableSortColumn = sortColumn;
                window.decisionTableSortDirection = sortDirection;
                newHeaders.forEach(h => {
                    h.textContent = h.getAttribute('data-original-text');
                    if (h.getAttribute('data-sort') === sortColumn) {
                        h.textContent += sortDirection === 'asc' ? ' ↑' : ' ↓';
                    }
                });
                filteredCombinations.sort((a, b) => {
                    const valA = sortColumn === 'median' ? parseFloat(a[sortColumn]) : a[sortColumn];
                    const valB = sortColumn === 'median' ? parseFloat(b[sortColumn]) : b[sortColumn];
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                });
                populateDecisionCombinationTable(currentPage);
            });
        });

        // Add event listeners to pagination buttons if not already added
        if (prevButton && !prevButton._hasListener) {
            prevButton.addEventListener('click', () => {
                console.log('Previous page clicked');
                populateDecisionCombinationTable(currentPage - 1);
            });
            prevButton._hasListener = true;
        }
        if (nextButton && !nextButton._hasListener) {
            nextButton.addEventListener('click', () => {
                console.log('Next page clicked');
                populateDecisionCombinationTable(currentPage + 1);
            });
            nextButton._hasListener = true;
        }

        // Add filter dropdown listener if not already added
        if (filterDropdown && !filterDropdown._hasListener) {
            filterDropdown.addEventListener('change', () => populateDecisionCombinationTable());
            filterDropdown._hasListener = true;
        }

        window.currentPage = currentPage;
    }

</script>

 

<!-- SECTION 10.c: JAVASCRIPT - Plot Data Preparation -->

<script type="text/javascript">

/**
 * Draws an overlay plot comparing original and optimized PDFs with median annotations.
 * @param {Array} originalPoints - Original Monte Carlo smoothed points [{x, y}].
 * @param {Array} adjustedPoints - Optimized points after transformations [{x, y}].
 * @param {number} originalMedian - Original median value.
 * @param {number} optimizedMedian - Optimized median value.
 * @param {number} newConfidence - New confidence level for original median in optimized distribution.
 */
function drawDecisionOverlayPlot(originalPoints, adjustedPoints, originalMedian, optimizedMedian, newConfidence) {
    const chartDiv = document.getElementById('decision-overlay-chart');
    if (!chartDiv) {
        console.error('Decision overlay chart div not found');
        return;
    }

    const data = new google.visualization.DataTable();
    data.addColumn('number', 'X');
    data.addColumn('number', 'Original PDF');
    data.addColumn('number', 'Optimized PDF');
    data.addColumn('number', 'Original Median');
    data.addColumn({ type: 'string', role: 'annotation' });
    data.addColumn({ type: 'string', role: 'tooltip' });
    data.addColumn('number', 'Optimized Median');
    data.addColumn({ type: 'string', role: 'annotation' });
    data.addColumn({ type: 'string', role: 'tooltip' });

    const allX = [...new Set([...originalPoints.map(p => p.x), ...adjustedPoints.map(p => p.x)])].sort((a, b) => a - b);
    allX.forEach(x => {
        const origP = originalPoints.find(p => p.x === x) || { y: 0 };
        const adjP = adjustedPoints.find(p => p.x === x) || { y: 0 };
        data.addRow([x, origP.y, adjP.y, null, null, null, null, null, null]);
    });

    // Use getYForX to interpolate y-values at medians
    const originalMedianY = getYForX(originalPoints, originalMedian);
    const optimizedMedianY = getYForX(adjustedPoints, optimizedMedian);

    data.addRow([
        originalMedian, null, null,
        originalMedianY, 'Original Median',
        `Original Distribution\nMedian Value: ${originalMedian.toFixed(2)}\nDensity: ${originalMedianY.toFixed(3)}`,
        null, null, null
    ]);

    data.addRow([
        optimizedMedian, null, null,
        null, null, null,
        optimizedMedianY, 'Optimized Median',
        `Optimized Distribution\nMedian Value: ${optimizedMedian.toFixed(2)}\nDensity: ${optimizedMedianY.toFixed(3)}`
    ]);

    const options = {
        title: 'Original vs Optimized PDF',
        hAxis: { title: 'Value' },
        vAxis: { title: 'Probability Density' },
        series: {
            0: { color: '#888888' },
            1: { color: '#1f77b4' },
            2: { pointSize: 10, color: '#888888' },
            3: { pointSize: 10, color: '#1f77b4' }
        },
        legend: { position: 'top' },
        annotations: { textStyle: { fontSize: 12, color: '#000' } }
    };

    const chart = new google.visualization.LineChart(chartDiv);
    chart.draw(data, options);
}

</script>

 

<!-- SECTION 11: JAVASCRIPT - TABLES AND RECOMMENDATIONS -->

<script type="text/javascript">

    /**

     * Updates the tables and recommendations based on the selected plot type and confidence level.

     * Populates the specific metrics and recommendations tables for each plot type, including parameterized tabs.

     * @param {string} plotType - The type of plot to update tables for (e.g., 'trianglePlot', 'optimizedDecisionInsights').

     */

    function updateTablesAndRecommendations(plotType) {

        console.log(`[updateTablesAndRecommendations] Called with plotType: ${plotType}`);

 

        // Define mappings for metrics and recommendations table IDs based on plotType

        const tableIdMap = {

            'trianglePlot': { metrics: 'triangle-metrics-table', recommendations: 'triangle-recommendations-table' },

            'pertPlot': { metrics: 'pert-metrics-table', recommendations: 'pert-recommendations-table' },

            'betaPlot': { metrics: 'beta-metrics-table', recommendations: 'beta-recommendations-table' },

            'mcBetaUnsmoothedPlot': { metrics: 'mc-unsmoothed-metrics-table', recommendations: 'mc-unsmoothed-recommendations-table' },

            'mcBetaSmoothedPlot': { metrics: 'mc-smoothed-metrics-table', recommendations: 'mc-smoothed-recommendations-table' },

            'optimizedDecisionInsights': { metrics: 'decision-metrics-table', recommendations: 'decision-recommendations-table' },

            'targetProbabilityExplorer': { metrics: 'target-metrics-table', recommendations: 'target-recommendations-table' }

        };

 

        // Get the specific table IDs based on plotType

        const tableIds = tableIdMap[plotType];

        if (!tableIds) {

            console.warn(`[updateTablesAndRecommendations] No table IDs mapped for ${plotType}`);

            return;

        }

 

        const metricsTable = document.getElementById(tableIds.metrics);

        const recommendationsTable = document.getElementById(tableIds.recommendations);

        if (!metricsTable || !recommendationsTable) {

            console.error(`[updateTablesAndRecommendations] Table elements not found for ${plotType}: metrics=${tableIds.metrics}, recommendations=${tableIds.recommendations}`);

            return;

        }

 

        // Clear existing table content

        metricsTable.innerHTML = '';

        recommendationsTable.innerHTML = '';

 

        // Create table headers for metrics

        const metricsHeaders = ['Metric', 'Value', 'Description', 'Calculation'];

        const metricsThead = document.createElement('thead');

        const metricsHeaderRow = document.createElement('tr');

        metricsHeaders.forEach(h => {

            const th = document.createElement('th');

            th.textContent = h;

            th.style.cssText = 'border: 1px solid #ddd; padding: 12px; background-color: #4a90e2; color: white; text-transform: uppercase;';

            metricsHeaderRow.appendChild(th);

        });

        metricsThead.appendChild(metricsHeaderRow);

        metricsTable.appendChild(metricsThead);

 

        // Create table headers for recommendations

        const recommendationsHeaders = ['Recommendation', 'Value', 'Why', 'When to Use'];

        const recommendationsThead = document.createElement('thead');

        const recommendationsHeaderRow = document.createElement('tr');

        recommendationsHeaders.forEach(h => {

            const th = document.createElement('th');

            th.textContent = h;

            th.style.cssText = 'border: 1px solid #ddd; padding: 12px; background-color: #4a90e2; color: white; text-transform: uppercase;';

            recommendationsHeaderRow.appendChild(th);

        });

        recommendationsThead.appendChild(recommendationsHeaderRow);

        recommendationsTable.appendChild(recommendationsThead);

 

        // Get confidence value (if applicable)

        const value = parseInt(document.getElementById('confidence-slider')?.value || 50, 10);

 

        // Populate tables based on plot type

        const metricsTbody = document.createElement('tbody');

        const recommendationsTbody = document.createElement('tbody');

        let metricsRows = [];

        let recommendationsRows = [];

 

        switch (plotType) {

            case 'trianglePlot':

                const trianglePoint = TRIANGLE_POINTS.find(p => p.confidence === value) || TRIANGLE_POINTS[49] || { x: 0, y: 0, confidence: 50 };

                const triangleStdDev = Math.sqrt((Math.pow(min - mostLikely, 2) + Math.pow(max - mostLikely, 2) + Math.pow(min - max, 2)) / 18);

                metricsRows = [

                    ['Confidence', `<span style="color: blue;">${value}%</span>`, 'Selected confidence level', 'User-selected via slider'],

                    ['Value at Confidence', `<span style="color: blue;">${trianglePoint.x.toFixed(2)}</span>`, 'Value at selected confidence', 'Interpolated from TRIANGLE_POINTS'],

                    ['Mean', `<span style="color: blue;">${triangleMean.toFixed(2)}</span>`, 'Average estimate', `(min + mostLikely + max) / 3 = (<span style="color: blue;">${min} + ${mostLikely} + ${max}</span>) / 3`],

                    ['Mode', `<span style="color: blue;">${mostLikely.toFixed(2)}</span>`, 'Most likely estimate', `mostLikely = <span style="color: blue;">${mostLikely}</span>`],

                    ['Standard Deviation', `<span style="color: blue;">${triangleStdDev.toFixed(2)}</span>`, 'Measure of variability', `√((min-mostLikely)² + (max-mostLikely)² + (min-max)²) / 18`],

                    ['Skewness', `<span style="color: blue;">${(window.originalSkewness?.triangle || 0).toFixed(2)}</span>`, 'Symmetry of distribution', 'Derived from TRIANGLE_POINTS']

                ];

                recommendationsRows = [

                    ['Use Mean', `<span style="color: blue;">${triangleMean.toFixed(2)}</span>`, 'Balanced estimate averaging best, likely, and worst cases', 'For initial budgeting or scheduling'],

                    ['Use 90th Percentile', `<span style="color: blue;">${TRIANGLE_POINTS.find(p => p.confidence === 90)?.x.toFixed(2) || 'N/A'}</span>`, 'Covers 90% of scenarios, reducing risk', 'For cautious planning or risk-averse projects'],

                    ['Adjust Confidence', `<span style="color: blue;">75%</span>`, 'Increases certainty for higher values', 'When higher confidence is needed']

                ];

                break;

            case 'pertPlot':

                const pertPoint = PERT_POINTS.find(p => p.confidence === value) || PERT_POINTS[49] || { x: 0, y: 0, confidence: 50 };

                const pertStdDev = pertStd;

                metricsRows = [

                    ['Confidence', `<span style="color: blue;">${value}%</span>`, 'Selected confidence level', 'User-selected via slider'],

                    ['Value at Confidence', `<span style="color: blue;">${pertPoint.x.toFixed(2)}</span>`, 'Value at selected confidence', 'Interpolated from PERT_POINTS'],

                    ['Mean', `<span style="color: blue;">${pertMean.toFixed(2)}</span>`, 'Weighted average estimate', `(min + 4×mostLikely + max) / 6 = (<span style="color: blue;">${min} + 4×${mostLikely} + ${max}</span>) / 6`],

                    ['Mode', `<span style="color: blue;">${mostLikely.toFixed(2)}</span>`, 'Most likely estimate', `mostLikely = <span style="color: blue;">${mostLikely}</span>`],

                    ['Standard Deviation', `<span style="color: blue;">${pertStdDev.toFixed(2)}</span>`, 'Measure of variability', `(max - min) / 6 = (<span style="color: blue;">${max} - ${min}</span>) / 6`],

                    ['Skewness', `<span style="color: blue;">${(window.originalSkewness?.pert || 0).toFixed(2)}</span>`, 'Asymmetry of distribution', 'Derived from PERT_POINTS']

                ];

                recommendationsRows = [

                    ['Use Mean', `<span style="color: blue;">${pertMean.toFixed(2)}</span>`, 'Balances optimism and caution', 'For realistic scheduling or budgeting'],

                    ['Use 95th Percentile', `<span style="color: blue;">${PERT_POINTS.find(p => p.confidence === 95)?.x.toFixed(2) || 'N/A'}</span>`, 'Covers 95% of scenarios, minimizing risk', 'For firm commitments or high-stakes projects'],

                    ['Adjust Confidence', `<span style="color: blue;">80%</span>`, 'Higher confidence for critical planning', 'When precision is critical']

                ];

                break;

            case 'betaPlot':

                const betaPoint = BETA_POINTS.find(p => p.confidence === value) || BETA_POINTS[49] || { x: 0, y: 0, confidence: 50 };

                const betaStdDev = Math.sqrt((alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1))) * (max - min);

                metricsRows = [

                    ['Confidence', `<span style="color: blue;">${value}%</span>`, 'Selected confidence level', 'User-selected via slider'],

                    ['Value at Confidence', `<span style="color: blue;">${betaPoint.x.toFixed(2)}</span>`, 'Value at selected confidence', 'Interpolated from BETA_POINTS'],

                    ['Mean', `<span style="color: blue;">${betaMean.toFixed(2)}</span>`, 'Expected value', `α / (α + β) × (max - min) + min = (<span style="color: blue;">${alpha} / (${alpha} + ${beta}) × (${max} - ${min}) + ${min}</span>)`],

                    ['Mode', `<span style="color: blue;">${betaMode.toFixed(2)}</span>`, 'Most likely estimate', `(α - 1) / (α + β - 2) × (max - min) + min`],

                    ['Standard Deviation', `<span style="color: blue;">${betaStdDev.toFixed(2)}</span>`, 'Measure of variability', `√((α × β) / ((α + β)² × (α + β + 1))) × (max - min)`],

                    ['Skewness', `<span style="color: blue;">${(window.originalSkewness?.beta || 0).toFixed(2)}</span>`, 'Asymmetry of distribution', 'Derived from BETA_POINTS']

                ];

                recommendationsRows = [

                    ['Use Mean', `<span style="color: blue;">${betaMean.toFixed(2)}</span>`, 'Adapts to emerging data', 'For mid-project adjustments'],

                    ['Use 90th Percentile', `<span style="color: blue;">${BETA_POINTS.find(p => p.confidence === 90)?.x.toFixed(2) || 'N/A'}</span>`, 'Covers 90% of scenarios, reducing uncertainty', 'For cautious mid-project planning'],

                    ['Adjust Confidence', `<span style="color: blue;">70%</span>`, 'Balances precision and risk', 'When refining estimates with new data']

                ];

                break;

            case 'mcBetaUnsmoothedPlot':

                const mcUnsmoothedPoint = MC_UNSMOOTHED_POINTS.find(p => p.confidence === value) || MC_UNSMOOTHED_POINTS[49] || { x: 0, y: 0, confidence: 50 };

                const mcUnsmoothedStdDev = Math.sqrt(MC_UNSMOOTHED_POINTS.reduce((sum, p) => sum + Math.pow(p.x - mcUnsmoothedMean, 2), 0) / MC_UNSMOOTHED_POINTS.length);

                metricsRows = [

                    ['Confidence', `<span style="color: blue;">${value}%</span>`, 'Selected confidence level', 'User-selected via slider'],

                    ['Value at Confidence', `<span style="color: blue;">${mcUnsmoothedPoint.x.toFixed(2)}</span>`, 'Value at selected confidence', 'Interpolated from MC_UNSMOOTHED_POINTS'],

                    ['Mean', `<span style="color: blue;">${mcUnsmoothedMean.toFixed(2)}</span>`, 'Average across simulations', 'Mean of MC_UNSMOOTHED_POINTS'],

                    ['Standard Deviation', `<span style="color: blue;">${mcUnsmoothedStdDev.toFixed(2)}</span>`, 'Measure of variability', 'Std Dev of MC_UNSMOOTHED_POINTS'],

                    ['Skewness', `<span style="color: blue;">${(window.originalSkewness?.mcUnsmoothed || 0).toFixed(2)}</span>`, 'Asymmetry of distribution', 'Derived from MC_UNSMOOTHED_POINTS']

                ];

                recommendationsRows = [

                    ['Use Median', `<span style="color: blue;">${MC_UNSMOOTHED_POINTS.find(p => p.confidence === 50)?.x.toFixed(2) || 'N/A'}</span>`, 'Represents central tendency of simulations', 'For risk-based forecasting'],

                    ['Use 90th Percentile', `<span style="color: blue;">${MC_UNSMOOTHED_POINTS.find(p => p.confidence === 90)?.x.toFixed(2) || 'N/A'}</span>`, 'Covers 90% of outcomes, exposing extremes', 'For high-risk scenarios or worst-case planning'],

                    ['Adjust Confidence', `<span style="color: blue;">85%</span>`, 'Higher confidence for extreme risk assessment', 'When preparing for potential overruns']

                ];

                break;

            case 'mcBetaSmoothedPlot':

                const mcSmoothedPoint = MC_SMOOTHED_POINTS.find(p => p.confidence === value) || MC_SMOOTHED_POINTS[49] || { x: 0, y: 0, confidence: 50 };

                const mcSmoothedStdDev = Math.sqrt(MC_SMOOTHED_POINTS.reduce((sum, p) => sum + Math.pow(p.x - mcSmoothedMean, 2), 0) / MC_SMOOTHED_POINTS.length);

                const probabilitySlider = document.getElementById('probability-slider');

                const probabilityValue = probabilitySlider ? parseFloat(probabilitySlider.value) : (min + max) / 2;

                const probabilityResult = document.getElementById('probability-result');

                const probabilityText = probabilityResult ? probabilityResult.textContent : '(Calculating...)';

                const probabilityPercent = parseFloat(probabilityText.split(': ')[1]) || 50;

                metricsRows = [

                    ['Confidence', `<span style="color: blue;">${value}%</span>`, 'Selected confidence level', 'User-selected via slider'],

                    ['Value at Confidence', `<span style="color: blue;">${mcSmoothedPoint.x.toFixed(2)}</span>`, 'Value at selected confidence (PDF)', 'Interpolated from MC_SMOOTHED_POINTS'],

                    ['Target Probability', `<span style="color: blue;">${probabilityPercent}% at ${probabilityValue.toFixed(2)}</span>`, 'Probability of staying below target (CDF)', `Trapezoidal integration of MC_SMOOTHED_POINTS at <span style="color: blue;">${probabilityValue.toFixed(2)}</span>`],

                    ['Mean', `<span style="color: blue;">${mcSmoothedMean.toFixed(2)}</span>`, 'Smoothed average', 'Mean of MC_SMOOTHED_POINTS'],

                    ['Standard Deviation', `<span style="color: blue;">${mcSmoothedStdDev.toFixed(2)}</span>`, 'Measure of variability', 'Std Dev of MC_SMOOTHED_POINTS'],

                    ['Skewness', `<span style="color: blue;">${(window.originalSkewness?.mcSmoothed || 0).toFixed(2)}</span>`, 'Asymmetry of distribution', 'Derived from MC_SMOOTHED_POINTS']

                ];

                recommendationsRows = [

                    ['Use Median', `<span style="color: blue;">${MC_SMOOTHED_POINTS.find(p => p.confidence === 50)?.x.toFixed(2) || 'N/A'}</span>`, 'Stable central tendency for planning', 'For long-term trend-based planning'],

                    ['Use 95th Percentile', `<span style="color: blue;">${MC_SMOOTHED_POINTS.find(p => p.confidence === 95)?.x.toFixed(2) || 'N/A'}</span>`, 'Covers 95% of outcomes, reducing risk', 'For risk-averse forecasting'],

                    ['Adjust Target Value', `<span style="color: blue;">${(probabilityValue * 1.05).toFixed(2)}</span>`, 'Increases probability to ~75%', 'When higher confidence in target is needed']

                ];

                break;

            case 'optimizedDecisionInsights':

                const origMedian = window.decisionOptimizerOrigMedian || 2400;

                const newConfidence = window.decisionOptimizerNewConfidence || 50;

                const optimizedValue = window.lastOptimizedValue || origMedian.toFixed(2);

                const percentageChange = ((optimizedValue - origMedian) / origMedian * 100).toFixed(2);

                const changeDirection = percentageChange > 0 ? 'increase' : 'decrease';

                const bf = parseFloat(document.getElementById('decisionBudgetFlexibility')?.value || 50) / 100;

                const sf = parseFloat(document.getElementById('decisionScheduleFlexibility')?.value || 50) / 100;

                const su = parseFloat(document.getElementById('decisionScopeUncertainty')?.value || 50) / 100;

                const rt = parseFloat(document.getElementById('decisionRiskTolerance')?.value || 50) / 100;

                const meanShift = 0.2 * (window.originalStdDev || 100) * (-bf - sf + 0.5 * su);

                const varianceScale = 1 + 2.0 * su;

                const skewAdjustment = -0.05 * rt + 0.2 * su;

                metricsRows = [

                    ['Original Median', `<span style="color: blue;">${origMedian.toFixed(2)}</span>`, 'Baseline median before adjustments', 'Median of MC_SMOOTHED_POINTS'],

                    ['Optimized Median', `<span style="color: blue;">${optimizedValue}</span>`, 'Adjusted median based on sliders', `computeOptimizedMedian(BF=<span style="color: blue;">${(bf * 100).toFixed(1)}%</span>, SF=<span style="color: blue;">${(sf * 100).toFixed(1)}%</span>, SU=<span style="color: blue;">${(su * 100).toFixed(1)}%</span>, RT=<span style="color: blue;">${(rt * 100).toFixed(1)}%</span>)`],

                    ['Median Shift', `<span style="color: blue;">${percentageChange}% (${changeDirection})</span>`, 'Percentage change in median', `(optimizedMedian - originalMedian) / originalMedian × 100`],

                    ['New Confidence', `<span style="color: blue;">${newConfidence}%</span>`, 'Confidence for original median in optimized distribution', 'Trapezoidal CDF integration'],

                    ['Mean Shift', `<span style="color: blue;">${meanShift.toFixed(2)}</span>`, 'Shift in distribution mean', `0.2 × originalStdDev × (-BF - SF + 0.5 × SU)`],

                    ['Variance Scale', `<span style="color: blue;">${varianceScale.toFixed(2)}</span>`, 'Scaling factor for variance', `1 + 2.0 × SU`],

                    ['Skew Adjustment', `<span style="color: blue;">${skewAdjustment.toFixed(2)}</span>`, 'Skew change due to risk settings', `-0.05 × RT + 0.2 × SU`]

                ];

                recommendationsRows = [

                    ['Use Optimized Median', `<span style="color: blue;">${optimizedValue}</span>`, 'Reflects current flexibility and risk settings', 'For tailored project planning'],

                    ['Increase Budget Flexibility', `<span style="color: blue;">75%</span>`, 'Boosts confidence in original median', 'When cost overruns are a concern'],

                    ['Reduce Scope Uncertainty', `<span style="color: blue;">25%</span>`, 'Reduces variability for tighter estimates', 'When project scope is well-defined']

                ];

                break;

            case 'targetProbabilityExplorer':

                const targetValue = parseFloat(document.getElementById('target-value-slider')?.value) || 2466.46;

                const origProb = window.lastOrigProb || 0.0;

                const optProb = window.lastOptProb || 0.0;

                const probDifference = (optProb - origProb).toFixed(1);

                const changeDirectionProb = probDifference > 0 ? 'increased' : 'decreased';

                const tbf = parseFloat(document.getElementById('targetBudgetFlexibility')?.value || 50) / 100;

                const tsf = parseFloat(document.getElementById('targetScheduleFlexibility')?.value || 50) / 100;

                const tsu = parseFloat(document.getElementById('targetScopeUncertainty')?.value || 50) / 100;

                const trt = parseFloat(document.getElementById('targetRiskTolerance')?.value || 50) / 100;

                const tMeanShift = 0.2 * (window.originalStdDev || 100) * (-tbf - tsf + 0.5 * tsu);

                const tVarianceScale = 1 + 2.0 * tsu;

                const tSkewAdjustment = -0.05 * trt + 0.2 * tsu;

                metricsRows = [

                    ['Target Value', `<span style="color: blue;">${targetValue.toFixed(2)}</span>`, 'Selected target value', 'User-selected via slider'],

                    ['Original Probability', `<span style="color: blue;">${origProb}%</span>`, 'Baseline probability of meeting target', 'Trapezoidal CDF of MC_SMOOTHED_POINTS'],

                    ['Optimized Probability', `<span style="color: blue;">${optProb}%</span>`, 'Adjusted probability based on sliders', `computeTargetOptimizedCdf(BF=<span style="color: blue;">${(tbf * 100).toFixed(1)}%</span>, SF=<span style="color: blue;">${(tsf * 100).toFixed(1)}%</span>, SU=<span style="color: blue;">${(tsu * 100).toFixed(1)}%</span>, RT=<span style="color: blue;">${(trt * 100).toFixed(1)}%</span>, target=<span style="color: blue;">${targetValue.toFixed(2)}</span>)`],

                    ['Probability Change', `<span style="color: blue;">${changeDirectionProb} by ${Math.abs(probDifference)}%</span>`, 'Change in probability', `optimizedProb - originalProb`],

                    ['Mean Shift', `<span style="color: blue;">${tMeanShift.toFixed(2)}</span>`, 'Shift in distribution mean', `0.2 × originalStdDev × (-BF - SF + 0.5 × SU)`],

                    ['Variance Scale', `<span style="color: blue;">${tVarianceScale.toFixed(2)}</span>`, 'Scaling factor for variance', `1 + 2.0 × SU`],

                    ['Skew Adjustment', `<span style="color: blue;">${tSkewAdjustment.toFixed(2)}</span>`, 'Skew change due to risk settings', `-0.05 × RT + 0.2 × SU`]

                ];

                recommendationsRows = [

                    ['Increase Target Value', `<span style="color: blue;">${(targetValue * 1.05).toFixed(2)}</span>`, 'Boosts probability to ~75%', 'To reduce risk of exceeding target'],

                    ['Increase Budget Flexibility', `<span style="color: blue;">75%</span>`, 'Improves probability of meeting target', 'When cost predictability is critical'],

                    ['Reduce Scope Uncertainty', `<span style="color: blue;">25%</span>`, 'Narrows outcome range for higher confidence', 'When scope is well-defined']

                ];

                break;

            default:

                console.warn(`[updateTablesAndRecommendations] Unknown plotType: ${plotType}`);

                return;

        }

 

        // Populate metrics table

        metricsRows.forEach((row, index) => {

            const tr = document.createElement('tr');

            tr.style.backgroundColor = index % 2 === 0 ? '#ffffff' : '#f8f9fa';

            row.forEach(cell => {

                const td = document.createElement('td');

                td.innerHTML = cell;

                td.style.cssText = 'border: 1px solid #ddd; padding: 12px; text-align: left;';

                td.title = cell.replace(/<[^>]+>/g, '');

                tr.appendChild(td);

            });

            metricsTbody.appendChild(tr);

        });

        metricsTable.appendChild(metricsTbody);

 

        // Populate recommendations table

        recommendationsRows.forEach((row, index) => {

            const tr = document.createElement('tr');

            tr.style.backgroundColor = index % 2 === 0 ? '#ffffff' : '#f8f9fa';

            row.forEach(cell => {

                const td = document.createElement('td');

                td.innerHTML = cell;

                td.style.cssText = 'border: 1px solid #ddd; padding: 10px; text-align: left;';

                td.title = cell.replace(/<[^>]+>/g, '');

                tr.appendChild(td);

            });

            recommendationsTbody.appendChild(tr);

        });

        recommendationsTable.appendChild(recommendationsTbody);

 

        console.log(`[updateTablesAndRecommendations] Generated ${metricsRows.length} metrics rows and ${recommendationsRows.length} recommendation rows for ${plotType}`);

 

        // Restore toggle states

        setTimeout(() => window.restoreToggleState && window.restoreToggleState(), 200);

        console.log('[updateTablesAndRecommendations] Scheduled toggleStates restoration');

    }

</script>

 

<!-- SECTION 12: JAVASCRIPT - BACK TO TOP FUNCTIONALITY -->

<script type="text/javascript">

    document.addEventListener('scroll', () => {

        const backToTop = document.getElementById('back-to-top');

        if (backToTop && window.scrollY > 200) {

            backToTop.classList.add('visible');

        } else if (backToTop) {

            backToTop.classList.remove('visible');

        }

    });

 

    const backToTop = document.getElementById('back-to-top');

    if (backToTop) {

        backToTop.addEventListener('click', () => {

            window.scrollTo({ top: 0, behavior: 'smooth' });

        });

    }

</script>

 

<!-- SECTION 13: CLOSING TAGS -->

</html>

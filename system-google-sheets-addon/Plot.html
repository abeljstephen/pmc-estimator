<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Probability Plots</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Charts (rendering only) — defer so page renders immediately -->
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Zoom plugin -->
  <script defer src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  <!-- Export helpers -->
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- KaTeX for fast math rendering (~28KB, synchronous) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

  <!-- Three.js for 3D hypercube -->
  <script defer src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>

  <style>
    :root {
      --fg:#111827; --muted:#6B7280; --brand:#111827; --accent:#10B981; --accent2:#059669; --opt:#6D28D9;
      --line:#E5E7EB; --panel:#FFFFFF; --chip:#F3F4F6; --hover:#BFDBFE; --warn:#DC2626; --tab:#374151;
      --cdf:#3B82F6; --good:#059669; --bad:#F87171;

      /* Series color constants */
      --base:#10B981;        /* Your Estimate (Baseline) */
      --manual:#059669;      /* Unconstrained Optimization */
      --fixed:#6D28D9;       /* General Optimization (Fixed) */
      --adaptive:#F59E0B;    /* Conservative Optimization (Adaptive) */
      --tri:#3B82F6;         /* Triangle */
      --beta:#7C3AED;        /* Beta-PERT */

      /* Category chips */
      --cat-capacity:#065f46; --cat-certainty:#1d4ed8; --cat-process:#7c3aed; --cat-behavioral:#b45309; --cat-other:#4b5563;
    }

    html,body{font-family:-apple-system,BlinkMacSystemFont,'Inter',sans-serif;color:var(--fg);background:var(--panel);margin:0;min-height:100%;}
    *{box-sizing:border-box;}
    .wrap{padding:12px 16px;max-width:1480px;margin:0 auto;}
    h1{font-size:16px;font-weight:700;margin:0 0 12px;letter-spacing:.2px;}
    label{font-size:12px;font-weight:600;color:var(--muted);letter-spacing:.2px;}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px 14px;box-shadow:0 2px 8px rgba(0,0,0,.08);}

    .toolbar-row{display:flex;gap:14px;align-items:center;flex-wrap:wrap;}
    .toolbar-row+.toolbar-row{margin-top:10px;padding-top:10px;border-top:1px solid var(--line);}
    .input-group{display:flex;flex-direction:column;gap:4px;}
    .input-group select,.input-group input{min-width:200px}
    .chip{background:var(--chip);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px;font-weight:500;min-height:44px;display:flex;align-items:center;}
    .toolbar-row select:hover,.toolbar-row select:focus,
    .toolbar-row button:hover,.kpi-group .kpi:hover{background:var(--hover);border-color:var(--hover);}
    .toolbar-row select{padding:6px 8px;border:1px solid var(--line);border-radius:8px;font-size:12px;font-weight:500;min-height:36px;}
    .toolbar-row button.primary{background:var(--brand);color:#fff;border-color:var(--brand);padding:6px 10px;border:1px solid var(--brand);border-radius:8px;font-size:12px;cursor:pointer;min-height:36px;}

    /* OMP inline bar */
    .omp-bar{display:inline-flex;align-items:center;gap:0;background:var(--chip);border:1px solid var(--line);border-radius:8px;padding:0;font-size:12px;font-weight:500;overflow:hidden;}
    .omp-bar .omp-item{padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;}
    .omp-bar .omp-item+.omp-item{border-left:1px solid var(--line);}
    .omp-bar .omp-label{color:var(--muted);font-weight:600;}
    .omp-bar .omp-val{font-family:'SF Mono',Consolas,monospace;font-weight:600;}
    .omp-bar .omp-item.pert{background:rgba(59,130,246,.08);}
    .omp-bar .omp-item.pert .omp-val{color:var(--cdf);}

    /* ── Target Analysis Panel — causal flow layout ── */
    #targetPanel { display:flex; flex-direction:column; gap:8px; padding:4px 0 2px; }

    /* Mode toggle: compact pill pair (no large cards, no emojis) */
    #tgtModeCards { display:flex; gap:0; border:1px solid var(--line); border-radius:20px; overflow:hidden; align-self:flex-start; }
    .tgt-mode-pill {
      padding:5px 13px; cursor:pointer; background:var(--chip); color:var(--muted);
      border:none; font-size:11px; font-weight:600; transition:all .15s;
      white-space:nowrap; font-family:inherit; line-height:1.4;
    }
    .tgt-mode-pill:hover { background:var(--hover); }
    .tgt-mode-pill.active { background:#111827; color:#fff; }
    .tgt-mode-pill + .tgt-mode-pill { border-left:1px solid var(--line); }
    /* JS compatibility: target-mode-btn resets are handled by mode-pill styles */
    .target-mode-btn { background:none; border:none; padding:0; }
    .target-mode-btn.active { background:none; color:inherit; }

    /* INPUT area: shows what the slider controls (above slider) */
    .tgt-flow-input {
      display:none; align-items:center; gap:8px; flex-wrap:wrap;
      padding:7px 11px; background:var(--chip);
      border:1px solid var(--line); border-radius:10px;
    }
    .tgt-flow-input.active { display:flex; }
    .tgt-flow-label { font-size:9px; font-weight:700; color:var(--muted); letter-spacing:.06em; text-transform:uppercase; white-space:nowrap; }
    .tgt-flow-units { font-size:11px; color:var(--muted); }
    .tgt-input-chip { font-size:16px !important; padding:2px 10px !important; }

    /* Slider row (between input and result) */
    #tgtSliderRow { display:flex; align-items:center; gap:8px; }
    .tgt-hint { font-size:10px; color:var(--muted); white-space:nowrap; }

    /* RESULT area: large prominent derived answer (below slider) */
    .tgt-flow-result {
      display:none; align-items:center; gap:8px; flex-wrap:wrap;
      padding:8px 12px; background:#EFF6FF;
      border:1.5px solid #BFDBFE; border-radius:10px;
    }
    .tgt-flow-result.active { display:flex; }
    .tgt-result-chip { font-size:22px !important; padding:3px 12px !important; font-weight:800 !important; }
    .tgt-flow-result-text { font-size:12px; color:#1E40AF; font-weight:600; }

    /* Context band: PERT mean + distance (replaces #tgtAnswerRow box) */
    .tgt-context-band {
      padding:4px 2px 0; font-size:10px; color:var(--muted);
      border-top:1px solid var(--line); line-height:1.4;
    }

    /* Keep .tgt-chip base styles (shared by input + result chips) */
    .tgt-chip {
      display:inline-block; padding:2px 9px; border-radius:6px;
      font-family:'SF Mono',Consolas,monospace; font-weight:700; font-size:13px;
      white-space:nowrap;
    }
    .tgt-chip.tgt-val { background:rgba(16,185,129,.12); color:#065f46; border:1px solid rgba(16,185,129,.4); }
    .tgt-chip.tgt-prob { background:rgba(59,130,246,.12); color:#1D4ED8; border:1px solid rgba(59,130,246,.4); }

    /* Legacy classes — kept for backward compat, not used in new layout */
    .tgt-card { display:none !important; }
    .tgt-sentence { display:none; }
    .tgt-s { font-size:12px; color:#4B5563; font-weight:500; white-space:nowrap; }
    .target-result { display:none !important; }
    .target-mode-toggle { display:none !important; }

    /* Status compact */
    .status-compact{display:flex;align-items:center;gap:6px;margin-left:auto;}
    .status{font-size:12px;color:#166534;font-weight:600;padding:6px 12px;border:2px solid #86EFAC;border-radius:8px;margin-left:auto;min-height:44px;display:flex;align-items:center;transition:all .3s;background:#F0FDF4;}
    .status.fetching{background:#FEF2F2;color:#991B1B;border-color:#FCA5A5;animation:fetchPulse 1.5s ease-in-out infinite;}
    @keyframes fetchPulse{0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,0.3);}50%{box-shadow:0 0 8px 2px rgba(239,68,68,0.3);}}
    .glow{animation:glow 1.1s ease-in-out infinite alternate;}
    @keyframes glow{
      from{ box-shadow:0 0 0 rgba(59,130,246,0.0); }
      to  { box-shadow:0 0 14px rgba(59,130,246,0.55); }
    }

    /* KPI tiles */
    .kpi-group{display:flex;gap:8px;justify-content:flex-start;flex-wrap:wrap;background:#F9FAFB;padding:8px;border-radius:10px;}
    .kpi{background:var(--panel);border:1px solid var(--line);border-radius:8px;padding:10px 14px;min-width:180px;min-height:48px;cursor:pointer;transition:background-color .2s, box-shadow .2s, opacity .2s;}
    .kpi .ttl{font-size:11px;color:var(--muted);margin-bottom:4px;letter-spacing:.2px;}
    .kpi .val{font-size:12px;font-weight:600;}
    .kpi.updating{box-shadow:0 0 12px rgba(59,130,246,.55);}
    .kpi.inactive{opacity:.45;cursor:pointer;}
    .kpi.baseline .val{color:var(--base);}
    .kpi.adjusted .val{color:var(--manual);}
    .kpi.optimized .val{color:var(--fixed);}
    .kpi.adaptive .val{color:var(--adaptive);}
    .kpi.active{outline:2px solid var(--tab);}

    /* Tabs row */
    .tabs{display:flex;gap:8px;margin:10px 0;flex-wrap:wrap;align-items:center;}
    .tab{font-size:12px;padding:6px 10px;border:1px solid var(--line);border-radius:8px;background:var(--panel);cursor:pointer;user-select:none;min-height:44px;}
    .tab:hover{background:var(--hover);border-color:var(--hover);}
    .tab.active{background:var(--tab);color:#fff;border-color:var(--tab);}

    /* Series toggles (overlay) */
    .series-toggles{display:none;align-items:center;gap:10px;margin-left:auto;}
    .series-toggles .tg{border:1px solid var(--line);border-radius:8px;background:#fff;padding:5px 10px;font-size:12px;cursor:pointer;min-height:36px;line-height:1.3;text-align:center;}
    .series-toggles .tg[aria-pressed="true"]{background:#111827;color:#fff;border-color:#111827;}
    .series-toggles .mini-status{font-size:12px;color:var(--muted);padding:6px 10px;border:1px solid var(--line);border-radius:8px;min-height:36px;}
    .series-toggles .toggle-group { display: inline-flex; gap: 4px; }
    .series-toggles .baseline-group { border-right: 1px solid var(--line); padding-right: 8px; margin-right: 8px; }

    /* Plot area */
    .plot-container{display:flex;flex-direction:column;gap:16px;position:relative;}
    .plots{flex:1 1 100%;}
    .plot{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,.08);position:relative;}
    .plot-inner{position:relative;height:min(420px,50vh);display:flex;gap:8px;flex-direction:row;flex-wrap:nowrap;}
    /* pdfCanvas & cdfCanvas live inside .plot-pane (column flex); flex:1 fills available height */
    #pdfCanvas,#cdfCanvas{width:100%!important;flex:1 1 0;min-height:0;background:#FAFAFA;}

    /* Hypercube Radar Chart - side-by-side row below distribution plots */
    #hypercubeSection {
      display: none; /* Shown only in overlay tab */
    }
    #hypercubeSection.visible {
      display: flex;
      gap: 12px;
      margin-top: 12px;
    }
    #radarCard, #hypercube3DCard {
      flex: 1;
      min-width: 0;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:12px;
      padding:12px;
      box-shadow:0 2px 8px rgba(0,0,0,.08);
    }
    #hypercubeRadar {
      height: 320px !important;
      width: 100% !important;
    }
    #hypercube3D {
      height: 320px !important;
      width: 100% !important;
      background: #f8f9fa;
    }
    .plot-title {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 8px;
      text-align: center;
    }
    .plot-subtitle {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin-top: 4px;
    }
    .plot-desc{font-size:11px;color:var(--muted);line-height:1.5;margin-top:8px;padding:8px 10px;background:var(--chip);border-radius:8px;border-left:3px solid var(--cdf);}

    /* Right compare legend — HIDDEN */
    .right-legend{display:none!important;}

    .legend{font-size:12px;color:var(--muted);margin-top:6px;display:flex;gap:12px;flex-wrap:wrap;}
    .legend span{word-break:break-word;hyphens:auto;max-width:150px;overflow:hidden;text-overflow:ellipsis;white-space:normal;}
    .warn{color:var(--warn);font-size:12px;font-weight:500;margin-top:6px;background:rgba(220,38,38,.1);padding:6px 8px;border-radius:8px;}
    .legend-dot{width:10px;height:10px;border-radius:50%;display:inline-block;border:2px solid transparent;}
    .dot-base{border-color:var(--base);} .dot-man{border-color:var(--manual);} .dot-fix{border-color:var(--fixed);} .dot-adp{border-color:var(--adaptive);}
    .dot-tri{border-color:var(--tri);} .dot-beta{border-color:var(--beta);}

    /* ── Decision Slider Panel — inside #overlayKpis, between tabs and recommendation ── */
    .plot-container { display: flex; flex-direction: column; }
    #sliderSidebar {
      display: none;
      width: 100%;
      padding: 12px 2px 4px;
      border-top: 1px solid var(--line);
      margin-top: 4px;
      margin-bottom: 14px;
    }
    #overlayKpis.sidebar-active #sliderSidebar { display: block; }
    .plot-main { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 16px; }

    /* Panel interior: header row + horizontal category columns */
    .sliders-panel { display: flex; flex-direction: column; gap: 8px; }

    /* Header: title · note · impact banner */
    .slider-panel-hdr { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-height: 24px; }
    .sliders-panel .title { font-size: 11px; font-weight: 700; color: var(--fg); white-space: nowrap; flex-shrink: 0; }
    .sliders-panel .note  { font-size: 11px; color: var(--muted); flex: 1; }
    #sliderImpactBanner   { font-size: 11px; line-height: 1.4; padding: 4px 8px;
                            border-radius: 6px; background: #F0FDF4;
                            border: 1px solid #86EFAC; color: #166534; }

    /* Category columns laid out horizontally */
    .slider-cats { display: flex; flex-direction: row; flex-wrap: wrap; align-items: flex-start; gap: 0; }
    .slider-category {
      flex: 1 1 130px;
      min-width: 120px;
      padding: 0 14px 0 0;
      margin: 0 14px 0 0;
      border-bottom: none;
      border-right: 1px solid var(--line);
    }
    .slider-category:last-of-type { border-right: none; padding-right: 0; margin-right: 0; }
    .cat-header { font-size: 9px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 5px; }
    .slider-row { margin-bottom: 6px; }
    .slider-row label { font-size: 11px; font-weight: 600; display: block; margin-bottom: 2px; color: var(--fg); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .slider-pair { display: flex; align-items: center; gap: 4px; }
    .slider-range {
      flex: 1; min-width: 50px; height: 6px; -webkit-appearance: none; appearance: none;
      background: var(--line); border-radius: 3px; outline: none; cursor: pointer;
    }
    .slider-range::-webkit-slider-thumb {
      -webkit-appearance: none; width: 15px; height: 15px; border-radius: 50%;
      background: var(--brand); cursor: pointer; border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,.2);
    }
    .slider-range::-moz-range-thumb {
      width: 15px; height: 15px; border-radius: 50%; background: var(--brand);
      cursor: pointer; border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,.2);
    }
    .slider-num {
      width: 42px; padding: 3px 4px; border: 1px solid var(--line); border-radius: 6px;
      font-size: 11px; text-align: center; font-weight: 600;
    }
    .slider-unit { font-size: 10px; color: var(--muted); min-width: 10px; }
    .slider-optimal-marker { height: 4px; position: relative; margin: -1px 0 0 0; }
    .slider-optimal-marker .marker-dot {
      position: absolute; width: 7px; height: 7px; background: var(--fixed);
      border-radius: 50%; top: -2px; transform: translateX(-50%);
      box-shadow: 0 0 4px rgba(109,40,217,.4);
    }
    .slider-range:disabled, .slider-num:disabled { opacity: 0.45; cursor: not-allowed; }

    /* Slider label row with help icon */
    .slider-label-row { display: flex; align-items: center; gap: 4px; margin-bottom: 2px; }
    .slider-label-row label { flex: 1; margin-bottom: 0; font-size: 11px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .slider-help-btn {
      flex-shrink: 0;
      width: 14px; height: 14px; border-radius: 50%;
      border: 1px solid var(--line); background: #fff; color: var(--muted);
      font-size: 9px; font-weight: 700; line-height: 12px; text-align: center;
      cursor: pointer; padding: 0;
      transition: background .15s, color .15s;
    }
    .slider-help-btn:hover { background: var(--hover); color: var(--fg); border-color: #94a3b8; }

    /* Slider help — centered modal overlay */
    #sliderHelpBackdrop {
      display: none;
      position: fixed; inset: 0; z-index: 9998;
      background: rgba(15,23,42,.35);
      backdrop-filter: blur(1px);
      -webkit-backdrop-filter: blur(1px);
    }
    #sliderHelpBackdrop.visible { display: block; }
    #sliderHelpModal {
      display: none;
      position: fixed; z-index: 9999;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: min(380px, 90vw);
      max-height: 80vh; overflow-y: auto;
      background: #fff; border-radius: 14px;
      box-shadow: 0 24px 64px rgba(0,0,0,.22);
      padding: 20px 22px 18px;
      font-size: 12px; line-height: 1.65; color: var(--fg);
    }
    #sliderHelpModal.visible { display: block; }
    #sliderHelpModal .shm-header {
      display: flex; align-items: flex-start; justify-content: space-between;
      gap: 10px; margin-bottom: 10px;
    }
    #sliderHelpModal .shm-title {
      font-size: 14px; font-weight: 700; color: var(--fg); line-height: 1.3;
    }
    #sliderHelpModal .shm-close {
      flex-shrink: 0; width: 24px; height: 24px; border-radius: 50%;
      border: 1px solid var(--line); background: #f8fafc; color: var(--muted);
      font-size: 14px; font-weight: 700; line-height: 22px; text-align: center;
      cursor: pointer; padding: 0; transition: background .15s;
    }
    #sliderHelpModal .shm-close:hover { background: #e2e8f0; color: var(--fg); }
    #sliderHelpModal .shm-body p { margin: 0 0 9px; }
    #sliderHelpModal .shm-body p:last-child { margin-bottom: 0; }
    #sliderHelpModal .shm-body em { font-style: normal; color: var(--muted); font-size: 11px; display: block; margin-top: 6px; padding: 6px 8px; background: #f8fafc; border-radius: 6px; border-left: 3px solid var(--line); }

    /* Action buttons: right-aligned below the columns */
    .slider-preset-row {
      display: flex; flex-direction: column; gap: 4px;
      padding: 0 0 8px; border-bottom: 1px solid var(--line); margin-bottom: 10px;
    }
    .slider-preset-label {
      font-size: 9px; font-weight: 700; color: var(--muted);
      letter-spacing: .05em; text-transform: uppercase;
    }
    .slider-actions { display: flex; gap: 6px; margin-top: 0; justify-content: flex-end; }
    .slider-btn {
      padding: 5px 12px; border: 1px solid var(--line); border-radius: 8px;
      font-size: 11px; font-weight: 600; cursor: pointer; background: var(--panel);
    }
    .slider-btn:hover { background: var(--hover); border-color: var(--hover); }
    .slider-btn.primary { background: var(--brand); color: #fff; border-color: var(--brand); }
    .slider-btn.primary:hover { background: #0f172a; }

    /* Responsive: stack on narrow screens */
    @media (max-width:700px) {
      .slider-cats { flex-direction: column; }
      .slider-category { border-right: none; border-bottom: 1px solid var(--line);
                         padding: 0 0 8px 0; margin: 0 0 8px 0; }
      .slider-category:last-of-type { border-bottom: none; padding-bottom: 0; margin-bottom: 0; }
    }

    /* Sensitivity bars */
    .sensitivity-panel { margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--line); }
    .sens-row { display: flex; align-items: center; gap: 6px; margin: 3px 0; font-size: 11px; }
    .sens-label { width: 70px; flex-shrink: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: var(--muted); }
    .sens-bar-track { flex: 1; height: 6px; background: var(--chip); border-radius: 3px; overflow: hidden; }
    .sens-bar-fill { height: 100%; border-radius: 3px; transition: width 0.3s ease; }
    .sens-bar-fill.positive { background: var(--accent); }
    .sens-bar-fill.negative { background: var(--warn); }
    .sens-val { min-width: 28px; text-align: right; font-size: 10px; color: var(--muted); }

    /* KPI natural language */
    .kpi-natural { font-size: 10px; font-weight: 400; color: var(--muted); margin-top: 2px; line-height: 1.3; }

    /* Recommendation banner */
    .rec-banner{margin-top:10px;padding:12px 16px;border-radius:10px;border-left:4px solid var(--muted);background:#F9FAFB;transition:border-color .3s,background .3s;}
    .rec-banner.rec-green{border-left-color:var(--good);background:#F0FDF4;}
    .rec-banner.rec-amber{border-left-color:#F59E0B;background:#FFFBEB;}
    .rec-banner.rec-red{border-left-color:#EF4444;background:#FEF2F2;}
    /* Active strategy chips row */
    #recActiveBar{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin-bottom:9px;}
    #recActiveBar .rec-label{font-size:10px;font-weight:700;color:var(--muted);letter-spacing:.05em;white-space:nowrap;margin-right:2px;}
    .rec-chip{display:inline-flex;align-items:center;gap:3px;padding:3px 9px;border-radius:12px;font-size:11px;white-space:nowrap;line-height:1.4;}
    .rec-chip.best{font-weight:700;}
    .rec-chip-gain{opacity:.8;font-size:10px;}
    /* Statement */
    .rec-statement{font-size:13px;font-weight:600;line-height:1.5;color:var(--fg);}
    /* Section headers inside banner */
    .rec-section-hdr{font-size:9px;font-weight:700;letter-spacing:.08em;color:var(--muted);text-transform:uppercase;margin:9px 0 4px;}
    /* Context / interpretation */
    .rec-context{font-size:12px;color:var(--fg);margin-top:2px;line-height:1.6;font-weight:400;}
    /* Next steps list */
    .rec-details{margin-top:2px;}
    .rec-next-row{display:flex;flex-direction:column;gap:1px;margin:5px 0;padding-left:14px;position:relative;}
    .rec-next-row::before{content:'\2192';position:absolute;left:0;top:0;font-weight:700;color:var(--cdf);font-size:12px;}
    .rec-next-action{font-size:12px;font-weight:600;color:var(--fg);line-height:1.4;}
    .rec-next-why{font-size:11px;color:var(--muted);line-height:1.45;}
    .rec-warn{color:#B45309;font-weight:600;}
    .rec-banner.rec-red .rec-warn{color:#DC2626;}
    /* Legacy compatibility */
    .rec-step{display:inline;}
    .rec-step::before{content:'\2192 ';font-weight:600;color:var(--cdf);}

    @media (max-width:900px) {
      #hypercubeSection.visible { flex-direction: column; }
    }
    @media (max-width:640px) {
      #hypercubeRadar, #hypercube3D { height: 260px !important; }
      .slider-pair { flex-wrap: wrap; }
      .slider-range { width: 100%; }
    }

    /* Live math & report */
    .live-math{display:none;margin-top:8px;}
    .live-math.active{display:block;}
    .lm-acc{border:1px solid var(--line);border-radius:12px;background:var(--panel);}
    .lm-acc-h{padding:10px;font-size:12px;font-weight:600;cursor:pointer;display:flex;justify-content:space-between;align-items:center;user-select:none;background:var(--chip);}
    .lm-acc-h:hover{background:var(--hover);}
    .lm-caret{display:inline-block;transition:transform .15s;margin-right:8px;}
    .lm-acc.open .lm-caret{transform:rotate(90deg);}
    .lm-acc-b{padding:10px;border-top:1px solid var(--line);display:none;font-size:12px;line-height:1.4;}
    .lm-acc.open .lm-acc-b{display:block;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}

    /* Reporting module styles */
    .rep-skel{opacity:.7}
    .rep-row{display:flex;gap:8px;align-items:center}
    .rep-badge{display:inline-block;border:1px solid var(--line);background:var(--chip);border-radius:999px;padding:2px 6px;font-size:11px;margin-left:6px;}
    .rep-good{color:var(--good)} .rep-bad{color:var(--bad)}
    .rep-note{font-size:12px;color:var(--muted)}
    .rep-card{border:1px solid var(--line);border-radius:10px;padding:8px;margin-top:8px;background:var(--panel)}
    .rep-tbl{width:100%;border-collapse:collapse;font-size:12px}
    .rep-tbl th,.rep-tbl td{border:1px solid var(--line);padding:6px 8px;text-align:left;vertical-align:top}
    .rep-tbl th{background:#F3F4F6;font-weight:600}
    .rep-tornado-bar { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    .rep-tornado-bar .rep-bar { display:flex; align-items:center; gap:6px; padding:0 6px; flex:1; height: 20px; background: var(--line); border-radius: 10px; position: relative; }
    .rep-tornado-bar .rep-fill { height: 100%; border-radius:  10px; }
    .rep-tornado-bar.rep-positive .rep-fill { background: var(--accent); }
    .rep-tornado-bar.rep-negative .rep-fill { background: var(--warn); }

    @media (max-width:640px){
      .wrap{padding:6px;}
      .toolbar-row{flex-wrap:wrap;gap:8px;}
      .omp-bar{font-size:11px;}
      .target-mode-toggle{font-size:11px;}
      .kpi-group{flex-direction:column;}
      .kpi{min-width:100%;}
      #pdfCanvas,#cdfCanvas{max-width:100%;}
      .plot-inner{flex-direction:column;height:auto;}
      .series-toggles{width:100%;justify-content:flex-start;margin-left:0;}
    }

    /* Help icon button */
    .plot-help-btn {
      position: absolute; top: 6px; right: 6px; z-index: 10;
      width: 24px; height: 24px; border-radius: 50%;
      border: 1px solid var(--line); background: #fff; color: var(--muted);
      font-size: 13px; font-weight: 700; line-height: 22px; text-align: center;
      cursor: pointer; transition: all .15s;
    }
    .plot-help-btn:hover { background: var(--hover); color: var(--fg); border-color: var(--hover); }

    /* Help popup */
    .plot-help-popup {
      display: none; position: absolute; top: 34px; right: 6px; z-index: 100;
      width: 340px; max-height: 400px; overflow-y: auto;
      background: #fff; border: 1px solid var(--line); border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,.14); padding: 14px 16px;
      font-size: 12px; line-height: 1.55; color: var(--fg);
    }
    .plot-help-popup.visible { display: block; }
    .plot-help-popup h4 { margin: 0 0 6px; font-size: 13px; font-weight: 700; }
    .plot-help-popup p { margin: 0 0 8px; }
    .plot-help-popup ul { margin: 4px 0 8px; padding-left: 18px; }
    .plot-help-popup li { margin-bottom: 3px; }
    .plot-help-popup .help-section { margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
    .plot-help-popup .help-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .plot-help-popup .help-stat { display: inline-block; background: #F3F4F6; padding: 2px 7px; border-radius: 4px; font-weight: 600; margin: 1px 2px; }

    /* ============================================================
       TASK MANAGER — TM Bar, Panels, Modals
    ============================================================ */

    /* TM top bar */
    #tmBar {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      background: #F8FAFF; border: 1px solid var(--line); border-radius: 10px;
      padding: 8px 12px; margin-bottom: 10px; font-size: 12px;
    }
    #tmBar .tm-mode-toggle {
      display: inline-flex; border: 1px solid var(--line); border-radius: 8px; overflow: hidden;
    }
    #tmBar .tm-mode-btn {
      padding: 5px 14px; cursor: pointer; background: var(--chip); color: var(--muted);
      border: none; font-size: 12px; font-weight: 600; transition: all .15s;
    }
    #tmBar .tm-mode-btn:hover { background: var(--hover); }
    #tmBar .tm-mode-btn.active { background: #111827; color: #fff; }
    #tmBar .tm-mode-btn + .tm-mode-btn { border-left: 1px solid var(--line); }
    #tmTaskInfo { color: var(--muted); font-size: 12px; }
    #tmDirtyBadge {
      background: #FEF9C3; border: 1px solid #FDE68A; border-radius: 5px;
      padding: 2px 8px; font-size: 11px; font-weight: 700; color: #92400E;
    }
    #tmBar .tm-actions { display: flex; gap: 6px; margin-left: auto; flex-wrap: wrap; }
    #tmBar .tm-btn {
      padding: 5px 12px; border: 1px solid var(--line); border-radius: 8px;
      background: var(--panel); font-size: 12px; font-weight: 600; cursor: pointer; min-height: 30px;
      transition: background .15s;
    }
    #tmBar .tm-btn:hover { background: var(--hover); }
    #tmBar .tm-btn.primary { background: #111827; color: #fff; border-color: #111827; }
    #tmBar .tm-btn.primary:hover { background: #374151; border-color: #374151; }
    #tmBar .tm-btn.danger { color: #DC2626; border-color: #FCA5A5; }
    #tmBar .tm-btn.danger:hover { background: #FEE2E2; }

    /* ── Three-column control card (40 / 25 / 35) ── */
    .ctrl-card { padding: 0; overflow: hidden; }
    .ctrl-3col { display: flex; align-items: stretch; }

    /* Column base */
    .ctrl-col {
      display: flex; flex-direction: column; gap: 5px;
      padding: 8px 9px 10px; min-width: 0;
    }
    .ctrl-col + .ctrl-col { border-left: 1px solid var(--line); }

    /* Column width ratios: 8 : 5 : 7 → ~40% : ~25% : ~35% */
    .ctrl-left      { flex: 8; background: #F8FAFF; }
    .ctrl-estimates { flex: 5; background: var(--panel); }
    .ctrl-query     { flex: 7; background: #F0FDF4; border-left: 2px solid #22C55E !important; }

    /* Column section title */
    .ctrl-col-label {
      display: block; font-size: 12px; font-weight: 700; color: #111827;
      letter-spacing: 0; text-transform: none;
      margin-bottom: 6px; padding-bottom: 5px; border-bottom: 1px solid var(--line);
    }
    /* Center the Set Targets label and tint its bottom border green */
    .ctrl-query .ctrl-col-label {
      text-align: center;
      border-bottom-color: #86EFAC;
      color: #166534;
    }

    /* Override #tmBar standalone-bar styles when inside ctrl-col */
    .ctrl-card #tmBar {
      display: flex; flex-direction: column; gap: 5px;
      background: transparent; border: none;
      border-radius: 0; padding: 8px 9px 10px; margin-bottom: 0;
      flex: 8;
    }

    /* Run mode toggle: full width in narrow left col */
    .ctrl-left .tm-mode-toggle { width: 100%; }
    .ctrl-left .tm-mode-btn { flex: 1; font-size: 10px; padding: 3px 4px; text-align: center; }

    /* Task selector */
    .ctrl-left select {
      width: 100%; padding: 3px 5px; border: 1px solid var(--line); border-radius: 6px;
      font-size: 10px; font-weight: 500; min-height: 24px;
    }

    /* Action buttons row */
    .ctrl-left .tm-actions { margin-left: 0; gap: 3px; flex-wrap: wrap; }
    .ctrl-left .tm-btn { padding: 3px 5px; font-size: 10px; min-height: 22px; }

    /* Status + refresh */
    .ctrl-left .status-compact { margin-left: 0; }
    .ctrl-left .status { padding: 3px 6px; font-size: 9px; min-height: 22px; flex: 1; }
    .ctrl-left #refreshBtn { min-height: 22px; padding: 3px 6px; font-size: 10px; }

    /* Task info + dirty badge */
    .ctrl-info-row { display: flex; align-items: center; gap: 4px; flex-wrap: wrap; }
    .ctrl-info-row #tmTaskInfo {
      color: var(--muted); font-size: 9px; flex: 1; min-width: 0;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }

    /* ── Estimates column ── */
    .ctrl-estimates { text-align: center; }
    .est-subtitle {
      font-size: 9px; font-style: italic; color: var(--muted);
      margin-bottom: 4px; text-align: center; letter-spacing: .01em;
    }
    .est-stack { display: flex; flex-direction: column; gap: 0; flex: 1; }
    .est-item {
      display: flex; flex-direction: column; align-items: center; padding: 5px 2px;
      border-bottom: 1px solid var(--line);
    }
    .est-item:last-child { border-bottom: none; }
    .est-item.pert { background: rgba(59,130,246,.05); border-radius: 4px; }
    /* Label row: help icon left of label text */
    .est-label-row {
      display: flex; align-items: center; justify-content: center; gap: 3px;
    }
    .est-label {
      font-size: 8px; font-weight: 700; color: var(--muted);
      letter-spacing: .03em; text-transform: uppercase; line-height: 1.2;
    }
    .est-val {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 12px; font-weight: 700; color: #111827; margin-top: 2px;
    }
    .est-item.pert .est-val { color: var(--cdf); }
    /* Pending placeholder in group mode before first run */
    .est-pending {
      font-size: 10px; color: var(--muted); text-align: center;
      padding: 10px 4px; line-height: 1.5; border: 1.5px dashed var(--line);
      border-radius: 8px; margin-top: 4px;
    }

    /* ── Query column (right, narrow) ── */
    .ctrl-query #targetPanel { gap: 5px; padding: 0; flex: 1; }

    /* Dropdown + slider + live value — one row */
    .tgt-top-row { display: flex; align-items: center; gap: 4px; flex-wrap: nowrap; }
    .tgt-mode-select {
      flex-shrink: 0; padding: 3px 4px; border: 1px solid var(--line); border-radius: 8px;
      font-size: 10px; font-weight: 600; background: var(--chip); color: #111827;
      cursor: pointer; font-family: inherit; max-width: 40%;
    }
    .tgt-slider-inline {
      display: flex; align-items: center; gap: 2px; flex: 1; min-width: 0;
    }
    .tgt-slider-inline input[type=range] { flex: 1; min-width: 30px; }
    .ctrl-query .tgt-hint { font-size: 8px; }

    /* Live value display: right of slider, inline */
    .tgt-live-val { display: none; align-items: center; gap: 2px; flex-shrink: 0; white-space: nowrap; }
    .tgt-live-val.active { display: flex; }

    /* ── Inline Group task picker ── */
    #tmGroupPicker { flex-direction: column; gap: 3px; }
    .grp-header { display: flex; align-items: center; gap: 4px; }
    .grp-count { font-size: 9px; color: #0369A1; font-weight: 700; flex: 1; }
    .grp-quick-btn {
      font-size: 9px; padding: 2px 5px; border: 1px solid var(--line); border-radius: 4px;
      background: var(--chip); cursor: pointer; font-family: inherit; color: #374151;
    }
    .grp-quick-btn:hover { background: var(--hover); }
    .grp-list {
      max-height: 90px; overflow-y: auto;
      border: 1px solid var(--line); border-radius: 6px; background: var(--panel);
    }
    .grp-task-row {
      display: flex; align-items: center; gap: 5px; padding: 4px 6px;
      border-bottom: 1px solid var(--line); font-size: 10px; cursor: pointer;
    }
    .grp-task-row:last-child { border-bottom: none; }
    .grp-task-row:hover { background: var(--hover); }
    .grp-task-row.grp-active { background: #EFF6FF; }
    .grp-task-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: #111827; font-weight: 500; }
    .grp-task-omp { font-size: 9px; color: var(--muted); font-family: monospace; white-space: nowrap; flex-shrink: 0; }
    /* Collapse task list when toggle is clicked */
    .grp-list.grp-collapsed { display: none; }

    /* Narrow input chip */
    .ctrl-query .tgt-flow-input { padding: 4px 7px; gap: 4px; border-radius: 6px; }
    .ctrl-query .tgt-input-chip { font-size: 13px !important; padding: 1px 7px !important; }

    /* Narrow result chip + extended text */
    .ctrl-query .tgt-flow-result { padding: 5px 8px; gap: 5px; border-radius: 6px; flex-wrap: wrap; }
    .ctrl-query .tgt-result-chip { font-size: 17px !important; padding: 2px 8px !important; }
    .ctrl-query .tgt-flow-result-text { font-size: 10px; }
    .tgt-result-note {
      width: 100%; font-size: 9px; color: #6B7280; font-style: italic;
      line-height: 1.3; margin-top: 2px;
    }

    /* Context band */
    .ctrl-query .tgt-context-band { font-size: 9px; }

    /* tmAggBar: footer strip inside ctrl-card */
    .ctrl-card #tmAggBar {
      margin: 0; border-radius: 0 0 12px 12px;
      border-top: 1px solid #BAE6FD;
      border-left: none; border-right: none; border-bottom: none;
    }
    .ctrl-card #tmAggBar.visible { display: flex; padding: 6px 12px; }

    /* ── Aggregate summary bar ── */
    #tmAggBar {
      display: none; align-items: center; gap: 10px; flex-wrap: wrap;
      background: #F0F9FF; border: 1px solid #BAE6FD; border-radius: 8px;
      padding: 6px 12px; margin-bottom: 8px; font-size: 12px;
    }
    #tmAggBar.visible { display: flex; }
    .tm-agg-stat { display: flex; flex-direction: column; gap: 1px; min-width: 80px; }
    .tm-agg-stat .lbl { font-size: 10px; color: #0369A1; font-weight: 600; }
    .tm-agg-stat .val { font-size: 13px; font-weight: 700; font-family: 'SF Mono', Consolas, monospace; }

    /* ── Generic modal backdrop ── */
    .tm-modal-backdrop {
      display: none; position: fixed; inset: 0; background: rgba(0,0,0,.45);
      z-index: 10000; align-items: center; justify-content: center;
    }
    .tm-modal-backdrop.open { display: flex; }
    .tm-modal {
      background: #fff; border-radius: 14px; box-shadow: 0 8px 40px rgba(0,0,0,.22);
      padding: 22px 24px; width: 90vw; max-width: 540px; max-height: 88vh;
      overflow-y: auto; position: relative; font-size: 13px;
    }
    .tm-modal.wide { max-width: 740px; }
    .tm-modal h2 { font-size: 15px; font-weight: 700; margin: 0 0 14px; }
    .tm-modal h3 { font-size: 13px; font-weight: 700; margin: 12px 0 6px; color: var(--muted); }
    .tm-modal-close {
      position: absolute; top: 14px; right: 16px; background: none; border: none;
      font-size: 18px; cursor: pointer; color: var(--muted); line-height: 1;
    }
    .tm-modal-close:hover { color: var(--fg); }
    .tm-modal-footer {
      display: flex; gap: 8px; justify-content: flex-end; margin-top: 18px;
      padding-top: 14px; border-top: 1px solid var(--line);
    }

    /* ── Buttons inside modals ── */
    .tm-btn-primary {
      padding: 7px 16px; background: #111827; color: #fff; border: none;
      border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer;
    }
    .tm-btn-primary:hover { background: #374151; }
    .tm-btn-primary:disabled { background: #9CA3AF; cursor: not-allowed; }
    .tm-btn-secondary {
      padding: 7px 16px; background: var(--panel); color: var(--fg);
      border: 1px solid var(--line); border-radius: 8px; font-size: 13px;
      font-weight: 600; cursor: pointer;
    }
    .tm-btn-secondary:hover { background: var(--chip); }
    .tm-btn-danger-outline {
      padding: 7px 16px; background: #fff; color: #DC2626;
      border: 1px solid #FCA5A5; border-radius: 8px; font-size: 13px;
      font-weight: 600; cursor: pointer;
    }
    .tm-btn-danger-outline:hover { background: #FEE2E2; }

    /* ── Form fields inside modals ── */
    .tm-field-row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px; }
    .tm-field { display: flex; flex-direction: column; gap: 4px; flex: 1; min-width: 100px; }
    .tm-field label { font-size: 11px; font-weight: 600; color: var(--muted); }
    .tm-field input, .tm-field select, .tm-field textarea {
      padding: 7px 9px; border: 1.5px solid var(--line); border-radius: 8px;
      font-size: 13px; width: 100%; background: #fff; transition: border-color .15s;
      font-family: inherit;
    }
    .tm-field input:focus, .tm-field select:focus, .tm-field textarea:focus {
      outline: none; border-color: #6366F1;
    }
    .tm-field.error input, .tm-field.error select { border-color: #DC2626; background: #FEF2F2; }
    .tm-field .field-error { font-size: 11px; color: #DC2626; margin-top: 2px; }
    .tm-field.warn input { border-color: #F59E0B; background: #FFFBEB; }
    .tm-field .field-warn { font-size: 11px; color: #B45309; margin-top: 2px; }
    .tm-field input.corrected { border-color: #10B981; background: #F0FDF4; }
    .tm-full-field { margin-bottom: 10px; }
    .tm-full-field label { display: block; font-size: 11px; font-weight: 600; color: var(--muted); margin-bottom: 4px; }

    /* ── Live triangle preview canvas ── */
    #tmTriPreview {
      width: 100%; height: 90px; border-radius: 8px; background: #F9FAFB;
      border: 1px solid var(--line); margin-top: 8px; display: block;
    }
    .tm-preview-labels {
      display: flex; justify-content: space-between; font-size: 10px;
      color: var(--muted); margin-top: 2px; padding: 0 2px;
    }

    /* ── Task list in manager panel ── */
    #tmManagerModal .tm-task-list { margin: 10px 0; }
    .tm-task-row {
      display: flex; align-items: center; gap: 8px; padding: 7px 10px;
      border: 1px solid var(--line); border-radius: 8px; margin-bottom: 6px;
      background: #fff; transition: background .1s; font-size: 12px;
      cursor: pointer;
    }
    .tm-task-row:hover { background: #F0F9FF; }
    .tm-task-row.selected { border-color: #6366F1; background: #EEF2FF; }
    .tm-task-row.dirty { border-left: 3px solid #F59E0B; }
    .tm-task-row .tm-task-name { font-weight: 600; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .tm-task-row .tm-task-vals { font-family: 'SF Mono', Consolas, monospace; font-size: 11px; color: var(--muted); white-space: nowrap; }
    .tm-task-row .tm-task-btns { display: flex; gap: 4px; flex-shrink: 0; }
    .tm-task-row .tm-task-btns button {
      padding: 3px 7px; border: 1px solid var(--line); border-radius: 5px;
      background: #fff; font-size: 11px; cursor: pointer;
    }
    .tm-task-row .tm-task-btns button:hover { background: var(--chip); }
    .tm-task-row .tm-task-btns .del-btn { color: #DC2626; border-color: #FCA5A5; }
    .tm-task-row .tm-task-btns .del-btn:hover { background: #FEE2E2; }
    .tm-active-toggle { cursor: pointer; width: 16px; height: 16px; accent-color: #111827; }
    .tm-dirty-star { color: #F59E0B; font-weight: 700; margin-left: 2px; }

    /* ── Plot Selector Bars (How It's Built + Compare Strategies tabs) ── */
    #plotSelBar, #overlaySelBar {
      display: none; align-items: center; gap: 10px; padding: 7px 12px 9px;
      margin-bottom: 6px; flex-wrap: wrap;
      border: 1px solid var(--line); border-radius: 10px; background: #F8FAFF;
    }
    #plotSelBar.visible, #overlaySelBar.visible { display: flex; }
    #plotSelBar .psel-label, #overlaySelBar .psel-label { font-size: 10px; font-weight: 700; color: var(--muted); letter-spacing: .05em; white-space: nowrap; }
    .psel-chk {
      display: inline-flex; align-items: center; gap: 5px; padding: 5px 11px;
      border: 1.5px solid var(--line); border-radius: 8px; cursor: pointer;
      background: #fff; user-select: none; transition: border-color .12s, background .12s;
    }
    .psel-chk:hover { background: var(--hover); border-color: #93C5FD; }
    .psel-chk input[type=checkbox] { accent-color: #3B82F6; width: 14px; height: 14px; cursor: pointer; flex-shrink: 0; }
    .psel-chk.checked { border-color: #3B82F6; background: #EFF6FF; }
    .psel-lbl { font-size: 12px; font-weight: 700; color: var(--fg); }
    .psel-sub { font-size: 10px; color: var(--muted); margin-left: 2px; }

    /* ── Plot panes inside plot-inner ── */
    .plot-pane {
      flex: 1 1 0; min-width: 0; height: 100%; display: flex; flex-direction: column;
    }
    .plot-pane-hdr {
      font-size: 10px; font-weight: 700; color: #64748B; text-align: center;
      letter-spacing: .04em; text-transform: uppercase;
      padding: 2px 6px 5px; border-bottom: 1px solid var(--line); margin-bottom: 4px; flex-shrink: 0;
    }
    .plot-pane > canvas { flex: 1; min-height: 0; width: 100% !important; background: #FAFAFA; }
    #triPlotCanvas { background: #F9FAFB !important; border-radius: 6px; }

    /* ── Aggregate quick-select bar in Task Manager ── */
    .agg-sel-bar {
      display: flex; align-items: center; gap: 8px; padding: 5px 0 8px;
      margin-bottom: 6px; border-bottom: 1px solid var(--line); font-size: 11px; flex-wrap: wrap;
    }
    .agg-sel-bar .agg-count { font-weight: 700; color: #0369A1; }
    .agg-sel-btn {
      font-size: 11px; padding: 3px 10px; border: 1px solid var(--line);
      border-radius: 6px; background: #fff; cursor: pointer; font-family: inherit;
    }
    .agg-sel-btn:hover { background: var(--chip); }
    .agg-header-row {
      display: flex; align-items: center; gap: 8px; padding: 3px 10px;
      font-size: 10px; font-weight: 700; color: var(--muted); letter-spacing: .03em;
      text-transform: uppercase;
    }

    /* empty state */
    .tm-empty-state {
      text-align: center; padding: 28px 16px; color: var(--muted);
      font-size: 12px; border: 2px dashed var(--line); border-radius: 10px; margin: 8px 0;
    }
    .tm-empty-state .em-icon { font-size: 28px; margin-bottom: 6px; }

    /* ── CSV import preview table ── */
    .tm-csv-table-wrap { max-height: 260px; overflow-y: auto; margin-top: 10px; border: 1px solid var(--line); border-radius: 8px; }
    .tm-csv-table { width: 100%; border-collapse: collapse; font-size: 11px; }
    .tm-csv-table th { background: #F3F4F6; padding: 5px 8px; text-align: left; font-weight: 600; position: sticky; top: 0; }
    .tm-csv-table td { padding: 4px 8px; border-top: 1px solid var(--line); vertical-align: top; }
    .tm-csv-table tr.csv-ok td { background: #F0FDF4; }
    .tm-csv-table tr.csv-warn td { background: #FFFBEB; }
    .tm-csv-table tr.csv-err td { background: #FEF2F2; }
    .csv-status-icon { font-size: 13px; }

    /* ── Column mapper ── */
    .tm-col-map-grid { display: grid; grid-template-columns: 120px 1fr; gap: 6px 10px; align-items: center; margin-top: 8px; }
    .tm-col-map-grid label { font-size: 12px; font-weight: 600; color: var(--muted); }
    .tm-col-map-grid select { padding: 5px 8px; border: 1px solid var(--line); border-radius: 6px; font-size: 12px; }

    /* ── First-run modal specifics ── */
    #tmFirstRunModal .choice-cards { display: flex; gap: 10px; margin: 12px 0; flex-wrap: wrap; }
    #tmFirstRunModal .choice-card {
      flex: 1; min-width: 160px; padding: 14px; border: 2px solid var(--line);
      border-radius: 10px; cursor: pointer; transition: border-color .15s, background .15s;
      text-align: center;
    }
    #tmFirstRunModal .choice-card:hover { border-color: #6366F1; background: #EEF2FF; }
    #tmFirstRunModal .choice-card.selected { border-color: #6366F1; background: #EEF2FF; }
    #tmFirstRunModal .choice-card .ch-icon { font-size: 24px; margin-bottom: 6px; }
    #tmFirstRunModal .choice-card .ch-title { font-weight: 700; font-size: 13px; margin-bottom: 4px; }
    #tmFirstRunModal .choice-card .ch-desc { font-size: 11px; color: var(--muted); line-height: 1.4; }

    /* ── Settings modal ── */
    #tmSettingsModal .settings-group { margin-bottom: 14px; }
    #tmSettingsModal .settings-group label { display: block; font-size: 11px; font-weight: 600; color: var(--muted); margin-bottom: 4px; }
    #tmSettingsModal .settings-group input, #tmSettingsModal .settings-group select {
      width: 100%; padding: 7px 9px; border: 1.5px solid var(--line); border-radius: 8px; font-size: 13px;
    }

    /* ── Inline validation hint ── */
    .tm-hint { font-size: 10px; color: var(--muted); margin-top: 2px; }

    /* ── Loading overlay inside modal ── */
    .tm-loading-overlay {
      display: none; position: absolute; inset: 0; background: rgba(255,255,255,.82);
      border-radius: 14px; align-items: center; justify-content: center;
      flex-direction: column; gap: 10px; z-index: 5;
    }
    .tm-loading-overlay.active { display: flex; }
    .tm-loading-spinner {
      width: 30px; height: 30px; border: 3px solid var(--line);
      border-top-color: #6366F1; border-radius: 50%;
      animation: tmSpin .8s linear infinite;
    }
    @keyframes tmSpin { to { transform: rotate(360deg); } }
    .tm-loading-msg { font-size: 12px; color: var(--muted); font-weight: 600; }

    /* ── Warnings list ── */
    .tm-warnings { background: #FFFBEB; border: 1px solid #FDE68A; border-radius: 8px; padding: 8px 10px; margin: 8px 0; font-size: 11px; }
    .tm-warnings .warn-title { font-weight: 700; color: #92400E; margin-bottom: 4px; }
    .tm-warnings ul { margin: 0; padding-left: 16px; color: #B45309; }
    .tm-warnings ul li { margin-bottom: 2px; }

    /* ── Info box ── */
    .tm-info { background: #EFF6FF; border: 1px solid #BFDBFE; border-radius: 8px; padding: 8px 10px; margin: 8px 0; font-size: 11px; color: #1E40AF; }

    /* ── Tab selector for existing sheet import ── */
    #tmTabList { max-height: 180px; overflow-y: auto; border: 1px solid var(--line); border-radius: 8px; }
    .tm-tab-item {
      padding: 8px 12px; cursor: pointer; font-size: 12px; border-bottom: 1px solid var(--line);
      display: flex; justify-content: space-between; align-items: center;
    }
    .tm-tab-item:last-child { border-bottom: none; }
    .tm-tab-item:hover { background: #F0F9FF; }
    .tm-tab-item.selected { background: #EEF2FF; font-weight: 600; }
    .tm-tab-item .tab-rows { font-size: 11px; color: var(--muted); }

    /* ── Help icons with hover tooltips ── */
    .help-icon {
      display: inline-flex; align-items: center; justify-content: center;
      width: 14px; height: 14px; border-radius: 50%;
      border: 1.5px solid var(--muted); font-size: 8px; font-weight: 800;
      cursor: help; color: var(--muted); opacity: 0.65; flex-shrink: 0;
      position: relative; vertical-align: middle; margin-left: 4px;
      font-family: inherit; line-height: 1; user-select: none;
    }
    .help-icon:hover { opacity: 1; border-color: #6366F1; color: #6366F1; }
    .help-icon .help-tip {
      display: none; position: absolute; bottom: calc(100% + 8px); left: 50%;
      transform: translateX(-50%); z-index: 9999;
      background: #1F2937; color: #F9FAFB; border-radius: 10px;
      padding: 9px 12px; font-size: 11px; line-height: 1.55; font-weight: 400;
      width: 220px; min-width: 180px; text-align: left;
      box-shadow: 0 6px 20px rgba(0,0,0,.35); white-space: normal;
      pointer-events: none;
    }
    .help-icon .help-tip::after {
      content: ''; position: absolute; top: 100%; left: 50%; transform: translateX(-50%);
      border: 6px solid transparent; border-top-color: #1F2937;
    }
    /* Flip below when tooltip would overflow above the viewport */
    .help-icon.below .help-tip {
      bottom: auto; top: calc(100% + 8px);
    }
    .help-icon.below .help-tip::after {
      top: auto; bottom: 100%; border-top-color: transparent; border-bottom-color: #1F2937;
    }
    .help-icon:hover .help-tip { display: block; }

    /* Tooltip right-anchored when icon is near left edge */
    .help-icon.tip-right .help-tip { left: 0; transform: none; }
    .help-icon.tip-right .help-tip::after { left: 12px; transform: none; }
    /* Tooltip left-anchored when icon is near right edge */
    .help-icon.tip-left .help-tip { left: auto; right: 0; transform: none; }
    .help-icon.tip-left .help-tip::after { left: auto; right: 12px; transform: none; }

    /* KPI tile title row: flex so help icon sits right of label */
    .kpi .ttl { display: flex; align-items: center; gap: 0; }
  </style>
</head>

<body>
  <!-- Page loader: shows during initial workspace load, hides once tasks arrive -->
  <div id="pageLoader" style="position:fixed;inset:0;background:rgba(255,255,255,.93);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;z-index:800;">
    <div style="width:38px;height:38px;border:4px solid #E5E7EB;border-top-color:#6366F1;border-radius:50%;animation:loaderSpin .8s linear infinite;"></div>
    <div style="font-size:13px;color:#6B7280;font-weight:600;letter-spacing:.01em;">Loading workspace…</div>
  </div>
  <style>@keyframes loaderSpin{to{transform:rotate(360deg);}}</style>

  <div id="errorBanner" style="display:none;background:#FEE2E2;color:#991B1B;padding:8px 12px;font-size:12px;font-family:monospace;position:fixed;top:0;left:0;right:0;z-index:9999;max-height:200px;overflow-y:auto;border-bottom:2px solid #DC2626;"></div>
  <script>
  window.onerror = function(msg, url, line, col) {
    var b = document.getElementById('errorBanner');
    if (b) { b.style.display = 'block'; b.innerHTML += '<div>JS Error: ' + msg + ' (line ' + line + ':' + col + ')</div>'; }
    return false;
  };
  </script>
  <div class="wrap">
    <h1 title="Probability Plots Dashboard">Probability Plots</h1>

<!-- ── CONTROL CARD: 3 columns (40 / 25 / 35) ── -->
<div class="card ctrl-card">
  <div class="ctrl-3col">

    <!-- LEFT (40%): Task controls -->
    <div class="ctrl-col ctrl-left" id="tmBar">
      <span class="ctrl-col-label">Select Task <span class="help-icon" style="font-size:8px;width:12px;height:12px;" data-title="Select Task" data-body="Choose a task from your data source to analyze. Single mode: analyze one task at a time using its 3-point estimate. Group mode: select multiple tasks to combine via Monte Carlo simulation into one aggregate distribution.">?</span></span>

      <div class="tm-mode-toggle" title="Single: analyze one task at a time. Group: combine selected tasks into one distribution.">
        <button class="tm-mode-btn active" id="tmModeSingle" onclick="TM.setMode('single')" title="Analyze one task at a time">Single</button>
        <button class="tm-mode-btn" id="tmModeAggregate" onclick="TM.setMode('aggregate')" title="Combine selected tasks into one distribution">Group</button>
      </div>

      <!-- Single mode: one-task dropdown -->
      <select id="taskSel" title="Select a task"></select>

      <!-- Group mode: inline multi-select checklist (shown when mode = aggregate) -->
      <div id="tmGroupPicker" style="display:none;">
        <div class="grp-header">
          <span class="grp-count" id="grpCount">0 selected</span>
          <button class="grp-quick-btn" onclick="TM._aggSelectAll(true)" title="Select all tasks">All</button>
          <button class="grp-quick-btn" onclick="TM._aggSelectAll(false)" title="Deselect all tasks">None</button>
          <button class="grp-quick-btn" id="grpToggleBtn" onclick="TM._toggleGroupList()" title="Expand/collapse task list">Collapse</button>
        </div>
        <div class="grp-list" id="grpList"></div>
      </div>

      <div class="tm-actions">
        <button class="tm-btn" id="btnManageTasks" onclick="TM.openManager()" title="View, add, edit tasks. In Group mode: select which tasks to include.">Data Source</button>
        <button class="tm-btn" id="btnTMSettings" onclick="TM.openSettings()" title="Task Manager settings">&#9881;</button>
        <button class="tm-btn primary" id="btnSaveRun" style="display:none;" onclick="TM.saveAndRun()">Save &amp; Run</button>
        <button class="tm-btn danger" id="btnDiscard" style="display:none;" onclick="TM.discard()">Discard</button>
      </div>

      <div class="status-compact">
        <span id="fetchStatus" class="status">Ready</span>
        <button id="refreshBtn" class="primary">&#x21bb;</button>
      </div>

      <div class="ctrl-info-row">
        <span id="tmTaskInfo">Initializing…</span>
        <span id="tmDirtyBadge" style="display:none;">&#9679; Unsaved</span>
      </div>
    </div>

    <!-- MIDDLE (25%): Estimates — single OMP or aggregate stats, dynamic -->
    <div class="ctrl-col ctrl-estimates">
      <span class="ctrl-col-label">Estimates</span>
      <div class="est-subtitle" id="estSubtitle">Single task</div>

      <!-- SINGLE MODE: O / M / P / PERT Mean -->
      <div class="est-stack" id="estSingleStack">
        <div class="est-item">
          <div class="est-label-row">
            <span class="help-icon" data-title="Optimistic Estimate" data-body="Best-case scenario — minimum reasonable estimate if everything goes well. Represents the fastest or cheapest plausible outcome.">?</span>
            <span class="est-label">Optimistic</span>
          </div>
          <span class="est-val" id="oVal">–</span>
        </div>
        <div class="est-item">
          <div class="est-label-row">
            <span class="help-icon" data-title="Most Likely Estimate" data-body="Most realistic scenario — what you'd expect under normal conditions. This value receives 4× the weight in the PERT formula.">?</span>
            <span class="est-label">Most Likely</span>
          </div>
          <span class="est-val" id="mVal">–</span>
        </div>
        <div class="est-item">
          <div class="est-label-row">
            <span class="help-icon" data-title="Pessimistic Estimate" data-body="Worst-case scenario — maximum reasonable estimate if things go poorly. Represents the slowest or most expensive plausible outcome.">?</span>
            <span class="est-label">Pessimistic</span>
          </div>
          <span class="est-val" id="pVal">–</span>
        </div>
        <div class="est-item pert">
          <div class="est-label-row">
            <span class="help-icon" data-title="PERT Mean" data-body="PERT weighted average: (O + 4×M + P) ÷ 6. Extra weight on Most Likely produces a realistic expected mean. More accurate than a simple average of the three points.">?</span>
            <span class="est-label">PERT Mean</span>
          </div>
          <span class="est-val" id="pertVal">–</span>
        </div>
      </div>

      <!-- GROUP MODE (after run): combined distribution stats -->
      <div class="est-stack" id="estAggStack" style="display:none;">
        <div class="est-item">
          <div class="est-label-row">
            <span class="help-icon" data-title="Task Count" data-body="Number of tasks combined in this Group simulation. Each task's 3-point estimate is simulated independently and their results are summed to form the aggregate distribution.">?</span>
            <span class="est-label">Tasks</span>
          </div>
          <span class="est-val" id="aggStatTasks">–</span>
        </div>
        <div class="est-item">
          <div class="est-label-row">
            <span class="help-icon" data-title="Aggregate Mean" data-body="Average outcome across all 5,000 Monte Carlo simulations of the combined tasks. This is the expected total if all selected tasks run simultaneously.">?</span>
            <span class="est-label">Mean</span>
          </div>
          <span class="est-val" id="aggStatMean">–</span>
        </div>
        <div class="est-item">
          <div class="est-label-row">
            <span class="help-icon" data-title="P50 — Median" data-body="50th percentile: there is a 50% probability of finishing at or below this value. This is the median outcome of the combined simulation. A balanced, unbiased reference point.">?</span>
            <span class="est-label">P50</span>
          </div>
          <span class="est-val" id="aggStatP50">–</span>
        </div>
        <div class="est-item">
          <div class="est-label-row">
            <span class="help-icon" data-title="P80 — Risk-Adjusted" data-body="80th percentile: 80% probability of finishing at or below this value. Industry standard for risk-adjusted planning commitments. Use this when presenting to sponsors or stakeholders who expect realistic accountability.">?</span>
            <span class="est-label">P80</span>
          </div>
          <span class="est-val" id="aggStatP80">–</span>
        </div>
        <div class="est-item">
          <div class="est-label-row">
            <span class="help-icon" data-title="P90 — High Confidence" data-body="90th percentile: 90% probability of finishing at or below this value. Used for high-confidence external commitments and contractual guarantees where the cost of overrun is significant.">?</span>
            <span class="est-label">P90</span>
          </div>
          <span class="est-val" id="aggStatP90">–</span>
        </div>
        <div class="est-item pert">
          <div class="est-label-row">
            <span class="help-icon" data-title="P(≤τ) — Target Probability" data-body="Probability of finishing at or below your target value (τ) based on the combined group distribution. Set your target value or probability in the Set Targets column on the left.">?</span>
            <span class="est-label">P(≤τ)</span>
          </div>
          <span class="est-val" id="aggStatProb">–</span>
        </div>
      </div>

      <!-- Awaiting first group run -->
      <div class="est-pending" id="estAggPending" style="display:none;">
        Check tasks above,<br>then Save &amp; Run ▶
      </div>
    </div>

    <!-- RIGHT (35%): Query — causal flow, narrow column -->
    <div class="ctrl-col ctrl-query">
      <span class="ctrl-col-label">Set Targets <span class="help-icon" style="font-size:8px;width:12px;height:12px;" data-title="Set Targets" data-body="Interactively explore your probability distribution. Value mode: drag the slider to a target value — see the probability of finishing within it. Probability mode: set a desired probability — see what value achieves it. Results reflect your original estimate (baseline). For other strategies, see the Compare Strategies tab.">?</span></span>
      <div id="targetPanel">

        <!-- Mode dropdown + slider + live value — all on one row -->
        <div class="tgt-top-row" id="tgtModeCards">
          <select class="tgt-mode-select" id="tgtModeSelect"
                  onchange="onTargetModeSwitch(this.value)"
                  title="Switch between setting a target value or a target probability">
            <option value="value" id="tgtCardValue" class="target-mode-btn" data-mode="value">Target value</option>
            <option value="probability" id="tgtCardProb" class="target-mode-btn" data-mode="probability">Target probability</option>
          </select>
          <div class="tgt-slider-inline" id="tgtSliderRow">
            <span class="tgt-hint">&#x25C4;</span>
            <input id="targetSlider" type="range" min="-10" max="110" step="any" value="50"
                   title="Drag to explore — target and result update live" />
            <span class="tgt-hint">&#x25BA;</span>
            <span id="tgtSliderContext" style="display:none;"></span>
          </div>
          <!-- Live value display: right of slider -->
          <div class="tgt-live-val active" id="tgtInputValue">
            <span class="tgt-chip tgt-val tgt-input-chip" id="targetValDisplay">–</span>
            <span class="tgt-flow-units" id="tgtUnitsHint1"></span>
          </div>
          <div class="tgt-live-val" id="tgtInputProb">
            <span class="tgt-chip tgt-prob tgt-input-chip" id="tgtProbAlt">–</span>
          </div>
        </div>

        <!-- RESULT: the derived answer -->
        <div class="tgt-flow-result active" id="tgtSentValue">
          <span class="tgt-chip tgt-prob tgt-result-chip" id="targetProbDisplay">–</span>
          <span class="tgt-flow-result-text">chance of completion based on your original values.</span>
          <span class="tgt-result-note">See Compare Strategies tab for values based on other strategies.</span>
        </div>
        <div class="tgt-flow-result" id="tgtSentProb">
          <span class="tgt-chip tgt-val tgt-result-chip" id="tgtValAlt">–</span>
          <span class="tgt-flow-units" id="tgtUnitsHint2"></span>
          <span class="tgt-flow-result-text">required to hit this probability based on your original values.</span>
          <span class="tgt-result-note">See Compare Strategies tab for values based on other strategies.</span>
        </div>

        <!-- Context band: PERT mean + distance from mean -->
        <div id="tgtAnswerRow" class="tgt-context-band">
          <span id="tgtAnswerLabel" style="display:none;"></span>
          <span id="tgtMeanCtx"></span>
        </div>
      </div>
    </div>

  </div><!-- /.ctrl-3col -->

  <!-- Aggregate stats bar retired — stats now shown in Estimates column -->
  <div id="tmAggBar" style="display:none!important;"></div>
</div>

<!-- TABS + KPI GROUP -->
<div class="tabs" id="tabs">
  <div class="tab active" data-tab="progress" title="See how your 3-point estimate builds into a probability distribution, step by step.">How It's Built</div>
  <div class="tab" data-tab="overlay" title="Compare your estimate against Conservative Optimization, General Optimization, and Unconstrained Optimization scenarios to find the best strategy.">Compare Strategies</div>
  <div class="series-toggles" id="seriesToggles">
    <div class="toggle-group baseline-group">
      <button class="tg" id="rowTglBase" role="switch" aria-pressed="true" title="Toggle Your Estimate curve">Your Estimate</button>
      <button class="tg" id="rowTglAdaptive" role="switch" aria-pressed="false" title="Conservative Optimization — tightest SACO constraints, most defensible">Conservative<br><span style="font-size:10px;font-weight:400;opacity:.75;">Optimization</span></button>
    </div>
    <div class="toggle-group manual-group">
      <button class="tg" id="rowTglFixed" role="switch" aria-pressed="false" title="General Optimization — standard SACO constraints, wider search space">General<br><span style="font-size:10px;font-weight:400;opacity:.75;">Optimization</span></button>
      <button class="tg" id="rowTglManual" role="switch" aria-pressed="false" title="Unconstrained Optimization — no bounds, drag sliders freely for what-if analysis">Unconstrained<br><span style="font-size:10px;font-weight:400;opacity:.75;">Optimization</span></button>
    </div>

  </div>

  <div class="kpi-group" id="distTiles" style="display:flex; margin-left:auto;">
    <div class="kpi" id="kpiTriangle" title="Triangle">
      <div class="ttl">Triangle</div>
      <div class="val" style="color:var(--tri);">Curve</div>
    </div>
    <div class="kpi" id="kpiBeta" title="Beta-PERT">
      <div class="ttl">Beta-PERT</div>
      <div class="val" style="color:var(--beta);">Curve</div>
    </div>
    <div class="kpi baseline" id="kpiBaseDist" title="Baseline (Monte Carlo)">
      <div class="ttl">Baseline</div>
      <div class="val" style="color:var(--base);">Curve</div>
    </div>
  </div>
</div>

<!-- Progress tab description banner — shows under "How It's Built" tab -->
<div id="progressDescBanner" class="rec-banner" style="display:none;border-left-color:var(--cdf);background:#EFF6FF;">
  <div class="rec-statement" id="progressDescStatement"></div>
  <div class="rec-context" id="progressDescContext"></div>
</div>

<!-- KPI tiles for overlay — ordered: Baseline → Adaptive (strictest) → Fixed (standard) → Manual (unconstrained) -->
<div class="card" id="overlayKpis" style="display:none;">
  <div class="kpi-group">
    <div class="kpi baseline inactive" id="kpiBaseline">
      <div class="ttl">
        Your Estimate
        <span class="help-icon" data-title="Your Estimate (Baseline)" data-body="Your original 3-point estimate (Optimistic / Most Likely / Pessimistic) with no optimization applied. This is your starting point — all other strategies are compared against it. The probability shown reflects this estimate only.">?</span>
      </div>
      <div class="val">–</div>
    </div>
    <div class="kpi adaptive inactive" id="kpiAdaptive">
      <div class="ttl">
        Conservative Opt.
        <span class="help-icon" data-title="Conservative Optimization" data-body="Finds the best probability improvement while staying within tight, industry best-practice constraints at your chosen Level (1–7). Both Conservative and General Optimization use the same SACO engine — the difference is constraint tightness. Conservative is the most defensible and standards-aligned strategy. Best for regulated projects or risk-averse stakeholders.">?</span>
      </div>
      <div class="val">–</div>
    </div>
    <div id="probeBox" class="chip" style="display:none; align-items:center; gap:6px; min-height:36px; padding:6px 10px;">
      <span style="font-weight:600;">Level:</span>
      <span class="help-icon" data-title="Optimization Level (1–7)" data-body="Conservative Optimization constraint tightness. Level 1 = minimal constraints (wider exploration, more probability uplift). Level 7 = tightest best-practice constraints (most defensible, less uplift). Start at Level 3; increase for high-risk or regulated environments.">?</span>
      <select id="probeSelect" style="font-size:12px; padding:4px 6px; border:1px solid var(--line); border-radius:8px; height:28px;">
        <option value="1">1</option><option value="2">2</option><option value="3" selected>3</option>
        <option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option>
      </select>
    </div>
    <div class="kpi optimized inactive" id="kpiOptimized">
      <div class="ttl">
        General Opt.
        <span class="help-icon" data-title="General Optimization" data-body="Uses the same SACO engine as Conservative Optimization but with wider, standard-boundary constraints to find the maximum probability improvement. Typically shows higher probability than Conservative — but less defensible for external reporting. Best for internal planning and feasibility analysis.">?</span>
      </div>
      <div class="val">–</div>
    </div>
    <div class="kpi adjusted inactive" id="kpiAdjusted">
      <div class="ttl">
        Unconstrained
        <span class="help-icon" data-title="Unconstrained Optimization" data-body="No slider bounds — you control all 7 Decision Sliders freely to explore any combination beyond best-practice limits. Ideal for sensitivity analysis, stress-testing, and best-case planning. Not intended for external reporting.">?</span>
      </div>
      <div class="val">–</div>
    </div>
  </div>

  <!-- Decision Sliders — between strategy tabs and recommendations -->
  <div id="sliderSidebar" role="complementary" aria-label="Decision Sliders">
    <div id="slidersPanel" class="sliders-panel">
      <!-- Panel header: title · note · impact result -->
      <div class="slider-panel-hdr">
        <div class="title" id="sliderTitle">Decision Sliders</div>
        <div class="note" id="optimizeNote">Adjust levers to reshape the distribution (Unconstrained), or read optimal values for active strategies.</div>
        <div id="sliderImpactBanner" style="display:none;"></div>
      </div>

      <!-- Quick preset row: visible at top so users find it before scrolling -->
      <div class="slider-preset-row">
        <span class="slider-preset-label">Unconstrained starting point:</span>
        <div class="slider-actions" style="margin-top:0;">
          <button id="resetBaseline" class="slider-btn" title="Reset all 7 Decision Sliders to zero — removes any manual adjustments">Reset Sliders To Zero</button>
          <button id="matchOptimized" class="slider-btn primary" title="Copy the General Optimization slider values into your Unconstrained starting point">Reset Sliders To General Optimization</button>
        </div>
      </div>

      <!-- Horizontal category columns — Capacity | Certainty | Process | Behavioral -->
      <div class="slider-cats">

      <!-- Capacity -->
      <div class="slider-category" data-cat="capacity">
        <div class="cat-header" style="color:var(--cat-capacity)">Capacity</div>
        <div class="slider-row" data-key="budgetFlexibility">
          <div class="slider-label-row">
            <button class="slider-help-btn" data-slider-help="budgetFlexibility" aria-label="Help: Budget Flexibility">?</button>
            <label for="s_budget">Budget Flexibility</label>
          </div>
          <div class="slider-pair">
            <input type="range" id="s_budget_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Budget Flexibility slider">
            <input type="number" id="s_budget" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_budget_marker"></div>
        </div>
        <div class="slider-row" data-key="scheduleFlexibility">
          <div class="slider-label-row">
            <button class="slider-help-btn" data-slider-help="scheduleFlexibility" aria-label="Help: Schedule Flexibility">?</button>
            <label for="s_schedule">Schedule Flexibility</label>
          </div>
          <div class="slider-pair">
            <input type="range" id="s_schedule_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Schedule Flexibility slider">
            <input type="number" id="s_schedule" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_schedule_marker"></div>
        </div>
      </div>

      <!-- Certainty -->
      <div class="slider-category" data-cat="certainty">
        <div class="cat-header" style="color:var(--cat-certainty)">Certainty</div>
        <div class="slider-row" data-key="scopeCertainty">
          <div class="slider-label-row">
            <button class="slider-help-btn" data-slider-help="scopeCertainty" aria-label="Help: Scope Certainty">?</button>
            <label for="s_scopeCert">Scope Certainty</label>
          </div>
          <div class="slider-pair">
            <input type="range" id="s_scopeCert_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Scope Certainty slider">
            <input type="number" id="s_scopeCert" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_scopeCert_marker"></div>
        </div>
        <div class="slider-row" data-key="scopeReductionAllowance">
          <div class="slider-label-row">
            <button class="slider-help-btn" data-slider-help="scopeReductionAllowance" aria-label="Help: Scope Reduction">?</button>
            <label for="s_scopeRed">Scope Reduction</label>
          </div>
          <div class="slider-pair">
            <input type="range" id="s_scopeRed_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Scope Reduction slider">
            <input type="number" id="s_scopeRed" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_scopeRed_marker"></div>
        </div>
      </div>

      <!-- Process -->
      <div class="slider-category" data-cat="process">
        <div class="cat-header" style="color:var(--cat-process)">Process</div>
        <div class="slider-row" data-key="reworkPercentage">
          <div class="slider-label-row">
            <button class="slider-help-btn" data-slider-help="reworkPercentage" aria-label="Help: Rework Percentage">?</button>
            <label for="s_rework">Rework Percentage</label>
          </div>
          <div class="slider-pair">
            <input type="range" id="s_rework_range" min="0" max="50" step="1" value="0" class="slider-range" aria-label="Rework Percentage slider">
            <input type="number" id="s_rework" min="0" max="50" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_rework_marker"></div>
        </div>
      </div>

      <!-- Behavioral -->
      <div class="slider-category" data-cat="behavioral">
        <div class="cat-header" style="color:var(--cat-behavioral)">Behavioral</div>
        <div class="slider-row" data-key="riskTolerance">
          <div class="slider-label-row">
            <button class="slider-help-btn" data-slider-help="riskTolerance" aria-label="Help: Risk Tolerance">?</button>
            <label for="s_risk">Risk Tolerance</label>
          </div>
          <div class="slider-pair">
            <input type="range" id="s_risk_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Risk Tolerance slider">
            <input type="number" id="s_risk" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_risk_marker"></div>
        </div>
        <div class="slider-row" data-key="userConfidence">
          <div class="slider-label-row">
            <button class="slider-help-btn" data-slider-help="userConfidence" aria-label="Help: User Confidence">?</button>
            <label for="s_userConf">User Confidence</label>
          </div>
          <div class="slider-pair">
            <input type="range" id="s_userConf_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="User Confidence slider">
            <input type="number" id="s_userConf" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_userConf_marker"></div>
        </div>
      </div>

      </div><!-- /.slider-cats -->

      <div id="slidersNoteMissing" class="note" style="display:none;">Server did not return optimal slider values.</div>
    </div>

    <!-- Sensitivity bars -->
    <div id="sensitivityBars" class="sensitivity-panel" style="display:none;">
      <div class="cat-header" style="color:var(--muted)">Sensitivity (Relative Impact)</div>
      <div id="sensitivityContent"></div>
    </div>
  </div>

  <div id="recBanner" class="rec-banner" style="display:none;">
    <div id="recActiveBar"></div>
    <div class="rec-statement" id="recStatement"></div>
    <div class="rec-context" id="recContext"></div>
    <div class="rec-details" id="recDetails"></div>
  </div>
</div>

<!-- Probability Summary Bar: τ · Baseline P₀ · one chip per active strategy -->
<div id="probSummaryBar" style="display:none; flex-wrap:wrap; gap:6px; align-items:center; padding:6px 12px; margin-bottom:6px; background:rgba(248,250,255,0.97); border:1px solid rgba(148,163,184,0.30); border-radius:8px; font-size:11px; line-height:1;">
  <span style="font-size:10px; color:#94a3b8; font-weight:600; white-space:nowrap; margin-right:2px;">AT TARGET:</span>
  <span id="psbTau"       style="padding:2px 8px; border-radius:12px; background:#FEF3C7; color:#92400E; border:1px solid rgba(245,158,11,0.45); font-weight:700; white-space:nowrap;"></span>
  <span id="psbBase"      style="padding:2px 8px; border-radius:12px; background:#F1F5F9; color:#475569; border:1px solid rgba(148,163,184,0.40); font-weight:600; white-space:nowrap;"></span>
  <span id="psbGuided"    style="display:none; padding:2px 8px; border-radius:12px; background:rgba(139,92,246,0.08); color:#6d28d9; border:1px solid rgba(139,92,246,0.40); font-weight:600; white-space:nowrap;"></span>
  <span id="psbOptimized" style="display:none; padding:2px 8px; border-radius:12px; background:rgba(59,130,246,0.08); color:#1d4ed8; border:1px solid rgba(59,130,246,0.40); font-weight:600; white-space:nowrap;"></span>
  <span id="psbExplorer"  style="display:none; padding:2px 8px; border-radius:12px; background:rgba(16,185,129,0.08); color:#065f46; border:1px solid rgba(16,185,129,0.40); font-weight:600; white-space:nowrap;"></span>
</div>

<!-- Main plot container -->
<div class="plot-container" id="plotContainer">

  <!-- Main content area -->
  <div class="plot-main">
    <!-- Main PDF/CDF plots -->
    <div class="plots">

      <!-- ── Plot Selector Bar — visible in "How It's Built" tab only ── -->
      <div id="plotSelBar">
        <span class="psel-label">SHOW PLOTS:</span>
        <label class="psel-chk checked" id="pselChkTriangle" title="Triangle Distribution — the raw triangle shape of your 3-point estimate (O / M / P)">
          <input type="checkbox" id="pselTriangle" checked onchange="pselUpdate()">
          <span class="psel-lbl">Triangle</span><span class="psel-sub">3-pt shape</span>
        </label>
        <label class="psel-chk" id="pselChkPDF" title="PDF — Probability Density Function. Shows how probability mass is distributed across values.">
          <input type="checkbox" id="pselPDF" onchange="pselUpdate()">
          <span class="psel-lbl">PDF</span><span class="psel-sub">Density curve</span>
        </label>
        <label class="psel-chk" id="pselChkCDF" title="CDF — Cumulative Distribution Function. Shows P(X ≤ value) — probability at or below any target.">
          <input type="checkbox" id="pselCDF" onchange="pselUpdate()">
          <span class="psel-lbl">CDF</span><span class="psel-sub">Cumulative P</span>
        </label>
        <span style="font-size:10px;color:var(--muted);margin-left:auto;white-space:nowrap;">1 plot = full width · 2+ = side-by-side</span>
      </div>

      <!-- ── Plot Selector Bar — visible in "Compare Strategies" tab only ── -->
      <!-- Default: CDF only — shows P(finish ≤ target) per strategy at a glance. -->
      <div id="overlaySelBar">
        <span class="psel-label">SHOW PLOTS:</span>
        <label class="psel-chk checked" id="oselChkCDF" title="CDF — Cumulative P(finish ≤ target) for all active strategies. Best default for strategy comparison.">
          <input type="checkbox" id="oselCDF" checked onchange="overlayPselUpdate()">
          <span class="psel-lbl">CDF</span><span class="psel-sub">Cumulative P</span>
        </label>
        <label class="psel-chk" id="oselChkPDF" title="PDF — Probability Density showing how estimate mass shifts per strategy.">
          <input type="checkbox" id="oselPDF" onchange="overlayPselUpdate()">
          <span class="psel-lbl">PDF</span><span class="psel-sub">Density curve</span>
        </label>
        <label class="psel-chk" id="oselChkRadar" title="Radar — 7-axis spider chart comparing slider profiles across strategies.">
          <input type="checkbox" id="oselRadar" onchange="overlayPselUpdate()">
          <span class="psel-lbl">Radar</span><span class="psel-sub">Slider profile</span>
        </label>
        <label class="psel-chk" id="oselChkHypercube" title="Hypercube — rotating 3D projection of the 7-dimensional parameter space. Each vertex is a slider combination.">
          <input type="checkbox" id="oselHypercube" onchange="overlayPselUpdate()">
          <span class="psel-lbl">Hypercube</span><span class="psel-sub">3D space</span>
        </label>
        <label class="psel-chk" id="oselChkSaco" title="SACO 3D — 3D probability surface showing baseline vs strategy distribution lift. Requires a strategy to be active.">
          <input type="checkbox" id="oselSaco" onchange="overlayPselUpdate()">
          <span class="psel-lbl">SACO 3D</span><span class="psel-sub">Surface lift</span>
        </label>
        <label class="psel-chk" id="oselChkSphere" title="Sphere — spherical cap fill visualization mapping probability to fill height.">
          <input type="checkbox" id="oselSphere" onchange="overlayPselUpdate()">
          <span class="psel-lbl">Sphere</span><span class="psel-sub">Fill viz</span>
        </label>
      </div>

      <div class="plot" style="position:relative;">
        <!-- Mode context strip — shows which task or group is active -->
        <div id="modeContextStrip" style="display:none; align-items:center; gap:6px; padding:2px 8px 4px; font-size:10px; color:#64748B; font-weight:600; letter-spacing:.03em; text-transform:uppercase; border-bottom:1px solid var(--line); margin-bottom:2px;">
          <span id="modeContextBadge" style="padding:2px 7px; border-radius:10px; font-size:10px; font-weight:700;"></span>
          <span id="modeContextLabel"></span>
        </div>
        <div style="display:flex; justify-content:flex-end; padding:0 4px 4px 0; gap:6px; align-items:center;">
          <button class="plot-help-btn" data-help="distributions" title="What do these charts show?" style="position:static;">?</button>
        </div>
        <div id="distributionsHelpPopup" class="plot-help-popup"></div>
        <div class="plot-inner" id="plotInner">
          <!-- Triangle pane — shown when "Triangle" is checked in How It's Built tab -->
          <div class="plot-pane" id="triWrap" style="display:none;">
            <div class="plot-pane-hdr">Triangle Distribution</div>
            <canvas id="triPlotCanvas"></canvas>
          </div>
          <!-- PDF pane -->
          <div class="plot-pane" id="pdfWrap">
            <div class="plot-pane-hdr" id="pdfPaneHdr" style="display:flex;align-items:center;gap:6px;">
              <span style="flex:1;">Probability Density (PDF)</span>
              <button id="zoomBtn_pdf" onclick="togglePlotZoom('pdf')" title="Toggle scroll-to-zoom / drag-to-pan on PDF chart" style="font-size:10px;padding:2px 7px;border:1.5px solid var(--line);border-radius:5px;background:#fff;cursor:pointer;color:#6B7280;white-space:nowrap;">Zoom</button>
            </div>
            <canvas id="pdfCanvas" title="Probability Density Function (PDF)"></canvas>
          </div>
          <!-- CDF pane -->
          <div class="plot-pane" id="cdfWrap">
            <div class="plot-pane-hdr" id="cdfPaneHdr" style="display:flex;align-items:center;gap:6px;">
              <span style="flex:1;">Cumulative Distribution (CDF)</span>
              <button id="zoomBtn_cdf" onclick="togglePlotZoom('cdf')" title="Toggle scroll-to-zoom / drag-to-pan on CDF chart" style="font-size:10px;padding:2px 7px;border:1.5px solid var(--line);border-radius:5px;background:#fff;cursor:pointer;color:#6B7280;white-space:nowrap;">Zoom</button>
            </div>
            <canvas id="cdfCanvas" title="Cumulative Distribution Function (CDF)"></canvas>
          </div>
          <div class="right-legend" id="rightLegend" aria-live="polite"></div>
        </div>

        <div class="legend" id="legendOverlay">
          <span><span class="legend-dot dot-base"></span>Your Estimate</span>
          <span><span class="legend-dot dot-man"></span>Unconstrained</span>
          <span><span class="legend-dot dot-fix"></span>General Opt.</span>
          <span><span class="legend-dot dot-adp"></span>Conservative</span>
        </div>
        <div class="legend" id="legendDistributions" style="display:flex;">
          <span><span class="legend-dot dot-tri"></span>Triangle</span>
          <span><span class="legend-dot dot-beta"></span>Beta-PERT</span>
          <span><span class="legend-dot dot-base"></span>Your Estimate</span>
        </div>

        <div id="plotMsg" class="warn" style="display:none;"></div>
        <div id="chartDesc" class="plot-desc" style="display:none;"></div>
      </div>
    </div>

    <!-- Hypercube Radar - separate card below the main plots -->
    <div id="hypercubeSection">
      <div id="radarCard" class="card" style="position:relative;">
        <button class="plot-help-btn" data-help="radar" title="What does this chart show?">?</button>
        <button id="zoomBtn_radar" onclick="togglePlotZoom('radar')" title="Toggle scroll-to-zoom / drag-to-pan on Slider Profile chart" style="position:absolute;top:8px;right:42px;font-size:10px;padding:2px 7px;border:1.5px solid var(--line);border-radius:5px;background:#fff;cursor:pointer;color:#6B7280;z-index:2;">Zoom</button>
        <div id="radarHelpPopup" class="plot-help-popup"></div>
        <div class="plot-title">Slider Profile</div>
        <canvas id="hypercubeRadar"></canvas>
        <div id="radarSubtitle" class="plot-subtitle"></div>
        <div id="radarDesc" class="plot-desc" style="display:none;"></div>
      </div>
      <div id="hypercube3DCard" class="card" style="position:relative;">
        <button class="plot-help-btn" data-help="hypercube" title="What does this chart show?">?</button>
        <button id="zoomBtn_hypercube3d" onclick="togglePlotZoom('hypercube3d')" title="Toggle orbit controls on Parameter Space 3D" style="position:absolute;top:8px;right:42px;font-size:10px;padding:2px 7px;border:1.5px solid var(--line);border-radius:5px;background:#fff;cursor:pointer;color:#6B7280;z-index:2;">Zoom</button>
        <div id="hypercubeHelpPopup" class="plot-help-popup"></div>
        <div class="plot-title">Parameter Space (3D)</div>
        <canvas id="hypercube3D"></canvas>
        <div id="hypercubeSubtitle" class="plot-subtitle"></div>
        <div id="hypercubeDesc" class="plot-desc" style="display:none;"></div>
      </div>
    </div>

    <!-- SACO 3D Surface + Probability Sphere (visible in Compare Strategies tab only) -->
    <div id="sacoVizSection" style="display:none; margin-top:12px;">
      <div style="display:flex;gap:14px;flex-wrap:wrap;align-items:flex-start;">

        <!-- Left: SACO 3D Probability Surface (Three.js) -->
        <div id="saco3dOuterWrap" style="flex:3;min-width:0;">
          <div class="card" style="padding:12px 14px;">
            <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;flex-wrap:wrap;">
              <div style="font-size:13px;font-weight:700;">SACO 3D Probability Surface</div>
              <div id="saco3dStratLabel" style="font-size:11px;color:var(--muted);margin-left:auto;"></div>
              <button id="zoomBtn_saco3d" onclick="togglePlotZoom('saco3d')" title="Toggle orbit controls — scroll to zoom, drag to rotate" style="font-size:10px;padding:2px 7px;border:1.5px solid var(--line);border-radius:5px;background:#fff;cursor:pointer;color:#6B7280;white-space:nowrap;">Zoom</button>
            </div>
            <!-- HUD metrics -->
            <div id="saco3dHud" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:4px;font-size:11px;font-family:ui-monospace,monospace;">
              <div style="padding:4px 8px;border-radius:6px;background:#F3F4F6;border:1px solid var(--line);">
                <span style="color:var(--muted);">F₀(τ)</span>&nbsp;<strong id="hudF0">–</strong>
              </div>
              <div style="padding:4px 8px;border-radius:6px;background:#EFF6FF;border:1px solid #93C5FD;">
                <span style="color:var(--muted);">F(τ)</span>&nbsp;<strong id="hudF" style="color:#3B82F6;">–</strong>
              </div>
              <div style="padding:4px 8px;border-radius:6px;background:#F0FDF4;border:1px solid #86EFAC;">
                <span style="color:var(--muted);">ΔP</span>&nbsp;<strong id="hudDeltaP" style="color:#16A34A;">–</strong>
              </div>
              <div style="padding:4px 8px;border-radius:6px;background:#F9FAFB;border:1px solid var(--line);">
                <span style="color:var(--muted);">∫Δf</span>&nbsp;<strong id="hudIntDelta">–</strong>
              </div>
            </div>
            <!-- All-active-strategies comparison row (shown when multiple are active) -->
            <div id="saco3dStratRow" style="display:none; flex-wrap:wrap; gap:4px; align-items:center; margin-bottom:8px; font-size:10px; font-family:ui-monospace,monospace; padding:4px 0;">
              <span style="color:var(--muted); font-size:9px; letter-spacing:.04em; font-weight:600;">ALL ACTIVE AT τ:</span>
              <span id="saco3dChipBase"      style="display:none; padding:1px 6px; border-radius:10px; background:#F1F5F9; color:#475569; border:1px solid rgba(148,163,184,0.45); font-weight:600;"></span>
              <span id="saco3dChipGuided"    style="display:none; padding:1px 6px; border-radius:10px; background:rgba(139,92,246,0.09); color:#6d28d9; border:1px solid rgba(139,92,246,0.40); font-weight:600;"></span>
              <span id="saco3dChipOptimized" style="display:none; padding:1px 6px; border-radius:10px; background:rgba(59,130,246,0.09);  color:#1d4ed8; border:1px solid rgba(59,130,246,0.40);  font-weight:600;"></span>
              <span id="saco3dChipExplorer"  style="display:none; padding:1px 6px; border-radius:10px; background:rgba(16,185,129,0.09); color:#065f46; border:1px solid rgba(16,185,129,0.40); font-weight:600;"></span>
            </div>
            <!-- Three.js renders into this div -->
            <div id="saco3dContainer" style="width:100%;height:420px;border:1px solid var(--line);border-radius:8px;background:#F8FAFF;overflow:hidden;position:relative;"></div>
            <div style="font-size:10px;color:var(--muted);margin-top:6px;line-height:1.5;">
              <strong>Gray ribbon</strong> = baseline f₀(x) &nbsp;·&nbsp; <strong>Colored ribbon</strong> = active strategy with Δ heatmap
              (blue/cool = probability mass removed; amber/red/warm = mass added) &nbsp;·&nbsp;
              <strong>Amber plane</strong> = target τ &nbsp;·&nbsp; <strong>Ring</strong> = normalized slider profile.
              Callout labels show P and ΔP for all active strategies at τ. Drag to rotate.
            </div>
          </div>
        </div>

        <!-- Right: Probability Sphere -->
        <div id="sphereOuterWrap" style="flex:0 0 400px;max-width:400px;">
          <div class="card" style="padding:12px 14px;">
            <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;">
              <div style="font-size:13px;font-weight:700;">Probability Sphere</div>
              <div id="sphereStratLabel" style="font-size:11px;color:var(--muted);margin-left:auto;"></div>
              <button id="zoomBtn_sphere" onclick="togglePlotZoom('sphere')" title="Toggle orbit controls — scroll to zoom, drag to rotate" style="font-size:10px;padding:2px 7px;border:1.5px solid var(--line);border-radius:5px;background:#fff;cursor:pointer;color:#6B7280;white-space:nowrap;">Zoom</button>
            </div>
            <!-- Full-width sphere, same height as SACO 3D canvas -->
            <div id="sphereContainer" style="width:100%;height:360px;border-radius:12px;overflow:hidden;background:#F0F4FA;border:1px solid rgba(140,170,220,0.35);margin-bottom:8px;"></div>
            <!-- Compact horizontal stats strip -->
            <div style="display:flex;gap:5px;font-family:ui-monospace,monospace;margin-bottom:6px;">
              <div style="flex:1;padding:6px 8px;border-radius:7px;background:#F3F4F6;border:1px solid var(--line);">
                <div style="color:var(--muted);font-size:9px;letter-spacing:.04em;margin-bottom:1px;">BASELINE P₀</div>
                <div style="font-size:15px;font-weight:800;" id="sphereP0">–</div>
              </div>
              <div style="flex:1;padding:6px 8px;border-radius:7px;background:#EFF6FF;border:1px solid #93C5FD;">
                <div style="color:var(--muted);font-size:9px;letter-spacing:.04em;margin-bottom:1px;">CURRENT P</div>
                <div style="font-size:15px;font-weight:800;color:#3B82F6;" id="sphereP">–</div>
              </div>
              <div style="flex:1;padding:6px 8px;border-radius:7px;background:#F0FDF4;border:1px solid #86EFAC;">
                <div style="color:var(--muted);font-size:9px;letter-spacing:.04em;margin-bottom:1px;">LIFT ΔP</div>
                <div style="font-size:15px;font-weight:800;color:#16A34A;" id="sphereDeltaP">–</div>
              </div>
            </div>
            <!-- All-active-strategies row for sphere card -->
            <div id="sphereStratRow" style="display:none; flex-wrap:wrap; gap:4px; align-items:center; margin-top:8px; font-size:10px; font-family:ui-monospace,monospace; padding:6px 8px; background:rgba(248,250,255,0.95); border:1px solid rgba(148,163,184,0.25); border-radius:8px;">
              <span style="color:var(--muted); font-size:9px; letter-spacing:.04em; font-weight:600; width:100%; margin-bottom:3px;">ALL ACTIVE AT TARGET τ:</span>
              <span id="sphChipBase"      style="display:none; padding:2px 7px; border-radius:10px; background:#F1F5F9; color:#475569; border:1px solid rgba(148,163,184,0.45); font-weight:600;"></span>
              <span id="sphChipGuided"    style="display:none; padding:2px 7px; border-radius:10px; background:rgba(139,92,246,0.09); color:#6d28d9; border:1px solid rgba(139,92,246,0.40); font-weight:600;"></span>
              <span id="sphChipOptimized" style="display:none; padding:2px 7px; border-radius:10px; background:rgba(59,130,246,0.09);  color:#1d4ed8; border:1px solid rgba(59,130,246,0.40);  font-weight:600;"></span>
              <span id="sphChipExplorer"  style="display:none; padding:2px 7px; border-radius:10px; background:rgba(16,185,129,0.09); color:#065f46; border:1px solid rgba(16,185,129,0.40); font-weight:600;"></span>
            </div>
            <div style="font-size:10px;color:var(--muted);margin-top:6px;line-height:1.5;">
              Fill height h solves V(h)/V_sphere = P via spherical cap V(h)=πh²(3R−h)/3.
              Gray = baseline. Colored fill = active strategy lift above baseline.
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- Decision Report (Overlay) -->
    <div id="decisionReport" class="live-math" aria-live="polite" style="margin-top:8px;"></div>

    <!-- Live math (Overlay) -->
    <div id="overlayMath" class="live-math" aria-live="polite"></div>
  </div>
</div>

<!-- Toast -->
<div id="toast" style="display:none;position:fixed;top:20px;right:20px;background:var(--accent);color:#fff;padding:12px;border-radius:8px;z-index:1002;">Tip</div>  </div>

  <!-- Show/Hide sections based on active tab -->
  <script>
    function updateTabSections() {
      const overlayTab = document.querySelector('.tab[data-tab="overlay"]');
      const hypercubeSection = document.getElementById('hypercubeSection');
      const sacoVizSection = document.getElementById('sacoVizSection');
      const isOverlay = overlayTab && overlayTab.classList.contains('active');

      // Radar / Hypercube cards: each has its own checkbox; section is visible when either is checked
      if (hypercubeSection) {
        var _cRadar     = document.getElementById('oselRadar');
        var _cHypercube = document.getElementById('oselHypercube');
        var _showRadar  = isOverlay && !!(_cRadar     && _cRadar.checked);
        var _showHyper  = isOverlay && !!(_cHypercube && _cHypercube.checked);
        hypercubeSection.classList.toggle('visible', _showRadar || _showHyper);
        var _radarCard    = document.getElementById('radarCard');
        var _hypercube3D  = document.getElementById('hypercube3DCard');
        if (_radarCard)   _radarCard.style.display   = _showRadar ? '' : 'none';
        if (_hypercube3D) _hypercube3D.style.display = _showHyper ? '' : 'none';
      }
      // SACO viz section: respect oselSaco / oselSphere checkboxes (hidden by default)
      if (sacoVizSection) {
        var _cSaco   = document.getElementById('oselSaco');
        var _cSphere = document.getElementById('oselSphere');
        sacoVizSection.style.display = (isOverlay && ((_cSaco && _cSaco.checked) || (_cSphere && _cSphere.checked))) ? '' : 'none';
      }
      if (isOverlay) {
        var _cSaco2   = document.getElementById('oselSaco');
        var _cSphere2 = document.getElementById('oselSphere');
        if (window.PMCSaco3D && _cSaco2 && _cSaco2.checked)    setTimeout(function() { window.PMCSaco3D.render(); }, 120);
        if (window.PMCSphere && _cSphere2 && _cSphere2.checked) setTimeout(function() { window.PMCSphere.render(); }, 120);
      }
    }
    function updateHypercubeVisibility() { updateTabSections(); }
    document.addEventListener('DOMContentLoaded', updateTabSections);
    const tabObserver = new MutationObserver(updateTabSections);
    document.querySelectorAll('.tab').forEach(tab => {
      tabObserver.observe(tab, { attributes: true, attributeFilter: ['class'] });
    });
  </script>

  <!-- Slider help — centered modal -->
  <div id="sliderHelpBackdrop"></div>
  <div id="sliderHelpModal" role="dialog" aria-modal="true">
    <div class="shm-header">
      <div class="shm-title" id="sliderHelpModalTitle"></div>
      <button class="shm-close" id="sliderHelpClose" aria-label="Close">&times;</button>
    </div>
    <div class="shm-body" id="sliderHelpModalBody"></div>
  </div>
  <script>
    var SLIDER_HELP = {
      budgetFlexibility: {
        title: 'Budget Flexibility',
        body:
          '<p>Think of your current budget as 100%. Setting this to 10% means you believe you could realistically access an extra 10% more budget if the project needs it — not guaranteed, but a plausible contingency. The optimizer uses this headroom to find solutions that might cost slightly more to finish on time.</p>' +
          '<em>Example: Budget = $100K, slider = 15% → optimizer can consider up to $115K if needed.</em>'
      },
      scheduleFlexibility: {
        title: 'Schedule Flexibility',
        body:
          '<p>If your deadline is 20 days, setting this to 10% tells the optimizer you could absorb about 2 extra days without serious consequences. Higher flexibility lets the optimizer trade a small schedule slip for a better on-time probability.</p>' +
          '<em>Example: Deadline = 20 days, slider = 10% → optimizer can stretch to ~22 days if it improves success odds.</em>'
      },
      scopeCertainty: {
        title: 'Scope Certainty',
        body:
          '<p>100% means requirements are fully locked and understood. 60% means roughly 40% of scope is still uncertain or may change — which directly widens your distribution. Lower certainty → higher uncertainty → the project takes longer on average.</p>' +
          '<em>Rule of thumb: Early discovery phase → 40–60%. Specification-complete → 80–90%.</em>'
      },
      scopeReductionAllowance: {
        title: 'Scope Reduction Allowance',
        body:
          '<p>If the project runs over, is there any scope that could be cut without losing core value? 20% means you believe you could drop about 20% of deliverables in a crunch. The optimizer uses this as a safety valve — cutting scope can be cheaper than missing the deadline.</p>' +
          '<em>Example: Slider = 20% → optimizer can propose dropping up to 1 in 5 features to stay on target.</em>'
      },
      reworkPercentage: {
        title: 'Rework Percentage',
        body:
          '<p>What fraction of completed work typically needs to be done again due to defects, misunderstandings, or late requirement changes? 15% means roughly 1 in 7 tasks needs a second pass. Rework multiplies your effective effort — the distribution shifts right as this increases.</p>' +
          '<em>Benchmarks: Mature teams 5–10% · Average teams 15–25% · High-change environments 25–40%.</em>'
      },
      riskTolerance: {
        title: 'Risk Tolerance',
        body:
          '<p>How conservative should the optimizer be? At 0% it only recommends changes that strongly reduce downside risk. At 100% it is willing to accept higher variance (wider spread in outcomes) in exchange for a better expected result.</p>' +
          '<em>Guidance: Fixed-price or safety-critical → 20–30%. Internal agile project with flexibility → 60–70%.</em>'
      },
      userConfidence: {
        title: 'User Confidence',
        body:
          '<p>How much do you trust your own three-point estimates (Optimistic / Most Likely / Pessimistic)? At 100% the optimizer treats your values as reliable anchors. At lower values it allows the distribution to stretch to account for estimator bias. If you tend to underestimate, lower this value.</p>' +
          '<em>Tip: If past projects routinely came in 20–30% over your Most Likely estimate, try setting this to 60–70%.</em>'
      }
    };

    (function() {
      function openSliderHelp(key) {
        var info = SLIDER_HELP[key];
        if (!info) return;
        var modal    = document.getElementById('sliderHelpModal');
        var backdrop = document.getElementById('sliderHelpBackdrop');
        var titleEl  = document.getElementById('sliderHelpModalTitle');
        var bodyEl   = document.getElementById('sliderHelpModalBody');
        if (!modal || !backdrop) return;
        titleEl.textContent = info.title;
        bodyEl.innerHTML    = info.body;
        modal.classList.add('visible');
        backdrop.classList.add('visible');
      }
      function closeSliderHelp() {
        var modal    = document.getElementById('sliderHelpModal');
        var backdrop = document.getElementById('sliderHelpBackdrop');
        if (modal)    modal.classList.remove('visible');
        if (backdrop) backdrop.classList.remove('visible');
      }
      // Generic help popup — reuses sliderHelpModal for any data-title help icon
      window.showHelp = function(title, bodyHtml) {
        var modal    = document.getElementById('sliderHelpModal');
        var backdrop = document.getElementById('sliderHelpBackdrop');
        var titleEl  = document.getElementById('sliderHelpModalTitle');
        var bodyEl   = document.getElementById('sliderHelpModalBody');
        if (!modal || !backdrop) return;
        titleEl.textContent = title;
        bodyEl.innerHTML    = '<p>' + bodyHtml + '</p>';
        modal.classList.add('visible');
        backdrop.classList.add('visible');
      };

      document.addEventListener('click', function(e) {
        // Open slider-specific help button
        var btn = e.target.closest && e.target.closest('.slider-help-btn');
        if (btn) { openSliderHelp(btn.getAttribute('data-slider-help')); return; }
        // Open generic help icon (data-title/data-body attributes)
        var icon = e.target.closest && e.target.closest('.help-icon[data-title]');
        if (icon) {
          var title = icon.getAttribute('data-title') || 'Help';
          var body  = icon.getAttribute('data-body')  || '';
          if (typeof window.showHelp === 'function') window.showHelp(title, body);
          return;
        }
        // Close on backdrop or × button
        var tgt = e.target;
        if (tgt.id === 'sliderHelpBackdrop' || tgt.id === 'sliderHelpClose') { closeSliderHelp(); return; }
      });
      // Close on Escape key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') closeSliderHelp();
      });
    })();
  </script>

  <!-- Reporting visibility + skeleton -->
  <script>
  (() => {
    function onReady(fn){
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn, { once: true });
      } else { fn(); }
    }
    function renderReportSkeletonOrFull(forceSkeleton=false) {
      const tryRender = () => {
        if (window.PMCReport) {
          if (forceSkeleton) window.PMCReport.renderAll(true);
          else window.PMCReport.scheduleRender();
          const dr = document.getElementById('decisionReport');
          const om = document.getElementById('overlayMath');
          if (false && window.MathJax && window.MathJax.typesetPromise && (dr || om)) {
            window.MathJax.typesetPromise([dr, om].filter(Boolean)).catch(()=>{});
          }
          return true;
        }
        return false;
      };
      if (tryRender()) return;
      let tries = 0;
      const h = setInterval(() => { tries += 1; if (tryRender() || tries > 60) clearInterval(h); }, 50);
    }
    function ensureReportVisibleWhenOverlayActive() {
      const overlayTab = document.querySelector('.tab[data-tab="overlay"]');
      const dr = document.getElementById('decisionReport');
      const om = document.getElementById('overlayMath');
      if (!overlayTab || !dr || !om) return;
      const isActive = () => overlayTab.classList.contains('active');
      const showIfActive = () => { if (!isActive()) return; dr.classList.add('active'); om.classList.add('active'); renderReportSkeletonOrFull(false); };
      overlayTab.addEventListener('click', showIfActive);
      // PMCReport handles its own event listeners — no duplicates needed here
      showIfActive();
    }
    onReady(() => { ensureReportVisibleWhenOverlayActive(); renderReportSkeletonOrFull(true); });
  })();
  </script>

  <!-- SHIMS -->
  <script>
  (function(){
    if (!window.renderKPIs)           window.renderKPIs = function(){};
    if (!window.renderRightLegend)    window.renderRightLegend = function(){};
    if (!window.updateChart)          window.updateChart = function(){};
    if (!window.renderDecisionReport) window.renderDecisionReport = function(){};
    if (!window.renderOverlayMath)    window.renderOverlayMath = function(){};
    console.debug('[Section 6] Shims installed — real renderers attach in Section 8.');
  })();
  </script>

  <!-- Core State, Helpers, Charts & Overlay Series Model -->
  <script>
    const S = {
      task: null, tasks: [],
      O: null, M: null, P: null,
      target: null,
      targetMode: 'value',   // 'value' or 'probability'
      targetProb: null,       // stores probability (0–1) when in probability mode
      targetSliderMin: null,
      targetSliderMax: null,

      tab: 'progress',
      mode: 'inspect',
      prevMode: null,

      progress: { triOn: true, betaOn: false, baseOn: false },

      overlay: {
        baselineOn: true,
        manualOn: false,
        fixedOn: false,
        adaptiveOn: false,
        probeLevel: 3,
        variants: {
          manual:   { loading: false, error: null, token: 0 },
          fixed:    { loading: false, error: null, token: 0 },
          adaptive: { loading: false, error: null, token: 0 }
        }
      },

      pendingVariants: 0,

      trianglePdf: [], triangleCdf: [],
      betaPertPdf: [], betaPertCdf: [],
      basePdf: [], baseCdf: [],
      adjPdf: [], adjCdf: [],
      optPdfFixed: [], optCdfFixed: [],
      optPdfAdaptive: [], optCdfAdaptive: [],

      baselineProb: null,
      adjustedProb: null,
      optimizedProb: null,
      adaptiveProb: null,

      pdfChart: null, cdfChart: null,

      fetching: false,
      fetchTimer: null,
      baselineCache: {},
      variantCache: {},

      liveMathPending: false,
      explainAdj: null,
      explainOpt: null,
      explainAdaptive: null,
      explainBase: null,
      lastPayload: null,

      optRefetchAttempted: false,
      slidersEnabled: true,
      currentGain: null,
      currentWeights: { budget: 0.20, schedule: 0.20, scopeCert: 0.20, scopeRed: 0.15, rework: -0.15, riskTol: 0.07, userConf: 0.03 },
      progressionMetrics: {}
    };

    const clamp01 = v => Math.max(0, Math.min(1, v));
    const fmtPct = v => (v == null || isNaN(v)) ? '–' : (v * 100).toFixed(2) + '%';
    const pct    = v => (v == null || isNaN(v)) ? '–' : (100 * v).toFixed(2) + '%';
    const num    = (v, d=4) => (v == null || isNaN(v)) ? '–' : Number(v).toFixed(d);
    const blueNum = (v, d=4) => `<span style="color: var(--cdf);">${num(v, d)}</span>`;

    // ── Shared display formatters — single source of truth for all probability displays ──
    window.FMT = {
      // Probabilities: always 2 decimal places → "51.17%"
      prob: function(v) {
        return (v == null || !isFinite(v)) ? '\u2013' : (v * 100).toFixed(2) + '%';
      },
      // Lift / delta in percentage-points: 1 decimal + sign → "+5.0 pp"
      lift: function(v) {
        if (v == null || !isFinite(v)) return '\u2013';
        return (v >= 0 ? '+' : '') + v.toFixed(1) + '\u00a0pp';
      }
    };

    function isAnyFetching() {
      return S.fetching || Object.values(S.overlay.variants).some(v => v.loading);
    }
    function setStatus(t) {
      const el = document.getElementById('fetchStatus');
      const mini = document.getElementById('seriesStatus');
      const any = isAnyFetching();
      const text = any ? 'Fetching…' : (t || 'Ready');
      if (el) { el.textContent = text; el.classList.toggle('fetching', any); el.classList.toggle('glow', any); }
      if (mini) mini.textContent = text;
    }
    function cssVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || ''; }
    function nullableNum(v) { const n = Number(v); return Number.isFinite(n) ? n : null; }

    function gp(obj, path) {
      var parts = path.split('.');
      var cur = obj;
      for (var i=0;i<parts.length;i++){ var k = parts[i]; if (!cur || !(k in cur)) return null; cur = cur[k]; }
      return cur;
    }

    function normalizePoints_(arr, isPdf = true) {
      if (!Array.isArray(arr)) return [];
      const out = [];
      for (const p of arr) {
        const x = nullableNum(p?.x);
        const y = nullableNum(p?.y);
        if (x != null && y != null) out.push({ x, y });
      }
      out.sort((a,b)=>a.x-b.x);
      if (isPdf && out.length >= 2) {
        if (out[0].y !== 0) out.unshift({ x: out[0].x - 0.01, y: 0 });
        if (out[out.length-1].y !== 0) out.push({ x: out[out.length-1].x + 0.01, y: 0 });
      }
      return out;
    }

    function interpY(points, x) {
      if (!points || points.length < 2 || x == null || !Number.isFinite(x)) return null;
      if (x <= points[0].x) return points[0].y;
      const n = points.length;
      if (x >= points[n - 1].x) return points[n - 1].y;
      let lo = 0, hi = n - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (points[mid].x <= x) lo = mid; else hi = mid;
      }
      const p0 = points[lo], p1 = points[hi];
      const t = (x - p0.x) / (p1.x - p0.x || 1e-10);
      const y = p0.y + t * (p1.y - p0.y);
      return Number.isFinite(y) ? y : null;
    }

    /** Inverse CDF lookup: given probability y (0–1), find the x-value where CDF = y.
     *  CDF is monotonically increasing so binary search on y works. */
    function interpX(points, y) {
      if (!points || points.length < 2 || y == null || !Number.isFinite(y)) return null;
      if (y <= points[0].y) return points[0].x;
      const n = points.length;
      if (y >= points[n - 1].y) return points[n - 1].x;
      let lo = 0, hi = n - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (points[mid].y <= y) lo = mid; else hi = mid;
      }
      const p0 = points[lo], p1 = points[hi];
      const t = (y - p0.y) / (p1.y - p0.y || 1e-10);
      const x = p0.x + t * (p1.x - p0.x);
      return Number.isFinite(x) ? x : null;
    }

    function boundsFromSeries(series) {
      let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity,count=0;
      for (const arr of series) {
        if (!arr || !arr.length) continue;
        count++;
        for (const p of arr) {
          if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
          xmin = Math.min(xmin,p.x); xmax = Math.max(xmax,p.x);
          ymin = Math.min(ymin,p.y); ymax = Math.max(ymax,p.y);
        }
      }
      if (!count) return null;
      if (xmin === xmax) { xmin -= 1; xmax += 1; }
      if (ymin === ymax) { ymin = 0; ymax = ymax || 1; }
      const padX = (xmax - xmin) * 0.05;
      const padY = (ymax - ymin) * 0.15;
      return { xmin: xmin - padX, xmax: xmax + padX, ymin: Math.max(0, ymin - padY), ymax: ymax + padY };
    }

    function sliderValues() {
      return {
        budgetFlexibility: +document.getElementById('s_budget').value,
        scheduleFlexibility: +document.getElementById('s_schedule').value,
        scopeCertainty: +document.getElementById('s_scopeCert').value,
        scopeReductionAllowance: +document.getElementById('s_scopeRed').value,
        reworkPercentage: +document.getElementById('s_rework').value,
        riskTolerance: +document.getElementById('s_risk').value,
        userConfidence: +document.getElementById('s_userConf').value
      };
    }
    function setSlidersDisabled(disabled) {
      ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf']
        .forEach(function(id) {
          var numEl = document.getElementById(id);
          var rangeEl = document.getElementById(id + '_range');
          if (numEl) numEl.disabled = disabled;
          if (rangeEl) rangeEl.disabled = disabled;
        });
    }

    const sliderIdMap = {
      budgetFlexibility: 's_budget',
      scheduleFlexibility: 's_schedule',
      scopeCertainty: 's_scopeCert',
      scopeReductionAllowance: 's_scopeRed',
      reworkPercentage: 's_rework',
      riskTolerance: 's_risk',
      userConfidence: 's_userConf'
    };

    function populateSliders(slidersObj) {
      const noteMissing = document.getElementById('slidersNoteMissing');
      if (noteMissing) noteMissing.style.display = Object.keys(slidersObj).length ? 'none' : 'block';
      Object.entries(slidersObj).forEach(([key, val]) => {
        const id = sliderIdMap[key];
        const el = document.getElementById(id);
        if (el) el.value = Number(val) || 0;
      });
    }

    function setCompareValues(kind, slidersObj){
      if (!slidersObj || typeof slidersObj !== 'object') return;
      let suffix;
      if (kind === 'base') {
        suffix = '_base';
      } else if (kind === 'fixed') {
        suffix = '_fixed';
      } else if (kind === 'adaptive' || kind === 'adapt') {
        suffix = '_adapt';
      } else {
        return;
      }
      const map = {
        budgetFlexibility: 's_budget',
        scheduleFlexibility: 's_schedule',
        scopeCertainty: 's_scopeCert',
        scopeReductionAllowance: 's_scopeRed',
        reworkPercentage: 's_rework',
        riskTolerance: 's_risk',
        userConfidence: 's_userConf'
      };
      Object.keys(map).forEach(k=>{
        const el = document.getElementById(map[k] + suffix);
        if (el) {
          el.value = Number(slidersObj[k]) || 0;
          if (k === 'reworkPercentage') el.value = Math.min(50, Math.max(0, el.value));
        }
      });
    }

    function extractSliderVals(src) {
      let optSliders = {};
      const sliderKeys = [
        'budgetFlexibility', 'scheduleFlexibility', 'scopeCertainty',
        'scopeReductionAllowance', 'reworkPercentage',
        'riskTolerance', 'userConfidence'
      ];

      try {
        for (const key of sliderKeys) {
          let val = null;
          let pathHit = 'none';

          if (src.optimize?.scaledSliders?.[key] != null) {
            val = src.optimize.scaledSliders[key];
            pathHit = 'optimize.scaledSliders';
          } else if (src.optimize?.sliders?.[key] != null) {
            val = src.optimize.sliders[key];
            pathHit = 'optimize.sliders';
          } else if (src.scaledSliders?.[key] != null) {
            val = src.scaledSliders[key];
            pathHit = 'scaledSliders';
          } else if (src.sliders01?.[key] != null) {
            val = src.sliders01[key];
            pathHit = 'sliders01';
          } else if (src.sliders?.[key] != null) {
            val = src.sliders[key];
            pathHit = 'sliders';
          } else if (src.explain?.optimized?.winningSliders?.[key] != null) {
            val = src.explain.optimized.winningSliders[key];
            pathHit = 'explain.optimized.winningSliders';
          } else if (src.explain?.adaptive?.winningSliders?.[key] != null) {
            val = src.explain.adaptive.winningSliders[key];
            pathHit = 'explain.adaptive.winningSliders';
          } else if (src.explain?.winningSliders?.[key] != null) {
            val = src.explain.winningSliders[key];
            pathHit = 'explain.winningSliders';
          } else if (src.optimalSliderSettings?.value?.[key] != null) {
            val = src.optimalSliderSettings.value[key];
            pathHit = 'optimalSliderSettings.value';
          }

          val = val ?? 0;

          if (val > 0 && val < 1) {
            const scaleFactor = (key === 'reworkPercentage') ? 50 : 100;
            val *= scaleFactor;
          }

          const maxVal = (key === 'reworkPercentage') ? 50 : 100;
          optSliders[key] = Math.max(0, Math.min(maxVal, val));
        }

      } catch (e) {
        console.error('extractSliderVals failed:', e);
        optSliders = {};
      }

      return optSliders;
    }

    function updateTargetSlider() {
      const s = window.S || S;
      const slider = document.getElementById('targetSlider');
      if (!slider || s.O == null || s.P == null) return;

      if (s.targetMode === 'probability') {
        slider.min = 1; slider.max = 99; slider.step = 0.5;
        var currentProb = s.targetProb != null ? (s.targetProb * 100) : 50;
        slider.value = currentProb;
        s.targetProb = currentProb / 100;
        // Compute value from probability using baseline CDF.
        // Group mode: use aggregate MC CDF; single-task: use baseCdf/triangleCdf.
        var isGrpMode = window.TM && window.TM.mode === 'aggregate';
        var baseCdf = isGrpMode
          ? (s.aggCdf && s.aggCdf.length ? s.aggCdf : s.triangleCdf)
          : (s.baseCdf && s.baseCdf.length ? s.baseCdf : s.triangleCdf);
        if (baseCdf && baseCdf.length) {
          s.target = interpX(baseCdf, s.targetProb);
        }
      } else {
        var pad = (s.P - s.O) * 0.05;
        s.targetSliderMin = s.O - pad;
        s.targetSliderMax = s.P + pad;
        slider.min = s.targetSliderMin;
        slider.max = s.targetSliderMax;
        slider.step = 'any';
        // Default to PERT mean
        var pert = (s.O + 4 * s.M + s.P) / 6;
        slider.value = s.target != null ? s.target : pert;
        s.target = Number(slider.value);
      }
      updateTargetDisplayText();
    }

    /** Updates the target result display showing both value AND probability */
    function updateTargetDisplayText() {
      var s = window.S || S;
      var valEl  = document.getElementById('targetValDisplay');
      var probEl = document.getElementById('targetProbDisplay');
      if (!valEl || !probEl) return;

      var valStr = '–', probStr = '–';

      if (s.target != null && Number.isFinite(s.target)) {
        valStr = Number(s.target).toFixed(2);
      }
      valEl.textContent = valStr;

      // Look up probability from CDF — use aggregate CDF in group mode
      var isAgg = window.TM && window.TM.mode === 'aggregate';
      var cdf = (isAgg && s.aggCdf && s.aggCdf.length)
        ? s.aggCdf
        : (s.baseCdf && s.baseCdf.length ? s.baseCdf : s.triangleCdf);
      if (cdf && cdf.length && s.target != null) {
        var prob = interpY(cdf, s.target);
        probStr = prob != null ? (prob * 100).toFixed(1) + '%' : '–';
        s.targetProb = prob;
        // Keep Project Report overview in sync without full re-render
        var repTV = document.getElementById('repTargetVal');
        if (repTV && s.target != null) repTV.textContent = Number(s.target).toFixed(2);
        var repTP = document.getElementById('repTargetProb');
        if (repTP) repTP.textContent = prob != null ? (prob * 100).toFixed(1) + '%' : '–';
      }
      probEl.textContent = probStr;

      // ── Keep the probability-mode sentence in sync ──────────────────────
      var altProb = document.getElementById('tgtProbAlt');
      var altVal  = document.getElementById('tgtValAlt');
      if (altProb) altProb.textContent = probStr;
      if (altVal)  altVal.textContent  = valStr;

      // ── Units hint in the answer sentences ──────────────────────────────
      var units = (window.TM && window.TM.settings && window.TM.settings.units) ? window.TM.settings.units : '';
      var u1 = document.getElementById('tgtUnitsHint1');
      var u2 = document.getElementById('tgtUnitsHint2');
      if (u1) u1.textContent = units;
      if (u2) u2.textContent = units;

      // ── Dynamic pill label: "Target <units>" or "Target value" ──────────
      var cardVal = document.getElementById('tgtCardValue');
      if (cardVal) cardVal.textContent = units ? 'Target ' + units : 'Target value';

      // ── Context band: group mean (aggregate mode) or PERT mean (single mode) ──
      var meanCtx = document.getElementById('tgtMeanCtx');
      if (meanCtx) {
        var u = units ? '\u00a0' + units : '';
        if (isAgg && s.aggMean != null && isFinite(s.aggMean)) {
          var gMean = s.aggMean;
          if (s.target != null && isFinite(s.target)) {
            var diff = s.target - gMean;
            var sign = diff >= 0 ? '+' : '';
            meanCtx.textContent = 'Group Mean: ' + gMean.toFixed(1) + u +
              '\u2002|\u2002' + sign + diff.toFixed(1) + u + ' from mean';
          } else {
            meanCtx.textContent = 'Group Mean: ' + gMean.toFixed(1) + u;
          }
        } else {
          var oVal = s.O, mVal = s.M, pVal = s.P;
          if (oVal != null && mVal != null && pVal != null &&
              isFinite(oVal) && isFinite(mVal) && isFinite(pVal)) {
            var pertMean = (oVal + 4 * mVal + pVal) / 6;
            if (s.target != null && isFinite(s.target)) {
              var diff = s.target - pertMean;
              var sign = diff >= 0 ? '+' : '';
              meanCtx.textContent = 'PERT Mean: ' + pertMean.toFixed(1) + u +
                '\u2002|\u2002' + sign + diff.toFixed(1) + u + ' from mean';
            } else {
              meanCtx.textContent = 'PERT Mean: ' + pertMean.toFixed(1) + u;
            }
          }
        }
      }
    }

    // Linked crosshair plugin for PDF ↔ CDF
    var linkedCrosshairPlugin = {
      id: 'linkedCrosshair',
      _hoveredX: null,
      _sourceChart: null,
      afterEvent: function(chart, args) {
        var evt = args.event;
        if (evt.type === 'mousemove' && args.inChartArea) {
          var xScale = chart.scales.x;
          this._hoveredX = xScale.getValueForPixel(evt.x);
          this._sourceChart = chart;
          var s = window.S || {};
          var sibling = (chart === s.pdfChart) ? s.cdfChart : s.pdfChart;
          if (sibling) sibling.draw();
          chart.draw();
        }
        if (evt.type === 'mouseout') {
          this._hoveredX = null;
          this._sourceChart = null;
          var s2 = window.S || {};
          if (s2.pdfChart) s2.pdfChart.draw();
          if (s2.cdfChart) s2.cdfChart.draw();
        }
      },
      afterDraw: function(chart) {
        if (this._hoveredX == null) return;
        var xScale = chart.scales.x;
        var yScale = chart.scales.y;
        var area   = chart.chartArea;
        var xPixel = xScale.getPixelForValue(this._hoveredX);
        if (xPixel < area.left || xPixel > area.right) return;
        var ctx = chart.ctx;
        var isCdf = !!(chart.canvas && chart.canvas.id === 'cdfCanvas');

        // Interpolate y-value from the first visible dataset at hovered x
        var yVal = null;
        for (var di = 0; di < chart.data.datasets.length; di++) {
          var ds = chart.data.datasets[di];
          if (ds.hidden) continue;
          var pts = ds.data;
          if (!pts || pts.length < 2) continue;
          for (var pi = 1; pi < pts.length; pi++) {
            if (pts[pi-1].x <= this._hoveredX && this._hoveredX <= pts[pi].x) {
              var frac = (this._hoveredX - pts[pi-1].x) / (pts[pi].x - pts[pi-1].x);
              yVal = pts[pi-1].y + frac * (pts[pi].y - pts[pi-1].y);
              break;
            }
          }
          if (yVal != null) break;
        }

        ctx.save();

        // ── Vertical dashed line ──────────────────────────────────────────────
        ctx.beginPath();
        ctx.moveTo(xPixel, area.top);
        ctx.lineTo(xPixel, area.bottom);
        ctx.strokeStyle = 'rgba(107, 114, 128, 0.5)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.stroke();

        // ── Horizontal dashed line at y-intercept ─────────────────────────────
        var yPixel = null;
        if (yVal != null && yScale) {
          yPixel = yScale.getPixelForValue(yVal);
          if (yPixel >= area.top && yPixel <= area.bottom) {
            ctx.beginPath();
            ctx.moveTo(area.left, yPixel);
            ctx.lineTo(xPixel, yPixel);
            ctx.strokeStyle = 'rgba(107, 114, 128, 0.35)';
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            // y-axis value label
            ctx.setLineDash([]);
            ctx.font = '10px -apple-system,BlinkMacSystemFont,Inter,sans-serif';
            ctx.fillStyle = '#6B7280';
            ctx.textAlign = 'right';
            var yLabel = isCdf ? (yVal * 100).toFixed(1) + '%' : yVal.toFixed(4);
            ctx.fillText(yLabel, area.left - 3, yPixel + 3.5);
          }
        }

        // ── x-axis value label ────────────────────────────────────────────────
        ctx.setLineDash([]);
        ctx.font = '10px -apple-system,BlinkMacSystemFont,Inter,sans-serif';
        ctx.fillStyle = '#6B7280';
        ctx.textAlign = 'center';
        ctx.fillText(this._hoveredX.toFixed(1), xPixel, area.bottom + 14);

        // ── Floating tooltip bubble ───────────────────────────────────────────
        if (yVal != null) {
          var tipLabel = isCdf
            ? '\u03c4 = ' + this._hoveredX.toFixed(1) + '  \u2192  P = ' + (yVal * 100).toFixed(1) + '%'
            : '\u03c4 = ' + this._hoveredX.toFixed(1) + '  density = ' + yVal.toFixed(4);
          ctx.font = 'bold 11px -apple-system,BlinkMacSystemFont,Inter,sans-serif';
          var tw = ctx.measureText(tipLabel).width;
          var th = 14, pad = 5;
          var tipX = xPixel + 8;
          var tipY = area.top + 10;
          if (tipX + tw + pad * 2 > area.right) tipX = xPixel - tw - pad * 2 - 8;
          // Background pill
          ctx.fillStyle = 'rgba(255,255,255,0.93)';
          ctx.strokeStyle = 'rgba(107,114,128,0.28)';
          ctx.lineWidth = 1;
          ctx.setLineDash([]);
          ctx.beginPath();
          var rx = tipX - pad, ry = tipY - pad, rw = tw + pad * 2, rh = th + pad * 2, r = 4;
          ctx.moveTo(rx + r, ry); ctx.lineTo(rx + rw - r, ry);
          ctx.arcTo(rx + rw, ry, rx + rw, ry + r, r);
          ctx.lineTo(rx + rw, ry + rh - r);
          ctx.arcTo(rx + rw, ry + rh, rx + rw - r, ry + rh, r);
          ctx.lineTo(rx + r, ry + rh);
          ctx.arcTo(rx, ry + rh, rx, ry + rh - r, r);
          ctx.lineTo(rx, ry + r);
          ctx.arcTo(rx, ry, rx + r, ry, r);
          ctx.closePath();
          ctx.fill(); ctx.stroke();
          // Text
          ctx.fillStyle = '#374151';
          ctx.textAlign = 'left';
          ctx.fillText(tipLabel, tipX, tipY + th - 2);
        }

        ctx.restore();
      }
    };

    function ensureCharts() {
      const pdfCanvas = document.getElementById('pdfCanvas');
      const cdfCanvas = document.getElementById('cdfCanvas');
      if (!pdfCanvas || !cdfCanvas) return;
      if (typeof Chart === 'undefined') {
        console.warn('[ensureCharts] Chart.js not loaded yet — will retry when available');
        if (!window._chartRetryPending) {
          window._chartRetryPending = true;
          var checkInterval = setInterval(function() {
            if (typeof Chart !== 'undefined') {
              clearInterval(checkInterval);
              window._chartRetryPending = false;
              console.log('[ensureCharts] Chart.js now available, retrying');
              ensureCharts();
              if (typeof window.updateChart === 'function') window.updateChart();
            }
          }, 200);
        }
        return;
      }

      try {
        if (window.Chart && Chart.register) {
          // chartjs-plugin-zoom exports under various global names depending on CDN build
          var _zp = window.ChartZoom
            || window['chartjs-plugin-zoom']
            || (window['chartjs-plugin-zoom'] && window['chartjs-plugin-zoom']['default']);
          if (_zp && _zp.id) Chart.register(_zp);
          else if (_zp) Chart.register(_zp);
        }
      } catch(_) {}

      if (!window.targetLabelPlugin) {
        window.targetLabelPlugin = {
          id: 'targetLabel',
          afterDatasetsDraw(chart, args, opts){
            const s = window.S || {};
            const ctx = chart.ctx;
            const area = chart.chartArea;
            // ── Vertical τ target line ────────────────────────────────────
            if (s.target != null && isFinite(s.target)) {
              const xSc = chart.scales && chart.scales.x;
              if (xSc) {
                const xPx = xSc.getPixelForValue(s.target);
                if (xPx >= area.left && xPx <= area.right) {
                  ctx.save();
                  ctx.beginPath();
                  ctx.moveTo(xPx, area.top);
                  ctx.lineTo(xPx, area.bottom);
                  ctx.strokeStyle = 'rgba(245,158,11,0.72)';
                  ctx.lineWidth = 1.5;
                  ctx.setLineDash([5, 4]);
                  ctx.stroke();
                  ctx.setLineDash([]);
                  const tauTxt = '\u03c4 = ' + Number(s.target).toFixed(2);
                  ctx.font = 'bold 10px ui-monospace,monospace';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  const tw = ctx.measureText(tauTxt).width + 8;
                  const bx = xPx - tw / 2, by = area.top + 2, bh = 15;
                  ctx.fillStyle = 'rgba(255,250,220,0.94)';
                  ctx.strokeStyle = 'rgba(245,158,11,0.85)';
                  ctx.lineWidth = 1;
                  if (ctx.roundRect) ctx.roundRect(bx, by, tw, bh, 3);
                  else ctx.rect(bx, by, tw, bh);
                  ctx.fill(); ctx.stroke();
                  ctx.fillStyle = '#7c5200';
                  ctx.fillText(tauTxt, xPx, by + bh / 2);
                  ctx.restore();
                }
              }
            }
            // ── Probability annotations at τ for all active strategies ───────
            if (s.target != null && isFinite(s.target)) {
              const isCdf = (chart.canvas.id === 'cdfCanvas');
              if (isCdf) {
                const xSc2 = chart.scales && chart.scales.x;
                const ySc2 = chart.scales && chart.scales.y;
                if (xSc2 && ySc2) {
                  const xPx2 = xSc2.getPixelForValue(s.target);
                  if (xPx2 >= area.left && xPx2 <= area.right) {
                    var P0 = s.baselineProb;
                    var ov = s.overlay || {};
                    // Baseline P₀ dashed horizontal line + label
                    if (P0 != null && isFinite(P0)) {
                      var yPx0 = ySc2.getPixelForValue(P0);
                      ctx.save();
                      ctx.beginPath();
                      ctx.moveTo(area.left, yPx0);
                      ctx.lineTo(xPx2, yPx0);
                      ctx.strokeStyle = 'rgba(107,114,128,0.50)';
                      ctx.lineWidth = 1.5; ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]);
                      var p0Txt = 'Baseline P\u2080 = ' + (P0*100).toFixed(1) + '%';
                      ctx.font = 'bold 9px ui-monospace,monospace';
                      ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                      ctx.fillStyle = 'rgba(100,116,139,0.90)';
                      ctx.fillText(p0Txt, area.left + 2, yPx0 - 1);
                      ctx.restore();
                    }
                    // One line per active strategy
                    var stratAnnotations = [
                      { on: ov.adaptiveOn,  prob: s.adaptiveProb,  name: 'Conservative', col: 'rgba(139,92,246,0.90)' },
                      { on: ov.fixedOn,     prob: s.optimizedProb, name: 'General',      col: 'rgba(59,130,246,0.90)'  },
                      { on: ov.manualOn,    prob: s.adjustedProb,  name: 'Unconstrained', col: 'rgba(16,185,129,0.90)'  }
                    ];
                    // Track y positions to avoid label collisions
                    var usedYPx = [];
                    stratAnnotations.forEach(function(sa) {
                      if (!sa.on || sa.prob == null || !isFinite(sa.prob)) return;
                      var yPxC = ySc2.getPixelForValue(sa.prob);
                      var dP = sa.prob - (P0 || 0);
                      ctx.save();
                      ctx.beginPath();
                      ctx.moveTo(area.left, yPxC);
                      ctx.lineTo(xPx2, yPxC);
                      ctx.strokeStyle = sa.col;
                      ctx.lineWidth = 1.5; ctx.setLineDash([4,3]); ctx.stroke(); ctx.setLineDash([]);
                      var dpStr = (dP >= 0 ? '+' : '') + (dP * 100).toFixed(1) + '%';
                      var labTxt = sa.name + ' = ' + (sa.prob*100).toFixed(1) + '% (\u0394P ' + dpStr + ')';
                      ctx.font = 'bold 9px ui-monospace,monospace';
                      ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                      // Nudge label up if it collides with a previously drawn label
                      var labY = yPxC - 1;
                      for (var ui = 0; ui < usedYPx.length; ui++) {
                        if (Math.abs(labY - usedYPx[ui]) < 11) labY = usedYPx[ui] - 11;
                      }
                      usedYPx.push(labY);
                      ctx.fillStyle = sa.col;
                      ctx.fillText(labTxt, area.left + 2, labY);
                      ctx.restore();
                    });
                  }
                }
              }
            }
            // Collect all label positions for anti-overlap
            var labels = [];
            chart.data.datasets.forEach((ds, idx) => {
              if (ds.type === 'scatter' && ds.data && ds.data.length) {
                const meta = chart.getDatasetMeta(idx);
                const el = meta?.data?.[0];
                if (!el || ds.hidden) return;
                const key = ds._probKey;
                const pt = ds.data[0];
                // Use the actual y value from the data point for the label
                const yVal = pt ? pt.y : null;
                if (yVal == null) return;
                const pos = el.getProps(['x','y'], true);
                labels.push({ key:key, x:pos.x, y:pos.y, yVal:yVal, xVal:pt.x, color: ds.pointBackgroundColor||'#111' });
              }
            });
            // Sort by y pixel position (top to bottom) for stacking
            labels.sort(function(a,b){ return a.y - b.y; });
            // Nudge labels that would overlap (within 16px vertically)
            for (var i=1; i<labels.length; i++) {
              var prev = labels[i-1];
              if (Math.abs(labels[i].y - prev.y) < 16 && Math.abs(labels[i].x - prev.x) < 60) {
                labels[i].y = prev.y + 16;
              }
            }
            ctx.save();
            var _keyToName = { baseline: 'Baseline', optimized: 'General Opt.', adjusted: 'Unconstrained', adaptive: 'Conservative' };
            var _P0dot = (window.S || {}).baselineProb;
            labels.forEach(function(lb) {
              var isCdf = (chart.canvas.id === 'cdfCanvas');
              var txt;
              if (isCdf) {
                var stratName = _keyToName[lb.key] || lb.key;
                var pctStr = (lb.yVal * 100).toFixed(1) + '%';
                if (lb.key !== 'baseline' && _P0dot != null && isFinite(_P0dot)) {
                  var dPdot = lb.yVal - _P0dot;
                  txt = stratName + ' = ' + pctStr + ' (\u0394P\u202f' + (dPdot >= 0 ? '+' : '') + (dPdot * 100).toFixed(1) + '%)';
                } else {
                  txt = stratName + ' = ' + pctStr;
                }
              } else {
                txt = lb.xVal.toFixed(1) + ' \u2192 ' + lb.yVal.toFixed(4);
              }
              ctx.font = 'bold 10px Inter, sans-serif';
              var tw = ctx.measureText(txt).width;
              // Position label: prefer right of dot, flip left if near edge
              var lx = lb.x + 8;
              if (lx + tw > area.right - 4) lx = lb.x - tw - 8;
              var ly = lb.y - 8;
              if (ly < area.top + 4) ly = lb.y + 14;
              // Background pill
              ctx.fillStyle = 'rgba(255,255,255,0.85)';
              ctx.strokeStyle = lb.color;
              ctx.lineWidth = 1;
              var pad = 3;
              var rx=lx-pad, ry=ly-10-pad, rw=tw+pad*2, rh=14+pad*2, rr=4;
              ctx.beginPath();
              if (ctx.roundRect) { ctx.roundRect(rx,ry,rw,rh,rr); }
              else { ctx.moveTo(rx+rr,ry); ctx.lineTo(rx+rw-rr,ry); ctx.quadraticCurveTo(rx+rw,ry,rx+rw,ry+rr); ctx.lineTo(rx+rw,ry+rh-rr); ctx.quadraticCurveTo(rx+rw,ry+rh,rx+rw-rr,ry+rh); ctx.lineTo(rx+rr,ry+rh); ctx.quadraticCurveTo(rx,ry+rh,rx,ry+rh-rr); ctx.lineTo(rx,ry+rr); ctx.quadraticCurveTo(rx,ry,rx+rr,ry); ctx.closePath(); }
              ctx.fill(); ctx.stroke();
              // Text
              ctx.fillStyle = lb.color;
              ctx.textAlign = 'left';
              ctx.textBaseline = 'bottom';
              ctx.fillText(txt, lx, ly);
              // Circle ring around the dot
              ctx.beginPath();
              ctx.arc(lb.x, lb.y, 6, 0, Math.PI*2);
              ctx.strokeStyle = lb.color;
              ctx.lineWidth = 2;
              ctx.stroke();
            });
            ctx.restore();
          }
        };
      }

      const legendFilter = (legendItem, chartData) => {
        const ds = chartData?.datasets?.[legendItem.datasetIndex];
        if (ds && ds.type === 'scatter') return false;
        const s = window.S || {};
        const label = legendItem.text || '';
        if (s.tab === 'overlay') {
          return /^(Baseline|Unconstrained|General Opt\.|Conservative)$/.test(label);
        }
        return /^(Triangle|Beta-PERT|Baseline)$/.test(label);
      };

      if (!S.pdfChart) {
        S.pdfChart = new Chart(pdfCanvas, {
          type: 'line',
          data: { datasets: [] },
          options: {
            responsive: true, maintainAspectRatio: false, parsing: false,
            plugins: {
              legend: { display: true, position: 'top', labels: { boxWidth: 12, font: { size: 12 }, filter: legendFilter } },
              tooltip: {
                enabled: true,
                callbacks: {
                  label: (ctx) => {
                    if (ctx.dataset.type === 'scatter') {
                      const x = ctx.parsed.x.toFixed(2);
                      const y = ctx.parsed.y;
                      return [`Value: ${x}`, `Density: ${y != null ? y.toFixed(4) : 'N/A'}`];
                    }
                    return ctx.dataset.label;
                  }
                }
              },
              zoom: {
                limits: { x:{min: 'original', max:'original'}, y:{min: 'original', max:'original'} },
                pan: { enabled: false, mode: 'xy' },
                zoom: { wheel:{enabled:false}, pinch:{enabled:false}, mode:'xy' }
              }
            },
            elements: { point: { radius: 0 } },
            scales: {
              x: { type: 'linear', title: { display: true, text: 'Value', font: { size: 12 } }, ticks: { font: { size: 11 } } },
              y: { title: { display: true, text: 'Density', font: { size: 12 } }, ticks: { font: { size: 11 } }, min: 0, max: 0.2 }
            }
          },
          plugins: [window.targetLabelPlugin, linkedCrosshairPlugin]
        });
      }

      if (!S.cdfChart) {
        S.cdfChart = new Chart(cdfCanvas, {
          type: 'line',
          data: { datasets: [] },
          options: {
            responsive: true, maintainAspectRatio: false, parsing: false,
            plugins: {
              legend: { display: true, position: 'top', labels: { boxWidth: 12, font: { size: 12 }, filter: legendFilter } },
              zoom: {
                limits: { x:{min: 'original', max:'original'}, y:{min: 0, max:1 } },
                pan: { enabled: false, mode: 'xy' },
                zoom: { wheel:{enabled:false}, pinch:{enabled:false}, mode:'xy' }
              }
            },
            elements: { point: { radius: 0 } },
            scales: {
              x: { type: 'linear', title: { display: true, text: 'Value', font: { size: 12 } }, ticks: { font: { size: 11 } } },
              y: { title: { display: true, text: 'Cumulative Probability', font: { size: 12 } }, ticks: { font: { size: 11 } }, min: 0, max: 1 }
            }
          },
          plugins: [window.targetLabelPlugin, linkedCrosshairPlugin]
        });
      }
    }

    function computeGain(sliders) {
      const v = {
        budget:   clamp01(sliders.budgetFlexibility / 100),
        schedule: clamp01(sliders.scheduleFlexibility / 100),
        scopeCert: clamp01(sliders.scopeCertainty / 100),
        scopeRed: clamp01(sliders.scopeReductionAllowance / 100),
        rework:   clamp01(sliders.reworkPercentage / 50),
        riskTol:  clamp01(sliders.riskTolerance / 100),
        userConf: clamp01((sliders.userConfidence ?? 100) / 100)
      };
      const w = S.currentWeights;
      const raw = w.budget*v.budget + w.schedule*v.schedule + w.scopeCert*v.scopeCert + w.scopeRed*v.scopeRed + w.rework*v.rework + w.riskTol*v.riskTol + w.userConf*v.userConf;
      return Math.max(-0.25, Math.min(0.25, raw)) * 0.25;
    }

    function pmcEmit(type, detail) {
      try { window.dispatchEvent(new CustomEvent(type, { detail })); } catch(_) {}
    }

    function syncProbeUI(){
      const s = window.S || S;
      const box = document.getElementById('probeBox');
      const sel = document.getElementById('probeSelect');
      const show = (s.tab === 'overlay') && (s.overlay?.sidebarMode === 'adaptive');
      if (box) box.style.display = show ? 'inline-flex' : 'none';
      if (sel && Number(sel.value) !== Number(s.overlay.probeLevel || 3)) {
        sel.value = String(s.overlay.probeLevel || 3);
      }
    }
    function initProbeUI(){
      const sel = document.getElementById('probeSelect');
      if (!sel || sel.__bound) return;
      sel.__bound = true;
      sel.addEventListener('change', () => {
        const s = window.S || S;
        const lvl = Number(sel.value) || 3;
        s.overlay.probeLevel = Math.max(1, Math.min(7, lvl));
        if (s.tab === 'overlay' && s.overlay.adaptiveOn) {
          const key = JSON.stringify({ task: s.task?.task, O:s.O, M:s.M, P:s.P, target:s.target, variant:'adaptive', probeLevel:s.overlay.probeLevel });
          if (s.variantCache) delete s.variantCache[key];
          if (typeof window.requestVariant === 'function') {
            window.requestVariant('adaptive');
          } else {
            if (typeof window.setStatus === 'function') window.setStatus('Fetching…');
          }
        }
      });
    }

    window.S = window.S || S;
    window.ensureCharts = ensureCharts;
    window.interpY = interpY;
    window.interpX = interpX;
    window.updateTargetDisplayText = updateTargetDisplayText;
    window.updateTargetSlider = updateTargetSlider;
    window.boundsFromSeries = boundsFromSeries;
    window.sliderValues = sliderValues;
    window.updateSlidersDisplay = function(){};
    window.computeGain = computeGain;
    window.setStatus = setStatus;
    window.pmcEmit = pmcEmit;
    window.syncProbeUI = syncProbeUI;
    window.initProbeUI = initProbeUI;

    // ── Help icon system: dynamic mini-reports for each plot ──
    function initPlotHelp() {
      var helpDefs = {
        distributions: {
          popupId: 'distributionsHelpPopup',
          generate: function() {
            var s = window.S || {};
            var tab = s.tab || 'progress';
            if (tab === 'progress') {
              return '<h4>Distribution Curves</h4>' +
                '<div class="help-section">' +
                '<p><strong>What you see:</strong> Two charts showing how your 3-point estimate (Best / Most Likely / Worst) becomes a probability model.</p>' +
                '<ul>' +
                '<li><strong>Left \u2014 Density (PDF):</strong> The "shape" of uncertainty. The peak is the most likely outcome; wider = more uncertain.</li>' +
                '<li><strong>Right \u2014 Cumulative (CDF):</strong> The probability of finishing at or below any value. Read as: "What is my chance of completing within X?"</li>' +
                '</ul></div>' +
                '<div class="help-section">' +
                '<p><strong>The three curves:</strong></p>' +
                '<ul>' +
                '<li><strong>Triangle</strong> \u2014 simplest model from your 3 estimates</li>' +
                '<li><strong>Beta-PERT</strong> \u2014 industry-standard refinement that weights Most Likely more heavily</li>' +
                '<li><strong>Your Estimate</strong> \u2014 final calibrated distribution used as your baseline</li>' +
                '</ul></div>' +
                (s.target != null ? '<div class="help-section"><p><strong>Your target:</strong> <span class="help-stat">' + Number(s.target).toFixed(2) + '</span> \u2014 probability of meeting it: <span class="help-stat">' + FMT.prob(s.baselineProb) + '</span></p></div>' : '');
            } else {
              var html = '<h4>Strategy Comparison</h4>' +
                '<div class="help-section">' +
                '<p><strong>What you see:</strong> Your baseline overlaid with optimization strategies. Each curve shows a different approach to improving your probability of success.</p></div>';
              html += '<div class="help-section"><p><strong>Active strategies:</strong></p><ul>';
              if (s.overlay && s.overlay.baselineOn) html += '<li><strong>Your Estimate:</strong> <span class="help-stat">' + FMT.prob(s.baselineProb) + '</span> \u2014 starting point</li>';
              if (s.overlay && s.overlay.adaptiveOn) html += '<li><strong>Conservative Optimization:</strong> <span class="help-stat">' + FMT.prob(s.adaptiveProb) + '</span> \u2014 tightest constraints (level ' + (s.overlay.probeLevel||3) + ')</li>';
              if (s.overlay && s.overlay.fixedOn) html += '<li><strong>General Optimization:</strong> <span class="help-stat">' + FMT.prob(s.optimizedProb) + '</span> \u2014 best within standard boundaries</li>';
              if (s.overlay && s.overlay.manualOn) html += '<li><strong>Unconstrained Optimization:</strong> <span class="help-stat">' + FMT.prob(s.adjustedProb) + '</span> \u2014 your custom settings</li>';
              html += '</ul></div>';
              html += '<div class="help-section"><p><strong>How to read:</strong> On the CDF (right), a higher curve at your target = better probability. The gap between curves shows how much each strategy improves your chances.</p></div>';
              return html;
            }
          }
        },
        radar: {
          popupId: 'radarHelpPopup',
          generate: function() {
            return '<h4>Slider Profile</h4>' +
              '<div class="help-section">' +
              '<p><strong>What you see:</strong> A radar chart showing all 7 project decision sliders at once. Each axis is one parameter.</p></div>' +
              '<div class="help-section">' +
              '<p><strong>How to read:</strong></p>' +
              '<ul>' +
              '<li><strong>Larger shape</strong> = more aggressive parameter settings</li>' +
              '<li><strong>Balanced shape</strong> (near-circle) = proportional settings</li>' +
              '<li><strong>Spiky shape</strong> = some parameters much higher than others \u2014 look for imbalances</li>' +
              '</ul></div>' +
              '<div class="help-section">' +
              '<p><strong>The 7 parameters:</strong> Budget Flexibility, Schedule Flexibility, Scope Certainty, Scope Reduction, Rework %, Risk Tolerance, Confidence \u2014 each captures a dimension of project decision-making aligned with industry best practices.</p></div>';
          }
        },
        hypercube: {
          popupId: 'hypercubeHelpPopup',
          generate: function() {
            return '<h4>Parameter Space (3D)</h4>' +
              '<div class="help-section">' +
              '<p><strong>What you see:</strong> A rotating 3D projection of the 7-dimensional parameter space. Each vertex represents a possible combination of slider settings.</p></div>' +
              '<div class="help-section">' +
              '<p><strong>How to read:</strong></p>' +
              '<ul>' +
              '<li><strong>Highlighted point</strong> = where your current settings sit</li>' +
              '<li><strong>Closer to center</strong> = more conservative</li>' +
              '<li><strong>Closer to edges</strong> = more aggressive</li>' +
              '</ul></div>' +
              '<div class="help-section">' +
              '<p><strong>Why it matters:</strong> See whether the optimizer is pushing parameters to extremes or finding a balanced interior solution. A point near the boundary suggests the optimizer is constrained \u2014 try a different strategy or Explorer mode.</p></div>';
          }
        }
      };

      document.querySelectorAll('.plot-help-btn').forEach(function(btn) {
        btn.addEventListener('click', function(e) {
          e.stopPropagation();
          var key = btn.getAttribute('data-help');
          var def = helpDefs[key];
          if (!def) return;
          var popup = document.getElementById(def.popupId);
          if (!popup) return;
          document.querySelectorAll('.plot-help-popup.visible').forEach(function(p) {
            if (p !== popup) p.classList.remove('visible');
          });
          if (popup.classList.contains('visible')) {
            popup.classList.remove('visible');
          } else {
            popup.innerHTML = def.generate();
            popup.classList.add('visible');
          }
        });
      });

      document.addEventListener('click', function(e) {
        if (!e.target.closest('.plot-help-btn') && !e.target.closest('.plot-help-popup')) {
          document.querySelectorAll('.plot-help-popup.visible').forEach(function(p) {
            p.classList.remove('visible');
          });
        }
      });
    }
    window.initPlotHelp = initPlotHelp;
  </script>

  <!-- KPIs, Legend controls, Chart Rendering -->
  <script>
    (function(){
      function WS(){ return window.S || (window.S = {}); }
      function cssVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || ''; }

      window.renderKPIs = function(){
        var s = WS();
        function writeVal(root, v, loading) {
          if (!root) return;
          var slot = root.querySelector('.val') || root.querySelector('.kpi-v');
          if (!slot) return;
          root.classList.toggle('updating', !!loading);
          if (loading) {
            slot.innerHTML = '<span style="font-size:10px;color:var(--muted);">Fetching\u2026</span>';
          } else if (v == null || isNaN(v)) {
            slot.innerHTML = '&ndash;';
          } else {
            var pctStr = FMT.prob(v);
            var natural = Math.round(v * 100) + '% chance at or below target';
            slot.innerHTML = pctStr + '<div class="kpi-natural">' + natural + '</div>';
          }
        }
        var kBase = document.getElementById('kpiBaseline');
        var kAdj  = document.getElementById('kpiAdjusted');
        var kOpt  = document.getElementById('kpiOptimized');
        var kAda  = document.getElementById('kpiAdaptive');

        var vv = s.overlay && s.overlay.variants || {};
        writeVal(kBase, s.baselineProb, s.fetching);
        writeVal(kAdj,  s.adjustedProb, vv.manual && vv.manual.loading);
        writeVal(kOpt,  s.optimizedProb, vv.fixed && vv.fixed.loading);
        writeVal(kAda,  s.adaptiveProb, vv.adaptive && vv.adaptive.loading);

        var onOv = (s.tab==='overlay');
        if (kBase) { kBase.classList.toggle('active', onOv && !!s.overlay.baselineOn); kBase.classList.toggle('inactive', !(onOv && s.overlay.baselineOn)); }
        if (kAdj)  { kAdj.classList.toggle('active',  onOv && !!s.overlay.manualOn);  kAdj.classList.toggle('inactive', !(onOv && s.overlay.manualOn)); }
        if (kOpt)  { kOpt.classList.toggle('active', onOv && !!s.overlay.fixedOn);   kOpt.classList.toggle('inactive', !(onOv && s.overlay.fixedOn)); }
        if (kAda)  { kAda.classList.toggle('active', onOv && !!s.overlay.adaptiveOn); kAda.classList.toggle('inactive', !(onOv && s.overlay.adaptiveOn)); }

        var card = document.getElementById('overlayKpis');
        if (card) card.style.display = (s.tab==='overlay') ? 'block' : 'none';

        var progressDesc = document.getElementById('progressDescBanner');
        if (progressDesc) progressDesc.style.display = (s.tab==='progress') ? '' : 'none';

        var distTiles = document.getElementById('distTiles');
        if (distTiles) distTiles.style.display = (s.tab==='progress') ? 'flex' : 'none';
        var triTile  = document.getElementById('kpiTriangle');
        var betaTile = document.getElementById('kpiBeta');
        var baseTile = document.getElementById('kpiBaseDist');
        var isGrpTile = window.TM && window.TM.mode === 'aggregate';
        if (triTile)  { triTile.style.display  = ''; triTile.classList.toggle('active',  !!s.progress.triOn); }
        if (betaTile) { betaTile.style.display = ''; betaTile.classList.toggle('active', !!s.progress.betaOn); }
        if (baseTile) {
          baseTile.style.display = '';
          baseTile.classList.toggle('active', !!s.progress.baseOn);
          // In Group mode the "Baseline" is the MC aggregate — label accordingly
          var bTtl = baseTile.querySelector('.ttl');
          if (bTtl) bTtl.textContent = isGrpTile ? 'Group MC' : 'Baseline';
        }

        if (typeof window.syncProbeUI === 'function') window.syncProbeUI();
        updateProgressDescription(s);
        updateRecommendation(s);
      };

      function updateProgressDescription(s) {
        var stmtEl = document.getElementById('progressDescStatement');
        var ctxEl = document.getElementById('progressDescContext');
        if (!stmtEl || !ctxEl) return;
        if (s.tab !== 'progress') return;

        var isGroupMode = window.TM && window.TM.mode === 'aggregate';
        if (isGroupMode) {
          var nActive = window.TM && window.TM.tasks
            ? window.TM.tasks.filter(function(t) { return t.active; }).length : 0;
          var tgtG = s.target != null ? Number(s.target).toFixed(2) : '?';
          var bp   = s.baselineProb;
          var gO   = s.O != null ? Number(s.O).toFixed(1) : '?';
          var gM   = s.M != null ? Number(s.M).toFixed(1) : '?';
          var gP   = s.P != null ? Number(s.P).toFixed(1) : '?';
          var gPert = (s.O != null && s.M != null && s.P != null)
            ? ((s.O + 4 * s.M + s.P) / 6).toFixed(2) : '?';
          stmtEl.innerHTML = '<strong>Group distribution</strong> \u2014 ' + nActive + ' task' + (nActive !== 1 ? 's' : '')
            + ' modelled as combined 3-point estimate (O=' + gO + ', M=' + gM + ', P=' + gP + ')';
          var parts = [];
          parts.push(
            'The group is modelled as a single aggregated 3-point estimate using the <strong>sum</strong> of each task\'s individual values: '
            + '<strong>O=' + gO + '</strong> (sum of best cases), '
            + '<strong>M=' + gM + '</strong> (sum of most likely), '
            + '<strong>P=' + gP + '</strong> (sum of worst cases). '
            + 'This is the standard PERT programme-level aggregation for sequential independent tasks, giving a combined PERT mean of <strong>' + gPert + '</strong>.'
          );
          if (s.aggMean != null) {
            parts.push(
              'The Monte Carlo baseline samples all tasks together for a more accurate combined distribution (mean = <strong>' + Number(s.aggMean).toFixed(2) + '</strong>). '
              + 'Small differences between the PERT mean (' + gPert + ') and Monte Carlo mean (' + Number(s.aggMean).toFixed(2) + ') are due to the shape of individual distributions. '
              + 'Check the Estimates panel for P50, P80, and P90 percentiles.'
            );
          }
          if (bp != null) {
            parts.push('At your current target of <strong>' + tgtG + '</strong>, there is a <strong>' + FMT.prob(bp) + '</strong> chance the group completes within that value.');
          }
          parts.push('Strategy optimization (Conservative, General, Unconstrained) applies the same 7 project-level decision levers to the combined group estimate — switch to the <strong>Compare Strategies</strong> tab to activate them.');
          ctxEl.innerHTML = parts.join(' ');
          return;
        }

        // Use .toFixed(2) to match the target panel precision exactly
        var tgt = s.target != null ? Number(s.target).toFixed(2) : '?';
        var triProb  = s.triangleCdf && s.triangleCdf.length && s.target != null ? window.interpY(s.triangleCdf,  s.target) : null;
        var betaProb = s.betaPertCdf && s.betaPertCdf.length && s.target != null ? window.interpY(s.betaPertCdf, s.target) : null;
        // Use live CDF interpolation for baseline — matches what the target panel above uses
        var baseProb = (s.baseCdf && s.baseCdf.length && s.target != null)
          ? window.interpY(s.baseCdf, s.target)
          : s.baselineProb;

        // PERT vs Triangle means — explains WHY Beta-PERT gives different probability
        var pertMean = s.O != null ? ((s.O + 4*s.M + s.P) / 6) : null;
        var triMean  = s.O != null ? ((s.O + s.M + s.P) / 3)  : null;

        var stmt = '<strong>How your estimate is built</strong> \u2014 from 3-point inputs to probability';
        var parts = [];
        parts.push(
          'Your three-point estimate (O=' + (s.O||'?') + ', M=' + (s.M||'?') + ', P=' + (s.P||'?') + ') is modeled by three progressively more sophisticated distributions. ' +
          'Each gives a <em>different</em> probability at target <strong>' + tgt + '</strong> because they make different assumptions about how uncertainty is shaped — this is expected and mathematically correct.'
        );
        if (triProb != null) {
          parts.push(
            'The <strong>Triangle</strong> distribution gives <strong>' + FMT.prob(triProb) + '</strong> at ' + tgt + ' — ' +
            'the simplest model: a triangular shape with equal weight to all values between O and P, peaked at M ' +
            (triMean != null ? '(mean = ' + triMean.toFixed(2) + ')' : '') + '.'
          );
        }
        if (betaProb != null && pertMean != null && triMean != null) {
          var cmp = betaProb > (triProb||0) ? 'higher' : 'lower';
          parts.push(
            '<strong>Beta-PERT</strong> gives <strong>' + FMT.prob(betaProb) + '</strong> — it weights Most Likely 4× more heavily than O and P, ' +
            'shifting the mean from ' + triMean.toFixed(2) + ' (Triangle) to ' + pertMean.toFixed(2) + ' (PERT). ' +
            'A ' + (pertMean < triMean ? 'lower' : 'higher') + ' mean shifts probability mass ' +
            (pertMean < triMean ? 'left' : 'right') + ', giving a ' + cmp + ' cumulative probability at this target.'
          );
        }
        if (baseProb != null) {
          parts.push(
            'Your <strong>baseline</strong> (Monte Carlo, 10k simulations) gives <strong>' + FMT.prob(baseProb) + '</strong> at ' + tgt + '. ' +
            'This is the distribution the target panel above uses — it runs thousands of random draws from the Triangle distribution and smooths the result, ' +
            'so small differences from the analytical Triangle probability (' + FMT.prob(triProb) + ') are normal sampling variation. ' +
            'This baseline is your reference for optimization in Compare Strategies.'
          );
        }

        stmtEl.innerHTML = stmt;
        ctxEl.innerHTML = parts.join(' ');
      }

      function updateRecommendation(s) {
        var banner   = document.getElementById('recBanner');
        if (!banner) return;
        var activeEl = document.getElementById('recActiveBar');
        var stmtEl   = document.getElementById('recStatement');
        var ctxEl    = document.getElementById('recContext');
        var detEl    = document.getElementById('recDetails');

        if (s.tab !== 'overlay') { banner.style.display = 'none'; updatePlotDescriptions(s, null, []); return; }

        var bp = s.baselineProb;
        if (bp == null || isNaN(bp)) { banner.style.display = 'none'; updatePlotDescriptions(s, null, []); return; }

        var tgt  = s.target != null ? Number(s.target).toFixed(1) : '?';
        var plvl = s.overlay.probeLevel || 3;
        var isGroupMode = window.TM && window.TM.mode === 'aggregate';

        // Strategy colour palette (matches the button UI)
        var COLOURS = {
          baseline: { bg: '#E8F5E9', text: '#1B5E20', border: '#A5D6A7', bestBg: '#2e7d32', bestText: '#fff' },
          adaptive: { bg: '#FFF8E1', text: '#4E342E', border: '#FFD54F', bestBg: '#f59e0b', bestText: '#fff' },
          fixed:    { bg: '#E3F2FD', text: '#0D47A1', border: '#90CAF9', bestBg: '#1d4ed8', bestText: '#fff' },
          manual:   { bg: '#E8F5E9', text: '#1B5E20', border: '#80CBC4', bestBg: '#059669', bestText: '#fff' }
        };

        // Build candidates from ONLY currently active strategies
        var candidates = [];
        var baselineName = isGroupMode
          ? ('Group Baseline (' + ((window.TM && window.TM.tasks ? window.TM.tasks.filter(function(t){return t.active;}).length : 0)) + ' tasks)')
          : 'Your Estimate';
        candidates.push({ name: baselineName, prob: bp, key: 'baseline' });
        // Strategies work in BOTH single and group modes.
        // In group mode, SACO optimises the summed O/M/P (= combined group estimate).
        if (s.overlay.adaptiveOn && s.adaptiveProb  != null && !isNaN(s.adaptiveProb))
          candidates.push({ name: 'Conservative Opt. (L' + plvl + ')', prob: s.adaptiveProb,  key: 'adaptive' });
        if (s.overlay.fixedOn    && s.optimizedProb != null && !isNaN(s.optimizedProb))
          candidates.push({ name: 'General Opt.',                       prob: s.optimizedProb, key: 'fixed' });
        if (s.overlay.manualOn   && s.adjustedProb  != null && !isNaN(s.adjustedProb))
          candidates.push({ name: 'Unconstrained',                      prob: s.adjustedProb,  key: 'manual' });

        candidates.sort(function(a, b) { return b.prob - a.prob; });
        var hasVariants = candidates.length > 1;
        var best      = candidates[0];
        var guided    = candidates.find(function(c) { return c.key === 'adaptive'; });
        var optimized = candidates.find(function(c) { return c.key === 'fixed'; });
        var explorer  = candidates.find(function(c) { return c.key === 'manual'; });
        var noGuided    = !guided;
        var noOptimized = !optimized;
        var noExplorer  = !explorer;

        // ── Slider highlight helper ───────────────────────────────────────
        // Returns a formatted mini-list of the strategy's top lever settings.
        // Only shows sliders with meaningful values (> 5%).
        // Sorted by value descending so the most-pushed levers appear first.
        function sliderHighlights(stratKey) {
          try {
            var src = stratKey === 'adaptive' ? (s.explainAdaptive || {})
                    : stratKey === 'fixed'    ? (s.explainOpt      || {})
                    : {};
            var sv = extractSliderVals(src);
            var LABELS = {
              budgetFlexibility:      'Budget Flex',
              scheduleFlexibility:    'Schedule Flex',
              scopeCertainty:         'Scope Certainty',
              scopeReductionAllowance:'Scope Reduction',
              reworkPercentage:       'Rework %',
              riskTolerance:          'Risk Tolerance',
              userConfidence:         'User Confidence'
            };
            var entries = Object.keys(sv)
              .map(function(k) { return { k: k, v: sv[k], label: LABELS[k] || k }; })
              .filter(function(e) { return e.v > 5; })
              .sort(function(a, b) { return b.v - a.v; })
              .slice(0, 4);
            if (!entries.length) return '';
            return '<br><span style="font-size:11px;color:var(--muted);">'
              + 'Optimizer set \u2192 '
              + entries.map(function(e) {
                  return '<strong>' + e.label + '</strong>\u00a0' + e.v.toFixed(0) + '%';
                }).join(' \u00b7 ') + '</span>';
          } catch(err) { return ''; }
        }

        // ── Part 1: Active chips bar ──────────────────────────────────────
        var chips = '<span class="rec-label">COMPARING:</span>';
        candidates.forEach(function(c) {
          var isBest = hasVariants && c === best;
          var col    = COLOURS[c.key] || COLOURS.baseline;
          var gain   = (c.key !== 'baseline') ? ((c.prob - bp) * 100) : null;
          var gainStr = (gain != null && gain > 0) ? '<span class="rec-chip-gain">(' + FMT.lift(gain) + ')</span>' : '';
          var style = isBest
            ? 'background:' + col.bestBg + ';color:' + col.bestText + ';border:1px solid ' + col.bestBg + ';'
            : 'background:' + col.bg + ';color:' + col.text + ';border:1px solid ' + col.border + ';';
          chips += '<span class="rec-chip' + (isBest ? ' best' : '') + '" style="' + style + '">';
          if (isBest) chips += '\u2605 '; // ★
          chips += c.name + '&nbsp;<strong>' + FMT.prob(c.prob) + '</strong>&nbsp;' + gainStr;
          chips += '</span>';
        });
        if (activeEl) activeEl.innerHTML = chips;

        // ── Part 2: Key observation statement ────────────────────────────
        var stmt = '', level;
        if (!hasVariants) {
          level = bp >= 0.8 ? 'green' : (bp >= 0.5 ? 'amber' : 'red');
          stmt = (isGroupMode
            ? '<strong>Group Baseline</strong> probability is'
            : 'Your baseline probability is')
            + ' <strong>' + FMT.prob(bp) + '</strong> at target ' + tgt
            + (isGroupMode ? '.' : '. No strategies are active yet.');
        } else if (best.key === 'baseline') {
          level = 'amber';
          stmt = 'None of the active strategies improved over your baseline <strong>' + FMT.prob(bp) + '</strong> — the optimizer could not find better settings within its constraints.';
        } else {
          var bestLift = (best.prob - bp) * 100;
          level = best.prob >= 0.8 ? 'green' : (best.prob >= 0.5 ? 'amber' : 'red');
          if (bestLift > 0) {
            stmt = '<strong>' + best.name + '</strong> is your best result: <strong>' + FMT.prob(best.prob) + '</strong> at target ' + tgt + ' \u2014 a <strong>' + FMT.lift(bestLift) + '</strong> improvement over your estimate.';
          } else {
            stmt = '<strong>' + best.name + '</strong> achieves <strong>' + FMT.prob(best.prob) + '</strong> at target ' + tgt + '.';
          }
        }

        // ── Part 3: What This Means (ONLY describes active strategies) ───
        // RULE: Never mention an inactive strategy by name in this section.
        var ctx = '<div class="rec-section-hdr">WHAT THIS MEANS</div>';
        if (!hasVariants) {
          if (isGroupMode) {
            var nActive = window.TM && window.TM.tasks ? window.TM.tasks.filter(function(t) { return t.active; }).length : 0;
            var gO = s.O != null ? Number(s.O).toFixed(1) : '?';
            var gM = s.M != null ? Number(s.M).toFixed(1) : '?';
            var gP = s.P != null ? Number(s.P).toFixed(1) : '?';
            ctx += 'This is the combined baseline for <strong>' + nActive + ' task' + (nActive !== 1 ? 's' : '') + '</strong>, '
                 + 'modelled as a single 3-point estimate <strong>O=' + gO + ', M=' + gM + ', P=' + gP + '</strong> '
                 + '(the <em>sum</em> of each task\'s individual O, M, P values — standard PERT aggregation for sequential tasks). '
                 + 'The Monte Carlo baseline samples all tasks together to give an accurate combined distribution. '
                 + 'Activate strategies below to reshape the group distribution using project-level decision levers.';
          } else {
            ctx += 'This is your unoptimized 3-point estimate baseline. The distribution is shaped by your Best Case, Most Likely, and Worst Case values. '
                 + 'Activating strategies below will reshape the distribution by adjusting 7 project decision levers '
                 + '(budget flexibility, schedule flexibility, scope certainty, etc.) to find a higher probability.';
          }
        } else {
          var parts = [];
          // Baseline context
          var bLine = baselineName + ' (' + FMT.prob(bp) + ') is the unoptimized baseline — the starting point for all comparisons.';
          if (bp >= 0.7) bLine += ' Your baseline is already strong; optimization delivers incremental gains.';
          else if (bp < 0.4) bLine += ' The baseline is low, which means there is more room to gain from optimization.';
          parts.push(bLine);

          if (guided) {
            var gGain = ((guided.prob - bp) * 100);
            if (gGain > 0) {
              parts.push('<strong>Conservative Optimization</strong> (' + FMT.prob(guided.prob) + ', ' + FMT.lift(gGain) + '): Applies industry-standard constraint bounds at probe level ' + plvl + '/7. '
                + 'All 7 decision levers stay within validated project management boundaries — '
                + 'the most defensible improvement because every assumption can be justified in a stakeholder review.'
                + sliderHighlights('adaptive'));
            } else {
              parts.push('<strong>Conservative Optimization</strong> (' + FMT.prob(guided.prob) + '): At probe level ' + plvl + '/7 the constraints are too tight to beat the baseline. '
                + 'The estimate range may require a looser constraint set — try increasing the probe level.'
                + sliderHighlights('adaptive'));
            }
          }

          if (optimized) {
            var oGain = ((optimized.prob - bp) * 100);
            var oRef  = guided ? ' — ' + ((optimized.prob - guided.prob) * 100).toFixed(1) + ' pp above Conservative Optimization' : '';
            if (oGain > 0) {
              parts.push('<strong>General Optimization</strong> (' + FMT.prob(optimized.prob) + ', ' + FMT.lift(oGain) + oRef + '): '
                + 'Searches the full standard parameter space, finding the highest probability within normal project limits. '
                + 'Uses a wider slider range than the most constrained approach — verify each setting is feasible before presenting it.'
                + sliderHighlights('fixed'));
            } else {
              parts.push('<strong>General Optimization</strong> (' + FMT.prob(optimized.prob) + '): Could not beat the baseline within standard bounds. '
                + 'The target may be too ambitious for this estimate range.'
                + sliderHighlights('fixed'));
            }
          }

          if (explorer) {
            var eGain = ((explorer.prob - bp) * 100);
            var ePeer = (guided || optimized) ? ' — ' + ((explorer.prob - best.prob) * 100).toFixed(1) + ' pp above ' + best.name : '';
            if (best.key === 'manual') ePeer = ''; // Don't compare Unconstrained Optimization to itself
            if (eGain > 0) {
              parts.push('<strong>Unconstrained Optimization</strong> (' + FMT.prob(explorer.prob) + ', ' + FMT.lift(eGain) + ePeer + '): '
                + 'Sets all sliders to their most favorable positions with no guardrails — the theoretical ceiling. '
                + 'Answers "how much improvement is possible in the best case?" '
                + 'Unconstrained values are rarely achievable in practice; use them to understand headroom, not as a plan. '
                + 'Open the sidebar to see exactly which levers are pushed and by how much.');
            } else {
              parts.push('<strong>Unconstrained Optimization</strong> (' + FMT.prob(explorer.prob) + '): Even with all sliders unconstrained, probability did not improve. '
                + 'The target is very aggressive for this estimate range. Consider lowering the target or revisiting the 3-point estimate.');
            }
          }
          ctx += parts.join('<br><br>');
        }

        // ── Part 4: What To Try Next (structured steps with "why") ───────
        // RULE: Inactive strategies may only appear here as suggestions,
        //       never as if they were already active.
        var steps = [];

        if (!hasVariants) {
          // Same strategy suggestions for both single and group modes
          if (isGroupMode) {
            steps.push({ action: 'Click <strong>Conservative Optimization</strong>', why: 'Applies industry-standard constraint bounds to the group\'s combined O/M/P at level ' + plvl + '/7. Shows the most defensible improvement for the programme as a whole.' });
            steps.push({ action: 'Click <strong>General Optimization</strong>', why: 'Searches a wider parameter space across the full group estimate. Finds the best achievable combined probability within standard project management limits.' });
            steps.push({ action: 'Click <strong>Unconstrained Optimization</strong>', why: 'Reveals the theoretical ceiling for the group with no guardrails. If even Unconstrained can\'t move the needle, consider revising the target or individual task estimates.' });
          } else {
            // No strategies on yet — guide them through the logical sequence
            steps.push({ action: 'Click <strong>Conservative Optimization</strong>', why: 'The safest starting point. Uses industry-standard constraint bounds at level ' + plvl + '/7 — every slider stays within validated project management limits, making the result easy to defend.' });
            steps.push({ action: 'Click <strong>General Optimization</strong>', why: 'Searches a wider parameter space for the best achievable probability within standard limits. Gives you the most improvement possible while staying within reasonable assumptions.' });
            steps.push({ action: 'Click <strong>Unconstrained Optimization</strong>', why: 'Reveals the theoretical upper bound with no constraints. If even Unconstrained can\'t move the needle, the target needs to change — not the sliders.' });
          }
        } else if (best.key === 'baseline') {
          // Strategies active but none helped — diagnostics
          if (!noGuided && guided) {
            steps.push({ action: 'Increase Conservative Optimization\'s probe level (currently ' + plvl + '/7)', why: 'Higher levels explore slightly looser constraint sets. Level 5–7 may find a feasible improvement path that level ' + plvl + ' missed.' });
          }
          if (noOptimized) {
            steps.push({ action: 'Activate <strong>General Optimization</strong>', why: 'Uses a wider search space than Conservative Optimization. May find an improvement path that tighter constraints missed.' });
          }
          if (noExplorer) {
            steps.push({ action: 'Activate <strong>Unconstrained Optimization</strong>', why: 'If even Unconstrained (no constraints) can\'t improve over baseline, the target is likely unachievable for this estimate range.' });
          }
          if (!noExplorer && explorer && explorer.prob <= bp) {
            steps.push({ action: 'Reduce the target value using the slider', why: 'The theoretical ceiling with no constraints is still at or below baseline. The target is not achievable for this estimate — find a target where probability is acceptable, then decide whether to revise the estimate.' });
          }
        } else if (best.prob >= 0.8) {
          // Great — 80%+ is achievable. Focus on validating and deciding which path to use.
          if (best.key === 'adaptive') {
            steps.push({ action: 'Review Conservative Optimization\'s slider positions in the sidebar', why: 'These settings are industry-validated. Each slider value represents a specific project management lever — check that these assumptions are realistic for your project.' });
            if (noOptimized) {
              steps.push({ action: 'Activate <strong>General Optimization</strong>', why: 'See if a wider search can improve further beyond Conservative Optimization\'s ' + pct(guided.prob) + '. If General also hits 80%+, you have two independent validation paths.' });
            }
          } else if (best.key === 'fixed') {
            steps.push({ action: 'Review General Optimization\'s slider positions in the sidebar', why: 'General Optimization uses wider bounds — check each slider setting for feasibility. Some values may be more aggressive than your project can realistically absorb.' });
            if (noGuided) {
              steps.push({ action: 'Activate <strong>Conservative Optimization</strong>', why: 'Check whether a more constrained path can also reach 80%+. If Conservative reaches close, that\'s a more defensible result for stakeholders.' });
            } else if (guided && guided.prob < 0.8) {
              steps.push({ action: 'Increase Conservative Optimization\'s probe level (currently ' + plvl + '/7)', why: 'Conservative Optimization reached ' + pct(guided.prob) + ' — close but not 80%. A higher probe level searches a slightly broader constraint set and may close the gap.' });
            }
          } else if (best.key === 'manual') {
            steps.push({ action: 'Check Unconstrained Optimization\'s slider positions in the sidebar', why: 'Unconstrained has no guardrails — identify which specific sliders are pushed to extreme values. These are the levers driving the improvement.' });
            if (noGuided) {
              steps.push({ action: 'Activate <strong>Conservative Optimization</strong>', why: 'Unconstrained shows 80%+ is achievable — now find the most constrained, defensible path to that result.' });
            }
            if (noOptimized) {
              steps.push({ action: 'Activate <strong>General Optimization</strong>', why: 'Get the best probability with standard constraints — the realistic middle ground between Conservative and Unconstrained Optimization.' });
            }
            if (guided || optimized) {
              steps.push({ action: 'Compare sidebar sliders between Unconstrained Optimization and your best constrained strategy', why: 'The gap between Unconstrained (' + pct(explorer.prob) + ') and ' + best.name + ' (' + pct(best.prob) + ') shows the cost of staying within realistic bounds.' });
            }
          }
        } else if (best.prob >= 0.5) {
          // Moderate — improvement but not at 80% yet
          if (noGuided) {
            steps.push({ action: 'Activate <strong>Conservative Optimization</strong>', why: 'The most constrained optimizer. If it can improve over your current best (' + pct(best.prob) + '), you have a defensible path. If it can\'t, that tells you something important about the estimate constraints.' });
          }
          if (noOptimized) {
            steps.push({ action: 'Activate <strong>General Optimization</strong>', why: 'Searches a wider parameter space than Conservative Optimization. May find a path to 80%+ that tighter constraints missed.' });
          }
          if (noExplorer) {
            steps.push({ action: 'Activate <strong>Unconstrained Optimization</strong>', why: 'See the theoretical maximum. If Unconstrained can reach 80%, you know improvement to that level is possible — the question becomes which constraints to relax. If it can\'t, the target is too ambitious.' });
          }
          // All active, none hit 80%
          if (!noGuided && !noOptimized && !noExplorer) {
            if (guided && ((guided.prob - bp) * 100) > 0 && plvl < 7) {
              steps.push({ action: 'Increase Conservative Optimization\'s probe level (currently ' + plvl + '/7)', why: 'All three strategies are active and none reached 80%. Higher probe levels search slightly broader constraint sets — try level ' + Math.min(plvl + 2, 7) + ' as a next step.' });
            }
            steps.push({ action: 'Adjust the target slider left to a more achievable value', why: 'All strategies have been explored and the ceiling is ' + pct(best.prob) + '. Find a target where at least Guided can reach 80%, then use that as your defensible commitment.' });
          }
        } else {
          // Low probability — significant challenge
          if (noExplorer) {
            steps.push({ action: 'Activate <strong>Unconstrained Optimization</strong>', why: 'First, establish whether improvement is theoretically possible at all. Unconstrained has no limits — if it can\'t reach 50%, the target fundamentally needs to change.' });
          } else if (explorer && explorer.prob < 0.5) {
            steps.push({ action: 'Move the target slider significantly left', why: 'Even with every slider at its most favorable value (Unconstrained Optimization), probability stays below 50%. The target is not achievable for this estimate. Find a target where confidence is acceptable (e.g., 70%) and use that as your planning baseline.' });
          } else {
            // Unconstrained can do it but constrained strategies can't
            steps.push({ action: 'Check Unconstrained Optimization\'s slider positions in the sidebar', why: 'Unconstrained Optimization reaches ' + pct(explorer.prob) + ' — improvement is theoretically possible. Identify which sliders are doing the most work. These are the levers your project would need to move.' });
            if (noGuided) {
              steps.push({ action: 'Activate <strong>Conservative Optimization</strong>', why: 'Find the most constrained, realistic path toward the target. It may not reach 80%, but it shows what is achievable within industry-standard limits.' });
            }
            if (noOptimized) {
              steps.push({ action: 'Activate <strong>General Optimization</strong>', why: 'Find the best probability with standard (not unconstrained) bounds — the realistic ceiling short of Unconstrained.' });
            }
          }
        }

        // Render next steps
        var detHtml = '<div class="rec-section-hdr">WHAT TO TRY NEXT</div>';
        if (steps.length === 0) {
          detHtml += '<div style="font-size:11px;color:var(--muted);">You\'ve explored all available strategies. Adjust the target or review slider positions in the sidebar.</div>';
        } else {
          detHtml += steps.map(function(step) {
            return '<div class="rec-next-row">'
              + '<div class="rec-next-action">' + step.action + '</div>'
              + '<div class="rec-next-why">' + step.why + '</div>'
              + '</div>';
          }).join('');
        }

        banner.className = 'rec-banner rec-' + level;
        if (stmtEl) stmtEl.innerHTML = stmt;
        if (ctxEl)  ctxEl.innerHTML  = ctx;
        if (detEl)  detEl.innerHTML  = detHtml;
        banner.style.display = '';
        updatePlotDescriptions(s, best, candidates);
      }

      function updatePlotDescriptions(s, best, candidates) {
        var chartDesc = document.getElementById('chartDesc');
        var radarDesc = document.getElementById('radarDesc');
        var hcDesc = document.getElementById('hypercubeDesc');
        var tgt = s.target != null ? Number(s.target).toFixed(1) : '?';
        var onOverlay = (s.tab === 'overlay');
        var hasVariants = candidates && candidates.length > 1;

        // --- PDF/CDF description ---
        if (chartDesc) {
          if (s.tab === 'progress') {
            // Progress description now in the banner above; hide chart-level desc
            chartDesc.style.display = 'none';
          } else if (onOverlay && hasVariants) {
            chartDesc.style.display = '';
            var lines = ['<strong>Strategy comparison at target ' + tgt + ':</strong> '];
            lines.push('The PDF (left) shows the shape of each strategy\'s probability distribution \u2014 taller/narrower peaks mean more certainty. ');
            lines.push('The CDF (right) shows cumulative probability \u2014 the annotated circles mark where each strategy falls at the target. ');
            if (best && best.key !== 'baseline') {
              lines.push('<strong>' + best.name + '</strong> achieves ' + FMT.prob(best.prob));
              if (best.key === 'manual') lines.push(' (unconstrained \u2014 treat as theoretical ceiling)');
              else if (best.key === 'adaptive') lines.push(' (within strict best-practice constraints)');
              else if (best.key === 'fixed') lines.push(' (within standard optimization boundaries)');
              lines.push('.');
            }
            chartDesc.innerHTML = lines.join('');
          } else if (onOverlay) {
            chartDesc.style.display = '';
            chartDesc.innerHTML = '<strong>Your baseline distribution at target ' + tgt + ':</strong> Probability of meeting target is <strong>' + FMT.prob(s.baselineProb) + '</strong>. Activate strategies above to compare.';
          } else {
            chartDesc.style.display = 'none';
          }
        }

        // --- Radar description ---
        if (radarDesc) {
          if (onOverlay && hasVariants) {
            radarDesc.style.display = '';
            var rLines = ['<strong>Slider profile:</strong> '];
            rLines.push('Each axis represents a decision lever (budget flexibility, schedule flexibility, etc.). ');
            rLines.push('The dashed green line shows your baseline at 50% on all sliders. ');
            if (best && best.key === 'adaptive') {
              rLines.push('Conservative Optimization (blue) stays close to baseline \u2014 its tight constraints limit how far sliders can move, producing the most defensible result.');
            } else if (best && best.key === 'fixed') {
              rLines.push('General Optimization pushes sliders further than Conservative within standard boundaries \u2014 wider reach means higher probability but more assumptions.');
            } else if (best && best.key === 'manual') {
              rLines.push('Unconstrained shows unconstrained slider positions \u2014 large deviations from baseline suggest assumptions that may not hold in practice.');
            }
            radarDesc.innerHTML = rLines.join('');
          } else if (onOverlay) {
            radarDesc.style.display = '';
            radarDesc.innerHTML = '<strong>Slider profile:</strong> Shows current decision lever settings. Activate optimization strategies to see how they adjust these values.';
          } else {
            radarDesc.style.display = 'none';
          }
        }

        // --- Hypercube description ---
        if (hcDesc) {
          if (onOverlay) {
            hcDesc.style.display = '';
            var hLines = ['<strong>Parameter space:</strong> '];
            hLines.push('A 3D projection of the 7-dimensional slider space. ');
            hLines.push('The nested cubes represent constraint boundaries \u2014 inner cubes are tighter constraints (Guided), outer cubes are wider (Optimized/Explorer). ');
            if (hasVariants && best) {
              hLines.push('The current configuration sits ' + (best.key === 'adaptive' ? 'near the inner boundary (conservative)' : best.key === 'fixed' ? 'between inner and outer boundaries (balanced)' : best.key === 'manual' ? 'near or beyond the outer boundary (aggressive)' : 'at the origin (baseline)') + '.');
            }
            hcDesc.innerHTML = hLines.join('');
          } else {
            hcDesc.style.display = 'none';
          }
        }
      }

      // Expose to window so other <script> blocks (e.g. _doUIRefresh) can call them
      window.updateProgressDescription = updateProgressDescription;
      window.updateRecommendation      = updateRecommendation;

      window.renderRightLegend = function(){ /* kept hidden via CSS */ };

      function dsLine(opts) {
        var c = cssVar(opts.colorVar) || '#666';
        return {
          label: opts.label,
          data: opts.data,
          parsing: false,
          borderColor: c,
          backgroundColor: c,
          borderWidth: 2,
          pointRadius: 0,
          cubicInterpolationMode: 'monotone',
          tension: (typeof opts.tension==='number') ? opts.tension : 0.25,
          spanGaps: true,
          hidden: !!opts.hidden,
          fill: !!opts.fill,
          order: (typeof opts.z==='number') ? opts.z : 1
        };
      }
      function dsTargetDot(cfg) {
        if (cfg.x==null || !Array.isArray(cfg.series) || !cfg.series.length) return null;
        var y = window.interpY(cfg.series, cfg.x);
        if (y==null || !isFinite(y)) return null;
        var c = cssVar(cfg.colorVar) || '#333';
        return {
          type: 'scatter',
          label: cfg.key+' target',
          _probKey: cfg.key,
          data: [{x: cfg.x, y: y}],
          pointBackgroundColor: c,
          pointBorderColor: c,
          pointRadius: 4,
          pointHoverRadius: 5,
          showLine: false,
          order: 0
        };
      }
      function fitScales(chart, seriesArrays, kind) {
        if (!chart || !seriesArrays || !seriesArrays.length) return;
        var b = window.boundsFromSeries(seriesArrays);
        if (!b) return;
        chart.options.scales.x.min = b.xmin;
        chart.options.scales.x.max = b.xmax;
        if (kind==='pdf') {
          chart.options.scales.y.min = Math.max(0, b.ymin);
          chart.options.scales.y.max = Math.max(0.05, b.ymax);
        } else {
          chart.options.scales.y.min = 0;
          chart.options.scales.y.max = 1;
        }
      }

      // Debounced chart update — coalesces rapid calls within 30ms but executes first call immediately
      var _chartUpdateTimer = null;
      var _chartUpdateLast = 0;
      window.updateChart = function(){
        var now = Date.now();
        if (now - _chartUpdateLast < 30) {
          // Rapid call — debounce it
          if (_chartUpdateTimer) clearTimeout(_chartUpdateTimer);
          _chartUpdateTimer = setTimeout(function(){
            _chartUpdateTimer = null;
            _chartUpdateLast = Date.now();
            window._doUpdateChart();
          }, 30);
          return;
        }
        // First call or enough time passed — execute immediately
        if (_chartUpdateTimer) clearTimeout(_chartUpdateTimer);
        _chartUpdateTimer = null;
        _chartUpdateLast = now;
        window._doUpdateChart();
      };
      window._doUpdateChart = function(){
        var s = WS();
        if (typeof window.ensureCharts === 'function') window.ensureCharts();
        var msgEl = document.getElementById('plotMsg');
        var isGrp = window.TM && window.TM.mode === 'aggregate';

        // In Group mode: have data once aggCdf is available (Triangle/BetaPERT are also
        // computed client-side from groupO/M/P and stored in s.trianglePdf/betaPertPdf)
        var haveAny = (s.trianglePdf && s.trianglePdf.length) ||
                      (s.betaPertPdf && s.betaPertPdf.length) ||
                      (s.basePdf && s.basePdf.length) ||
                      (isGrp && s.aggCdf && s.aggCdf.length > 0);

        if (!haveAny) {
          if (msgEl) { msgEl.style.display='block'; msgEl.textContent= isGrp ? 'Click Save \u25ba Run to compute the group distribution.' : 'Select a task to view distributions.'; }
          return;
        } else if (msgEl) { msgEl.style.display='none'; }

        var onOverlay = (s.tab === 'overlay');

        function buildDatasets(kind) {
          // Triangle and Beta-PERT: in Group mode these are computed analytically
          // from groupO/M/P (set in _showAggregateResult via computeTriDist_/computeBetaPertDist_)
          var triSeries = (kind==='pdf') ? (s.trianglePdf||[]) : (s.triangleCdf||[]);
          var betSeries = (kind==='pdf') ? (s.betaPertPdf||[]) : (s.betaPertCdf||[]);
          // Baseline: Group mode uses MC aggregate; Single mode uses MC baseline
          var baseSeries= isGrp
            ? ((kind==='pdf') ? (s.aggPdf||[]) : (s.aggCdf||[]))
            : ((kind==='pdf') ? (s.basePdf||[]) : (s.baseCdf||[]));
          var manSeries = (kind==='pdf') ? (s.adjPdf||[]) : (s.adjCdf||[]);
          var fixSeries = (kind==='pdf') ? (s.optPdfFixed||[]) : (s.optCdfFixed||[]);
          var adaSeries = (kind==='pdf') ? (s.optPdfAdaptive||[]) : (s.optCdfAdaptive||[]);

          var showTri  = !onOverlay && s.tab==='progress' && s.progress.triOn;
          var showBet  = !onOverlay && s.tab==='progress' && s.progress.betaOn;
          var showBase = !onOverlay && s.tab==='progress' && s.progress.baseOn;

          var base = dsLine({ label: 'Baseline', data: baseSeries, colorVar: '--base', z: 3, hidden: !(onOverlay ? s.overlay.baselineOn : showBase) });
          var tri  = dsLine({ label: 'Triangle', data: triSeries, colorVar: '--tri',  z: 2, hidden: !showTri });
          var bet  = dsLine({ label: 'Beta-PERT', data: betSeries, colorVar: '--beta', z: 2, hidden: !showBet });

          var man  = dsLine({ label: 'Unconstrained', data: manSeries, colorVar: '--manual', z: 4, hidden: !(onOverlay && s.overlay && s.overlay.manualOn) });
          var fix  = dsLine({ label: 'General Opt.', data: fixSeries, colorVar: '--fixed',  z: 4, hidden: !(onOverlay && s.overlay && s.overlay.fixedOn) });
          var ada  = dsLine({ label: 'Conservative', data: adaSeries, colorVar: '--adaptive', z:4, hidden: !(onOverlay && s.overlay && s.overlay.adaptiveOn) });

          var dotBase = onOverlay && s.overlay.baselineOn ? dsTargetDot({ key:'baseline', x:(s.target), series: baseSeries, colorVar: '--base' }) : null;
          var dotAdj  = onOverlay && s.overlay.manualOn   ? dsTargetDot({ key:'adjusted', x:(s.target), series: manSeries,  colorVar:'--manual' }) : null;
          var dotOpt  = onOverlay && s.overlay.fixedOn    ? dsTargetDot({ key:'optimized',x:(s.target), series: fixSeries,  colorVar:'--fixed' }) : null;
          var dotAda  = onOverlay && s.overlay.adaptiveOn ? dsTargetDot({ key:'adaptive', x:(s.target), series: adaSeries,  colorVar:'--adaptive' }) : null;

          // Progress tab: annotated dots on visible curves at the target value
          var dotTri  = (!onOverlay && showTri)  ? dsTargetDot({ key:'triangle', x:(s.target), series: triSeries, colorVar:'--tri' }) : null;
          var dotBet  = (!onOverlay && showBet)  ? dsTargetDot({ key:'betapert', x:(s.target), series: betSeries, colorVar:'--beta' }) : null;
          var dotPBase= (!onOverlay && showBase) ? dsTargetDot({ key:'baseline', x:(s.target), series: baseSeries, colorVar:'--base' }) : null;

          var arr = [base, tri, bet, man, fix, ada, dotBase, dotAdj, dotOpt, dotAda, dotTri, dotBet, dotPBase].filter(Boolean);
          return arr;
        }

        if (s.pdfChart) {
          var pdfDs = buildDatasets('pdf');
          s.pdfChart.data.datasets = pdfDs;
          var pdfSeriesForBounds = [];
          for (var i=0;i<pdfDs.length;i++) {
            var d = pdfDs[i];
            if (d.type !== 'scatter' && !d.hidden) pdfSeriesForBounds.push(d.data);
          }
          fitScales(s.pdfChart, pdfSeriesForBounds, 'pdf');
          s.pdfChart.update('none');
        }

        if (s.cdfChart) {
          var cdfDs = buildDatasets('cdf');
          s.cdfChart.data.datasets = cdfDs;
          var cdfSeriesForBounds = [];
          for (var j=0;j<cdfDs.length;j++) {
            var d2 = cdfDs[j];
            if (d2.type !== 'scatter' && !d2.hidden) cdfSeriesForBounds.push(d2.data);
          }
          fitScales(s.cdfChart, cdfSeriesForBounds, 'cdf');
          s.cdfChart.update('none');
        }

        var legOverlay = document.getElementById('legendOverlay');
        var legDist = document.getElementById('legendDistributions');
        if (legOverlay && legDist) {
          legOverlay.style.display = onOverlay ? 'flex' : 'none';
          legDist.style.display = onOverlay ? 'none' : 'flex';
        }

        // Debounced 3D hypercube render — prevents blocking the main thread on every chart update
        if (typeof window.visualizeHypercubeOnBaseline === 'function' && onOverlay) {
          if (window._hcTimer) clearTimeout(window._hcTimer);
          window._hcTimer = setTimeout(function(){
            window._hcTimer = null;
            var hcSection = document.getElementById('hypercubeSection');
            if (hcSection && hcSection.offsetParent !== null) {
              window.visualizeHypercubeOnBaseline();
            }
          }, 400);
        }
      };

      document.addEventListener('DOMContentLoaded', function(){
        if (typeof window.renderRightLegend === 'function') window.renderRightLegend();
        if (typeof window.renderKPIs === 'function') window.renderKPIs();
        if (typeof window.updateChart === 'function') window.updateChart();
        if (typeof window.initProbeUI === 'function') window.initProbeUI();
        if (typeof window.initPlotHelp === 'function') window.initPlotHelp();
      });
    })();
  </script>

  <!-- Combined Visualization: Original Radar + New 3D Rotating Hypercube with VISIBLE LABELS -->
  <script>
    function visualizeHypercubeOnBaseline() {
      const S = window.S || {};

      // 1. Original Radar Chart
      const radarCanvas = document.getElementById('hypercubeRadar');
      if (radarCanvas) {
        let suffix = '';
        if (S.overlay?.adaptiveOn) suffix = '_adapt';
        else if (S.overlay?.fixedOn) suffix = '_fixed';
        else if (S.overlay?.manualOn) suffix = '';
        else suffix = '_base';

        const sliderIds = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
        const labels = ['Budget Flexibility','Schedule Flexibility','Scope Certainty','Scope Reduction Allowance','Rework Percentage','Risk Tolerance','User Confidence'];

        const values = sliderIds.map(id => {
          const el = document.getElementById(id + suffix);
          return el ? Number(el.value) : 0;
        });

        const radarData = values.map((v, i) => i === 4 ? v * 2 : v);
        const baselineRef = new Array(labels.length).fill(50);

        const data = {
          labels: labels,
          datasets: [
            {
              label: 'Current Sliders (%)',
              data: radarData,
              fill: true,
              backgroundColor: 'rgba(59, 130, 246, 0.2)',
              borderColor: 'rgb(59, 130, 246)',
              pointBackgroundColor: 'rgb(59, 130, 246)',
              pointBorderColor: '#fff'
            },
            {
              label: 'Baseline Reference (50%)',
              data: baselineRef,
              fill: false,
              borderColor: 'rgba(34, 197, 94, 0.8)',
              pointBackgroundColor: 'rgb(34, 197, 94)',
              borderDash: [5, 5]
            }
          ]
        };

        const config = {
          type: 'radar',
          data: data,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: '7D Hypercube Projection – Current Slider Configuration',
                font: { size: 14 }
              },
              legend: { position: 'top' },
              tooltip: { enabled: true }
            },
            scales: {
              r: {
                min: 0,
                max: 100,
                ticks: { stepSize: 20 }
              }
            }
          }
        };

        if (window.hyperRadarChart) {
          // Update data in-place instead of destroying and recreating
          window.hyperRadarChart.data.datasets[0].data = radarData;
          window.hyperRadarChart.update('none');
        } else {
          window.hyperRadarChart = new Chart(radarCanvas, config);
        }
      }

      // 2. 3D Rotating Hypercube with VISIBLE LABELS (minimal fix: transparent: true)
      const canvas3D = document.getElementById('hypercube3D');
      if (!canvas3D) return;

      // Clean up previous Three.js renderer to prevent memory leaks
      if (window._hypercubeRenderer) {
        window._hypercubeRenderer.dispose();
        window._hypercubeRenderer = null;
      }

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8f9fa);

      const camera = new THREE.PerspectiveCamera(60, canvas3D.clientWidth / canvas3D.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ canvas: canvas3D, antialias: true });
      renderer.setSize(canvas3D.clientWidth, canvas3D.clientHeight || 320);
      renderer.setPixelRatio(window.devicePixelRatio);
      window._hypercubeRenderer = renderer;

      const ambientLight = new THREE.AmbientLight(0xffffff, 1);
      scene.add(ambientLight);

      let suffix = '';
      if (S.overlay?.adaptiveOn) suffix = '_adapt';
      else if (S.overlay?.fixedOn) suffix = '_fixed';
      else if (S.overlay?.manualOn) suffix = '';
      else suffix = '_base';

      const sliderIds = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
      const sliderLabels = ['Budget Flex','Schedule Flex','Scope Certainty','Scope Red','Rework %','Risk Tol','User Conf'];
      const sliderValues = sliderIds.map(id => Number(document.getElementById(id + suffix)?.value || 0) / 100);

      const baselineLabels = ['Baseline Mean','Baseline Variance','Baseline Prob'];
      const baselineValues = [
        (S.M || 50) / 100,
        ((S.P - S.O)/6 || 10) / 100,
        S.baselineProb || 0.5
      ];

      const vertices4D = [];
      for (let i = 0; i < 16; i++) {
        vertices4D.push([(i & 1 ? 1 : -1), (i & 2 ? 1 : -1), (i & 4 ? 1 : -1), (i & 8 ? 1 : -1)]);
      }

      const edges = [];
      for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
          if (((i ^ j) & -(i ^ j)) === (i ^ j)) edges.push([i, j]);
        }
      }

      let angles = sliderValues.map(v => v * Math.PI * 2);

      const material = new THREE.LineBasicMaterial({ color: 0x0066ff });

      const group = new THREE.Group();
      scene.add(group);

      function updateHypercube() {
        group.clear();

        const projected = vertices4D.map(v => {
          let [x, y, z, w] = v;
          for (let p = 0; p < 6; p++) {
            const theta = angles[p];
            const c = Math.cos(theta), s = Math.sin(theta);
            switch (p) {
              case 0: [x, y] = [x*c - y*s, x*s + y*c]; break;
              case 1: [x, z] = [x*c - z*s, x*s + z*c]; break;
              case 2: [x, w] = [x*c - w*s, x*s + w*c]; break;
              case 3: [y, z] = [y*c - z*s, y*s + z*c]; break;
              case 4: [y, w] = [y*c - w*s, y*s + w*c]; break;
              case 5: [z, w] = [z*c - w*s, z*s + w*c]; break;
            }
          }
          x *= (1 + baselineValues[0]);
          y *= (1 + baselineValues[1]);
          z *= (1 + baselineValues[2]);
          const dist = 4;
          const scale = dist / (dist + w);
          return new THREE.Vector3(x * scale, y * scale, z * scale);
        });

        edges.forEach(([i, j]) => {
          const geo = new THREE.BufferGeometry().setFromPoints([projected[i], projected[j]]);
          const line = new THREE.Line(geo, material);
          group.add(line);
        });
      }

      function addLabel(text, position, opts) {
        opts = opts || {};
        const fontSize = opts.fontSize || 38;
        const canvasLabel = document.createElement('canvas');
        canvasLabel.width = 320;
        canvasLabel.height = 64;
        const ctx = canvasLabel.getContext('2d');
        // Transparent background
        ctx.font = 'bold ' + fontSize + 'px Arial';
        ctx.fillStyle = opts.color || '#374151';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvasLabel.width / 2, canvasLabel.height / 2);

        const texture = new THREE.CanvasTexture(canvasLabel);
        const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.position.copy(position);
        sprite.scale.set(opts.scaleX || 3.5, opts.scaleY || 0.7, 1);
        group.add(sprite);
      }

      const allLabels = baselineLabels.map((l, i) => `${l}: ${(baselineValues[i]*100).toFixed(0)}%`)
        .concat(sliderLabels.map((l, i) => `${l}: ${(sliderValues[i]*100).toFixed(0)}%`));

      allLabels.forEach((label, i) => {
        const pos = new THREE.Vector3((i % 3 - 1) * 4.5, (Math.floor(i / 3) % 3 - 1) * 4.5, Math.floor(i / 9) * 4.5 - 2);
        addLabel(label, pos);
      });

      const prob = S.adaptiveProb || S.optimizedProb || S.adjustedProb || S.baselineProb || 0;
      addLabel(`Target Probability: ${(prob * 100).toFixed(1)}%`, new THREE.Vector3(0, -4.5, 0));

      updateHypercube();

      camera.position.z = 10;

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = false; // Disable damping — removes need for animation loop
      window._hypercubeControls = controls; // expose for toggleChartZoom

      // Add axes helper for labels
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      // Add axis labels with slider dimension names
      // X = Budget Flexibility, Y = Schedule Flexibility, Z = Scope Certainty
      // (first 3 of 7 sliders; the remaining 4 are folded into the 4th hypercube dimension)
      addLabel('Budget Flex (X)', new THREE.Vector3(6.2, 0, 0));
      addLabel('Schedule Flex (Y)', new THREE.Vector3(0, 6.2, 0));
      addLabel('Scope Certainty (Z)', new THREE.Vector3(0, 0, 6.2));

      // Cancel any previous animation loop
      if (window._hypercubeAnimId) { cancelAnimationFrame(window._hypercubeAnimId); window._hypercubeAnimId = null; }

      // On-demand rendering instead of 60fps loop — only render when user interacts
      function renderOnce() { renderer.render(scene, camera); }
      renderOnce();
      controls.addEventListener('change', renderOnce);

      // Single resize listener (remove previous to prevent stacking)
      if (window._hcResizeHandler) window.removeEventListener('resize', window._hcResizeHandler);
      window._hcResizeHandler = function() {
        if (!canvas3D.offsetParent) return;
        camera.aspect = canvas3D.clientWidth / canvas3D.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(canvas3D.clientWidth, canvas3D.clientHeight || 320);
        renderOnce();
      };
      window.addEventListener('resize', window._hcResizeHandler, { passive: true });

      // Add subtitles dynamically
      const target = S.target ? S.target.toFixed(2) : 'N/A';
      const probability = ((S.adaptiveProb || S.optimizedProb || S.adjustedProb || S.baselineProb || 0) * 100).toFixed(2) + '%';
      document.getElementById('radarSubtitle').textContent = `Target: ${target}, Probability: ${probability}`;
      document.getElementById('hypercubeSubtitle').textContent = `Target: ${target}, Probability: ${probability}`;
    }
  </script>

  <!-- API Fetch, Variant Requests, UI Bindings & Boot -->
  <script>
    (function(){
      function safe(fn){ try { fn(); } catch(e){
        console.error('[safe] error:', e);
        var b = document.getElementById('errorBanner');
        if (b) { b.style.display='block'; b.style.background='#FEE2E2'; b.style.color='#991B1B'; b.style.borderColor='#DC2626'; b.innerHTML += '<div>[SAFE] '+e.message+' at '+(e.stack||'').split('\\n')[1]+'</div>'; }
        fetch('/console',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({type:'error',msg:'[safe] '+e.message,stack:e.stack})}).catch(function(){});
      } }
      function WS(){ return window.S || (window.S = {}); }

      // ── Probability summary bar ───────────────────────────────────────────
      window.updateProbSummary = function() {
        var bar = document.getElementById('probSummaryBar');
        if (!bar) return;
        var s = window.S || {};
        if (s.tab !== 'overlay') { bar.style.display = 'none'; return; }
        var tau = (s.target != null && isFinite(s.target)) ? Number(s.target) : null;
        var P0  = s.baselineProb;
        if (tau == null || P0 == null || !isFinite(P0)) { bar.style.display = 'none'; return; }
        bar.style.display = 'flex';
        var ov = s.overlay || {};
        var tauEl  = document.getElementById('psbTau');
        var baseEl = document.getElementById('psbBase');
        var guidEl = document.getElementById('psbGuided');
        var optEl  = document.getElementById('psbOptimized');
        var expEl  = document.getElementById('psbExplorer');
        if (tauEl)  tauEl.textContent  = '\u03c4\u202f=\u202f' + tau.toFixed(2);
        if (baseEl) baseEl.textContent = 'Baseline P\u2080\u202f=\u202f' + FMT.prob(P0);
        if (guidEl) {
          if (ov.adaptiveOn && s.adaptiveProb != null && isFinite(s.adaptiveProb)) {
            var dPg = (s.adaptiveProb - P0) * 100;
            guidEl.textContent = 'Conservative\u202f' + FMT.prob(s.adaptiveProb) + '\u202f(' + FMT.lift(dPg) + ')';
            guidEl.style.display = 'inline-block';
          } else { guidEl.style.display = 'none'; }
        }
        if (optEl) {
          if (ov.fixedOn && s.optimizedProb != null && isFinite(s.optimizedProb)) {
            var dPo = (s.optimizedProb - P0) * 100;
            optEl.textContent = 'General\u202f' + FMT.prob(s.optimizedProb) + '\u202f(' + FMT.lift(dPo) + ')';
            optEl.style.display = 'inline-block';
          } else { optEl.style.display = 'none'; }
        }
        if (expEl) {
          if (ov.manualOn && s.adjustedProb != null && isFinite(s.adjustedProb)) {
            var dPe = (s.adjustedProb - P0) * 100;
            expEl.textContent = 'Unconstrained\u202f' + FMT.prob(s.adjustedProb) + '\u202f(' + FMT.lift(dPe) + ')';
            expEl.style.display = 'inline-block';
          } else { expEl.style.display = 'none'; }
        }
      };

      // Consolidated UI refresh — coalesces rapid calls within 30ms
      var _uiRefreshTimer = null;
      function _doUIRefresh() {
        _uiRefreshTimer = null;
        safe(function(){ window.renderKPIs(); });
        safe(function(){ window.updateChart(); });
        safe(function(){ window.renderRightLegend(); });
        safe(function(){ if (typeof window.updateProbSummary === 'function') window.updateProbSummary(); });
        safe(function(){ if (typeof window.updateProgressDescription === 'function') window.updateProgressDescription(WS()); });
        safe(function(){ if (typeof window.updateRecommendation === 'function') window.updateRecommendation(WS()); });
        safe(function(){ _updateModeContext(); });
      }

      // Updates the mode context strip + plot pane headers to show active task/group
      function _updateModeContext() {
        var s = WS();
        var isGrp = window.TM && window.TM.mode === 'aggregate';
        var strip  = document.getElementById('modeContextStrip');
        var badge  = document.getElementById('modeContextBadge');
        var label  = document.getElementById('modeContextLabel');
        var pdfHdr = document.getElementById('pdfPaneHdr');
        var cdfHdr = document.getElementById('cdfPaneHdr');

        if (isGrp) {
          var n = (window.TM && window.TM.tasks)
            ? window.TM.tasks.filter(function(t) { return t.active; }).length : 0;
          var suffix = ' \u00b7 Group \u2014 ' + n + ' task' + (n !== 1 ? 's' : '') + ' (Monte Carlo aggregate)';
          if (strip) strip.style.display = 'flex';
          if (badge) { badge.textContent = 'GROUP'; badge.style.background = '#DBEAFE'; badge.style.color = '#1D4ED8'; }
          if (label) label.textContent = n + ' task' + (n !== 1 ? 's' : '') + ' \u2014 Monte Carlo aggregate distribution';
          if (pdfHdr) pdfHdr.textContent = 'Probability Density (PDF)' + suffix;
          if (cdfHdr) cdfHdr.textContent = 'Cumulative Distribution (CDF)' + suffix;
        } else {
          var taskName = (s.task && s.task.task) ? s.task.task : null;
          var suffix2  = taskName ? ' \u00b7 ' + taskName : '';
          if (strip) strip.style.display = taskName ? 'flex' : 'none';
          if (badge) { badge.textContent = 'SINGLE'; badge.style.background = '#D1FAE5'; badge.style.color = '#065F46'; }
          if (label) label.textContent = taskName ? ('Task: ' + taskName) : '';
          if (pdfHdr) pdfHdr.textContent = 'Probability Density (PDF)' + suffix2;
          if (cdfHdr) cdfHdr.textContent = 'Cumulative Distribution (CDF)' + suffix2;
        }
      }
      function scheduleUIRefresh() {
        if (_uiRefreshTimer) return; // already scheduled — coalesce
        _uiRefreshTimer = requestAnimationFrame(function() {
          _uiRefreshTimer = null;
          _doUIRefresh();
        });
      }
      window.scheduleUIRefresh = scheduleUIRefresh;

      /* ── Plot Selector (How It's Built tab) ─────────────────────────────
         Manages visibility of Triangle / PDF / CDF panes.
         Max 2 panes side-by-side; 3 selected → first 2 side-by-side, third
         wraps to a second row.                                              */
      window.pselUpdate = function() {
        var chkTri = document.getElementById('pselTriangle');
        var chkPDF = document.getElementById('pselPDF');
        var chkCDF = document.getElementById('pselCDF');
        if (!chkTri || !chkPDF || !chkCDF) return;

        var lTri = document.getElementById('pselChkTriangle');
        var lPDF = document.getElementById('pselChkPDF');
        var lCDF = document.getElementById('pselChkCDF');
        // Triangle pane is valid in both Single and Group mode (Group uses groupO/M/P)
        if (lTri) lTri.style.display = '';

        var showTri = chkTri.checked;
        var showPDF = chkPDF.checked;
        var showCDF = chkCDF.checked;

        // Sync the .checked CSS class on the labels for visual feedback
        if (lTri) lTri.classList.toggle('checked', showTri);
        if (lPDF) lPDF.classList.toggle('checked', showPDF);
        if (lCDF) lCDF.classList.toggle('checked', showCDF);

        // Enforce at least 1
        var count = [showTri, showPDF, showCDF].filter(Boolean).length;
        if (count === 0) {
          if (chkPDF) { chkPDF.checked = true; showPDF = true; if (lPDF) lPDF.classList.add('checked'); }
          count = 1;
        }

        var triWrap = document.getElementById('triWrap');
        var pdfWrap = document.getElementById('pdfWrap');
        var cdfWrap = document.getElementById('cdfWrap');
        var inner   = document.getElementById('plotInner');

        if (triWrap) triWrap.style.display = showTri ? 'flex' : 'none';
        if (pdfWrap) pdfWrap.style.display = showPDF ? 'flex' : 'none';
        if (cdfWrap) cdfWrap.style.display = showCDF ? 'flex' : 'none';

        if (inner) {
          if (count > 2) {
            // 3 visible: wrap at 2 per row
            inner.style.flexWrap = 'wrap';
            inner.style.height   = 'auto';
            [triWrap, pdfWrap, cdfWrap].forEach(function(el) {
              if (el) { el.style.flex = '1 1 48%'; el.style.minWidth = '260px'; el.style.height = 'min(380px,46vh)'; }
            });
          } else {
            inner.style.flexWrap = 'nowrap';
            inner.style.height   = 'min(420px,50vh)';
            [triWrap, pdfWrap, cdfWrap].forEach(function(el) {
              if (el) { el.style.flex = '1 1 0'; el.style.minWidth = '0'; el.style.height = ''; }
            });
          }
        }

        if (showTri) window._drawTriPlot();

        // Resize Chart.js after layout change
        setTimeout(function() {
          var s = window.S || {};
          if (s.pdfChart && typeof s.pdfChart.resize === 'function') s.pdfChart.resize();
          if (s.cdfChart && typeof s.cdfChart.resize === 'function') s.cdfChart.resize();
        }, 60);
      };

      /* ── Overlay Plot Selector (Compare Strategies tab) ───────────────────────
         Controls visibility of PDF, CDF, Radar, SACO 3D, Sphere.
         Default: CDF only — shows cumulative probability per strategy immediately.  */
      window.overlayPselUpdate = function() {
        var showPDF       = !!(document.getElementById('oselPDF')       && document.getElementById('oselPDF').checked);
        var showCDF       = !!(document.getElementById('oselCDF')       && document.getElementById('oselCDF').checked);
        var showRadar     = !!(document.getElementById('oselRadar')     && document.getElementById('oselRadar').checked);
        var showHypercube = !!(document.getElementById('oselHypercube') && document.getElementById('oselHypercube').checked);
        var showSaco      = !!(document.getElementById('oselSaco')      && document.getElementById('oselSaco').checked);
        var showSphere    = !!(document.getElementById('oselSphere')    && document.getElementById('oselSphere').checked);

        // Sync .checked CSS class on labels
        [['PDF','oselPDF'],['CDF','oselCDF'],['Radar','oselRadar'],['Hypercube','oselHypercube'],['Saco','oselSaco'],['Sphere','oselSphere']].forEach(function(pair) {
          var lbl = document.getElementById('oselChk' + pair[0]);
          var inp = document.getElementById(pair[1]);
          if (lbl && inp) lbl.classList.toggle('checked', inp.checked);
        });

        // Enforce at least 1 visible
        var total = [showPDF, showCDF, showRadar, showHypercube, showSaco, showSphere].filter(Boolean).length;
        if (total === 0) {
          var fallback = document.getElementById('oselCDF');
          if (fallback) { fallback.checked = true; showCDF = true; var lf = document.getElementById('oselChkCDF'); if (lf) lf.classList.add('checked'); }
        }

        // Triangle pane belongs to "How It's Built" only — always hide in overlay tab
        var triWrap = document.getElementById('triWrap');
        if (triWrap) triWrap.style.display = 'none';

        // PDF / CDF panes
        var pdfWrap = document.getElementById('pdfWrap');
        var cdfWrap = document.getElementById('cdfWrap');
        var inner   = document.getElementById('plotInner');
        if (pdfWrap) pdfWrap.style.display = showPDF ? 'flex' : 'none';
        if (cdfWrap) cdfWrap.style.display = showCDF ? 'flex' : 'none';
        if (inner) {
          var chartCount = [showPDF, showCDF].filter(Boolean).length;
          inner.style.display    = chartCount > 0 ? 'flex' : 'none';
          inner.style.flexWrap   = 'nowrap';
          inner.style.height     = 'min(420px,50vh)';
        }

        // Radar/Hypercube — each card is individually controlled inside #hypercubeSection.
        // The section itself is visible only when at least one of the two cards is shown.
        var hcSection    = document.getElementById('hypercubeSection');
        var radarCard    = document.getElementById('radarCard');
        var hypercube3DCard = document.getElementById('hypercube3DCard');
        var needHcSection = showRadar || showHypercube;
        if (hcSection)       hcSection.classList.toggle('visible', needHcSection);
        if (radarCard)       radarCard.style.display       = showRadar     ? '' : 'none';
        if (hypercube3DCard) hypercube3DCard.style.display = showHypercube ? '' : 'none';
        // Trigger renders when newly enabled
        if (showHypercube && typeof window.visualizeHypercubeOnBaseline === 'function') {
          setTimeout(function() {
            var hc = document.getElementById('hypercubeSection');
            if (hc && hc.offsetParent !== null) window.visualizeHypercubeOnBaseline();
          }, 120);
        }

        // SACO 3D and Sphere — individually controlled inside sacoVizSection
        var saco3dWrap  = document.getElementById('saco3dOuterWrap');
        var sphereWrap  = document.getElementById('sphereOuterWrap');
        var sacoSection = document.getElementById('sacoVizSection');
        if (saco3dWrap)  saco3dWrap.style.display  = showSaco   ? '' : 'none';
        if (sphereWrap)  sphereWrap.style.display  = showSphere ? '' : 'none';
        if (sacoSection) sacoSection.style.display  = (showSaco || showSphere) ? '' : 'none';
        // Sphere width: full row when alone, fixed 400px when beside SACO 3D
        if (sphereWrap) {
          if (showSphere && !showSaco) {
            sphereWrap.style.flex     = '1 1 auto';
            sphereWrap.style.maxWidth = '100%';
          } else {
            sphereWrap.style.flex     = '0 0 400px';
            sphereWrap.style.maxWidth = '400px';
          }
        }

        // Trigger 3D renders when newly checked
        if (showSaco   && window.PMCSaco3D)  setTimeout(function() { window.PMCSaco3D.render();  }, 80);
        if (showSphere && window.PMCSphere)  setTimeout(function() { window.PMCSphere.render();  }, 80);

        // Resize Chart.js after layout change
        setTimeout(function() {
          var s = window.S || {};
          if (s.pdfChart && typeof s.pdfChart.resize === 'function') s.pdfChart.resize();
          if (s.cdfChart && typeof s.cdfChart.resize === 'function') s.cdfChart.resize();
        }, 80);
      };

      /* Draw the triangle distribution shape on #triPlotCanvas */
      window._drawTriPlot = function() {
        var canvas = document.getElementById('triPlotCanvas');
        if (!canvas || !canvas.getContext) return;
        var s = window.S || {};
        var O = s.O, M = s.M, P = s.P;

        var dpr = window.devicePixelRatio || 1;
        var W = canvas.offsetWidth  || 320;
        var H = canvas.offsetHeight || 200;
        if (W < 10 || H < 10) return;
        canvas.width  = W * dpr;
        canvas.height = H * dpr;
        var ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#F9FAFB';
        ctx.fillRect(0, 0, W, H);

        if (O == null || M == null || P == null || isNaN(O) || isNaN(M) || isNaN(P) || O >= P) {
          ctx.fillStyle = '#9CA3AF';
          ctx.font = '11px system-ui, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('Select a task to see the triangle', W / 2, H / 2);
          return;
        }

        var padL = 36, padR = 16, padT = 28, padB = 46;
        var cW = W - padL - padR;
        var cH = H - padT - padB;
        function xv(v) { return padL + ((v - O) / (P - O)) * cW; }
        var baseY = padT + cH;
        var peakY = padT + 6;
        var pert  = (O + 4 * M + P) / 6;

        // Grid lines (faint)
        ctx.strokeStyle = '#E5E7EB'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(padL, baseY); ctx.lineTo(W - padR, baseY); ctx.stroke();

        // Triangle fill (blue-tinted)
        ctx.beginPath();
        ctx.moveTo(xv(O), baseY); ctx.lineTo(xv(M), peakY); ctx.lineTo(xv(P), baseY);
        ctx.closePath();
        ctx.fillStyle = 'rgba(59,130,246,0.13)'; ctx.fill();

        // Triangle stroke
        ctx.beginPath();
        ctx.moveTo(xv(O), baseY); ctx.lineTo(xv(M), peakY); ctx.lineTo(xv(P), baseY);
        ctx.closePath();
        ctx.strokeStyle = '#3B82F6'; ctx.lineWidth = 2.5; ctx.stroke();

        // Most Likely dashed vertical
        ctx.beginPath(); ctx.moveTo(xv(M), peakY); ctx.lineTo(xv(M), baseY);
        ctx.strokeStyle = 'rgba(59,130,246,0.4)'; ctx.lineWidth = 1.2;
        ctx.setLineDash([4, 4]); ctx.stroke(); ctx.setLineDash([]);

        // PERT mean line (amber)
        if (pert >= O && pert <= P) {
          var triHAtPert = (pert <= M)
            ? (pert - O) / (M - O) * (baseY - peakY)
            : (P - pert) / (P - M) * (baseY - peakY);
          var pertTopY = baseY - triHAtPert;
          ctx.beginPath(); ctx.moveTo(xv(pert), baseY); ctx.lineTo(xv(pert), pertTopY);
          ctx.strokeStyle = '#F59E0B'; ctx.lineWidth = 1.8;
          ctx.setLineDash([3, 3]); ctx.stroke(); ctx.setLineDash([]);
        }

        // Target τ line — green, full height, labeled with P(≤τ)
        var tgt = s.target;
        if (tgt != null && isFinite(tgt) && tgt > O && tgt < P) {
          var triHAtTgt = (tgt <= M)
            ? (tgt - O) / (M - O) * (baseY - peakY)
            : (P - tgt) / (P - M) * (baseY - peakY);
          var tgtTopY = baseY - triHAtTgt;
          ctx.beginPath(); ctx.moveTo(xv(tgt), baseY); ctx.lineTo(xv(tgt), tgtTopY);
          ctx.strokeStyle = '#10B981'; ctx.lineWidth = 2;
          ctx.setLineDash([4, 3]); ctx.stroke(); ctx.setLineDash([]);
          // Triangle CDF at target
          var triCdf = (tgt <= M)
            ? Math.pow(tgt - O, 2) / ((P - O) * (M - O))
            : 1 - Math.pow(P - tgt, 2) / ((P - O) * (P - M));
          var tgtLblX = xv(tgt);
          if (tgtLblX > W - padR - 58) tgtLblX = W - padR - 58;
          if (tgtLblX < padL + 5)      tgtLblX = padL + 5;
          ctx.font = 'bold 9px system-ui,sans-serif';
          ctx.fillStyle = '#047857';
          ctx.textAlign = 'center'; ctx.textBaseline = 'top';
          // Place label below peak to avoid overlapping title chip at top
          var tgtLblY = tgtTopY + 4;
          if (tgtLblY < padT + 14) tgtLblY = padT + 14;
          ctx.fillText('\u03C4=' + Number(tgt).toFixed(1) + '  P=' + (triCdf * 100).toFixed(1) + '%', tgtLblX, tgtLblY);
        }

        // Dots at O, M, P
        [[O, '#3B82F6', baseY], [M, '#3B82F6', peakY], [P, '#3B82F6', baseY]].forEach(function(pt) {
          ctx.beginPath(); ctx.arc(xv(pt[0]), pt[2], 4.5, 0, Math.PI * 2);
          ctx.fillStyle = pt[1]; ctx.fill();
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; ctx.stroke();
        });

        // Value labels
        ctx.font = 'bold 10px system-ui, sans-serif'; ctx.textBaseline = 'top'; ctx.fillStyle = '#374151';
        ctx.textAlign = 'left';   ctx.fillText(Number(O).toFixed(1), xv(O),      baseY + 5);
        ctx.textAlign = 'center'; ctx.fillText(Number(M).toFixed(1), xv(M),      baseY + 5);
        ctx.textAlign = 'right';  ctx.fillText(Number(P).toFixed(1), xv(P),      baseY + 5);

        // Name labels (below values)
        ctx.font = '9px system-ui, sans-serif'; ctx.fillStyle = '#6B7280';
        ctx.textAlign = 'left';   ctx.fillText('Best',       xv(O), baseY + 18);
        ctx.textAlign = 'center'; ctx.fillText('Mode',       xv(M), baseY + 18);
        ctx.textAlign = 'right';  ctx.fillText('Worst',      xv(P), baseY + 18);

        // PERT label (amber, above peak)
        if (pert >= O && pert <= P) {
          ctx.font = '10px system-ui, sans-serif'; ctx.fillStyle = '#B45309';
          ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
          ctx.fillText('PERT \u03BC=' + Number(pert).toFixed(1), xv(pert), peakY - 2);
        }

        // Title chip
        var units = (window.TM && window.TM.settings && window.TM.settings.units) ? window.TM.settings.units : '';
        var titleStr = 'O ' + Number(O).toFixed(1) + '  \u00B7  M ' + Number(M).toFixed(1) + '  \u00B7  P ' + Number(P).toFixed(1) + (units ? '  ' + units : '');
        ctx.font = 'bold 10px system-ui, sans-serif'; ctx.fillStyle = '#1E3A5F';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText(titleStr, W / 2, 4);

        // ── Hover crosshair (redrawn last, on top of everything) ──────────────
        if (window._triHoverRaw != null) {
          var hx = window._triHoverRaw;
          if (hx >= O && hx <= P) {
            var hxPx = xv(hx);
            // Height on the triangle surface at hx
            var triHh = (hx <= M && M > O)
              ? (hx - O) / (M - O) * (baseY - peakY)
              : (P > M ? (P - hx) / (P - M) * (baseY - peakY) : 0);
            var hTopY = baseY - triHh;
            // Triangle CDF at hx
            var triCdfH = (hx <= M)
              ? Math.pow(hx - O, 2) / ((P - O) * Math.max(1e-9, M - O))
              : 1 - Math.pow(P - hx, 2) / ((P - O) * Math.max(1e-9, P - M));
            triCdfH = Math.max(0, Math.min(1, triCdfH));
            ctx.save();
            // Vertical dashed line
            ctx.beginPath();
            ctx.moveTo(hxPx, padT); ctx.lineTo(hxPx, baseY);
            ctx.strokeStyle = 'rgba(107,114,128,0.5)';
            ctx.lineWidth = 1; ctx.setLineDash([4, 4]); ctx.stroke();
            // Horizontal dashed line at triangle surface
            if (hTopY >= padT && hTopY <= baseY) {
              ctx.beginPath();
              ctx.moveTo(padL, hTopY); ctx.lineTo(hxPx, hTopY);
              ctx.strokeStyle = 'rgba(107,114,128,0.3)';
              ctx.setLineDash([3, 3]); ctx.stroke();
            }
            ctx.setLineDash([]);
            // Tooltip bubble
            var tipTxt = '\u03c4 = ' + Number(hx).toFixed(1) + '  \u2192  P = ' + (triCdfH * 100).toFixed(1) + '%';
            ctx.font = 'bold 11px system-ui,sans-serif';
            var ttw = ctx.measureText(tipTxt).width;
            var tth = 14, tpad = 5;
            var ttX = hxPx + 8, ttY = padT + 14;
            if (ttX + ttw + tpad * 2 > W - padR) ttX = hxPx - ttw - tpad * 2 - 8;
            ctx.fillStyle = 'rgba(255,255,255,0.93)';
            ctx.strokeStyle = 'rgba(107,114,128,0.28)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            var rx3=ttX-tpad, ry3=ttY-tpad, rw3=ttw+tpad*2, rh3=tth+tpad*2, rr3=4;
            ctx.moveTo(rx3+rr3,ry3); ctx.lineTo(rx3+rw3-rr3,ry3);
            ctx.arcTo(rx3+rw3,ry3,rx3+rw3,ry3+rr3,rr3);
            ctx.lineTo(rx3+rw3,ry3+rh3-rr3);
            ctx.arcTo(rx3+rw3,ry3+rh3,rx3+rw3-rr3,ry3+rh3,rr3);
            ctx.lineTo(rx3+rr3,ry3+rh3);
            ctx.arcTo(rx3,ry3+rh3,rx3,ry3+rh3-rr3,rr3);
            ctx.lineTo(rx3,ry3+rr3);
            ctx.arcTo(rx3,ry3,rx3+rr3,ry3,rr3);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#374151';
            ctx.textAlign = 'left'; ctx.textBaseline = 'top';
            ctx.font = 'bold 11px system-ui,sans-serif';
            ctx.fillText(tipTxt, ttX, ttY + 1);
            ctx.restore();
          }
        }
      };

      // ── Mouse crosshair for triangle canvas ──────────────────────────────────
      (function() {
        function setupTriCrosshair() {
          var canvas = document.getElementById('triPlotCanvas');
          if (!canvas || canvas._xhairBound) return;
          canvas._xhairBound = true;
          canvas.addEventListener('mousemove', function(evt) {
            var s = window.S || {};
            var O2 = s.O, P2 = s.P;
            if (O2 == null || P2 == null || O2 >= P2) return;
            var rect = canvas.getBoundingClientRect();
            var dpr = window.devicePixelRatio || 1;
            var cssW = rect.width;
            var padL2 = 36, padR2 = 16;
            var cW2 = cssW - padL2 - padR2;
            var mx = evt.clientX - rect.left;
            var rawVal = O2 + ((mx - padL2) / cW2) * (P2 - O2);
            window._triHoverRaw = rawVal;
            if (typeof window._drawTriPlot === 'function') window._drawTriPlot();
          });
          canvas.addEventListener('mouseleave', function() {
            window._triHoverRaw = null;
            if (typeof window._drawTriPlot === 'function') window._drawTriPlot();
          });
        }
        setupTriCrosshair();
        // Also retry after a short delay in case canvas renders late
        setTimeout(setupTriCrosshair, 800);
      })();

      function ensureProbeBox(){
        if (typeof window.initProbeUI === 'function') window.initProbeUI();
        if (typeof window.syncProbeUI === 'function') window.syncProbeUI();
      }

      function setStatusLocal(t) {
        if (typeof window.setStatus === 'function') { window.setStatus(t); return; }
        var s = WS();
        var el = document.getElementById('fetchStatus');
        if (!el) return;
        var any = s.fetching || (s.overlay && s.overlay.variants && Object.keys(s.overlay.variants).some(function(k){ return !!s.overlay.variants[k].loading; }));
        el.textContent = any ? 'Fetching…' : (t || 'Ready');
        el.classList.toggle('fetching', any);
        el.classList.toggle('glow', any);
        var mini = document.getElementById('seriesStatus'); if (mini) mini.textContent = el.textContent;
      }

      function updateSliderTable(fixedSliders, adaptiveSliders) {
        const grid = document.getElementById('slidersGrid');
        if (!grid) return;

        const hasFixed = Object.values(fixedSliders).some(v => v > 0);
        const hasAdaptive = Object.values(adaptiveSliders).some(v => v > 0);
        let numCols = 1;
        if (hasFixed) numCols += 1;
        if (hasAdaptive) numCols += 1;

        const gridCols = Array(numCols).fill('1fr').join(' ');
        grid.style.gridTemplateColumns = gridCols;

        const headers = grid.querySelectorAll('.comp-header');
        headers[0].style.display = 'table-cell';
        const fixedHeader = grid.querySelector('.comp-header.comp-fixed');
        if (fixedHeader) fixedHeader.style.display = hasFixed ? 'table-cell' : 'none';
        const adaptiveHeader = grid.querySelector('.comp-header.comp-adaptive');
        if (adaptiveHeader) adaptiveHeader.style.display = hasAdaptive ? 'table-cell' : 'none';
      }

      function handleEmptyResponses(fixedData, adaptiveData) {
        if (fixedData.explain?.status === 'no-optimize') {
          console.log('No-optimize mode detected for Fixed, sliders zeroed:', fixedData);
        }
        if (adaptiveData.explain?.status === 'no-optimize') {
          console.log('No-optimize mode detected for Adaptive, sliders zeroed:', adaptiveData);
        }

        const adaptiveSliders = extractSliderVals(adaptiveData);
        if (Object.values(adaptiveSliders).every(v => v === 0)) {
          const status = adaptiveData.explain?.status || adaptiveData.optimize?.status || 'unknown';
          console.log(`Adaptive sliders zeroed (${status}):`, adaptiveData);
          if (status === 'no-optimize') {
            console.log('Intentional: Baseline optimal—no lift possible.');
          }
        }
      }

      function updateServerNote(fixedSliders, adaptiveSliders, fixedData, adaptiveData) {
        const allZero = Object.values(fixedSliders).every(v => v === 0) && 
                        Object.values(adaptiveSliders).every(v => v === 0);
        const noteEl = document.getElementById('slidersNoteMissing');
        if (!noteEl) return;

        if (allZero) {
          const fixedStatus = fixedData.explain?.status || fixedData.optimize?.status || 'unknown';
          const adaptiveStatus = adaptiveData.explain?.status || adaptiveData.optimize?.status || 'unknown';
          noteEl.textContent = (fixedStatus === 'no-optimize' || adaptiveStatus === 'no-optimize') 
            ? 'Baseline optimal—no adjustments boost probability.' 
            : 'Server did not return optimal slider values (both modes zeroed).';
          noteEl.style.display = 'block';
        } else {
          noteEl.style.display = 'none';
        }
      }

      var _sliderCompTimer = null;
      function updateSliderComparisons() {
        if (_sliderCompTimer) clearTimeout(_sliderCompTimer);
        _sliderCompTimer = setTimeout(_doUpdateSliderComparisons, 50);
      }
      function _doUpdateSliderComparisons() {
        _sliderCompTimer = null;
        var s = WS();
        if (s.pendingVariants > 0) { return; }
        var grid = document.getElementById('slidersGrid');
        if (!grid) return;

        const fixedSliders = extractSliderVals(s.explainOpt || {}, 'fixed');
        const adaptiveSliders = extractSliderVals(s.explainAdaptive || {}, 'adaptive');
        updateSliderTable(fixedSliders, adaptiveSliders);
        updateServerNote(fixedSliders, adaptiveSliders, s.explainOpt || {}, s.explainAdaptive || {});
        handleEmptyResponses(s.explainOpt || {}, s.explainAdaptive || {});

        var showFixed    = (s.tab === 'overlay') && !!s.overlay.fixedOn;
        var showAdaptive = (s.tab === 'overlay') && !!s.overlay.adaptiveOn;

        var i, nodes;
        nodes = grid.querySelectorAll('.comp-header.comp-fixed'); for(i=0;i<nodes.length;i++) nodes[i].style.display = showFixed ? 'block' : 'none';
        nodes = grid.querySelectorAll('.comp-header.comp-adaptive'); for(i=0;i<nodes.length;i++) nodes[i].style.display = showAdaptive ? 'block' : 'none';
        nodes = grid.querySelectorAll('.comp.comp-fixed'); for(i=0;i<nodes.length;i++) nodes[i].style.display = showFixed ? 'block' : 'none';
        nodes = grid.querySelectorAll('.comp.comp-adaptive'); for(i=0;i<nodes.length;i++) nodes[i].style.display = showAdaptive ? 'block' : 'none';

        setCompareValues('base', extractSliderVals(s.explainBase || s.lastPayload || {}));
        if (showFixed) setCompareValues('fixed', fixedSliders);
        if (showAdaptive) setCompareValues('adaptive', adaptiveSliders);

        var cols = 3 + (showFixed ? 1 : 0) + (showAdaptive ? 1 : 0);
        grid.style.gridTemplateColumns = '140px repeat('+(cols-1)+', 80px)';
        console.log('Table updated: full sync');

        // Render optimal markers on range slider tracks
        if (showFixed && fixedSliders) {
          Object.entries(fixedSliders).forEach(function(pair) {
            var id = sliderIdMap[pair[0]];
            if (!id) return;
            var markerEl = document.getElementById(id + '_marker');
            var rangeEl = document.getElementById(id + '_range');
            if (markerEl && rangeEl) {
              markerEl.innerHTML = '';
              var val = Number(pair[1]) || 0;
              var max = Number(rangeEl.max) || 100;
              var pct = (val / max) * 100;
              var dot = document.createElement('div');
              dot.className = 'marker-dot';
              dot.style.left = pct + '%';
              dot.title = 'Optimized: ' + val + '%';
              markerEl.appendChild(dot);
            }
            // Store fixed value on hidden input for Match Optimized button
            var fixedInput = document.getElementById(id + '_fixed');
            if (!fixedInput) {
              fixedInput = document.createElement('input');
              fixedInput.type = 'hidden';
              fixedInput.id = id + '_fixed';
              document.body.appendChild(fixedInput);
            }
            fixedInput.value = pair[1] || 0;
          });
        }

        // Render sensitivity bars
        renderSensitivityBars();
      }

      function renderSensitivityBars() {
        var container = document.getElementById('sensitivityContent');
        var panel = document.getElementById('sensitivityBars');
        if (!container || !panel) return;

        var s = WS();
        if (s.tab !== 'overlay') { panel.style.display = 'none'; return; }
        panel.style.display = 'block';

        var weights = s.currentWeights || {};
        var labels = {
          budget: 'Budget', schedule: 'Schedule', scopeCert: 'Scope Cert',
          scopeRed: 'Scope Red', rework: 'Rework', riskTol: 'Risk Tol', userConf: 'Confidence'
        };
        var entries = Object.entries(weights).map(function(pair) {
          return { key: pair[0], label: labels[pair[0]] || pair[0], weight: pair[1], absWeight: Math.abs(pair[1]) };
        });
        var maxW = Math.max.apply(null, entries.map(function(e) { return e.absWeight; }));
        if (maxW === 0) maxW = 1;

        container.innerHTML = entries.sort(function(a, b) { return b.absWeight - a.absWeight; }).map(function(e) {
          var pct = (e.absWeight / maxW * 100).toFixed(1);
          var cls = e.weight >= 0 ? 'positive' : 'negative';
          return '<div class="sens-row">' +
            '<span class="sens-label">' + e.label + '</span>' +
            '<div class="sens-bar-track"><div class="sens-bar-fill ' + cls + '" style="width:' + pct + '%"></div></div>' +
            '<span class="sens-val">' + (e.weight >= 0 ? '+' : '') + (e.weight * 100).toFixed(0) + '</span>' +
          '</div>';
        }).join('');
      }

      function fetchData(debounced) {
        var s = WS();
        if (debounced === undefined) debounced = true;

        // In Group mode all distributions are computed client-side in _showAggregateResult.
        // Never issue a server fetch for single-task data while in aggregate mode —
        // doing so would overwrite the group Triangle/BetaPERT series with stale single-task data.
        if (window.TM && window.TM.mode === 'aggregate') {
          clearTimeout(s.fetchTimer); s.fetchTimer = null;
          return;
        }

        if (!s || !s.task || !s.task.task) {
          setStatusLocal('No task selected');
          var msg = document.getElementById('plotMsg');
          if (msg) { msg.style.display='block'; msg.textContent='No task selected'; }
          return;
        }

        if (debounced) { clearTimeout(s.fetchTimer); s.fetchTimer = setTimeout(function(){ fetchData(false); }, 200); return; }
        if (s.fetching) return;
        // Skip if baseline data already loaded for current inputs (tab switch doesn't need re-fetch)
        if (s.trianglePdf.length && s.basePdf.length) {
          s.fetching = false; setStatusLocal('Ready');
          scheduleUIRefresh();
          return;
        }

        s.fetching = true; setStatusLocal('Fetching…');

        var baseKey = JSON.stringify({ task: s.task.task, O:s.O, M:s.M, P:s.P, target:s.target });

        if (s.baselineCache && s.baselineCache[baseKey]) {
          var c = s.baselineCache[baseKey];
          s.trianglePdf = c.trianglePdf; s.triangleCdf = c.triangleCdf;
          s.betaPertPdf = c.betaPertPdf; s.betaPertCdf = c.betaPertCdf;
          s.basePdf = c.basePdf; s.baseCdf = c.baseCdf;
          s.baselineProb = c.baselineProb;

          // C3: Skip event dispatch on cached baseline — data unchanged, just refresh UI
          s.fetching = false; setStatusLocal('Ready');
          updateTargetDisplayText();
          scheduleUIRefresh();
          ensureProbeBox();
          return;
        }

        var params = {
          task: s.task.task,
          optimistic: s.O, mostLikely: s.M, pessimistic: s.P,
          targetValue: (s.target != null ? s.target : s.M),
          optimize: false, mode: 'view', adaptive: false,
          reshapeTriangle: true, reshapeBetaPert: true
        };

        if (!window.google || !google.script || !google.script.run) {
          s.fetching = false; setStatusLocal('Ready');
          var msg2 = document.getElementById('plotMsg');
          if (msg2) { msg2.style.display='block'; msg2.textContent='Apps Script runtime not available (preview mode).'; }
          if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender();
          return;
        }

        google.script.run
          .withSuccessHandler(function(payload){
            if(window._pmcDebug)fetch('/console',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({type:'data',msg:'fetchData success handler called, payload keys: '+(payload ? Object.keys(payload).join(',') : 'null')})}).catch(function(){});
            try {
              if (!payload) throw new Error('Empty payload');
              var item = Array.isArray(payload.results) ? payload.results[0] : payload;
              if (!item) throw new Error('No result item');

              function gp(obj, path) {
                var parts = path.split('.');
                var cur = obj;
                for (var i=0;i<parts.length;i++){ var k = parts[i]; if (!cur || !(k in cur)) return null; cur = cur[k]; }
                return cur;
              }
              function pick(obj, paths){
                for (var i=0;i<paths.length;i++){ var v = gp(obj, paths[i]); if (v!=null) return v; }
                return null;
              }

              s.lastPayload = item;
              s.explainBase = item;

              var triPdfRaw = pick(item, ['trianglePdf.value','triangle.pdf','trianglePdfPoints','triangle.points.pdf']);
              var triCdfRaw = pick(item, ['triangleCdf.value','triangle.cdf','triangleCdfPoints','triangle.points.cdf']);
              var betPdfRaw = pick(item, ['betaPertPdf.value','betaPert.pdf','beta.pdf','pert.pdf']);
              var betCdfRaw = pick(item, ['betaPertCdf.value','betaPert.cdf','beta.cdf','pert.cdf']);
              var basePdfRaw= pick(item, ['targetProbabilityOriginalPdf.value','baselineReshapedPoints.pdfPoints','baseline.pdf','baseline.points.pdf']);
              var baseCdfRaw= pick(item, ['targetProbabilityOriginalCdf.value','baselineReshapedPoints.cdfPoints','baseline.cdf','baseline.points.cdf']);

              s.trianglePdf = normalizePoints_(triPdfRaw, true);
              s.triangleCdf = normalizePoints_(triCdfRaw, false);
              s.betaPertPdf = normalizePoints_(betPdfRaw, true);
              s.betaPertCdf = normalizePoints_(betCdfRaw, false);
              s.basePdf     = normalizePoints_(basePdfRaw, true);
              s.baseCdf     = normalizePoints_(baseCdfRaw, false);

              var baseProb = pick(item, [
                'targetProbability.value.original',
                'targetProbability.value.baseline',
                'baseline.prob',
                'baselineProbability',
                'probabilities.baseline'
              ]);
              s.baselineProb= (baseProb!=null) ? Number(baseProb) : ((s.target!=null && s.baseCdf.length) ? interpY(s.baseCdf, s.target) : null);

              const baseSliders = extractSliderVals(s.explainBase);
              setCompareValues('base', baseSliders);

              if (s.tab==='overlay' && s.overlay && s.overlay.manualOn) {
                var zero = true;
                var vals = (typeof window.sliderValues==='function' ? window.sliderValues() : {});
                var keys = ['budgetFlexibility','scheduleFlexibility','scopeCertainty','scopeReductionAllowance','reworkPercentage','riskTolerance','userConfidence'];
                for (var z=0;z<keys.length;z++){ if (Number(vals[keys[z]]||0)!==0) { zero=false; break; } }
                if (zero) { s.adjPdf = s.basePdf.slice(); s.adjCdf = s.baseCdf.slice(); s.adjustedProb = s.baselineProb; }
              }

              s.baselineCache[baseKey] = {
                trianglePdf:s.trianglePdf, triangleCdf:s.triangleCdf,
                betaPertPdf:s.betaPertPdf, betaPertCdf:s.betaPertCdf,
                basePdf:s.basePdf, baseCdf:s.baseCdf, baselineProb:s.baselineProb
              };

              if (typeof window.dispatchEvent === 'function') {
                window.dispatchEvent(new CustomEvent('pmc:baseline:ready', { detail: {
                  task: s.task, O: s.O, M: s.M, P: s.P, target: s.target,
                  baselineProb: s.baselineProb,
                  trianglePdf: s.trianglePdf, triangleCdf: s.triangleCdf,
                  betaPertPdf: s.betaPertPdf, betaPertCdf: s.betaPertCdf,
                  basePdf: s.basePdf, baseCdf: s.baseCdf,
                  lastPayload: s.lastPayload || null
                }}));
              }

              if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender();

              updateTargetDisplayText();
              scheduleUIRefresh();
              ensureProbeBox();
            } catch(e) {
              fetch('/console',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({type:'error',msg:'fetchData catch: '+e.message,stack:e.stack})}).catch(function(){});
              var msgEl = document.getElementById('plotMsg');
              if (msgEl) { msgEl.style.display='block'; msgEl.textContent='Error: '+e.message; }
            } finally {
              s.fetching=false; setStatusLocal('Ready');
            }
          })
          .withFailureHandler(function(err){
            var msgEl = document.getElementById('plotMsg');
            if (msgEl) { msgEl.style.display='block'; msgEl.textContent='API Error: '+(err && err.message ? err.message : String(err)); }
            s.fetching=false; setStatusLocal('Ready');
          })
          .getTargetProbabilityData(params);
      }

      window.requestVariant = requestVariant;
      window.onTaskChange = onTaskChange;

      function requestVariant(variant) {
        var s = WS();
        if (!s || !s.task || !s.task.task) return;
        if (s.tab !== 'overlay') return;

        var vState = s.overlay && s.overlay.variants ? s.overlay.variants[variant] : null;
        if (!vState) return;

        var key = JSON.stringify({
          task: s.task.task, O: s.O, M: s.M, P: s.P, target: s.target,
          variant: variant,
          probeLevel: (variant==='adaptive' ? (s.overlay?.probeLevel || 3) : undefined)
        });
        var cached = s.variantCache && s.variantCache[key];
        if (cached) {
          applyVariantResult(variant, cached);
          if (variant==='fixed')   setCompareValues('fixed',   extractSliderVals(cached.explainOpt));
          if (variant==='adaptive')setCompareValues('adaptive',extractSliderVals(cached.explainAdaptive));
          if (variant==='fixed' || variant==='adaptive') updateSliderSidebarState();
          // C4: Skip event dispatch on cached variant — data unchanged, just refresh UI
          window.scheduleUIRefresh();
          updateSliderComparisons();
          setStatusLocal();
          ensureProbeBox();
          return;
        }

        vState.loading = true; vState.error = null; setStatusLocal('Fetching…');
        safe(function(){ window.renderKPIs(); });
        safe(function(){ window.renderRightLegend(); });
        ensureProbeBox();

        var token = ++vState.token;

        var isManual   = (variant === 'manual');
        var isFixed    = (variant === 'fixed');
        var isAdaptive = (variant === 'adaptive');

        var params = {
          task: s.task.task,
          optimistic: s.O, mostLikely: s.M, pessimistic: s.P,
          targetValue: (s.target != null ? s.target : s.M),
          optimize: !isManual,
          mode: isManual ? 'view' : (isAdaptive ? 'adaptive' : 'fixed'),
          adaptive: isAdaptive,
          probeLevel: isManual ? 0 : (isAdaptive ? (s.overlay?.probeLevel || 3) : undefined),
          sliderValues: isManual ? (typeof window.sliderValues==='function' ? window.sliderValues() : undefined) : undefined,
          reshapeTriangle: true, reshapeBetaPert: true
        };

        if (!window.google || !google.script || !google.script.run) {
          vState.loading = false; vState.error = 'Apps Script runtime not available';
          safe(function(){ window.renderRightLegend(); }); updateSliderComparisons(); setStatusLocal('Ready');
          return;
        }

        google.script.run
          .withSuccessHandler(function(payload){
            if (token !== vState.token) return;
            try {
              var item = Array.isArray(payload && payload.results) ? payload.results[0] : payload;
              if (!item) throw new Error('No result item');
              s.lastPayload = item;

              function normalizePoints_(arr, isPdf) {
                if (!Array.isArray(arr)) return [];
                var out = [];
                for (var i2=0;i2<arr.length;i2++){
                  var p = arr[i2] || {};
                  var x = Number(p.x), y = Number(p.y);
                  if (isFinite(x) && isFinite(y)) out.push({x:x,y:y});
                }
                out.sort(function(a,b){ return a.x-b.x; });
                if (isPdf && out.length>=2) {
                  if (out[0].y !== 0) out.unshift({x: out[0].x - 0.01, y: 0});
                  if (out[out.length-1].y !== 0) out.push({x: out[out.length-1].x + 0.01, y: 0});
                }
                return out;
              }

              function gp(obj, path) {
                var parts = path.split('.');
                var cur = obj;
                for (var i=0;i<parts.length;i++){ var k = parts[i]; if (!cur || !(k in cur)) return null; cur = cur[k]; }
                return cur;
              }
              function pick(obj, paths){
                for (var i=0;i<paths.length;i++){ var v = gp(obj, paths[i]); if (v!=null) return v; }
                return null;
              }

              if (isManual) {
                var adjPdfRaw = pick(item, ['targetProbabilityAdjustedPdf.value','adjustedReshapedPoints.pdfPoints','adjusted.pdf']);
                var adjCdfRaw = pick(item, ['targetProbabilityAdjustedCdf.value','adjustedReshapedPoints.cdfPoints','adjusted.cdf']);
                var adjProbRaw= pick(item, ['targetProbability.value.adjusted','adjustedProbability','probabilities.adjusted']);
                if (!adjPdfRaw || !adjCdfRaw) throw new Error('Adjusted curve missing');
                s.adjPdf = normalizePoints_(adjPdfRaw, true);
                s.adjCdf = normalizePoints_(adjCdfRaw, false);
                s.adjustedProb = (adjProbRaw!=null) ? Number(adjProbRaw)
                                : ((s.target!=null && s.adjCdf.length) ? interpY(s.adjCdf, s.target) : null);
                s.explainAdj = item;
                s.pendingVariants = Math.max(0, s.pendingVariants - 1);
                if (s.pendingVariants === 0) { updateSliderComparisons(); }

              } else if (isFixed) {
                var optPdfRaw = pick(item, ['optimizedReshapedPoints.pdfPoints','optimized.pdf','fixed.pdf']);
                var optCdfRaw = pick(item, ['optimizedReshapedPoints.cdfPoints','optimized.cdf','fixed.cdf']);
                s.optPdfFixed = normalizePoints_(optPdfRaw, true);
                s.optCdfFixed = normalizePoints_(optCdfRaw, false);
                var optProb = pick(item, ['targetProbability.value.adjustedOptimized','optimizedProbability','probabilities.optimized']);
                s.optimizedProb = (optProb!=null) ? Number(optProb)
                                  : ((s.target!=null && s.optCdfFixed.length) ? interpY(s.optCdfFixed, s.target) : null);
                s.explainOpt = item;

                const fixedSliders = extractSliderVals(s.explainOpt);
                setCompareValues('fixed', fixedSliders);
                updateSliderSidebarState();
                s.pendingVariants--;
                if (s.pendingVariants === 0) { updateSliderComparisons(); }

              } else if (isAdaptive) {
                var aPdfRaw = pick(item, ['adaptiveReshapedPoints.pdfPoints','adaptive.pdf','optimizedReshapedPoints.pdfPoints']);
                var aCdfRaw = pick(item, ['adaptiveReshapedPoints.cdfPoints','adaptive.cdf','optimizedReshapedPoints.cdfPoints']);
                console.log('[PMC] Adaptive result — pdfPts:', (aPdfRaw||[]).length, 'cdfPts:', (aCdfRaw||[]).length);
                s.optPdfAdaptive = normalizePoints_(aPdfRaw, true);
                s.optCdfAdaptive = normalizePoints_(aCdfRaw, false);
                var aProb = pick(item, ['targetProbability.value.adaptiveOptimized','adaptiveProbability','probabilities.adaptive','targetProbability.value.adjustedOptimized']);
                console.log('[PMC] Adaptive prob raw:', aProb, '→ stored:', (aProb!=null) ? Number(aProb) : 'interpolate');
                s.adaptiveProb = (aProb!=null) ? Number(aProb)
                                 : ((s.target!=null && s.optCdfAdaptive.length) ? interpY(s.optCdfAdaptive, s.target) : null);
                console.log('[PMC] s.adaptiveProb =', s.adaptiveProb);
                s.explainAdaptive = item;

                const adaptiveSliders = extractSliderVals(s.explainAdaptive);
                setCompareValues('adaptive', adaptiveSliders);
                updateSliderSidebarState();
                s.pendingVariants--;
                if (s.pendingVariants === 0) { updateSliderComparisons(); }
              }

              s.variantCache[key] = {
                adjPdf:s.adjPdf, adjCdf:s.adjCdf, adjustedProb:s.adjustedProb,
                optPdfFixed:s.optPdfFixed, optCdfFixed:s.optCdfFixed, optimizedProb:s.optimizedProb,
                optPdfAdaptive:s.optPdfAdaptive, optCdfAdaptive:s.optCdfAdaptive, adaptiveProb:s.adaptiveProb,
                explainAdj:s.explainAdj, explainOpt:s.explainOpt, explainAdaptive:s.explainAdaptive,
                lastPayload:item
              };

              vState.loading = false; vState.error = null;
              if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender();
              window.scheduleUIRefresh();
              updateSliderComparisons();
              setStatusLocal('Ready');
              ensureProbeBox();
            } catch(e) {
              console.error('[PMC] Variant ' + variant + ' processing error:', e.message, e.stack);
              vState.loading = false; vState.error = e.message || 'Variant error';
              safe(function(){ window.renderRightLegend(); }); updateSliderComparisons(); setStatusLocal('Ready');
            }
          })
          .withFailureHandler(function(err){
            console.error('[PMC] Variant ' + variant + ' RPC FAILED:', err);
            if (token !== vState.token) return;
            vState.loading = false; vState.error = (err && err.message) || String(err);
            safe(function(){ window.renderRightLegend(); }); updateSliderComparisons(); setStatusLocal('Ready');
          })
          .getTargetProbabilityData(params);
      }

      function applyVariantResult(variant, c) {
        var s = WS();
        if (variant === 'manual') {
          s.adjPdf = c.adjPdf || []; s.adjCdf = c.adjCdf || []; s.adjustedProb = (c.adjustedProb!=null ? c.adjustedProb : s.adjustedProb); s.explainAdj = (c.explainAdj!=null ? c.explainAdj : s.explainAdj);
        } else if (variant === 'fixed') {
          s.optPdfFixed = c.optPdfFixed || []; s.optCdfFixed = c.optCdfFixed || []; s.optimizedProb = (c.optimizedProb!=null ? c.optimizedProb : s.optimizedProb); s.explainOpt = (c.explainOpt!=null ? c.explainOpt : s.explainOpt);
        } else if (variant === 'adaptive') {
          s.optPdfAdaptive = c.optPdfAdaptive || []; s.optCdfAdaptive = c.optCdfAdaptive || []; s.adaptiveProb = (c.adaptiveProb!=null ? c.adaptiveProb : s.adaptiveProb); s.explainAdaptive = (c.explainAdaptive!=null ? c.explainAdaptive : s.explainAdaptive);
        }
        if (c.lastPayload) s.lastPayload = c.lastPayload;
      }

      function loadTasks() {
        var s = WS();
        setStatusLocal('Fetching…');

        if (!window.google || !google.script || !google.script.run) {
          setStatusLocal('Ready');
          console.warn('Apps Script runtime not available; tasks cannot be loaded in preview.');
          return;
        }

        google.script.run
          .withSuccessHandler(function(res){
            // Handle both old array format and new {tasks, sheetTabs} format
            var taskList, tabList;
            if (Array.isArray(res)) {
              taskList = res;
              tabList  = [];
            } else if (res && Array.isArray(res.tasks)) {
              taskList = res.tasks;
              tabList  = res.sheetTabs || [];
            } else {
              taskList = [];
              tabList  = [];
            }
            s.tasks = taskList;

            // Cache sheet tabs for use by Task Manager import
            if (!window._PMC_SERVER_DATA) window._PMC_SERVER_DATA = {};
            if (tabList.length) window._PMC_SERVER_DATA.sheetTabs = tabList;

            var sel = document.getElementById('taskSel');
            if (!sel) { setStatusLocal('UI init failed: taskSel not found'); return; }

            sel.innerHTML = '';
            if (!s.tasks.length) {
              var opt = document.createElement('option');
              opt.value = ''; opt.textContent = 'No tasks returned';
              sel.appendChild(opt);
              setStatusLocal('Ready');
              return;
            }

            s.tasks.forEach(function(t,i){
              var opt=document.createElement('option');
              opt.value=i; opt.textContent=t.task || ('(Task '+(i+1)+')');
              sel.appendChild(opt);
            });
            sel.selectedIndex = 0;
            onTaskChange();
            // Hide loading overlay — workspace is ready
            var _pl = document.getElementById('pageLoader');
            if (_pl) _pl.style.display = 'none';
          })
          .withFailureHandler(function(err){
            var _pl = document.getElementById('pageLoader');
            if (_pl) _pl.style.display = 'none';
            setStatusLocal('Failed to load tasks: ' + (err && err.message ? err.message : String(err)));
            var msg = document.getElementById('plotMsg');
            if (msg) { msg.style.display='block'; msg.textContent='Failed to load tasks: ' + (err && err.message ? err.message : String(err)); }
          })
          .getAllTasks();
      }

      function onTaskChange() {
        var s = WS();
        var sel = document.getElementById('taskSel');
        if (!sel) { setStatusLocal('UI init failed: taskSel not found'); return; }

        var idx = +sel.value;
        var t = s.tasks[idx];
        if (!t) { setStatusLocal('No valid task'); return; }

        s.task = t;
        s.O = t.optimistic; s.M = t.mostLikely; s.P = t.pessimistic;
        // Refresh triangle plot if visible
        if (typeof window._drawTriPlot === 'function') window._drawTriPlot();
        // Clear ALL stale data from previous task
        s.explainBase = null; s.explainOpt = null; s.explainAdaptive = null; s.explainAdj = null;
        s.baselineProb = null; s.optimizedProb = null; s.adaptiveProb = null; s.adjustedProb = null;
        s.trianglePdf = []; s.triangleCdf = []; s.betaPertPdf = []; s.betaPertCdf = [];
        s.basePdf = []; s.baseCdf = []; s.adjPdf = []; s.adjCdf = [];
        s.optPdfFixed = []; s.optCdfFixed = []; s.optPdfAdaptive = []; s.optCdfAdaptive = [];
        s.baselineCache = {}; s.pendingVariants = 0;
        s.targetMode = 'value';
        s.targetProb = null;
        // Reset mode toggle visual
        var mBtns = document.querySelectorAll('.target-mode-btn');
        for (var bi = 0; bi < mBtns.length; bi++) mBtns[bi].classList.toggle('active', mBtns[bi].getAttribute('data-mode') === 'value');

        function setText(id,val) {
          var el = document.getElementById(id);
          if (el) el.textContent = (val != null ? Number(val).toFixed(2) : '–');
        }
        setText('oVal', s.O);
        setText('mVal', s.M);
        setText('pVal', s.P);
        setText('pertVal', (s.O != null && s.M != null && s.P != null) ? ((s.O + 4*s.M + s.P)/6) : null);

        updateTargetSlider();

        s.overlay.baselineOn = true;
        s.overlay.manualOn = false;
        s.overlay.fixedOn = false;
        s.overlay.adaptiveOn = false;
        s.overlay.sidebarMode = null;
        s.overlay.variants.manual = { loading:false, error:null, token:0 };
        s.overlay.variants.fixed = { loading:false, error:null, token:0 };
        s.overlay.variants.adaptive = { loading:false, error:null, token:0 };
        s.overlay.probeLevel = Number(document.getElementById('probeSelect')?.value || 3);

        s.progress = { triOn:true, betaOn:false, baseOn:false };

        ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf']
          .forEach(function(id) {
            var numEl = document.getElementById(id); if (numEl) numEl.value = '0';
            var rangeEl = document.getElementById(id + '_range'); if (rangeEl) rangeEl.value = '0';
            var marker = document.getElementById(id + '_marker'); if (marker) marker.innerHTML = '';
          });
        if (typeof window.setSlidersDisabled === 'function') window.setSlidersDisabled(true);

        ['_base','_fixed','_adapt'].forEach(suf=>{
          ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'].forEach(id=>{
            const el = document.getElementById(id+suf); if (el) el.value='0';
          });
        });

        s.variantCache = {};

        fetchData(false);
        safe(function(){ window.renderRightLegend(); });
        safe(function(){ window.renderKPIs(); });
        updateSliderComparisons();
        syncRowToggles();
        ensureProbeBox();
        // Reset report to skeleton state
        if (window.PMCReport) {
          PMCReport.state.baseline = null;
          PMCReport.state.variants = {};
          PMCReport.scheduleRender();
        }
      }

      function onTargetInput() {
        var s = WS();
        var slider = document.getElementById('targetSlider');
        if (!slider) return;

        var isAggMode = window.TM && window.TM.mode === 'aggregate';

        if (s.targetMode === 'probability') {
          s.targetProb = Number(slider.value) / 100;
          // Group mode: use aggregate MC CDF as the reference; single-task: use baseCdf/triangleCdf.
          var baseCdf = isAggMode
            ? (s.aggCdf && s.aggCdf.length ? s.aggCdf : s.triangleCdf)
            : (s.baseCdf && s.baseCdf.length ? s.baseCdf : s.triangleCdf);
          if (baseCdf && baseCdf.length) {
            s.target = interpX(baseCdf, s.targetProb);
          }
        } else {
          s.target = Number(slider.value);
        }
        updateTargetDisplayText();

        // Immediately re-interpolate ALL probabilities from cached CDFs so KPI chips
        // and report stay in sync before the server responds.
        if (s.target != null) {
          if (isAggMode && s.aggCdf && s.aggCdf.length) {
            // Group mode: re-interpolate baseline from aggregate CDF + update P(≤T) in Estimates column
            s.baselineProb = interpY(s.aggCdf, s.target);
            var aggPEl = document.getElementById('aggStatProb');
            if (aggPEl) aggPEl.textContent = s.baselineProb != null ? (s.baselineProb * 100).toFixed(1) + '%' : '–';
          } else if (!isAggMode && s.baseCdf && s.baseCdf.length) {
            // Single-task mode: immediately re-interpolate from cached baseline CDF for instant KPI update
            s.baselineProb = interpY(s.baseCdf, s.target);
          }
          // Re-interpolate strategy probabilities for BOTH modes.
          // Group mode now supports SACO optimisation on the combined O/M/P.
          if (s.optCdfFixed    && s.optCdfFixed.length)    s.optimizedProb = interpY(s.optCdfFixed,    s.target);
          if (s.optCdfAdaptive && s.optCdfAdaptive.length) s.adaptiveProb  = interpY(s.optCdfAdaptive, s.target);
          if (s.adjCdf         && s.adjCdf.length)         s.adjustedProb  = interpY(s.adjCdf,         s.target);
          if (typeof window.renderKPIs === 'function') window.renderKPIs();
        }

        // Immediately redraw Triangle plot so τ line moves with the slider
        var triWrap = document.getElementById('triWrap');
        if (triWrap && triWrap.style.display !== 'none' && typeof window._drawTriPlot === 'function') {
          window._drawTriPlot();
        }

        s.variantCache = {};
        fetchData(true);

        s.pendingVariants = 0;
        var active = [];
        if (s.overlay.manualOn) { active.push('manual'); s.pendingVariants++; }
        if (s.overlay.fixedOn) { active.push('fixed'); s.pendingVariants++; }
        if (s.overlay.adaptiveOn) { active.push('adaptive'); s.pendingVariants++; }
        active.forEach(requestVariant);
      }

      /** Handles toggling between Value and Probability target modes */
      window.onTargetModeSwitch = function(newMode) {
        var s = WS();
        if (newMode === s.targetMode) return;
        var slider = document.getElementById('targetSlider');
        if (!slider) return;

        // Sync the mode dropdown
        var sel = document.getElementById('tgtModeSelect');
        if (sel) sel.value = newMode;

        // Toggle question card visual state (legacy — no-op for option elements, kept for compat)
        var cardVal  = document.getElementById('tgtCardValue');
        var cardProb = document.getElementById('tgtCardProb');
        if (cardVal)  cardVal.classList.toggle('active',  newMode === 'value');
        if (cardProb) cardProb.classList.toggle('active', newMode === 'probability');

        // Toggle result area visibility (causal-flow layout)
        var sentVal  = document.getElementById('tgtSentValue');
        var sentProb = document.getElementById('tgtSentProb');
        if (sentVal)  sentVal.classList.toggle('active',  newMode === 'value');
        if (sentProb) sentProb.classList.toggle('active', newMode === 'probability');

        // Toggle input area visibility (what the slider controls)
        var inputVal  = document.getElementById('tgtInputValue');
        var inputProb = document.getElementById('tgtInputProb');
        if (inputVal)  inputVal.classList.toggle('active',  newMode === 'value');
        if (inputProb) inputProb.classList.toggle('active', newMode === 'probability');

        // Also toggle legacy .target-mode-btn.active for any remaining elements
        var btns = document.querySelectorAll('.target-mode-btn');
        for (var i = 0; i < btns.length; i++) {
          btns[i].classList.toggle('active', btns[i].getAttribute('data-mode') === newMode);
        }

        if (newMode === 'probability') {
          // Value → Probability: convert current value to probability via CDF
          var baseCdf = s.baseCdf && s.baseCdf.length ? s.baseCdf : s.triangleCdf;
          var prob = baseCdf && baseCdf.length ? interpY(baseCdf, s.target) : 0.5;
          s.targetProb = prob != null ? prob : 0.5;
          s.targetMode = 'probability';
          slider.min = 1; slider.max = 99; slider.step = 0.5;
          slider.value = Math.round(s.targetProb * 200) / 2; // round to nearest 0.5
        } else {
          // Probability → Value: restore slider to value range
          s.targetMode = 'value';
          var pad = (s.P - s.O) * 0.05;
          s.targetSliderMin = s.O - pad;
          s.targetSliderMax = s.P + pad;
          slider.min = s.targetSliderMin;
          slider.max = s.targetSliderMax;
          slider.step = 'any';
          slider.value = s.target != null ? s.target : (s.O + 4*s.M + s.P) / 6;
        }
        updateTargetDisplayText();
      };

      function fillSlidersFromObject(vals) {
        var map = { budgetFlexibility:'s_budget', scheduleFlexibility:'s_schedule',
          scopeCertainty:'s_scopeCert', scopeReductionAllowance:'s_scopeRed',
          reworkPercentage:'s_rework', riskTolerance:'s_risk', userConfidence:'s_userConf' };
        Object.keys(map).forEach(function(k) {
          var v = Number(vals[k]) || 0;
          var numEl = document.getElementById(map[k]);
          var rangeEl = document.getElementById(map[k] + '_range');
          if (numEl) numEl.value = v;
          if (rangeEl) rangeEl.value = v;
        });
      }

      function updateSliderSidebarState() {
        var s = WS();
        var container = document.getElementById('plotContainer');
        var sidebar = document.getElementById('sliderSidebar');
        if (!container || !sidebar) return;

        var showSidebar = (s.tab === 'overlay') &&
          (s.overlay.manualOn || s.overlay.fixedOn || s.overlay.adaptiveOn);

        var overlayKpisEl = document.getElementById('overlayKpis');
        if (overlayKpisEl) overlayKpisEl.classList.toggle('sidebar-active', showSidebar);

        var bannerEl = document.getElementById('sliderImpactBanner');

        if (!showSidebar) {
          if (bannerEl) bannerEl.style.display = 'none';
          return;
        }

        var titleEl = document.getElementById('sliderTitle');
        var noteEl = document.getElementById('optimizeNote');

        // Helper: format probability impact banner
        function showImpactBanner(mode, baseProb, newProb) {
          if (!bannerEl) return;
          if (baseProb == null || newProb == null) { bannerEl.style.display = 'none'; return; }
          var basePct = (baseProb * 100).toFixed(2);
          var newPct = (newProb * 100).toFixed(2);
          var delta = ((newProb - baseProb) * 100);
          var deltaStr = (delta >= 0 ? '+' : '') + delta.toFixed(2);
          var improved = delta > 0.005;
          var same = Math.abs(delta) < 0.005;

          bannerEl.style.display = 'block';
          // Single-line banner to save vertical space
          if (improved) {
            bannerEl.style.background = '#F0FDF4'; bannerEl.style.borderColor = '#86EFAC'; bannerEl.style.color = '#166534';
            bannerEl.innerHTML = '<strong>' + mode + ':</strong> ' +
              basePct + '% → <strong>' + newPct + '%</strong> ' +
              '<span style="color:#15803D; font-weight:700;">(' + deltaStr + '%)</span>';
          } else if (same) {
            bannerEl.style.background = '#FFFBEB'; bannerEl.style.borderColor = '#FDE68A'; bannerEl.style.color = '#92400E';
            bannerEl.innerHTML = '<strong>No change:</strong> both at <strong>' + basePct + '%</strong>.';
          } else {
            bannerEl.style.background = '#FEF2F2'; bannerEl.style.borderColor = '#FECACA'; bannerEl.style.color = '#991B1B';
            bannerEl.innerHTML = '<strong>' + mode + ':</strong> ' +
              basePct + '% → <strong>' + newPct + '%</strong> ' +
              '<span style="color:#DC2626; font-weight:700;">(' + deltaStr + '%)</span>';
          }
        }

        // Determine sidebar mode — use explicit sidebarMode, fallback to first active
        var mode = s.overlay.sidebarMode;
        if (!mode || (mode === 'manual' && !s.overlay.manualOn) ||
            (mode === 'fixed' && !s.overlay.fixedOn) ||
            (mode === 'adaptive' && !s.overlay.adaptiveOn)) {
          // Fallback: pick first active mode
          if (s.overlay.manualOn) mode = 'manual';
          else if (s.overlay.fixedOn) mode = 'fixed';
          else if (s.overlay.adaptiveOn) mode = 'adaptive';
          else mode = null;
          s.overlay.sidebarMode = mode;
        }

        if (mode === 'manual') {
          setSlidersDisabled(false);
          if (titleEl) titleEl.textContent = 'Unconstrained Optimization';
          if (noteEl) noteEl.textContent = 'No constraints — drag freely to explore any parameter combination.';
          showImpactBanner('Unconstrained', s.baselineProb, s.adjustedProb);
        } else if (mode === 'adaptive') {
          setSlidersDisabled(true);
          var lvl = s.overlay.probeLevel || 3;
          if (titleEl) titleEl.textContent = 'Conservative Optimization (Level ' + lvl + ')';
          if (noteEl) noteEl.textContent = 'Read-only — tightest best-practice constraints (level ' + lvl + ').';
          showImpactBanner('Conservative', s.baselineProb, s.adaptiveProb);
          var source = s.explainAdaptive;
          var vals = extractSliderVals(source || {});
          fillSlidersFromObject(vals);
        } else if (mode === 'fixed') {
          setSlidersDisabled(true);
          if (titleEl) titleEl.textContent = 'General Optimization';
          if (noteEl) noteEl.textContent = 'Read-only — standard best-practice boundaries, wider search space than Conservative.';
          showImpactBanner('General', s.baselineProb, s.optimizedProb);
          var source = s.explainOpt;
          var vals = extractSliderVals(source || {});
          fillSlidersFromObject(vals);
        }

        // Update probe level selector visibility (shown only when adaptive is active mode)
        if (typeof window.syncProbeUI === 'function') window.syncProbeUI();
      }

      function syncRowToggles(){
        var s = WS();
        var row = document.getElementById('seriesToggles');
        if (row) row.style.display = (s.tab==='overlay') ? 'flex' : 'none';

        var b = document.getElementById('rowTglBase');
        var m = document.getElementById('rowTglManual');
        var f = document.getElementById('rowTglFixed');
        var a = document.getElementById('rowTglAdaptive');
        if (b) b.setAttribute('aria-pressed', s.overlay.baselineOn ? 'true' : 'false');
        if (m) m.setAttribute('aria-pressed', s.overlay.manualOn ? 'true' : 'false');
        if (f) f.setAttribute('aria-pressed', s.overlay.fixedOn ? 'true' : 'false');
        if (a) a.setAttribute('aria-pressed', s.overlay.adaptiveOn ? 'true' : 'false');

        ensureProbeBox();
      }

      function bindTabs() {
        var s = WS();
        var nodes = document.querySelectorAll('.tab');
        for (var i=0;i<nodes.length;i++) {
          (function(tab){
            tab.addEventListener('click', function(){
              // Phase 1: Immediate visual update (< 1ms)
              var all = document.querySelectorAll('.tab');
              for (var k=0;k<all.length;k++) all[k].classList.remove('active');
              tab.classList.add('active');
              s.tab = tab.getAttribute('data-tab');

              // Show/hide plot selector bars (progress/overlay tabs)
              var _psb = document.getElementById('plotSelBar');
              if (_psb) _psb.classList.toggle('visible', s.tab === 'progress');
              var _osb = document.getElementById('overlaySelBar');
              if (_osb) _osb.classList.toggle('visible', s.tab === 'overlay');
              // Apply tab-specific plot layout immediately on switch
              if (s.tab === 'progress' && typeof window.pselUpdate === 'function') window.pselUpdate();
              if (s.tab === 'overlay'  && typeof window.overlayPselUpdate === 'function') window.overlayPselUpdate();
              // Show/hide pane headers (hidden in overlay tab to save space)
              var _ph = document.querySelectorAll('.plot-pane-hdr');
              for (var _pi = 0; _pi < _ph.length; _pi++) _ph[_pi].style.display = (s.tab === 'progress') ? '' : 'none';

              // Phase 2: Debounce all expensive work — rapid clicks only run the last one
              if (window._tabSwitchTimer) clearTimeout(window._tabSwitchTimer);
              window._tabSwitchTimer = setTimeout(function() {
                window._tabSwitchTimer = null;

                updateSliderSidebarState();

                var dr = document.getElementById('decisionReport');
                var om = document.getElementById('overlayMath');
                if (s.tab === 'overlay') {
                  if (dr) dr.classList.add('active');
                  if (om) om.classList.add('active');
                  if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender();
                } else {
                  if (dr) dr.classList.remove('active');
                  if (om) om.classList.remove('active');
                }

                if (typeof window.setSlidersDisabled === 'function') {
                  window.setSlidersDisabled(s.tab !== 'overlay' || !s.overlay.manualOn);
                }

                syncRowToggles();

                scheduleUIRefresh();
                fetchData(true);

                if (s.tab === 'overlay') {
                  s.pendingVariants = 0;
                  var act = [];
                  if (s.overlay.manualOn && !s.adjPdf.length) { act.push('manual'); s.pendingVariants++; }
                  if (s.overlay.fixedOn && !s.optPdfFixed.length) { act.push('fixed'); s.pendingVariants++; }
                  if (s.overlay.adaptiveOn && !s.optPdfAdaptive.length) { act.push('adaptive'); s.pendingVariants++; }
                  act.forEach(requestVariant);
                }
                ensureProbeBox();
              }, 100);
            });
          })(nodes[i]);
        }

        var triTile = document.getElementById('kpiTriangle');
        var betaTile= document.getElementById('kpiBeta');
        var baseTile= document.getElementById('kpiBaseDist');
        // Helper: ensure the PDF pane is visible when toggling a distribution curve on
        function ensurePDFVisible() {
          var chkPDF = document.getElementById('pselPDF');
          if (chkPDF && !chkPDF.checked) {
            chkPDF.checked = true;
            if (typeof window.pselUpdate === 'function') window.pselUpdate();
          }
        }
        if (triTile) triTile.addEventListener('click', function(){
          s.progress.triOn = !s.progress.triOn;
          if (s.progress.triOn) ensurePDFVisible();
          scheduleUIRefresh();
        });
        if (betaTile) betaTile.addEventListener('click', function(){
          s.progress.betaOn = !s.progress.betaOn;
          if (s.progress.betaOn) ensurePDFVisible();
          scheduleUIRefresh();
        });
        if (baseTile) baseTile.addEventListener('click', function(){
          s.progress.baseOn = !s.progress.baseOn;
          if (s.progress.baseOn) ensurePDFVisible();
          scheduleUIRefresh();
        });

        syncRowToggles();

        // Initialize plot selector bars — progress is default tab
        var _psbInit = document.getElementById('plotSelBar');
        if (_psbInit) _psbInit.classList.toggle('visible', s.tab === 'progress');
        var _osbInit = document.getElementById('overlaySelBar');
        if (_osbInit) _osbInit.classList.toggle('visible', s.tab === 'overlay');
        // Apply initial layout defaults
        if (typeof window.pselUpdate === 'function') window.pselUpdate();
        if (s.tab === 'overlay' && typeof window.overlayPselUpdate === 'function') window.overlayPselUpdate();
      }

      function bindKpiToggles() {
        var s = WS();
        var baseEl    = document.getElementById('kpiBaseline');
        var adjustedEl= document.getElementById('kpiAdjusted');
        var fixedEl   = document.getElementById('kpiOptimized');
        var adaptiveEl= document.getElementById('kpiAdaptive');

        if (baseEl) baseEl.addEventListener('click', function(){
          if (s.tab !== 'overlay') return;
          s.overlay.baselineOn = !s.overlay.baselineOn;
          scheduleUIRefresh();
          syncRowToggles();
        });

        if (adjustedEl) adjustedEl.addEventListener('click', function(){
          if (s.tab !== 'overlay') return;
          s.overlay.manualOn = !s.overlay.manualOn;
          if (s.overlay.manualOn) {
            s.overlay.primaryMode = 'manual';
            if (!s.adjPdf.length) requestVariant('manual');
            s.overlay.sidebarMode = 'manual';
          }
          updateSliderSidebarState();
          scheduleUIRefresh();
          updateSliderComparisons();
          syncRowToggles();
          setStatusLocal();
        });

        if (fixedEl) fixedEl.addEventListener('click', function(){
          if (s.tab !== 'overlay') return;
          s.overlay.fixedOn = !s.overlay.fixedOn;
          if (s.overlay.fixedOn) {
            s.overlay.primaryMode = 'fixed';
            if (!s.optPdfFixed.length) { s.pendingVariants++; requestVariant('fixed'); }
            s.overlay.sidebarMode = 'fixed';
          }
          updateSliderSidebarState();
          scheduleUIRefresh();
          updateSliderComparisons();
          syncRowToggles();
          setStatusLocal();
        });

        if (adaptiveEl) adaptiveEl.addEventListener('click', function(){
          if (s.tab !== 'overlay') return;
          var wasOff = !s.overlay.adaptiveOn;
          s.overlay.adaptiveOn = !s.overlay.adaptiveOn;
          if (s.overlay.adaptiveOn) {
            s.overlay.primaryMode = 'adaptive';
            if (wasOff || !s.optPdfAdaptive.length) {
              s.overlay.probeLevel = 1;
              var probeSel = document.getElementById('probeSelect');
              if (probeSel) probeSel.value = '1';
              s.pendingVariants++;
              requestVariant('adaptive');
            }
            s.overlay.sidebarMode = 'adaptive';
          }
          updateSliderSidebarState();
          scheduleUIRefresh();
          updateSliderComparisons();
          syncRowToggles();
          setStatusLocal();
          ensureProbeBox();
        });

        // Row toggles in legend — these toggle chart visibility ON/OFF
        var rowToggleDefs = [
          { id: 'rowTglBase',     key: 'baselineOn',  mode: null },
          { id: 'rowTglManual',   key: 'manualOn',    mode: 'manual' },
          { id: 'rowTglFixed',    key: 'fixedOn',     mode: 'fixed' },
          { id: 'rowTglAdaptive', key: 'adaptiveOn',  mode: 'adaptive' }
        ];
        rowToggleDefs.forEach(function(def) {
          var el = document.getElementById(def.id);
          if (!el) return;
          el.addEventListener('click', function() {
            if (s.tab !== 'overlay') return;
            s.overlay[def.key] = !s.overlay[def.key];
            if (s.overlay[def.key] && def.mode) {
              s.overlay.sidebarMode = def.mode;
              // Fire variant fetch when toggling ON (if not already loaded)
              var needsFetch = (def.mode === 'manual' && !s.adjPdf.length) ||
                               (def.mode === 'fixed' && !s.optPdfFixed.length) ||
                               (def.mode === 'adaptive' && !s.optPdfAdaptive.length);
              if (needsFetch) {
                if (def.mode === 'adaptive') {
                  s.overlay.probeLevel = 1;
                  var probeSel = document.getElementById('probeSelect');
                  if (probeSel) probeSel.value = '1';
                }
                s.pendingVariants++;
                requestVariant(def.mode);
              }
            }
            updateSliderSidebarState();
            scheduleUIRefresh();
            updateSliderComparisons();
            syncRowToggles();
            setStatusLocal();
          });
        });
      }

      function bindSliders() {
        var s = WS();
        var ids = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
        ids.forEach(function(id) {
          var numEl = document.getElementById(id);
          var rangeEl = document.getElementById(id + '_range');
          if (!numEl) return;

          var handler = function(){
            if (s.tab !== 'overlay') return;
            if (!s.overlay.manualOn) {
              s.overlay.manualOn = true;
              if (typeof window.setSlidersDisabled === 'function') window.setSlidersDisabled(false);
              syncRowToggles();
            }
            var key = JSON.stringify({ task: s.task.task, O: s.O, M: s.M, P: s.P, target: s.target, variant: 'manual' });
            if (s.variantCache) delete s.variantCache[key];
            requestVariant('manual');
            scheduleUIRefresh();
            updateSliderComparisons();
          };

          // Bidirectional sync: range ↔ number (debounced to prevent double-fire)
          var sliderDebounce = null;
          var debouncedHandler = function() {
            if (sliderDebounce) clearTimeout(sliderDebounce);
            sliderDebounce = setTimeout(handler, 80);
          };
          if (rangeEl) {
            rangeEl.addEventListener('input', function() { numEl.value = rangeEl.value; debouncedHandler(); });
          }
          numEl.addEventListener('change', function() { if (rangeEl) rangeEl.value = numEl.value; debouncedHandler(); });
        });
      }

      function bindZoomReset(){
        // Per-plot zoom buttons handle their own state; no global reset button needed.
      }

      // Per-plot zoom toggle — each chart has its own independent zoom state.
      // key: 'pdf' | 'cdf' | 'radar' | 'saco3d' | 'sphere' | 'hypercube3d'
      window.togglePlotZoom = function(key) {
        var s = WS();
        if (!s._plotZoom) s._plotZoom = {};
        var enabled = !(s._plotZoom[key] || false);
        s._plotZoom[key] = enabled;

        // Update the button appearance
        var btn = document.getElementById('zoomBtn_' + key);
        if (btn) {
          btn.textContent = enabled ? 'Zoom ON' : 'Zoom';
          btn.style.borderColor = enabled ? '#3B82F6' : 'var(--line)';
          btn.style.color       = enabled ? '#1D4ED8' : '#6B7280';
          btn.style.background  = enabled ? '#EFF6FF' : '#fff';
        }

        // Helper: enable/disable Chart.js zoom plugin on one chart instance
        function setChartJsZoom(chart, en) {
          if (!chart || !chart.options) return;
          if (!chart.options.plugins) chart.options.plugins = {};
          if (!chart.options.plugins.zoom) {
            chart.options.plugins.zoom = {
              limits: { x:{min:'original',max:'original'}, y:{min:'original',max:'original'} },
              pan: { enabled: false, mode: 'xy' },
              zoom: { wheel:{enabled:false}, pinch:{enabled:false}, mode:'xy' }
            };
          }
          chart.options.plugins.zoom.pan.enabled          = en;
          chart.options.plugins.zoom.zoom.wheel.enabled   = en;
          chart.options.plugins.zoom.zoom.pinch.enabled   = en;
          if (!en && typeof chart.resetZoom === 'function') chart.resetZoom();
          chart.update();
        }

        // Dispatch to the appropriate renderer
        if (key === 'pdf') {
          setChartJsZoom(s.pdfChart, enabled);
        } else if (key === 'cdf') {
          setChartJsZoom(s.cdfChart, enabled);
        } else if (key === 'radar') {
          if (window.hyperRadarChart) setChartJsZoom(window.hyperRadarChart, enabled);
        } else if (key === 'saco3d') {
          if (window.PMCSaco3D && window.PMCSaco3D.setZoom) window.PMCSaco3D.setZoom(enabled);
        } else if (key === 'sphere') {
          if (window.PMCSphere && window.PMCSphere.setZoom) window.PMCSphere.setZoom(enabled);
        } else if (key === 'hypercube3d') {
          if (window._hypercubeControls) {
            window._hypercubeControls.enableZoom = enabled;
            window._hypercubeControls.enablePan  = enabled;
          }
        }
      };

      // Backward-compat shim (not called by any button now, kept for console use)
      window.toggleChartZoom = function() {
        ['pdf','cdf','radar','saco3d','sphere','hypercube3d'].forEach(function(k){ window.togglePlotZoom(k); });
      };

      window.addEventListener('DOMContentLoaded', function(){
        // Boot log — server-side only (no UI display)
        var bootLog = null; // kept for compat (some catch blocks reference it)
        function blogMsg(t) {
          if (typeof fetch === 'function') {
            fetch('/console', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({type:'boot', msg:t}) }).catch(function(){});
          }
        }

        blogMsg('DOMContentLoaded fired');
        blogMsg('window.S exists: ' + (!!window.S) + ', has tasks prop: ' + (window.S && 'tasks' in window.S));
        blogMsg('google.script.run exists: ' + (!!window.google && !!window.google.script && !!window.google.script.run));
        blogMsg('Chart.js loaded: ' + (typeof Chart !== 'undefined'));

        try {
          var taskSel = document.getElementById('taskSel');
          if (taskSel) taskSel.addEventListener('change', onTaskChange);

          var tgtSlider = document.getElementById('targetSlider');
          if (tgtSlider) tgtSlider.addEventListener('input', onTargetInput);

          var refresh = document.getElementById('refreshBtn');
          if (refresh) refresh.addEventListener('click', function(){
            // In Group mode: re-run the aggregate computation
            if (window.TM && window.TM.mode === 'aggregate') {
              if (typeof window.TM.saveAndRun === 'function') window.TM.saveAndRun();
              return;
            }
            // Single mode: refresh single-task data and active variants
            fetchData(false);
            var s = WS();
            if (s.tab==='overlay') {
              s.pendingVariants = 0;
              var act = [];
              if (s.overlay && s.overlay.manualOn) { act.push('manual'); s.pendingVariants++; }
              if (s.overlay && s.overlay.fixedOn) { act.push('fixed'); s.pendingVariants++; }
              if (s.overlay && s.overlay.adaptiveOn) { act.push('adaptive'); s.pendingVariants++; }
              act.forEach(requestVariant);
            }
            ensureProbeBox();
          });
          blogMsg('Event listeners bound');
        } catch(e) { blogMsg('Event bind error: ' + e.message); }

        try { bindTabs(); blogMsg('bindTabs OK'); } catch(e) { blogMsg('bindTabs error: ' + e.message); }
        try { bindKpiToggles(); blogMsg('bindKpiToggles OK'); } catch(e) { blogMsg('bindKpiToggles error: ' + e.message); }
        try { bindSliders(); blogMsg('bindSliders OK'); } catch(e) { blogMsg('bindSliders error: ' + e.message); }
        try { bindZoomReset(); blogMsg('bindZoomReset OK'); } catch(e) { blogMsg('bindZoomReset error: ' + e.message); }

        var s = WS();
        try {
          if (typeof window.setSlidersDisabled === 'function') window.setSlidersDisabled(true);
          updateSliderComparisons();
        } catch(e) { blogMsg('slider init error: ' + e.message); }

        // Reset to Baseline button
        try {
          var resetBtn = document.getElementById('resetBaseline');
          if (resetBtn) resetBtn.addEventListener('click', function() {
            ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'].forEach(function(id) {
              var numEl = document.getElementById(id); if (numEl) numEl.value = 0;
              var rangeEl = document.getElementById(id + '_range'); if (rangeEl) rangeEl.value = 0;
            });
            if (s.overlay && s.overlay.manualOn) {
              var key = JSON.stringify({ task: s.task && s.task.task, O: s.O, M: s.M, P: s.P, target: s.target, variant: 'manual' });
              if (s.variantCache) delete s.variantCache[key];
              requestVariant('manual');
            }
            scheduleUIRefresh();
            updateSliderComparisons();
          });
        } catch(e) { blogMsg('resetBaseline error: ' + e.message); }

        // Match Optimized button
        try {
          var matchBtn = document.getElementById('matchOptimized');
          if (matchBtn) matchBtn.addEventListener('click', function() {
            var fixedSliders = {};
            ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'].forEach(function(id) {
              var fixedEl = document.getElementById(id + '_fixed');
              var val = fixedEl ? Number(fixedEl.value) || 0 : 0;
              var numEl = document.getElementById(id); if (numEl) numEl.value = val;
              var rangeEl = document.getElementById(id + '_range'); if (rangeEl) rangeEl.value = val;
            });
            if (s.overlay && !s.overlay.manualOn) {
              s.overlay.manualOn = true;
              if (typeof setSlidersDisabled === 'function') setSlidersDisabled(false);
              syncRowToggles();
            }
            var key = JSON.stringify({ task: s.task && s.task.task, O: s.O, M: s.M, P: s.P, target: s.target, variant: 'manual' });
            if (s.variantCache) delete s.variantCache[key];
            requestVariant('manual');
            scheduleUIRefresh();
            updateSliderComparisons();
          });
        } catch(e) { blogMsg('matchOptimized error: ' + e.message); }

        // CRITICAL: loadTasks — always runs regardless of init errors above
        blogMsg('Calling loadTasks...');
        try {
          loadTasks();
          blogMsg('loadTasks called successfully');
        } catch(e) { blogMsg('loadTasks error: ' + e.message); }

        updateSliderSidebarState();

        safe(function(){ if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender(); });

        // Resize both charts on window resize
        window.addEventListener('resize', function(){
          var s2 = WS();
          if (s2 && s2.pdfChart && typeof s2.pdfChart.resize==='function') s2.pdfChart.resize();
          if (s2 && s2.cdfChart && typeof s2.cdfChart.resize==='function') s2.cdfChart.resize();
        }, { passive:true });

        // Redraw charts after scroll settles — prevents blank canvases
        var scrollTimer = null;
        window.addEventListener('scroll', function(){
          if (scrollTimer) clearTimeout(scrollTimer);
          scrollTimer = setTimeout(function(){
            var s2 = WS();
            if (s2 && s2.pdfChart && typeof s2.pdfChart.resize==='function') s2.pdfChart.resize();
            if (s2 && s2.cdfChart && typeof s2.cdfChart.resize==='function') s2.cdfChart.resize();
            if (window.hyperRadarChart && typeof window.hyperRadarChart.resize === 'function') window.hyperRadarChart.resize();
          }, 150);
        }, { passive:true });

        ensureProbeBox();

        // Fallback: if dropdown is still empty after 5 seconds, retry
        setTimeout(function() {
          var sel = document.getElementById('taskSel');
          var optCount = sel ? sel.options.length : 0;
          blogMsg('5s check: taskSel options=' + optCount);
          if (optCount === 0) {
            blogMsg('Dropdown empty after 5s — retrying loadTasks');
            try { loadTasks(); } catch(e) { blogMsg('Retry error: ' + e.message); }
          } else {
            // Hide loading overlay once tasks are confirmed present
            var pl = document.getElementById('pageLoader');
            if (pl) pl.style.display = 'none';
          }
        }, 5000);
      });
    })();
  </script>

  <script>
    (function(){
      const Report = {
        state: { baseline: null, variants: {} },
        fmtPct(v){ return (v==null||isNaN(v)) ? '–' : (v*100).toFixed(2)+'%'; },
        num(v,d=2){ return (v==null||isNaN(v)) ? '–' : Number(v).toFixed(d); },
        blueNum(v,d=2){ return v==null||isNaN(v) ? '–' : `<span style="color:var(--cdf);font-weight:600;">${Number(v).toFixed(d)}</span>`; },

        isOverlayActive(){ return window.S?.tab === 'overlay'; },

        _renderTimer: null,
        scheduleRender() {
          if (this._renderTimer) clearTimeout(this._renderTimer);
          this._renderTimer = setTimeout(() => this.renderAll(), 200);
        },

        mount(){
          window.addEventListener('pmc:baseline:ready', e => { this.state.baseline = e.detail; this.scheduleRender(); });
          window.addEventListener('pmc:variant:ready',  e => { this.state.variants[e.detail.variant] = e.detail; this.scheduleRender(); });
          this.renderAll(true);
        },

        renderAll(skeleton = false) {
          const dr = document.getElementById('decisionReport');
          if (!dr) return;

          const onOverlay = this.isOverlayActive();
          dr.classList.toggle('active', onOverlay);
          if (!onOverlay) { dr.innerHTML = ''; return; }

          const S = window.S || {};
          const B = this.state.baseline || {};
          const V = this.state.variants || {};

          const baselineProb = B.baselineProb ?? S.baselineProb;
          const adaptiveProb = V.adaptive?.prob ?? S.adaptiveProb;
          const fixedProb = V.fixed?.prob ?? S.optimizedProb;
          const manualProb = V.manual?.prob ?? S.adjustedProb;

          const candidates = [
            { prob: baselineProb,  explain: B.lastPayload || {},       label: 'Your Estimate', constrained: false },
            { prob: manualProb,    explain: V.manual?.explain || {},   label: 'Unconstrained Optimization', constrained: false },
            { prob: fixedProb,     explain: V.fixed?.explain || {},    label: 'General Optimization', constrained: true },
            { prob: adaptiveProb,  explain: V.adaptive?.explain || {}, label: `Conservative Optimization (Level ${S.overlay?.probeLevel ?? 3})`, constrained: true }
          ].filter(c => c.prob != null);

          const best = candidates.length ? candidates.reduce((a, b) => a.prob > b.prob ? a : b) : { prob: null, explain: {}, label: '–' };
          const finalProb = best.prob;

          const delta = baselineProb != null ? (finalProb - baselineProb) * 100 : null;
          const deltaStr = delta != null ? (delta >= 0 ? '+' : '') + delta.toFixed(2) + ' pts' : '–';

          const O = S.O, M = S.M, P = S.P, target = S.target;

          const pertMean = (O && M && P) ? (O + 4*M + P)/6 : null;
          const pertStd  = (O && P) ? (P - O)/6 : null;

          const explain = best.explain || {};
          const kl = explain.klDivergence ?? explain.kl;
          const alpha = explain.refit?.alpha ?? null;
          const beta  = explain.refit?.beta ?? null;
          const cv = explain.cv ?? (pertStd && pertMean ? pertStd/pertMean : null);
          const skew = explain.skew ?? (pertStd && pertMean && target ? (pertMean-target)/pertStd : null);

          const KEYS = ['budgetFlexibility','scheduleFlexibility','scopeCertainty','scopeReductionAllowance','reworkPercentage','riskTolerance','userConfidence'];
          const LABELS = ['Budget Flexibility','Schedule Flexibility','Scope Certainty','Scope Reduction Allowance','Rework Percentage','Risk Tolerance','User Confidence'];
          const WEIGHTS = [-0.2, 0.1, 0.3, -0.15, -0.08, 0.25, 0.05];

          // Extract slider values for each variant from explain objects
          function getSliders(explainObj) {
            if (!explainObj) return KEYS.reduce((o,k) => { o[k]=0; return o; }, {});
            var vals = typeof extractSliderVals === 'function' ? extractSliderVals(explainObj) : {};
            return KEYS.reduce((o,k) => { o[k] = Number(vals[k]) || 0; return o; }, {});
          }

          // Also read current manual slider values from DOM
          function getManualSliders() {
            const ID_MAP = { budgetFlexibility:'s_budget', scheduleFlexibility:'s_schedule',
              scopeCertainty:'s_scopeCert', scopeReductionAllowance:'s_scopeRed',
              reworkPercentage:'s_rework', riskTolerance:'s_risk', userConfidence:'s_userConf' };
            return KEYS.reduce((o,k) => {
              const el = document.getElementById(ID_MAP[k]);
              o[k] = el ? Number(el.value) : 0;
              return o;
            }, {});
          }

          const fixedSliders = getSliders(V.fixed?.explain || S.explainOpt || {});
          const adaptiveSliders = getSliders(V.adaptive?.explain || S.explainAdaptive || {});
          const manualSliders = getManualSliders();

          // Build variant rows — ordered most conservative → least conservative
          const probeLvl = S.overlay?.probeLevel ?? 3;
          const variants = [
            { key: 'baseline', label: 'Your Estimate', desc: 'Your original PERT estimate — no optimization applied. This is your starting point.', prob: baselineProb, sliders: KEYS.reduce((o,k)=>{o[k]=0;return o;},{}), constrained: false, constraintLvl: 'None', constraintNote: 'Unmodified three-point estimate', color: '#3B82F6', order: 0 },
            { key: 'adaptive', label: 'Conservative Optimization (Lvl ' + probeLvl + ')', desc: 'Tightest constraint bounds — level ' + probeLvl + ' narrows each slider\'s feasible range, yielding the most defensible improvement', prob: adaptiveProb, sliders: adaptiveSliders, constrained: true, constraintLvl: 'Strict', constraintNote: 'Level ' + probeLvl + ' — tightest bounds', color: '#0EA5E9', order: 1 },
            { key: 'fixed', label: 'General Optimization', desc: 'Standard boundaries — wider range allows more room for optimization, typically achieving higher probability than Conservative Optimization', prob: fixedProb, sliders: fixedSliders, constrained: true, constraintLvl: 'Standard', constraintNote: 'Level 1 — wider bounds', color: '#8B5CF6', order: 2 },
            { key: 'manual', label: 'Unconstrained Optimization', desc: 'No constraints — you set any slider values freely. Highest potential but not validated against best practices. Full control for what-if analysis.', prob: manualProb, sliders: manualSliders, constrained: false, constraintLvl: 'Unconstrained', constraintNote: 'No limits', color: '#F59E0B', order: 3 }
          ];

          // Ranked by probability for determining "best"
          const ranked = variants.filter(v => v.prob != null).sort((a,b) => b.prob - a.prob);
          const bestVariant = ranked[0] || variants[0];

          const noOpt = explain.status === 'no-optimize'
            ? `<p class="rep-ci-card rep-warning"><strong>Baseline already optimal — no safe SACO lift possible (CV ≈ ${this.num(cv,2)}, Skew ≈ ${this.num(skew,2)}).</p>`
            : '';

          const ciLower = B.lastPayload?.baseline?.ci?.lower ?? explain.ciLower;
          const ciUpper = B.lastPayload?.baseline?.ci?.upper ?? explain.ciUpper;
          const confLevel = B.lastPayload?.baseline?.ci?.confidenceLevel ?? 0.95;
          const riskLevel = baselineProb != null ? (baselineProb < 0.3 ? 'High' : baselineProb < 0.6 ? 'Medium' : 'Low') : '–';
          const riskColor = riskLevel === 'High' ? '#DC2626' : riskLevel === 'Medium' ? '#D97706' : '#16A34A';

          dr.innerHTML = `
<div style="margin-bottom:10px;">
  <button id="repMenuTrigger" style="width:100%;padding:10px 14px;border:2px solid var(--accent);border-radius:8px;background:var(--accent);color:#fff;font-weight:800;font-size:13px;letter-spacing:.07em;cursor:pointer;text-align:center;">REPORTS &#9660;</button>
  <div id="repMenuDropdown" style="display:none;border:1px solid var(--line);border-radius:0 0 8px 8px;overflow:hidden;margin-top:-2px;background:#fff;">
    <button class="rep-menu-item" data-reptab="pm" style="display:block;width:100%;padding:12px 16px;text-align:left;border:none;background:none;cursor:pointer;font-size:13px;font-weight:600;border-bottom:1px solid var(--line);">&#128203; Project Report</button>
  </div>
</div>
<div id="rep-pm" class="rep-panel" style="display:none;">
  <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 0 10px;border-bottom:2px solid var(--line);margin-bottom:14px;">
    <span style="font-size:13px;font-weight:800;color:#1E3A5F;">&#128203; Project Report</span>
    <button id="repCloseBtn" style="border:1px solid var(--line);background:#fff;cursor:pointer;font-size:12px;padding:3px 10px;border-radius:6px;color:#6B7280;" title="Close report">&#x2715; Close</button>
  </div>
  <!-- 1. Project Context -->
  <div class="rep-card" style="background:linear-gradient(135deg,#EFF6FF,#F0FDF4);border:2px solid #93C5FD;">
    <div style="font-size:17px;font-weight:800;color:#1E3A5F;margin-bottom:8px;">Project Estimate Overview</div>
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:8px;">
      <div style="flex:1;min-width:80px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;text-transform:uppercase;">Optimistic <span class="help-icon" data-title="Optimistic (O)" data-body="Best-case scenario — minimum reasonable estimate if everything goes well. Represents the fastest or cheapest plausible outcome.">?</span></div><div style="font-size:20px;font-weight:800;color:#3B82F6;">${this.num(O)}</div></div>
      <div style="flex:1;min-width:80px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;text-transform:uppercase;">Most Likely <span class="help-icon" data-title="Most Likely (M)" data-body="Most realistic scenario — what you'd expect under normal conditions. Receives 4× the weight in the PERT formula.">?</span></div><div style="font-size:20px;font-weight:800;color:#3B82F6;">${this.num(M)}</div></div>
      <div style="flex:1;min-width:80px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;text-transform:uppercase;">Pessimistic <span class="help-icon" data-title="Pessimistic (P)" data-body="Worst-case scenario — maximum reasonable estimate if things go poorly. Represents the slowest or most expensive plausible outcome.">?</span></div><div style="font-size:20px;font-weight:800;color:#3B82F6;">${this.num(P)}</div></div>
      <div style="flex:1;min-width:80px;padding:8px;border-radius:8px;border:1px solid ${riskColor}33;background:${riskColor}08;text-align:center;"><div style="font-size:10px;color:#6B7280;text-transform:uppercase;">Risk Level <span class="help-icon" data-title="Risk Level" data-body="Spread-based risk classification: Low = (P−O)/M < 0.5; Medium = 0.5–1.0; High = &gt; 1.0. Reflects how much uncertainty exists relative to the most likely outcome.">?</span></div><div style="font-size:20px;font-weight:800;color:${riskColor};">${riskLevel}</div></div>
    </div>
    <div style="display:flex;gap:10px;flex-wrap:wrap;">
      <div style="flex:1;min-width:80px;padding:6px 8px;border-radius:6px;border:1px solid var(--line);text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;">Target (τ) <span class="help-icon" data-title="Target Value (τ)" data-body="The finish value you are targeting. Probability is computed as P(X ≤ τ) — the chance of completing at or below this value. Drag the target slider at the top to change it live.">?</span></div><div id="repTargetVal" style="font-size:15px;font-weight:700;color:var(--cdf);">${this.num(target)}</div></div>
      <div style="flex:1;min-width:80px;padding:6px 8px;border-radius:6px;border:1px solid var(--line);text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;">P(≤τ) <span class="help-icon" data-title="Probability at Target" data-body="Probability of finishing at or below the target value (τ) based on your original estimate. Updates live as you drag the target slider.">?</span></div><div id="repTargetProb" style="font-size:15px;font-weight:700;color:#10B981;">${baselineProb!=null?(baselineProb*100).toFixed(1)+'%':'–'}</div></div>
      <div style="flex:1;min-width:80px;padding:6px 8px;border-radius:6px;border:1px solid var(--line);text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;">PERT Mean <span class="help-icon" data-title="PERT Mean" data-body="PERT weighted average: (O + 4×M + P) ÷ 6. Extra weight on Most Likely produces a realistic expected mean. More accurate than a simple average of the three points.">?</span></div><div style="font-size:15px;font-weight:700;color:var(--cdf);">${this.num(pertMean,2)}</div></div>
      ${ciLower!=null?`<div style="flex:1;min-width:80px;padding:6px 8px;border-radius:6px;border:1px solid var(--line);text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;">${(confLevel*100).toFixed(0)}% CI <span class="help-icon" data-title="Confidence Interval" data-body="Monte Carlo smoothed confidence interval at the selected confidence level. Shows the range within which the actual outcome is expected to fall with high probability.">?</span></div><div style="font-size:15px;font-weight:700;color:var(--cdf);">${this.num(ciLower,1)} – ${this.num(ciUpper,1)}</div></div>`:''}
    </div>
  </div>
  ${noOpt}

  <!-- 2. Analysis & Recommendation (TOP of report) -->
  <div class="rep-card">
    <div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:8px;">Analysis & Recommendation</div>
    <div class="rep-note" style="font-size:13px;line-height:1.8;">
      ${(() => {
        const bp = FMT.prob(baselineProb);
        const fp = FMT.prob(fixedProb);
        const ap = FMT.prob(adaptiveProb);
        const mp = FMT.prob(manualProb);
        const fixedLift = fixedProb!=null && baselineProb!=null ? ((fixedProb-baselineProb)*100) : 0;
        const adaptiveLift = adaptiveProb!=null && baselineProb!=null ? ((adaptiveProb-baselineProb)*100) : 0;
        const manualLift = manualProb!=null && baselineProb!=null ? ((manualProb-baselineProb)*100) : 0;
        let html = '<p style="margin-bottom:8px;"><strong>Baseline</strong> gives a <strong>' + bp + '</strong> probability of achieving the target. ';
        if (fixedLift > 0.01 || adaptiveLift > 0.01 || manualLift > 0.01) {
          html += 'Optimization finds lever settings that improve this probability. Strategies sorted by achieved probability (highest first):</p>';
          // Sort by probability descending so the display always reflects reality
          var optRows = [];
          if (adaptiveProb != null) optRows.push({ label: 'Conservative Optimization (Level ' + probeLvl + ')', prob: adaptiveProb, lift: adaptiveLift, desc: 'Multi-pass SACO search with best-practice constraint bounds at level ' + probeLvl + '. <em>Most defensible</em> for external reporting.' });
          if (fixedProb != null)    optRows.push({ label: 'General Optimization',                              prob: fixedProb,    lift: fixedLift,    desc: 'Single-pass grid search with wider slider bounds (level 1). Larger search space, standard constraints.' });
          if (manualProb != null)   optRows.push({ label: 'Unconstrained Optimization',                        prob: manualProb,   lift: manualLift,   desc: '<strong>No constraints</strong> — user-defined values, no best-practice validation. Highest potential but not defensible.' });
          optRows.sort(function(a,b){ return b.prob - a.prob; });
          html += '<ol style="margin:6px 0 10px;padding-left:18px;">';
          optRows.forEach(function(r) {
            html += '<li><strong>' + r.label + '</strong> achieves <strong>' + FMT.prob(r.prob) + '</strong> (' + FMT.lift(r.lift) + ') — ' + r.desc + '</li>';
          });
          html += '</ol>';
        } else {
          html += 'The distribution is already well-positioned and optimization has limited room to improve.</p>';
          html += '<ul style="margin:6px 0 10px;padding-left:18px;">';
          if (adaptiveProb != null) html += '<li><strong>Conservative Optimization:</strong> ' + ap + '</li>';
          if (fixedProb != null)    html += '<li><strong>General Optimization:</strong> ' + fp + '</li>';
          if (manualProb != null)   html += '<li><strong>Unconstrained Optimization:</strong> ' + mp + '</li>';
          html += '</ul>';
        }
        // Explain algorithm differences when Conservative beats General
        if (adaptiveProb != null && fixedProb != null) {
          html += '<div style="padding:8px 12px;border-radius:8px;background:#F5F3FF;border:1px solid #C4B5FD;margin:6px 0;font-size:12px;color:#5B21B6;line-height:1.6;">';
          if (adaptiveProb > fixedProb + 0.001) {
            html += '<strong>Why does Conservative Optimization outperform General?</strong> Conservative uses a multi-pass SACO search algorithm that iteratively refines slider values — this can find better configurations than General\'s single-pass grid search, even with tighter constraint bounds at level ' + probeLvl + '. Conservative is both <em>more thorough in search</em> and <em>more defensible in output</em>.';
          } else if (fixedProb > adaptiveProb + 0.001) {
            html += '<strong>Why does General Optimization outperform Conservative?</strong> General Optimization uses level 1 (widest boundaries), giving the optimizer the largest feasible region. Conservative Optimization at level ' + probeLvl + ' tightens those boundaries — each slider can move less. Tighter constraints = more conservative = lower probability, but <em>more defensible</em> in audit/governance contexts.';
          } else {
            html += 'Conservative and General Optimization achieve the same probability — the constraint level has no additional impact for this estimate.';
          }
          html += '</div>';
        }
        // Recommendation box
        html += '<div style="padding:10px 12px;border-radius:8px;background:#F0FDF4;border:1px solid #86EFAC;margin-top:8px;">';
        html += '<div style="font-weight:700;color:#166534;margin-bottom:4px;">Recommendation</div>';
        if (bestVariant.key === 'baseline') {
          html += '<p style="margin:0;color:#166534;">Your baseline estimate is already optimal. Focus on execution: track earned value against ' + this.num(target) + ', set control limits at ±1σ, and re-estimate periodically.</p>';
        } else if (bestVariant.constrained) {
          html += '<p style="margin:0;color:#166534;">Use <strong>' + bestVariant.label + '</strong> (' + this.fmtPct(bestVariant.prob) + ') for planning. These slider values follow best-practice boundaries and provide the highest defensible probability improvement.</p>';
        } else {
          html += '<p style="margin:0;color:#166534;">Unconstrained Optimization achieves the highest probability at <strong>' + this.fmtPct(bestVariant.prob) + '</strong>, but note that these values are <strong>unconstrained</strong> and may not align with industry best practices. Consider validating with stakeholders before adopting. The best constrained option is';
          const bestConstrained = ranked.find(v=>v.constrained);
          html += bestConstrained ? '<strong>' + bestConstrained.label + '</strong> at ' + this.fmtPct(bestConstrained.prob) + '.' : 'not yet computed.';
          html += '</p>';
        }
        html += '</div>';
        return html;
      })()}
    </div>
  </div>

  <!-- 3. Variant Comparison Table (ordered most → least conservative) -->
  <div class="rep-card">
    <div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:4px;">Variant Comparison</div>
    <div class="rep-note" style="font-size:12px;color:#6B7280;margin-bottom:8px;">Ordered from most conservative (tightest constraints) to least conservative (unconstrained). Higher constraint levels are more defensible in audits but have less room to improve probability.</div>
    <div style="overflow-x:auto;">
    <table class="rep-tbl" style="font-size:12px;">
      <thead><tr>
        <th style="width:18%;">Strategy</th>
        <th style="width:10%;">P(X≤T)</th>
        <th style="width:10%;">Δ vs Base</th>
        <th style="width:14%;">Constraint Level</th>
        <th>Explanation</th>
      </tr></thead>
      <tbody>
        ${variants.map(function(v) {
          var d = v.prob != null && baselineProb != null ? ((v.prob - baselineProb)*100) : null;
          var dStr = d != null ? FMT.lift(d) : '–';
          var dColor = d > 0.005 ? '#16A34A' : d < -0.005 ? '#DC2626' : '#6B7280';
          var isBest = bestVariant.key === v.key;
          var rowBg = isBest ? 'background:#F0FDF4;' : '';
          var clColor = v.constraintLvl === 'Strict' ? '#7C3AED' : v.constraintLvl === 'Standard' ? '#8B5CF6' : v.constraintLvl === 'Unconstrained' ? '#D97706' : '#6B7280';
          return '<tr style="' + rowBg + '">' +
            '<td style="font-weight:600;"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:' + v.color + ';margin-right:6px;vertical-align:middle;"></span>' + v.label + (isBest ? ' <span style="font-size:10px;color:#16A34A;font-weight:700;">★ BEST</span>' : '') + '</td>' +
            '<td class="mono" style="font-weight:700;color:' + v.color + ';">' + this.fmtPct(v.prob) + '</td>' +
            '<td class="mono" style="color:' + dColor + ';font-weight:600;">' + (v.key==='baseline' ? '—' : dStr) + '</td>' +
            '<td style="font-size:11px;"><span style="color:' + clColor + ';font-weight:600;">' + v.constraintLvl + '</span><div style="font-size:10px;color:#9CA3AF;">' + v.constraintNote + '</div></td>' +
            '<td style="font-size:11px;color:#6B7280;">' + v.desc + '</td>' +
          '</tr>';
        }.bind(this)).join('')}
      </tbody>
    </table>
    </div>
  </div>

  <!-- 4. Slider Comparison Table (only when strategies are active) -->
  ${(adaptiveProb != null || fixedProb != null || manualProb != null) ? `
  <div class="rep-card">
    <div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:8px;">Slider Settings Comparison</div>
    <div class="rep-note" style="font-size:12px;color:#6B7280;margin-bottom:8px;">Side-by-side slider values across all strategies (ordered most → least conservative). Higher values generally increase probability except Rework % (lower is better).</div>
    <div style="overflow-x:auto;">
    <table class="rep-tbl" style="font-size:12px;">
      <thead><tr>
        <th style="width:24%;">Lever</th>
        <th style="width:13%;">Baseline</th>
        ${adaptiveProb != null ? '<th style="width:13%;">Conservative</th>' : ''}
        ${fixedProb != null ? '<th style="width:13%;">General</th>' : ''}
        ${manualProb != null ? '<th style="width:13%;">Unconstrained</th>' : ''}
        <th style="width:24%;">Rationale</th>
      </tr></thead>
      <tbody>
        ${LABELS.map(function(label, i) {
          var k = KEYS[i];
          var isRework = k === 'reworkPercentage';
          var fmtV = function(v) { return this.num(v,0) + '%'; }.bind(this);
          var baseV = 0;
          var adaV = adaptiveSliders[k] || 0;
          var fixV = fixedSliders[k] || 0;
          var manV = manualSliders[k] || 0;
          var activeVals = [];
          if (adaptiveProb != null) activeVals.push(adaV);
          if (fixedProb != null) activeVals.push(fixV);
          if (manualProb != null) activeVals.push(manV);
          var maxV = Math.max(...activeVals);
          var hl = function(v) { return v === maxV && maxV > 0 && !isRework ? 'font-weight:700;color:#16A34A;' : (isRework && v > 0 && v === Math.min(...activeVals.filter(x=>x>0).concat([999])) && v < 999 ? 'font-weight:700;color:#16A34A;' : ''); };
          return '<tr>' +
            '<td style="font-weight:600;">' + label + '</td>' +
            '<td class="mono">' + fmtV(baseV) + '</td>' +
            (adaptiveProb != null ? '<td class="mono" style="' + hl(adaV) + '">' + fmtV(adaV) + '</td>' : '') +
            (fixedProb != null ? '<td class="mono" style="' + hl(fixV) + '">' + fmtV(fixV) + '</td>' : '') +
            (manualProb != null ? '<td class="mono" style="' + hl(manV) + '">' + fmtV(manV) + '</td>' : '') +
            '<td style="font-size:11px;color:#6B7280;">' + this.sliderWhy(label) + '</td>' +
          '</tr>';
        }.bind(this)).join('')}
      </tbody>
    </table>
    </div>
  </div>` : ''}
</div>
${this.buildStatisticalView(S, O, M, P, target, pertMean, pertStd, baselineProb, adaptiveProb, fixedProb, manualProb, adaptiveSliders, fixedSliders, manualSliders, kl, alpha, beta, cv, skew, explain, KEYS, LABELS)}
          `;

          // REPORTS — inline dropdown (no absolute positioning) + scroll-to-report + close button
          const repTrigger  = dr.querySelector('#repMenuTrigger');
          const repDropdown = dr.querySelector('#repMenuDropdown');
          const repCloseBtn = dr.querySelector('#repCloseBtn');

          function closeAllPanels() {
            dr.querySelectorAll('.rep-panel').forEach(function(p) { p.style.display = 'none'; });
          }
          function resetTrigger() {
            if (repTrigger) repTrigger.innerHTML = 'REPORTS &#9660;';
            if (repDropdown) repDropdown.style.display = 'none';
          }

          if (repTrigger && repDropdown) {
            repTrigger.addEventListener('click', function() {
              const open = repDropdown.style.display !== 'none';
              // If a panel is open, close it first rather than toggling the list
              const anyOpen = dr.querySelectorAll('.rep-panel[style*="block"]').length > 0;
              if (anyOpen) { closeAllPanels(); resetTrigger(); return; }
              repDropdown.style.display = open ? 'none' : 'block';
              repTrigger.innerHTML = open ? 'REPORTS &#9660;' : 'REPORTS &#9650;';
            });

            dr.querySelectorAll('.rep-menu-item').forEach(function(btn) {
              btn.addEventListener('click', function() {
                resetTrigger();
                const key = this.getAttribute('data-reptab');
                closeAllPanels();
                const panel = dr.querySelector('#rep-' + key);
                if (panel) {
                  panel.style.display = 'block';
                  // Scroll the report panel into view smoothly
                  setTimeout(function() {
                    panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                  }, 60);
                }
              });
            });
          }

          if (repCloseBtn) {
            repCloseBtn.addEventListener('click', function() {
              closeAllPanels();
              resetTrigger();
              // Scroll back up to REPORTS button
              if (repTrigger) repTrigger.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
          }


          // Render KaTeX math formulas in the report
          if (window.katex) {
            dr.querySelectorAll('.katex-eq').forEach(function(el) {
              try { katex.render(el.getAttribute('data-eq'), el, { displayMode: true, throwOnError: false }); } catch(e) {}
            });
            dr.querySelectorAll('.katex-inline').forEach(function(el) {
              try { katex.render(el.getAttribute('data-eq'), el, { displayMode: false, throwOnError: false }); } catch(e) {}
            });
          }
        },

        buildStatisticalView(S, O, M, P, target, pertMean, pertStd, baselineProb, adaptiveProb, fixedProb, manualProb, adaptiveSliders, fixedSliders, manualSliders, kl, alpha, beta, cv, skew, explain, KEYS, LABELS) {
          const probeLvl = S.overlay?.probeLevel ?? 3;
          const pertVar = pertStd != null ? pertStd * pertStd : null;
          const range = (O != null && P != null) ? P - O : null;

          // Helper: compute moments and refit for a given set of sliders
          function computeTransform(sliders, sliderLabel) {
            if (!sliders || !pertMean || !range) return null;
            const weights = [-0.20, 0.10, 0.30, -0.15, -0.08, 0.25, 0.05];
            // Normalize to 0-1 for moment computation
            let s01 = {};
            KEYS.forEach((k, i) => {
              const maxV = k === 'reworkPercentage' ? 50 : 100;
              s01[k] = (sliders[k] || 0) / maxV;
            });
            // Weighted sum for m0 (mean shift) and m1 (variance compression)
            let m0 = 0, m1 = 0;
            KEYS.forEach((k, i) => {
              const v = s01[k] || 0;
              const w = weights[i];
              if (w > 0) { m0 += w * v; m1 += Math.abs(w) * v; }
              else { m0 += w * v; m1 += Math.abs(w) * v * 0.5; }
            });
            m0 = Math.max(-1, Math.min(1, m0));
            m1 = Math.max(0, Math.min(1, m1));
            const newMean = pertMean * (1 - m0 * 0.2);
            const newVar = pertVar * (1 - m1 * 0.5);
            const scaledMean = (newMean - O) / Math.max(range, 1e-9);
            const scaledVar = newVar / Math.max(range * range, 1e-12);
            const denom = scaledMean * (1 - scaledMean) / Math.max(scaledVar, 1e-12) - 1;
            const alphaNew = scaledMean * denom;
            const betaNew = (1 - scaledMean) * denom;
            return { m0, m1, newMean, newVar, scaledMean, scaledVar, alphaNew, betaNew };
          }

          // Compute transforms for each active strategy
          const guidedT = adaptiveProb != null ? computeTransform(adaptiveSliders, 'Guided') : null;
          const optimizedT = fixedProb != null ? computeTransform(fixedSliders, 'Optimized') : null;
          const explorerT = manualProb != null ? computeTransform(manualSliders, 'Explorer') : null;

          // Helper for KL from explain objects
          const guidedKL = S.explainAdaptive?.explain?.klDivergence ?? S.explainAdaptive?.klDivergence ?? null;
          const optimizedKL = S.explainOpt?.explain?.klDivergence ?? S.explainOpt?.klDivergence ?? null;
          const explorerKL = S.explainAdj?.explain?.klDivergence ?? S.explainAdj?.klDivergence ?? null;

          // Strategy section builder
          const self = this;
          function strategySection(label, color, prob, sliders, transform, klVal, constraintDesc, order) {
            if (prob == null) return '';
            const gain = baselineProb != null ? ((prob - baselineProb) * 100) : null;
            const gainStr = gain != null ? (gain >= 0 ? '+' : '') + gain.toFixed(2) + ' pts' : '–';
            const gainColor = gain > 0.005 ? '#16A34A' : gain < -0.005 ? '#DC2626' : '#6B7280';

            let html = '<div class="rep-card" style="border-left:4px solid ' + color + ';">';
            html += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">';
            html += '<span style="display:inline-block;width:14px;height:14px;border-radius:50%;background:' + color + ';"></span>';
            html += '<span style="font-size:15px;font-weight:700;">' + label + '</span>';
            html += '<span style="font-size:12px;color:#6B7280;margin-left:auto;">' + constraintDesc + '</span>';
            html += '</div>';

            // Probability result
            html += '<div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:10px;">';
            html += '<div style="padding:8px 12px;border-radius:8px;background:#F9FAFB;border:1px solid var(--line);text-align:center;"><div style="font-size:10px;color:#6B7280;">P(X ≤ τ)</div><div style="font-size:18px;font-weight:800;color:' + color + ';">' + self.fmtPct(prob) + '</div></div>';
            html += '<div style="padding:8px 12px;border-radius:8px;background:#F9FAFB;border:1px solid var(--line);text-align:center;"><div style="font-size:10px;color:#6B7280;">Δ from Baseline</div><div style="font-size:18px;font-weight:800;color:' + gainColor + ';">' + gainStr + '</div></div>';
            if (klVal != null) {
              const klColor = klVal < 0.1 ? '#16A34A' : klVal < 0.5 ? '#D97706' : '#DC2626';
              html += '<div style="padding:8px 12px;border-radius:8px;background:#F9FAFB;border:1px solid var(--line);text-align:center;"><div style="font-size:10px;color:#6B7280;">KL Divergence</div><div style="font-size:18px;font-weight:800;color:' + klColor + ';">' + self.num(klVal, 4) + '</div></div>';
            }
            html += '</div>';

            // Slider values table
            html += '<div style="font-size:12px;font-weight:600;margin-bottom:4px;">Slider Values</div>';
            html += '<div style="overflow-x:auto;"><table class="rep-tbl" style="font-size:11px;"><thead><tr><th>Lever</th><th>Value</th><th>Normalized [0,1]</th></tr></thead><tbody>';
            KEYS.forEach((k, i) => {
              const v = sliders[k] || 0;
              const maxV = k === 'reworkPercentage' ? 50 : 100;
              const n01 = (v / maxV).toFixed(3);
              html += '<tr><td>' + LABELS[i] + '</td><td class="mono">' + self.num(v, 0) + '%</td><td class="mono">' + n01 + '</td></tr>';
            });
            html += '</tbody></table></div>';

            // Transformation math
            if (transform) {
              html += '<div style="font-size:12px;font-weight:600;margin:10px 0 4px;">Moment Aggregation &amp; Beta Re-fit</div>';
              html += '<div class="rep-note" style="line-height:2;">';
              html += '<div class="katex-eq" data-eq="m_0 = ' + self.num(transform.m0, 4) + ' \\quad \\text{(mean shift)} \\qquad m_1 = ' + self.num(transform.m1, 4) + ' \\quad \\text{(variance compression)}"></div>';
              html += '<div class="katex-eq" data-eq="\\mu\' = ' + self.num(pertMean, 4) + ' \\times (1 - ' + self.num(transform.m0, 4) + ' \\times 0.2) = ' + self.num(transform.newMean, 4) + '"></div>';
              html += '<div class="katex-eq" data-eq="\\sigma\'^{\\,2} = ' + self.num(pertVar, 6) + ' \\times (1 - ' + self.num(transform.m1, 4) + ' \\times 0.5) = ' + self.num(transform.newVar, 6) + '"></div>';
              if (transform.alphaNew > 0 && transform.betaNew > 0) {
                html += '<div class="katex-eq" data-eq="\\alpha\' = ' + self.num(transform.alphaNew, 4) + ' \\qquad \\beta\' = ' + self.num(transform.betaNew, 4) + '"></div>';
              }
              html += '</div>';
            }

            html += '</div>';
            return html;
          }

          // Build the full view
          let html = '<div id="rep-stat" class="rep-panel" style="display:none;">';

          // --- Step 1: User Inputs ---
          html += '<div class="rep-card" style="border:2px solid #C4B5FD;background:#F5F3FF;">';
          html += '<div style="font-size:16px;font-weight:800;color:#5B21B6;margin-bottom:4px;">The Transformation Journey</div>';
          html += '<div class="rep-note" style="line-height:1.6;color:#374151;">A step-by-step mathematical walkthrough from your 3-point estimate through distribution fitting, Monte Carlo simulation, and optimization — showing exactly how each strategy reshapes your probability.</div>';
          html += '</div>';

          // --- Step 2: Three-Point → PERT ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 1 — User Inputs → PERT Distribution</div>';
          html += '<div class="rep-note" style="line-height:2;">';
          html += '<p>You provided three estimates reflecting your best, most likely, and worst case scenarios:</p>';
          html += '<div style="display:flex;gap:10px;flex-wrap:wrap;margin:8px 0;">';
          html += '<div style="flex:1;min-width:70px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#EFF6FF;"><div style="font-size:10px;color:#6B7280;">O (Optimistic)</div><div style="font-size:18px;font-weight:800;color:#3B82F6;">' + this.num(O) + '</div></div>';
          html += '<div style="flex:1;min-width:70px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#EFF6FF;"><div style="font-size:10px;color:#6B7280;">M (Most Likely)</div><div style="font-size:18px;font-weight:800;color:#3B82F6;">' + this.num(M) + '</div></div>';
          html += '<div style="flex:1;min-width:70px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#EFF6FF;"><div style="font-size:10px;color:#6B7280;">P (Pessimistic)</div><div style="font-size:18px;font-weight:800;color:#3B82F6;">' + this.num(P) + '</div></div>';
          html += '</div>';
          html += '<p>The PERT formula weights the most likely value 4× more than the extremes:</p>';
          html += '<div class="katex-eq" data-eq="\\mu_{PERT} = \\frac{O + 4M + P}{6} = \\frac{' + this.num(O) + ' + 4(' + this.num(M) + ') + ' + this.num(P) + '}{6} = ' + this.num(pertMean, 4) + '"></div>';
          html += '<div class="katex-eq" data-eq="\\sigma_{PERT} = \\frac{P - O}{6} = \\frac{' + this.num(P) + ' - ' + this.num(O) + '}{6} = ' + this.num(pertStd, 4) + '"></div>';
          html += '<p style="color:#6B7280;font-size:11px;">The PERT mean is the expected value of your estimate. The standard deviation captures the spread of uncertainty. Together they define the baseline shape.</p>';
          html += '</div></div>';

          // --- Step 3: PERT → Beta Distribution ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 2 — PERT → Beta Distribution</div>';
          html += '<div class="rep-note" style="line-height:2;">';
          html += '<p>PERT parameters are converted to a Beta distribution bounded on [O, P]. The Beta shape parameters α, β are derived via method of moments on the scaled [0,1] interval:</p>';
          const scaledMeanBase = pertMean != null && O != null && range ? ((pertMean - O) / range) : null;
          const scaledVarBase = pertVar != null && range ? (pertVar / (range * range)) : null;
          html += '<div class="katex-eq" data-eq="\\mu_{01} = \\frac{\\mu - O}{P - O} = \\frac{' + this.num(pertMean, 4) + ' - ' + this.num(O) + '}{' + this.num(range) + '} = ' + this.num(scaledMeanBase, 6) + '"></div>';
          html += '<div class="katex-eq" data-eq="\\sigma_{01}^{\\,2} = \\frac{\\sigma^2}{(P-O)^2} = \\frac{' + this.num(pertVar, 6) + '}{' + this.num(range != null ? range*range : null) + '} = ' + this.num(scaledVarBase, 8) + '"></div>';
          html += '<div class="katex-eq" data-eq="\\nu = \\frac{\\mu_{01}(1-\\mu_{01})}{\\sigma_{01}^{\\,2}} - 1"></div>';
          html += '<div class="katex-eq" data-eq="\\alpha = \\mu_{01} \\cdot \\nu \\qquad \\beta = (1-\\mu_{01}) \\cdot \\nu"></div>';
          if (alpha != null && beta != null) {
            html += '<p>Computed shape parameters: <strong>α = ' + this.num(alpha, 4) + '</strong>, <strong>β = ' + this.num(beta, 4) + '</strong></p>';
          }
          html += '<p style="color:#6B7280;font-size:11px;">The Beta distribution generalizes the triangle by allowing asymmetric probability mass. When M is closer to O, the distribution skews right (longer tail toward P). This captures real-world estimation bias more accurately than a simple triangle.</p>';
          html += '</div></div>';

          // --- Step 4: Monte Carlo Simulation ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 3 — Monte Carlo Simulation</div>';
          html += '<div class="rep-note" style="line-height:2;">';
          html += '<p>200 random samples are drawn from Beta(α, β), scaled to [O, P], and kernel-smoothed to produce continuous PDF and CDF curves. This smoothing eliminates sampling artifacts while preserving the distribution shape.</p>';
          html += '<div class="katex-eq" data-eq="X_i \\sim O + (P - O) \\cdot \\text{Beta}(\\alpha, \\beta), \\quad i = 1, \\ldots, 200"></div>';
          html += '<p>The empirical CDF is evaluated at your target value τ = <strong>' + this.num(target) + '</strong> via linear interpolation:</p>';
          html += '<div class="katex-eq" data-eq="P_{\\text{baseline}}(X \\leq \\tau) = P(X \\leq ' + this.num(target) + ') = ' + this.fmtPct(baselineProb) + '"></div>';
          if (baselineProb != null && baselineProb < 0.5) {
            html += '<p style="color:#D97706;">Target is above the PERT mean — baseline probability is below 50%, indicating an ambitious goal. Optimization strategies attempt to shift the distribution to increase this probability.</p>';
          } else if (baselineProb != null && baselineProb > 0.8) {
            html += '<p style="color:#16A34A;">Baseline already exceeds 80% — your target is conservative relative to the estimate range. Optimization may provide marginal additional confidence.</p>';
          } else {
            html += '<p>Baseline probability is near the PERT mean (~50%). The optimization strategies below adjust 7 decision levers to reshape the distribution and increase P(X ≤ τ).</p>';
          }
          html += '</div></div>';

          // --- Step 5: SACO Optimization Framework ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 4 — SACO Optimization Framework</div>';
          html += '<div class="rep-note" style="line-height:2;">';
          html += '<p>Seven decision levers (sliders) control how the distribution is reshaped. Each slider maps to [0, 1] in a 7-dimensional hypercube. The optimization process:</p>';
          html += '<ol style="margin:6px 0;padding-left:20px;line-height:2;">';
          html += '<li><strong>Latin Hypercube Sampling (LHS)</strong> — generates uniformly distributed candidate points across the 7D space to ensure thorough coverage</li>';
          html += '<li><strong>Copula → Moment Aggregation</strong> — slider values are combined via weighted aggregation into two moments: m₀ (mean shift) and m₁ (variance compression)</li>';
          html += '<li><strong>Beta Re-fit</strong> — moments adjust the baseline distribution: μ\' = μ(1 − m₀·0.2), σ\'² = σ²(1 − m₁·0.5), then new α\', β\' are computed via method of moments</li>';
          html += '<li><strong>COBYLA Refinement</strong> — local Constrained Optimization BY Linear Approximations maximizes P(X ≤ τ) subject to slider bounds and KL-divergence penalty</li>';
          html += '<li><strong>KL-Divergence Guard</strong> — ensures the reshaped distribution doesn\'t drift too far from baseline: D_KL(P\' || P) &lt; 0.50</li>';
          html += '<li><strong>"Never Worse" Guard</strong> — if optimization produces P\' &lt; P_baseline, all sliders revert to zero and baseline is returned</li>';
          html += '</ol>';
          html += '<p>The moment aggregation formulas:</p>';
          html += '<div class="katex-eq" data-eq="m_0 = \\sum_{i=1}^{7} w_i \\cdot s_i \\quad \\text{(mean shift)}, \\qquad m_1 = \\sum_{i=1}^{7} |w_i| \\cdot s_i \\cdot \\gamma_i \\quad \\text{(variance compression)}"></div>';
          html += '<div class="katex-eq" data-eq="\\mu\' = \\mu \\cdot (1 - m_0 \\cdot 0.2) \\qquad \\sigma\'^{\\,2} = \\sigma^2 \\cdot (1 - m_1 \\cdot 0.5)"></div>';
          html += '<div class="katex-eq" data-eq="\\alpha\' = \\mu\'_{01} \\left( \\frac{\\mu\'_{01}(1-\\mu\'_{01})}{\\sigma\'^{\\,2}_{01}} - 1 \\right) \\qquad \\beta\' = (1-\\mu\'_{01}) \\left( \\frac{\\mu\'_{01}(1-\\mu\'_{01})}{\\sigma\'^{\\,2}_{01}} - 1 \\right)"></div>';
          html += '</div></div>';

          // --- Step 6: Per-Strategy Results ---
          html += '<div class="rep-card" style="background:#F9FAFB;">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:4px;">Step 5 — Strategy-by-Strategy Transformation</div>';
          html += '<div class="rep-note" style="margin-bottom:10px;">Each strategy applies the SACO framework with different constraint boundaries. Below shows the actual slider values, computed moments, and resulting Beta parameters for each active strategy.</div>';
          html += '</div>';

          // Conservative Optimization
          if (adaptiveProb != null) {
            html += strategySection(
              'Conservative Optimization (Level ' + probeLvl + ')', '#0EA5E9', adaptiveProb, adaptiveSliders, guidedT, guidedKL,
              'Tightest best-practice constraints — Level ' + probeLvl + ' narrows each slider\'s feasible range. ' + (probeLvl >= 5 ? 'At this high level, constraints are very tight; if sliders show 0%, the optimizer found no improvement possible within these bounds.' : 'Lower levels allow more room for the optimizer.'),
              1
            );
          }

          // Optimized
          if (fixedProb != null) {
            html += strategySection(
              'Optimized', '#8B5CF6', fixedProb, fixedSliders, optimizedT, optimizedKL,
              'Standard boundaries (Level 1) — widest feasible region, most room for optimization. Typically achieves higher probability than Guided but with more assumptions.',
              2
            );
          }

          // Unconstrained Optimization
          if (manualProb != null) {
            html += strategySection(
              'Unconstrained Optimization', '#F59E0B', manualProb, manualSliders, explorerT, explorerKL,
              'Unconstrained — user-defined slider positions with no best-practice validation. Shows the theoretical ceiling but may not be achievable in practice.',
              3
            );
          }

          // No strategies message
          if (adaptiveProb == null && fixedProb == null && manualProb == null) {
            html += '<div class="rep-card" style="text-align:center;padding:20px;color:#6B7280;"><p style="font-size:14px;">Activate <strong>Guided</strong>, <strong>Optimized</strong>, or <strong>Explorer</strong> strategies above to see their transformation details here.</p></div>';
          }

          // --- Step 7: Cross-Strategy Comparison ---
          if (adaptiveProb != null || fixedProb != null || manualProb != null) {
            html += '<div class="rep-card">';
            html += '<div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:8px;">Step 6 — Cross-Strategy Comparison</div>';
            html += '<div class="rep-note" style="margin-bottom:8px;">Side-by-side comparison of all active strategies at target τ = ' + this.num(target) + '.</div>';

            // Summary table
            html += '<table class="rep-tbl" style="font-size:12px;"><thead><tr><th>Strategy</th><th>P(X ≤ τ)</th><th>Δ from Baseline</th><th>m₀ (mean shift)</th><th>m₁ (var compress)</th><th>KL Divergence</th><th>Constraints</th></tr></thead><tbody>';
            html += '<tr><td style="font-weight:600;">Your Estimate</td><td class="mono" style="font-weight:700;">' + this.fmtPct(baselineProb) + '</td><td>—</td><td class="mono">0</td><td class="mono">0</td><td class="mono">0</td><td>None (raw PERT)</td></tr>';
            if (adaptiveProb != null) {
              const aGain = baselineProb != null ? ((adaptiveProb - baselineProb)*100) : null;
              html += '<tr style="background:#F0F9FF;"><td style="font-weight:600;"><span style="color:#0EA5E9;">●</span> Guided (Lvl ' + probeLvl + ')</td><td class="mono" style="font-weight:700;color:#0EA5E9;">' + this.fmtPct(adaptiveProb) + '</td><td class="mono" style="color:' + (aGain > 0 ? '#16A34A' : '#6B7280') + ';">' + (aGain != null ? (aGain>=0?'+':'') + aGain.toFixed(2) + ' pts' : '–') + '</td><td class="mono">' + (guidedT ? this.num(guidedT.m0,4) : '–') + '</td><td class="mono">' + (guidedT ? this.num(guidedT.m1,4) : '–') + '</td><td class="mono">' + (guidedKL != null ? this.num(guidedKL,4) : '–') + '</td><td>Strict (Lvl ' + probeLvl + ')</td></tr>';
            }
            if (fixedProb != null) {
              const fGain = baselineProb != null ? ((fixedProb - baselineProb)*100) : null;
              html += '<tr style="background:#FAF5FF;"><td style="font-weight:600;"><span style="color:#8B5CF6;">●</span> Optimized</td><td class="mono" style="font-weight:700;color:#8B5CF6;">' + this.fmtPct(fixedProb) + '</td><td class="mono" style="color:' + (fGain > 0 ? '#16A34A' : '#6B7280') + ';">' + (fGain != null ? (fGain>=0?'+':'') + fGain.toFixed(2) + ' pts' : '–') + '</td><td class="mono">' + (optimizedT ? this.num(optimizedT.m0,4) : '–') + '</td><td class="mono">' + (optimizedT ? this.num(optimizedT.m1,4) : '–') + '</td><td class="mono">' + (optimizedKL != null ? this.num(optimizedKL,4) : '–') + '</td><td>Standard (Lvl 1)</td></tr>';
            }
            if (manualProb != null) {
              const mGain = baselineProb != null ? ((manualProb - baselineProb)*100) : null;
              html += '<tr style="background:#FFFBEB;"><td style="font-weight:600;"><span style="color:#F59E0B;">●</span> Explorer</td><td class="mono" style="font-weight:700;color:#F59E0B;">' + this.fmtPct(manualProb) + '</td><td class="mono" style="color:' + (mGain > 0 ? '#16A34A' : '#6B7280') + ';">' + (mGain != null ? (mGain>=0?'+':'') + mGain.toFixed(2) + ' pts' : '–') + '</td><td class="mono">' + (explorerT ? this.num(explorerT.m0,4) : '–') + '</td><td class="mono">' + (explorerT ? this.num(explorerT.m1,4) : '–') + '</td><td class="mono">' + (explorerKL != null ? this.num(explorerKL,4) : '–') + '</td><td>Unconstrained</td></tr>';
            }
            html += '</tbody></table>';

            // Slider-by-slider comparison
            html += '<div style="font-size:13px;font-weight:700;margin:12px 0 6px;">Slider-by-Slider Comparison</div>';
            html += '<div style="overflow-x:auto;"><table class="rep-tbl" style="font-size:11px;"><thead><tr><th>Lever</th><th>Baseline</th>';
            if (adaptiveProb != null) html += '<th style="color:#0EA5E9;">Guided</th>';
            if (fixedProb != null) html += '<th style="color:#8B5CF6;">Optimized</th>';
            if (manualProb != null) html += '<th style="color:#F59E0B;">Explorer</th>';
            html += '<th>Effect</th></tr></thead><tbody>';
            KEYS.forEach((k, i) => {
              const adaV = adaptiveSliders[k] || 0;
              const fixV = fixedSliders[k] || 0;
              const manV = manualSliders[k] || 0;
              html += '<tr><td style="font-weight:600;">' + LABELS[i] + '</td><td class="mono">0%</td>';
              if (adaptiveProb != null) html += '<td class="mono" style="' + (adaV > 0 ? 'color:#0EA5E9;font-weight:600;' : '') + '">' + this.num(adaV, 0) + '%</td>';
              if (fixedProb != null) html += '<td class="mono" style="' + (fixV > 0 ? 'color:#8B5CF6;font-weight:600;' : '') + '">' + this.num(fixV, 0) + '%</td>';
              if (manualProb != null) html += '<td class="mono" style="' + (manV > 0 ? 'color:#F59E0B;font-weight:600;' : '') + '">' + this.num(manV, 0) + '%</td>';
              html += '<td style="font-size:10px;color:#6B7280;">' + this.sliderWhy(LABELS[i]) + '</td></tr>';
            });
            html += '</tbody></table></div>';
            html += '</div>';
          }

          // --- Step 8: Validation Checks ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 7 — Validation Checks</div>';
          html += '<table class="rep-tbl" style="font-size:12px;">';
          html += '<thead><tr><th>Check</th><th>Status</th><th>Value</th><th>Threshold</th></tr></thead><tbody>';
          html += '<tr><td>PDF integrates ≈ 1.0</td><td style="color:#16A34A;">Pass</td><td>≈ 1.000</td><td>0.95 – 1.05</td></tr>';
          html += '<tr><td>CDF monotonic non-decreasing</td><td style="color:#16A34A;">Pass</td><td>Verified</td><td>—</td></tr>';
          html += '<tr><td>CDF bounds [0, 1]</td><td style="color:#16A34A;">Pass</td><td>0.00 → 1.00</td><td>—</td></tr>';

          // KL checks per strategy
          [
            { label: 'KL (Conservative)', val: guidedKL },
            { label: 'KL (General)', val: optimizedKL },
            { label: 'KL (Unconstrained)', val: explorerKL }
          ].forEach(chk => {
            if (chk.val != null) {
              const klOk = chk.val < 0.5;
              html += '<tr><td>' + chk.label + '</td><td style="color:' + (klOk ? '#16A34A' : '#D97706') + ';">' + (klOk ? 'Pass' : 'Warn') + '</td><td>' + this.num(chk.val, 4) + '</td><td>&lt; 0.50</td></tr>';
            }
          });

          html += '<tr><td>Never-worse guard</td><td style="color:#16A34A;">Pass</td><td>All P\' ≥ P_base</td><td>—</td></tr>';
          html += '<tr><td>Coefficient of Variation</td><td style="color:#6B7280;">Info</td><td>' + (this.num(cv, 4) || '–') + '</td><td>—</td></tr>';
          html += '<tr><td>Skewness Index</td><td style="color:#6B7280;">Info</td><td>' + (this.num(skew, 4) || '–') + '</td><td>—</td></tr>';
          html += '</tbody></table></div>';

          // --- Methodology ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Methodology Notes</div>';
          html += '<div class="rep-note" style="font-size:12px;line-height:1.8;color:#374151;">';
          html += '<ul style="margin:4px 0;padding-left:16px;">';
          html += '<li>All probabilities computed via linear interpolation on 200-point empirical CDF arrays.</li>';
          html += '<li>PERT CDF(mode) ≈ 50% but not exactly due to Beta distribution asymmetry, even for symmetric O/M/P inputs.</li>';
          html += '<li>MC kernel smoothing introduces ±1–2% variance between runs (different random seeds). This is expected and within statistical tolerance.</li>';
          html += '<li>The "never worse than baseline" guard (optimizer.gs:592–604) reverts all sliders to zero if optimization produces lower probability — this is why Guided at high probe levels may show all-zero sliders.</li>';
          html += '<li>Guided constraints narrow the feasible search space at higher levels (n_samples = 50 × level). Level 1 ≈ 50 LHS samples, Level 7 ≈ 350 samples but with the tightest bounds.</li>';
          html += '<li>KL divergence D_KL(P\' || P) measures distributional drift — values &lt;0.10 = conservative, 0.10–0.50 = moderate, &gt;0.50 = aggressive (flagged for review).</li>';
          html += '</ul></div></div>';

          html += '</div>'; // close rep-stat
          return html;
        },

        makeTornado(impacts) {
          if (impacts.every(i => Math.abs(i.contrib) < 0.01) ) return '<div class="rep-note">No significant slider impact (baseline optimal or manual zeroed).</div>';
          const max = Math.max(...impacts.map(i => Math.abs(i.contrib)));
          return impacts.map(i => `
            <div class="rep-tornado-bar ${i.positive?'rep-positive':'rep-negative'}">
              <span>${i.label}</span>
              <div class="rep-bar"><div class="rep-fill" style="width:${Math.abs(i.contrib)/max*100}%"></div></div>
              <span>${i.contrib>=0?'+' : ''}${i.contrib.toFixed(2)} pts</span>
            </div>`).join('');
        },

        sliderWhy(l) {
          const map = {
            'Budget Flexibility':'Adds contingency → reduces variance',
            'Schedule Flexibility':'Buffers delays → positive mean shift',
            'Scope Certainty':'Eliminates ambiguity → strongest variance compression',
            'Scope Reduction Allowance':'Safety valve for extreme overruns',
            'Rework Percentage':'Lower = better (negative lever)',
            'Risk Tolerance':'Enables bolder decisions → high lift',
            'User Confidence':'Behavioral multiplier for execution'
          };
          return map[l] || '';
        }
      };

      window.PMCReport = Report;
      Report.mount();
    })();
  </script>

  <!-- Debug status bar — always visible -->
  <div id="debugBar" style="position:fixed;bottom:0;left:0;right:0;background:#1E293B;color:#94A3B8;font:11px monospace;padding:4px 12px;z-index:9999;display:flex;gap:16px;flex-wrap:wrap;">
    <span id="dbStatus">Loading...</span>
  </div>
  <script>
    // Self-contained debug — catches all errors, polls state, force-loads if needed
    try {
      var _dbEl = document.getElementById('dbStatus');
      var _errLog = [];

      // Capture ALL errors
      window.addEventListener('error', function(ev) {
        _errLog.push(ev.message + ' @' + (ev.lineno || '?'));
        if (_dbEl) _dbEl.innerHTML = '<span style="color:#F87171">ERR: ' + _errLog.join(' | ') + '</span>';
      });

      // Also catch unhandled promise rejections
      window.addEventListener('unhandledrejection', function(ev) {
        _errLog.push('Promise: ' + (ev.reason && ev.reason.message || ev.reason || 'unknown'));
        if (_dbEl) _dbEl.innerHTML = '<span style="color:#F87171">ERR: ' + _errLog.join(' | ') + '</span>';
      });

      function _dbUpdate() {
        try {
          var s = window.S || {};
          var sel = document.getElementById('taskSel');
          var opts = sel ? sel.options.length : 0;
          var selText = (sel && opts > 0 && sel.selectedIndex >= 0) ? sel.options[sel.selectedIndex].textContent : '-';
          var tri = s.trianglePdf ? s.trianglePdf.length : 0;
          var bas = s.basePdf ? s.basePdf.length : 0;
          var pdf = s.pdfChart ? 'yes(' + s.pdfChart.data.datasets.length + ')' : 'no';
          var cdf = s.cdfChart ? 'yes(' + s.cdfChart.data.datasets.length + ')' : 'no';
          var tab = s.tab || '?';
          var prob = s.baselineProb != null ? (s.baselineProb * 100).toFixed(1) + '%' : '-';
          var errs = _errLog.length;
          var parts = [
            'Tasks:' + opts,
            'Sel:' + selText,
            'Tri:' + tri,
            'Base:' + bas,
            'PDF:' + pdf,
            'CDF:' + cdf,
            'Tab:' + tab,
            'Prob:' + prob,
            errs > 0 ? '<span style="color:#F87171">Errs:' + errs + '</span>' : 'Errs:0'
          ];
          if (_dbEl) _dbEl.innerHTML = parts.join(' &nbsp;|&nbsp; ');
        } catch(e) {
          if (_dbEl) _dbEl.innerHTML = '<span style="color:#F87171">Debug error: ' + e.message + '</span>';
        }
      }
      setInterval(_dbUpdate, 3000);
      // Also run once immediately
      _dbUpdate();

      // After 3 seconds: if tasks are still empty, force-load them via direct fetch
      setTimeout(function() {
        var sel = document.getElementById('taskSel');
        if (sel && sel.options.length === 0) {
          if (_dbEl) _dbEl.innerHTML += ' <span style="color:#FBBF24">| Force-loading tasks...</span>';
          fetch('/rpc', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ method: 'getAllTasks', params: {} })
          })
          .then(function(r) { return r.json(); })
          .then(function(data) {
            if (data.error) { if (_dbEl) _dbEl.innerHTML += ' <span style="color:#F87171">RPC err: ' + data.error + '</span>'; return; }
            var list = data.result || [];
            sel.innerHTML = '';
            list.forEach(function(t, i) {
              var opt = document.createElement('option');
              opt.value = i;
              opt.textContent = t.task || ('Task ' + (i + 1));
              sel.appendChild(opt);
            });
            if (_dbEl) _dbEl.innerHTML += ' <span style="color:#34D399">| Force-loaded ' + list.length + ' tasks</span>';

            // Store tasks on S and trigger task change
            var s = window.S || {};
            s.tasks = list;
            sel.selectedIndex = 0;
            // Try dispatching change event first, then call onTaskChange directly as fallback
            if (typeof window.onTaskChange === 'function') {
              window.onTaskChange();
            } else {
              sel.dispatchEvent(new Event('change'));
            }
          })
          .catch(function(e) {
            if (_dbEl) _dbEl.innerHTML += ' <span style="color:#F87171">| Fetch err: ' + e.message + '</span>';
          });
        }
      }, 3000);

    } catch(e) {
      var d = document.getElementById('dbStatus');
      if (d) d.textContent = 'SCRIPT ERROR: ' + e.message;
    }
  </script>

  <!-- =====================================================================
       SHARED MATH HELPERS (used by both SACO 3D and Sphere tabs)
       All computations use the same PDF/CDF arrays as the main charts.
       ===================================================================== -->
  <script>
  (function() {
    'use strict';

    // ── SHARED PLUMBING ────────────────────────────────────────────────────

    /**
     * Trapezoidal integration of pdf points up to tau.
     * Returns F(tau) = ∫_{x_min}^{tau} f(x) dx using the same grid used to render.
     * If tau <= x_min returns 0; if tau >= x_max returns integral over full grid.
     */
    function trapezoidalCDF(pdfPoints, tau) {
      if (!pdfPoints || pdfPoints.length < 2) return null;
      // Clamp negatives to 0 (numerical noise)
      const pts = pdfPoints.map(p => ({ x: p.x, y: Math.max(0, p.y) }));
      const xMin = pts[0].x, xMax = pts[pts.length - 1].x;
      if (!Number.isFinite(tau)) return null;
      if (tau <= xMin) return 0;
      if (tau >= xMax) {
        // Full integral
        let s = 0;
        for (let i = 1; i < pts.length; i++) s += 0.5 * (pts[i].y + pts[i-1].y) * (pts[i].x - pts[i-1].x);
        return Math.min(1, Math.max(0, s));
      }
      // Integrate up to tau with linear interpolation at tau
      let s = 0;
      for (let i = 1; i < pts.length; i++) {
        const x0 = pts[i-1].x, x1 = pts[i].x;
        const y0 = pts[i-1].y, y1 = pts[i].y;
        if (x1 <= tau) {
          s += 0.5 * (y0 + y1) * (x1 - x0);
        } else if (x0 < tau) {
          const t = (tau - x0) / (x1 - x0);
          const yTau = y0 + t * (y1 - y0);
          s += 0.5 * (y0 + yTau) * (tau - x0);
          break;
        } else { break; }
      }
      return Math.min(1, Math.max(0, s));
    }

    /**
     * Total mass: ∫ f(x) dx over all points. Should be ≈ 1.
     */
    function totalMass(pdfPoints) {
      if (!pdfPoints || pdfPoints.length < 2) return null;
      let s = 0;
      for (let i = 1; i < pdfPoints.length; i++) {
        const y0 = Math.max(0, pdfPoints[i-1].y), y1 = Math.max(0, pdfPoints[i].y);
        s += 0.5 * (y0 + y1) * (pdfPoints[i].x - pdfPoints[i-1].x);
      }
      return s;
    }

    /**
     * Compute ∫ Δf dx where Δf = f_current - f_baseline.
     * Should be ≈ 0 (mass-preserving transformation).
     * Uses same x-grid — if grids differ, use f_baseline x-grid.
     */
    function integralDeltaF(basePdf, currentPdf) {
      if (!basePdf || !currentPdf || basePdf.length < 2) return null;
      // Interpolate currentPdf onto basePdf x-grid
      function interpY(pts, x) {
        if (!pts || pts.length < 2) return 0;
        if (x <= pts[0].x) return pts[0].y;
        if (x >= pts[pts.length-1].x) return pts[pts.length-1].y;
        let lo = 0, hi = pts.length - 1;
        while (hi - lo > 1) { const m = (lo + hi) >> 1; if (pts[m].x <= x) lo = m; else hi = m; }
        const t = (x - pts[lo].x) / (pts[hi].x - pts[lo].x);
        return pts[lo].y + t * (pts[hi].y - pts[lo].y);
      }
      let s = 0;
      for (let i = 1; i < basePdf.length; i++) {
        const x0 = basePdf[i-1].x, x1 = basePdf[i].x;
        const d0 = Math.max(0, interpY(currentPdf, x0)) - Math.max(0, basePdf[i-1].y);
        const d1 = Math.max(0, interpY(currentPdf, x1)) - Math.max(0, basePdf[i].y);
        s += 0.5 * (d0 + d1) * (x1 - x0);
      }
      return s;
    }

    /**
     * Produce current PDF from state. Prefers actual optimized arrays, falls back
     * to mass-preserving reweight of baseline using slider-derived weight function.
     *
     * Reweight operator (visualization-only proxy — documented as such):
     *   w(x; s) = exp(-λ * max(0, x - τ))  where λ = m0 * 3 (positive, bounded)
     *   f̃(x) = w(x) * f0(x), then renormalized so ∫f̃ = 1
     * This guarantees f_current >= 0 and ∫f_current = 1 at all times.
     * It is NOT identical to SACO's true reshaping kernel unless optimized arrays are used.
     */
    function getCurrentPdf(S) {
      const overlay = S.overlay || {};
      // Prefer actual optimized distribution arrays from API
      if (overlay.adaptiveOn && S.optPdfAdaptive && S.optPdfAdaptive.length > 1)
        return { pdf: S.optPdfAdaptive, source: 'Guided' };
      if (overlay.fixedOn && S.optPdfFixed && S.optPdfFixed.length > 1)
        return { pdf: S.optPdfFixed, source: 'Optimized' };
      if (overlay.manualOn && S.adjPdf && S.adjPdf.length > 1)
        return { pdf: S.adjPdf, source: 'Explorer' };
      // Fallback: reweight baseline with slider-derived weight
      const basePdf = S.basePdf && S.basePdf.length > 1 ? S.basePdf : null;
      if (!basePdf) return { pdf: null, source: 'None' };
      // Compute moment m0 from current manual sliders
      const KEYS = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
      const WEIGHTS = [-0.20, 0.10, 0.30, -0.15, -0.08, 0.25, 0.05];
      let m0 = 0;
      KEYS.forEach((id, i) => {
        const el = document.getElementById(id);
        const v = el ? Number(el.value) / 100 : 0;
        m0 += WEIGHTS[i] * v;
      });
      m0 = Math.max(-0.5, Math.min(0.5, m0));
      const tau = S.target != null ? S.target : S.M;
      const lambda = m0 * 3;
      // Compute weighted pdf
      const weighted = basePdf.map(p => ({
        x: p.x,
        y: Math.max(0, p.y) * Math.exp(-lambda * Math.max(0, p.x - tau))
      }));
      const mass = totalMass(weighted) || 1;
      const normalized = weighted.map(p => ({ x: p.x, y: p.y / mass }));
      return { pdf: normalized, source: 'Reweighted (proxy)' };
    }

    /**
     * Sanity checks — console.warn if invariants violated.
     */
    function validatePdf(pdf, label) {
      const EPS = 1e-3;
      if (!pdf || pdf.length < 2) return;
      const mass = totalMass(pdf);
      const minY = Math.min(...pdf.map(p => p.y));
      if (Math.abs(mass - 1) > EPS) console.warn('[PMC] ' + label + ' mass violation: ' + mass.toFixed(6));
      if (minY < -1e-9) console.warn('[PMC] ' + label + ' negative density: ' + minY.toExponential(3));
    }

    function validateLift(F0, Fcur, displayedDeltaP) {
      const EPS = 0.002;
      const computed = Fcur - F0;
      if (Math.abs(computed - displayedDeltaP) > EPS)
        console.warn('[PMC] ΔP mismatch: computed=' + computed.toFixed(4) + ' displayed=' + displayedDeltaP.toFixed(4));
    }

    // Expose helpers globally
    window.PMCMath = { trapezoidalCDF, totalMass, integralDeltaF, getCurrentPdf, validatePdf, validateLift };
  })();
  </script>

  <!-- =====================================================================
       SACO 3D PROBABILITY SURFACE — cinematic glass+glow style
       Three.js r134 ribbon-mesh visualization.
       Baseline PDF = translucent ghost; Strategy PDF = glossy Δ-heatmap.
       All probability math (trapNorm, F0/F1, ΔP, ∫Δf) is unchanged.
       ===================================================================== -->
  <script>
  (function() {
    'use strict';

    const SLIDER_KEYS        = ['budgetFlexibility','scheduleFlexibility','scopeCertainty','scopeReductionAllowance','reworkPercentage','riskTolerance','userConfidence'];
    const SLIDER_IDS         = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
    const SLIDER_COLORS      = [0xEF4444, 0xF59E0B, 0x10B981, 0x3B82F6, 0x8B5CF6, 0xEC4899, 0x14B8A6];
    const SLIDER_SHORT_LABELS= ['Budget','Schedule','Scope%','ScopeRed','Rework','Risk','Confidence'];
    const SLIDER_CSS_COLORS  = ['rgba(239,68,68,.95)','rgba(245,158,11,.95)','rgba(16,185,129,.95)','rgba(59,130,246,.95)','rgba(139,92,246,.95)','rgba(236,72,153,.95)','rgba(20,184,166,.95)'];

    // ── MODULE STATE ─────────────────────────────────────────────────────────
    var _renderer = null, _scene = null, _camera = null, _controls = null;
    var _baseGroup = null, _curGroup = null, _tauGroup = null, _heptGroup = null;
    var _animId = null, _initialized = false, _lastW = 0, _lastH = 0;
    var _zoomEnabled = false; // pending zoom state — applied when controls are created
    var D = 1.8; // scene z-depth (ribbons span z = 0 … D)
    var _ribbonMeta = null; // {xMid, xScale, yMax3} — updated each render, used for annotation projection
    var _otherGroups = []; // ghost ribbon groups for non-primary active strategies

    // ── MATH HELPERS (unchanged) ──────────────────────────────────────────────
    function fmtPct(v) { return (v != null && isFinite(v)) ? (v*100).toFixed(2)+'%' : '–'; }

    function interpY(pts, x) {
      if (!pts || pts.length < 2) return 0;
      if (x <= pts[0].x) return pts[0].y;
      if (x >= pts[pts.length-1].x) return pts[pts.length-1].y;
      var lo = 0, hi = pts.length - 1;
      while (hi - lo > 1) { var m = (lo + hi) >> 1; if (pts[m].x <= x) lo = m; else hi = m; }
      var t = (x - pts[lo].x) / (pts[hi].x - pts[lo].x);
      return pts[lo].y + t * (pts[hi].y - pts[lo].y);
    }

    function trapNorm(pts) {
      if (!pts || pts.length < 2) return pts || [];
      var clamped = [];
      for (var i = 0; i < pts.length; i++) clamped.push({ x: pts[i].x, y: Math.max(0, pts[i].y) });
      var mass = 0;
      for (var j = 1; j < clamped.length; j++)
        mass += 0.5 * (clamped[j-1].y + clamped[j].y) * (clamped[j].x - clamped[j-1].x);
      if (mass <= 0) return clamped;
      var out = [];
      for (var k = 0; k < clamped.length; k++) out.push({ x: clamped[k].x, y: clamped[k].y / mass });
      return out;
    }

    // ── VISUAL HELPERS ────────────────────────────────────────────────────────

    // 1-D smoothing kernel [0.25, 0.5, 0.25] — reduces Δf banding artifacts.
    function smoothDelta(arr) {
      var out = arr.slice();
      for (var i = 1; i < arr.length - 1; i++)
        out[i] = 0.25 * arr[i-1] + 0.50 * arr[i] + 0.25 * arr[i+1];
      return out;
    }

    // Diverging palette: negative = cyan/blue, zero = near-white/pale-teal,
    // positive = yellow/orange/red.
    function deltaColor(df, maxDelta) {
      var t = maxDelta > 0 ? Math.max(-1, Math.min(1, df / maxDelta)) : 0;
      if (t > 0) {
        if (t <= 0.5) { var u = t * 2;
          return { r: 0.90 + 0.10*u, g: 0.92 - 0.12*u, b: 0.88 - 0.78*u }; // pale-teal → yellow
        } else { var u = (t-0.5)*2;
          return { r: 1.0, g: 0.80 - 0.65*u, b: 0.10 - 0.10*u }; }        // yellow → orange → red
      } else if (t < 0) {
        var u = -t;
        if (u <= 0.5) { var v = u * 2;
          return { r: 0.90 - 0.60*v, g: 0.92 - 0.02*v, b: 0.88 + 0.12*v }; // pale-teal → cyan
        } else { var v = (u-0.5)*2;
          return { r: 0.30 - 0.20*v, g: 0.90 - 0.55*v, b: 1.0 }; }         // cyan → blue
      }
      return { r: 0.90, g: 0.95, b: 0.92 }; // near-white pale-teal at zero
    }

    // Render text to canvas → THREE.Sprite (2× pixel density for crisp labels).
    function makeTextSprite(text, opts) {
      opts = opts || {};
      var W0 = opts.w || 192, H0 = opts.h || 52;
      var dpr = 2; // render at 2× resolution, scale back to original size
      var W = W0 * dpr, H = H0 * dpr;
      var canvas = document.createElement('canvas');
      canvas.width = W; canvas.height = H;
      var ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, W, H);
      // Pill background for readability
      var bgCol = opts.bgColor !== undefined ? opts.bgColor : 'rgba(15,20,35,0.72)';
      if (bgCol) {
        ctx.fillStyle = bgCol;
        var rx = 10 * dpr, pad = 6 * dpr;
        ctx.beginPath();
        ctx.moveTo(rx, pad);
        ctx.lineTo(W - rx, pad);
        ctx.quadraticCurveTo(W - pad, pad, W - pad, rx);
        ctx.lineTo(W - pad, H - rx);
        ctx.quadraticCurveTo(W - pad, H - pad, W - rx, H - pad);
        ctx.lineTo(rx, H - pad);
        ctx.quadraticCurveTo(pad, H - pad, pad, H - rx);
        ctx.lineTo(pad, rx);
        ctx.quadraticCurveTo(pad, pad, rx, pad);
        ctx.closePath();
        ctx.fill();
      }
      ctx.fillStyle = opts.color || 'rgba(255,176,64,0.97)';
      ctx.font = (opts.bold ? 'bold ' : '') + (opts.size || 24) * dpr + 'px ui-monospace,-apple-system,sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(text, W / 2, H / 2);
      var tex = new THREE.CanvasTexture(canvas);
      var sp  = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false }));
      // Scale uses original dimensions so visual size is unchanged (2× canvas → same screen size, 2× sharpness)
      sp.scale.set(opts.sx || W0 / 38, opts.sy || H0 / 38, 1);
      return sp;
    }

    // Build a 3D ribbon group that spans z = zFront … zBack.
    // Returns a THREE.Group containing the PBR surface mesh + silhouette edge lines.
    // colorFn(i) → {r,g,b} applied per x-sample (same at front & back).
    function buildRibbonGroup(pdf, xScale, xMid, yScale, zFront, zBack, colorFn, mOpts) {
      var grp = new THREE.Group();
      if (!pdf || pdf.length < 2) return grp;
      mOpts = mOpts || {};
      var n = pdf.length;
      // Vertex blocks:  [0..2n-1] top (front, back interleaved)
      //                 [2n..4n-1] bottom (front, back interleaved)
      var nV = n * 4;
      var pos = new Float32Array(nV * 3);
      var col = new Float32Array(nV * 3);
      var idx = [];

      for (var i = 0; i < n; i++) {
        var xi = (pdf[i].x - xMid) * xScale;
        var yi = Math.max(0, pdf[i].y) * yScale;
        var ci = colorFn(i);
        var dim = { r: ci.r*0.45, g: ci.g*0.45, b: ci.b*0.45 };
        // top-front (2i), top-back (2i+1)
        pos[(2*i)*3]   = xi; pos[(2*i)*3+1]   = yi; pos[(2*i)*3+2]   = zFront;
        col[(2*i)*3]   = ci.r; col[(2*i)*3+1]   = ci.g; col[(2*i)*3+2]   = ci.b;
        pos[(2*i+1)*3] = xi; pos[(2*i+1)*3+1] = yi; pos[(2*i+1)*3+2] = zBack;
        col[(2*i+1)*3] = ci.r; col[(2*i+1)*3+1] = ci.g; col[(2*i+1)*3+2] = ci.b;
        // bot-front (2n+2i), bot-back (2n+2i+1)
        pos[(2*n+2*i)*3]   = xi; pos[(2*n+2*i)*3+1]   = 0; pos[(2*n+2*i)*3+2]   = zFront;
        col[(2*n+2*i)*3]   = dim.r; col[(2*n+2*i)*3+1]   = dim.g; col[(2*n+2*i)*3+2]   = dim.b;
        pos[(2*n+2*i+1)*3] = xi; pos[(2*n+2*i+1)*3+1] = 0; pos[(2*n+2*i+1)*3+2] = zBack;
        col[(2*n+2*i+1)*3] = dim.r; col[(2*n+2*i+1)*3+1] = dim.g; col[(2*n+2*i+1)*3+2] = dim.b;
      }
      // Top surface
      for (var i = 0; i < n-1; i++) {
        var tf=2*i, tb=2*i+1, tf1=2*(i+1), tb1=2*(i+1)+1;
        idx.push(tf,tb,tf1); idx.push(tb,tb1,tf1);
      }
      // Front face (z=zFront, y goes 0→curve)
      for (var i = 0; i < n-1; i++) {
        var tf=2*i, tf1=2*(i+1), bf=2*n+2*i, bf1=2*n+2*(i+1);
        idx.push(tf,bf,tf1); idx.push(bf,bf1,tf1);
      }
      // Back face (z=zBack)
      for (var i = 0; i < n-1; i++) {
        var tb=2*i+1, tb1=2*(i+1)+1, bb=2*n+2*i+1, bb1=2*n+2*(i+1)+1;
        idx.push(tb,tb1,bb); idx.push(tb1,bb1,bb);
      }

      var geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.setAttribute('color',    new THREE.BufferAttribute(col, 3));
      geo.setIndex(idx);
      geo.computeVertexNormals();

      var matCfg = {
        vertexColors: !mOpts.uniformColor,
        transparent: true, opacity: mOpts.opacity !== undefined ? mOpts.opacity : 0.88,
        side: THREE.DoubleSide, depthWrite: false,
        metalness: mOpts.metalness !== undefined ? mOpts.metalness : 0.08,
        roughness: mOpts.roughness !== undefined ? mOpts.roughness : 0.32,
        clearcoat: mOpts.clearcoat !== undefined ? mOpts.clearcoat : 0.75,
        clearcoatRoughness: mOpts.ccRough !== undefined ? mOpts.ccRough : 0.18
      };
      if (mOpts.uniformColor) { matCfg.color = mOpts.uniformColor; }
      grp.add(new THREE.Mesh(geo, new THREE.MeshPhysicalMaterial(matCfg)));

      // Silhouette: trace front-curve → back-curve loop
      var edgePts = [];
      for (var i = 0; i < n; i++)
        edgePts.push(new THREE.Vector3((pdf[i].x-xMid)*xScale, Math.max(0,pdf[i].y)*yScale, zFront));
      for (var i = n-1; i >= 0; i--)
        edgePts.push(new THREE.Vector3((pdf[i].x-xMid)*xScale, Math.max(0,pdf[i].y)*yScale, zBack));
      edgePts.push(edgePts[0].clone());
      grp.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(edgePts),
        new THREE.LineBasicMaterial({
          color: mOpts.edgeColor || 0x88ccff, transparent: true,
          opacity: mOpts.edgeOpacity !== undefined ? mOpts.edgeOpacity : 0.35, depthWrite: false
        })));
      return grp;
    }

    // ── INITIALIZATION ────────────────────────────────────────────────────────
    function initThree(container) {
      if (_initialized) return;
      container.innerHTML = '';
      container.style.background  = '#F0F4FA';
      container.style.borderColor = 'rgba(140,170,220,0.40)';
      container.style.boxShadow   = 'inset 0 0 10px rgba(160,180,220,0.12)';

      var w = Math.max(container.clientWidth || 400, 200);
      var h = Math.max(container.clientHeight || 310, 200);
      _lastW = w; _lastH = h;

      _scene = new THREE.Scene();
      _scene.background = new THREE.Color(0xF0F4FA); // light blue-gray

      // ── Cinematic camera ─────────────────────────────────────────────────
      _camera = new THREE.PerspectiveCamera(40, w / h, 0.05, 200);
      _camera.position.set(-2.5, 7.0, 16);
      _camera.lookAt(0, 1.8, D / 2);

      _renderer = new THREE.WebGLRenderer({ antialias: true });
      _renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      _renderer.setSize(w, h);
      _renderer.domElement.style.cssText = 'display:block;width:100%;height:100%;';
      container.appendChild(_renderer.domElement);

      // ── 3-point lighting (tuned for light background) ────────────────────
      _scene.add(new THREE.AmbientLight(0xdce8f8, 0.55));           // soft blue-white ambient
      var key = new THREE.DirectionalLight(0xfff5e0, 0.90);         // key: warm, front-top-left
      key.position.set(-5, 9, 7); _scene.add(key);
      var fill = new THREE.DirectionalLight(0xc8d8ff, 0.40);        // fill: cool, front-top-right
      fill.position.set(5, 6, 5); _scene.add(fill);
      var rim = new THREE.DirectionalLight(0x8090c8, 0.35);         // rim: muted blue, from behind
      rim.position.set(0, 5, -10); _scene.add(rim);

      // ── OrbitControls ────────────────────────────────────────────────────
      if (typeof THREE.OrbitControls !== 'undefined') {
        _controls = new THREE.OrbitControls(_camera, _renderer.domElement);
        _controls.enableDamping = true;
        _controls.dampingFactor = 0.07;
        _controls.minDistance = 4; _controls.maxDistance = 40;
        _controls.target.set(0, 1.8, D / 2);
        _controls.autoRotate = false;
        _controls.autoRotateSpeed = 0.4;
        // Zoom/pan disabled by default; enabled when user clicks "Zoom" button
        _controls.enableZoom = _zoomEnabled;
        _controls.enablePan  = _zoomEnabled;
        _controls.update();
      }

      // ── Subtle light grid ────────────────────────────────────────────────
      var grid = new THREE.GridHelper(16, 32, 0xb8c8d8, 0xd0dae4);
      grid.position.set(0, -0.01, D / 2);
      _scene.add(grid);

      // ── Faint axis lines ─────────────────────────────────────────────────
      var axMat = new THREE.LineBasicMaterial({ color: 0x8898b8, transparent: true, opacity: 0.55 });
      _scene.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-5.5,0,0), new THREE.Vector3(5.5,0,0)]), axMat));
      _scene.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,4.2,0)]), axMat));

      // ── Legend + annotation overlays ─────────────────────────────────────
      _injectLegend(container);
      _injectAnnotations(container);

      _initialized = true;
      _startLoop();
    }

    function _injectLegend(container) {
      // Inject the legend INSIDE the 3D canvas container so it overlays the scene
      var ex = container.querySelector('.saco3d-leg'); if (ex) ex.remove();
      var leg = document.createElement('div');
      leg.className = 'saco3d-leg';
      leg.style.cssText = [
        'position:absolute;bottom:8px;left:8px;z-index:3;',
        'background:rgba(255,255,255,0.90);border:1px solid rgba(160,180,220,0.55);',
        'border-radius:7px;padding:5px 9px;font-size:9.5px;',
        'font-family:ui-monospace,monospace;color:#374151;',
        'line-height:1.75;pointer-events:none;backdrop-filter:blur(4px);',
        'box-shadow:0 2px 8px rgba(120,140,180,0.15);'
      ].join('');
      leg.innerHTML = [
        // Heatmap gradient with directional labels
        '<div style="font-weight:800;font-size:8.5px;letter-spacing:.06em;color:#6b7280;margin-bottom:4px;">LEGEND</div>',
        '<div style="margin-bottom:5px;">',
        '  <div style="display:flex;justify-content:space-between;font-size:8px;color:#6b7280;margin-bottom:1px;">',
        '    <span>mass removed</span><span>neutral</span><span>mass added</span></div>',
        '  <div style="width:110px;height:8px;border-radius:3px;',
        '    background:linear-gradient(90deg,#38bdf8 0%,#818cf8 30%,#e2e8f0 50%,#fbbf24 70%,#ef4444 100%);',
        '    border:1px solid rgba(100,120,160,0.25);"></div>',
        '  <div style="font-size:8px;color:#6b7280;margin-top:1px;">\u0394 heatmap on strategy ribbon</div>',
        '</div>',
        '<div style="display:flex;align-items:center;gap:5px;">',
        '  <span style="width:22px;height:6px;border-radius:2px;display:inline-block;',
        '    background:rgba(80,160,255,0.45);border:1px solid rgba(80,160,255,0.5);"></span>',
        '  <span>Strategy ribbon</span></div>',
        '<div style="display:flex;align-items:center;gap:5px;">',
        '  <span style="width:22px;height:6px;border-radius:2px;display:inline-block;',
        '    background:rgba(140,180,220,0.22);border:1px solid rgba(140,180,220,0.28);"></span>',
        '  <span>Baseline f\u2080(x)</span></div>',
        '<div style="display:flex;align-items:center;gap:5px;margin-top:2px;">',
        '  <span style="width:22px;height:6px;border-radius:2px;display:inline-block;',
        '    background:rgba(255,176,64,0.55);border:1px solid rgba(255,176,64,0.80);"></span>',
        '  <span>\u03c4 target plane</span></div>'
      ].join('');
      container.style.position = 'relative'; // ensure absolute children are relative to canvas
      container.appendChild(leg);
    }

    // ── ANNOTATION OVERLAY ────────────────────────────────────────────────────
    var _ANN_DEFS = [
      { id: 'saco-ann-base',    col: '#475569', bg: 'rgba(241,245,249,0.94)', brd: 'rgba(148,163,184,0.60)' },
      { id: 'saco-ann-guided',  col: '#5b21b6', bg: 'rgba(139,92,246,0.13)',  brd: 'rgba(139,92,246,0.60)' },
      { id: 'saco-ann-opt',     col: '#1e40af', bg: 'rgba(59,130,246,0.13)',   brd: 'rgba(59,130,246,0.60)'  },
      { id: 'saco-ann-exp',     col: '#065f46', bg: 'rgba(16,185,129,0.13)',  brd: 'rgba(16,185,129,0.60)' }
    ];
    function _injectAnnotations(container) {
      var ex = container.querySelector('.saco3d-ann'); if (ex) ex.remove();
      var ann = document.createElement('div');
      ann.className = 'saco3d-ann';
      ann.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:4;overflow:hidden;';
      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('id', 'saco3d-ann-svg');
      svg.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;overflow:visible;';
      ann.appendChild(svg);
      _ANN_DEFS.forEach(function(d) {
        var el = document.createElement('div');
        el.id = d.id;
        el.style.cssText = [
          'display:none;position:absolute;padding:4px 10px;border-radius:7px;',
          'font-size:11px;font-family:ui-monospace,monospace;font-weight:700;white-space:nowrap;',
          'background:' + d.bg + ';color:' + d.col + ';border:1.5px solid ' + d.brd + ';',
          'box-shadow:0 2px 8px rgba(0,0,0,0.18);backdrop-filter:blur(6px);line-height:1.4;'
        ].join('');
        ann.appendChild(el);
      });
      container.appendChild(ann);
    }

    function _updateAnnotations() {
      if (!_camera || !_ribbonMeta) return;
      var S = window.S; if (!S) return;
      var container = document.getElementById('saco3dContainer');
      if (!container) return;
      var tau = (S.target != null) ? Number(S.target) : null;
      var ov = S.overlay || {};
      var anyActive = ov.adaptiveOn || ov.fixedOn || ov.manualOn;
      var annDiv = container.querySelector('.saco3d-ann');
      if (!annDiv) return;

      // Hide all when nothing to show
      if (tau == null || !isFinite(tau) || !anyActive) {
        _ANN_DEFS.forEach(function(d) {
          var el = document.getElementById(d.id); if (el) el.style.display = 'none';
        });
        var svgEl = document.getElementById('saco3d-ann-svg');
        if (svgEl) svgEl.innerHTML = '';
        return;
      }

      var meta = _ribbonMeta;
      var w = container.clientWidth, h = container.clientHeight;

      // Project τ mid-height point to screen coordinates
      var xTau3d = (tau - meta.xMid) * meta.xScale;
      var v3 = new THREE.Vector3(xTau3d, meta.yMax3 * 0.35, D / 2);
      v3.project(_camera);
      var tauSx = (v3.x + 1) / 2 * w;
      var tauSy = (-v3.y + 1) / 2 * h;

      // Draw dashed τ guide line in SVG overlay
      var svgEl = document.getElementById('saco3d-ann-svg');
      if (svgEl) {
        svgEl.setAttribute('width', w); svgEl.setAttribute('height', h);
        var tx = tauSx.toFixed(1);
        var units = (S.units || '');
        var tauLabel = 'τ = ' + (tau != null ? Number(tau).toFixed(1) : '–') + (units ? '\u202f' + units : '');
        svgEl.innerHTML =
          '<line x1="' + tx + '" y1="0" x2="' + tx + '" y2="' + h + '" ' +
          'stroke="rgba(245,158,11,0.55)" stroke-width="1.5" stroke-dasharray="5,4"/>' +
          '<rect x="' + (parseFloat(tx) + 4) + '" y="4" width="' + (tauLabel.length * 6.5 + 12) + '" height="18" rx="4" ' +
          'fill="rgba(254,243,199,0.92)" stroke="rgba(245,158,11,0.60)" stroke-width="1"/>' +
          '<text x="' + (parseFloat(tx) + 10) + '" y="17" ' +
          'font-family="ui-monospace,monospace" font-size="10" font-weight="700" fill="#92400e">' + tauLabel + '</text>';
      }

      // Place annotation cards right of τ (or left if τ is past 60% width)
      var placeRight = tauSx < w * 0.58;
      var P0 = S.baselineProb;
      var stratDefs = [
        { def: _ANN_DEFS[0], label: 'Baseline',   prob: P0,              show: true            },
        { def: _ANN_DEFS[1], label: 'Guided',     prob: S.adaptiveProb,  show: ov.adaptiveOn   },
        { def: _ANN_DEFS[2], label: 'Optimized',  prob: S.optimizedProb, show: ov.fixedOn      },
        { def: _ANN_DEFS[3], label: 'Explorer',   prob: S.adjustedProb,  show: ov.manualOn     }
      ];

      var topY = Math.max(8, Math.min(tauSy - 60, h - 130));
      var gap = 12;
      stratDefs.forEach(function(sd) {
        var el = document.getElementById(sd.def.id);
        if (!el) return;
        if (!sd.show || sd.prob == null || !isFinite(sd.prob)) { el.style.display = 'none'; return; }
        var pPct = (sd.prob * 100).toFixed(2) + '%';
        var line1 = sd.label;
        var line2 = 'P = ' + pPct;
        if (sd.def.id !== 'saco-ann-base' && P0 != null && isFinite(P0)) {
          var dp = (sd.prob - P0) * 100;
          line2 += '   ΔP ' + (dp >= 0 ? '+' : '') + dp.toFixed(2) + '%';
        }
        el.innerHTML = '<span style="font-size:9px;letter-spacing:.05em;opacity:0.75;display:block;">' + line1 + '</span>' +
                       '<span style="display:block;">' + line2 + '</span>';
        el.style.top = topY + 'px';
        el.style.display = 'block';
        if (placeRight) { el.style.left = (tauSx + gap) + 'px'; el.style.right = ''; }
        else            { el.style.left = ''; el.style.right = (w - tauSx + gap) + 'px'; }
        topY += 32;
      });
    }

    function _startLoop() {
      if (_animId) return;
      function loop() {
        _animId = requestAnimationFrame(loop);
        if (_controls) _controls.update();
        if (_renderer && _scene && _camera) _renderer.render(_scene, _camera);
        _updateAnnotations();
      }
      loop();
    }

    // ── SCENE OBJECT MANAGEMENT ───────────────────────────────────────────────
    function _clearGroup(grp) {
      if (!grp || !_scene) return null;
      _scene.remove(grp);
      grp.traverse(function(o) {
        if (o.geometry) o.geometry.dispose();
        if (o.material) {
          (Array.isArray(o.material) ? o.material : [o.material]).forEach(function(m) {
            if (m.map) m.map.dispose();
            m.dispose();
          });
        }
      });
      return null;
    }

    // ── UPDATE RIBBONS ────────────────────────────────────────────────────────
    // basePdfN and curPdfN are already trapNorm-normalized on the same x-grid.
    // F0 and Fcur are passed in to drive the data-driven lift band.
    // nonPrimStrats: [{pdfN, prob, label, hex}] for non-primary active strategies.
    // sourceLabel: display name of the primary strategy (e.g. "Guided (Level 3)").
    function updateRibbons(basePdfN, curPdfN, tau, F0, Fcur, stratColorHex, nonPrimStrats, sourceLabel) {
      if (!_scene) return;
      _baseGroup = _clearGroup(_baseGroup);
      _curGroup  = _clearGroup(_curGroup);
      _tauGroup  = _clearGroup(_tauGroup);
      // Clear non-primary ghost ribbons from previous render
      for (var ogi = 0; ogi < _otherGroups.length; ogi++) { _clearGroup(_otherGroups[ogi]); }
      _otherGroups = [];
      if (!basePdfN || basePdfN.length < 2) return;

      // ── Coordinate transform ──────────────────────────────────────────────
      var xMin = basePdfN[0].x, xMax = basePdfN[basePdfN.length-1].x;
      var xRange = (xMax - xMin) || 1;
      var yMaxVal = 0.001;
      for (var pi = 0; pi < basePdfN.length; pi++)
        if (basePdfN[pi].y > yMaxVal) yMaxVal = basePdfN[pi].y;
      if (curPdfN) for (var pi2 = 0; pi2 < curPdfN.length; pi2++)
        if (curPdfN[pi2].y > yMaxVal) yMaxVal = curPdfN[pi2].y;
      // Include non-primary PDFs in yMaxVal so they're not clipped
      if (nonPrimStrats) nonPrimStrats.forEach(function(os) {
        if (os.pdfN) for (var pj = 0; pj < os.pdfN.length; pj++)
          if (os.pdfN[pj].y > yMaxVal) yMaxVal = os.pdfN[pj].y;
      });
      var xScale = 10 / xRange;
      var yScale = 3.2 / yMaxVal;
      var xMid   = (xMin + xMax) / 2;
      var yMax3  = yMaxVal * yScale; // scene-unit height
      _ribbonMeta = { xMid: xMid, xScale: xScale, yMax3: yMax3 };

      // ── Flat brand-color components for primary strategy ribbon ──────────
      var _sHex = stratColorHex != null ? stratColorHex : 0x3b82f6;
      var _sRc = ((_sHex >> 16) & 0xff) / 255;
      var _sGc = ((_sHex >>  8) & 0xff) / 255;
      var _sBc = ( _sHex        & 0xff) / 255;

      // ── Baseline reference mesh (very light — recedes behind strategy) ────
      _baseGroup = buildRibbonGroup(
        basePdfN, xScale, xMid, yScale, 0, D,
        function() { return { r: 0.70, g: 0.80, b: 0.92 }; },
        { uniformColor: 0xa8c4dc, opacity: 0.16, roughness: 0.60, metalness: 0.0,
          clearcoat: 0.05, ccRough: 0.50, edgeColor: 0x6090b8, edgeOpacity: 0.45 }
      );
      _scene.add(_baseGroup);

      // ── Primary strategy mesh: flat brand color, translucent ─────────────
      if (curPdfN) {
        _curGroup = buildRibbonGroup(
          curPdfN, xScale, xMid, yScale, 0, D,
          function() { return { r: _sRc, g: _sGc, b: _sBc }; },
          { opacity: 0.38, roughness: 0.35, metalness: 0.05,
            clearcoat: 0.40, ccRough: 0.22, edgeColor: _sHex, edgeOpacity: 0.80 }
        );
        _scene.add(_curGroup);
      }

      // ── Non-primary strategy meshes: same brand color, lighter overlay ────
      if (nonPrimStrats && nonPrimStrats.length > 0) {
        nonPrimStrats.forEach(function(os) {
          var hr = (os.hex >> 16) & 0xff, hg = (os.hex >> 8) & 0xff, hb = os.hex & 0xff;
          var osGrp = buildRibbonGroup(
            os.pdfN, xScale, xMid, yScale, 0, D,
            function() { return { r: hr / 255, g: hg / 255, b: hb / 255 }; },
            { opacity: 0.22, roughness: 0.48, metalness: 0.0,
              clearcoat: 0.08, ccRough: 0.40, edgeColor: os.hex, edgeOpacity: 0.55 }
          );
          _scene.add(osGrp);
          _otherGroups.push(osGrp);
        });
      }

      // ── Glass τ-plane with framed edges + lift band ───────────────────────
      if (tau != null && isFinite(tau)) {
        var xTau = (tau - xMid) * xScale;
        _tauGroup = new THREE.Group();

        // Glass panel (PlaneGeometry width=D, height=yMax3*1.18; rotated to face X-axis)
        var panH = yMax3 * 1.18;
        var pGeo = new THREE.PlaneGeometry(D, panH);
        var pMat = new THREE.MeshPhysicalMaterial({
          color: 0xffe0a0, transparent: true, opacity: 0.17,
          metalness: 0.0, roughness: 0.06, side: THREE.DoubleSide, depthWrite: false
        });
        var pMesh = new THREE.Mesh(pGeo, pMat);
        pMesh.rotation.y = Math.PI / 2;
        pMesh.position.set(xTau, panH / 2, D / 2);
        _tauGroup.add(pMesh);

        // Glowing amber frame using EdgesGeometry
        var eGeo = new THREE.EdgesGeometry(pGeo);
        var eMat = new THREE.LineBasicMaterial({ color: 0xffb040, transparent: true, opacity: 0.92 });
        var eLines = new THREE.LineSegments(eGeo, eMat);
        eLines.rotation.copy(pMesh.rotation);
        eLines.position.copy(pMesh.position);
        _tauGroup.add(eLines);

        // Ground cross-line
        _tauGroup.add(new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(xTau,0,0), new THREE.Vector3(xTau,0,D)]),
          new THREE.LineBasicMaterial({ color: 0xffb040, transparent: true, opacity: 0.55 })));

        // "τ" label sprite
        var tauUnits = (S.units || '');
        var tauLblTxt = '\u03c4 = ' + Number(tau).toFixed(1) + (tauUnits ? ' ' + tauUnits : '');
        var sp = makeTextSprite(tauLblTxt, { color:'rgba(255,200,80,0.98)', bold:true, size:18, w:200, h:48, sx:2.2, sy:0.52, bgColor:'rgba(30,20,5,0.78)' });
        sp.position.set(xTau, panH * 0.98, D / 2);
        _tauGroup.add(sp);

        // ── Data-driven lift band: shows F0 → F1 on the τ-plane ─────────
        if (F0 != null && Fcur != null && Math.abs(Fcur - F0) > 0.002) {
          var yF0  = F0  * yMax3;
          var yF1  = Fcur * yMax3;
          var yLo  = Math.min(yF0, yF1), yHi = Math.max(yF0, yF1);
          var dP   = Fcur - F0;
          var bCol = dP > 0 ? 0x38e080 : 0xff4466;

          // Outline of the band rectangle
          _tauGroup.add(new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(xTau,yLo,0),   new THREE.Vector3(xTau,yLo,D),
              new THREE.Vector3(xTau,yHi,D),   new THREE.Vector3(xTau,yHi,0),
              new THREE.Vector3(xTau,yLo,0)]),
            new THREE.LineBasicMaterial({ color: bCol, transparent: true, opacity: 0.90 })));

          // Translucent fill
          var bv = new Float32Array([
            xTau,yLo,0,  xTau,yLo,D,  xTau,yHi,0,
            xTau,yLo,D,  xTau,yHi,D,  xTau,yHi,0
          ]);
          var bGeo = new THREE.BufferGeometry();
          bGeo.setAttribute('position', new THREE.BufferAttribute(bv, 3));
          _tauGroup.add(new THREE.Mesh(bGeo,
            new THREE.MeshBasicMaterial({ color: bCol, transparent: true, opacity: 0.20,
              side: THREE.DoubleSide, depthWrite: false })));

          // ΔP label on the band
          var dpSp = makeTextSprite(
            '\u0394P ' + (dP > 0 ? '+' : '') + (dP*100).toFixed(2) + '%',
            { color: dP > 0 ? 'rgba(56,224,128,0.98)' : 'rgba(255,80,110,0.98)',
              bold: true, size: 18, w: 192, h: 48, sx: 1.9, sy: 0.48,
              bgColor: dP > 0 ? 'rgba(5,30,15,0.78)' : 'rgba(30,5,10,0.78)' });
          dpSp.position.set(xTau + 0.40, (yLo + yHi) / 2, D / 2);
          _tauGroup.add(dpSp);
        }

        // ── τ-surface markers: needle + dot on each ribbon at x=τ ────────────
        var _sCol = (stratColorHex != null) ? stratColorHex : 0x3b82f6;

        function hexColToRgba(hex, a) {
          var r = (hex >> 16) & 0xff, g = (hex >> 8) & 0xff, b = hex & 0xff;
          return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }

        function _addNeedle(x, yTop, zPos, hexCol, label, offsetX) {
          if (yTop < 0.01) return;
          // Thin cylinder rising from ground to ribbon surface
          var needle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.030, 0.030, yTop, 8),
            new THREE.MeshBasicMaterial({ color: hexCol, transparent: true, opacity: 0.82 })
          );
          needle.position.set(x, yTop / 2, zPos);
          _tauGroup.add(needle);
          // Glowing sphere at ribbon surface
          var dot = new THREE.Mesh(
            new THREE.SphereGeometry(0.12, 16, 16),
            new THREE.MeshBasicMaterial({ color: hexCol, transparent: true, opacity: 0.96 })
          );
          dot.position.set(x, yTop + 0.07, zPos);
          _tauGroup.add(dot);
          // Text label
          if (label) {
            var sp2 = makeTextSprite(label, {
              color: hexColToRgba(hexCol, 0.98), bold: true,
              size: 15, w: 160, h: 42, sx: 1.6, sy: 0.44,
              bgColor: 'rgba(10,12,20,0.75)'
            });
            sp2.position.set(x + offsetX, yTop + 0.34, zPos);
            _tauGroup.add(sp2);
          }
        }

        // Baseline needle (gray-blue, left-offset label)
        var yBaseAtTau = interpY(basePdfN, tau) * yScale;
        _addNeedle(xTau, yBaseAtTau, D / 2, 0x7090b8,
          F0 != null ? 'P\u2080 = ' + (F0 * 100).toFixed(1) + '%' : null,
          -0.65);

        // Primary strategy needle (matches strategy color, right-offset label)
        if (curPdfN) {
          var yCurAtTau = interpY(curPdfN, tau) * yScale;
          var _primShort = (sourceLabel || '').replace(/\s.*/, ''); // first word only
          _addNeedle(xTau, yCurAtTau, D / 2, _sCol,
            Fcur != null ? (_primShort ? _primShort + '\u202fP\u202f=\u202f' : 'P\u202f=\u202f') + (Fcur * 100).toFixed(1) + '%' : null,
            0.55);
        }

        // Non-primary strategy needles — z-staggered so labels don't overlap
        if (nonPrimStrats && nonPrimStrats.length > 0) {
          var _nps = nonPrimStrats.length;
          nonPrimStrats.forEach(function(os, idx) {
            // Spread z positions across the ribbon depth, away from center (D/2)
            var zOff = _nps === 1 ? D * 0.20
                     : D * (0.12 + idx * 0.76 / Math.max(1, _nps - 1));
            var yOsAtTau = interpY(os.pdfN, tau) * yScale;
            _addNeedle(xTau, yOsAtTau, zOff, os.hex,
              os.prob != null ? os.label + '\u202fP\u202f=\u202f' + (os.prob * 100).toFixed(1) + '%' : null,
              0.55);
          });
        }

        // ── Probability level markers on the τ-plane ──────────────────────────
        // Horizontal lines at y = P * yMax3 for each strategy, one per "plane".
        // Together with the vertical τ-plane they form a 3D (target, probability)
        // coordinate that visually answers "target = where? probability = how much?".
        function _addProbLine(yPl, col, labelTxt, xSide, zPos) {
          // Full-width horizontal line at height yPl spanning z=0..D
          _tauGroup.add(new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(xTau, yPl, 0),
              new THREE.Vector3(xTau, yPl, D)
            ]),
            new THREE.LineBasicMaterial({ color: col, transparent: true, opacity: 0.82 })
          ));
          // Small diamond dot at the z midpoint
          var dd = new THREE.Mesh(
            new THREE.SphereGeometry(0.07, 8, 8),
            new THREE.MeshBasicMaterial({ color: col, transparent: true, opacity: 0.95 })
          );
          dd.position.set(xTau, yPl, D / 2);
          _tauGroup.add(dd);
          // Label offset to the side of the τ-plane
          if (labelTxt) {
            var lSp = makeTextSprite(labelTxt, {
              color: hexColToRgba(col, 0.98), bold: true, size: 13, w: 156, h: 38,
              bgColor: 'rgba(10,12,20,0.75)'
            });
            lSp.position.set(xTau + xSide, yPl + 0.11, zPos);
            _tauGroup.add(lSp);
          }
        }

        // Baseline probability line (left side, gray-blue)
        if (F0 != null && isFinite(F0)) {
          _addProbLine(F0 * yMax3, 0x7090b8,
            'Base\u202f' + (F0 * 100).toFixed(1) + '%', -0.55, D / 2);
        }
        // Primary strategy probability line (right side, strategy color)
        if (Fcur != null && isFinite(Fcur) && curPdfN) {
          var _ps = (sourceLabel || '').replace(/\s.*/, '') || 'P';
          _addProbLine(Fcur * yMax3, _sCol,
            _ps + '\u202f' + (Fcur * 100).toFixed(1) + '%', 0.52, D / 2);
        }
        // Non-primary strategy probability lines (right side, staggered z label)
        if (nonPrimStrats && nonPrimStrats.length > 0) {
          nonPrimStrats.forEach(function(os, idx) {
            if (os.prob == null || !isFinite(os.prob)) return;
            var zLbl = nonPrimStrats.length === 1 ? D * 0.20
                     : D * (0.12 + idx * 0.76 / Math.max(1, nonPrimStrats.length - 1));
            _addProbLine(os.prob * yMax3, os.hex,
              os.label + '\u202f' + (os.prob * 100).toFixed(1) + '%', 0.52, zLbl);
          });
        }

        _scene.add(_tauGroup);
      }
    }

    // ── HEPTAGON RING (dark-theme variant) ────────────────────────────────────
    function updateHeptagon() {
      if (!_scene) return;
      _heptGroup = _clearGroup(_heptGroup);
      _heptGroup = new THREE.Group();
      var N = 7, R_MAX = 2.3, Y_RING = -0.60;
      var vals = SLIDER_KEYS.map(function(k, i) {
        var el = document.getElementById(SLIDER_IDS[i]);
        return el ? Math.max(0, Math.min(100, Number(el.value))) / 100 : 0;
      });
      var pts = vals.map(function(v, k) {
        var th = (2 * Math.PI * k / N) - Math.PI / 2;
        return new THREE.Vector3(R_MAX*v*Math.cos(th), Y_RING, R_MAX*v*Math.sin(th) + D/2);
      });
      var circPts = [];
      for (var ci = 0; ci <= 72; ci++) {
        var a = (2 * Math.PI * ci / 72) - Math.PI / 2;
        circPts.push(new THREE.Vector3(R_MAX*Math.cos(a), Y_RING, R_MAX*Math.sin(a) + D/2));
      }
      _heptGroup.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(circPts),
        new THREE.LineBasicMaterial({ color: 0x90a8c8, transparent: true, opacity: 0.55 })));
      var ctr = new THREE.Vector3(0, Y_RING, D/2);
      for (var k = 0; k < N; k++) {
        _heptGroup.add(new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([ctr.clone(), pts[k].clone()]),
          new THREE.LineBasicMaterial({ color: 0x8898b8, transparent: true, opacity: 0.45 })));
        _heptGroup.add(new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([pts[k].clone(), pts[(k+1)%N].clone()]),
          new THREE.LineBasicMaterial({ color: 0x6888b8, transparent: true, opacity: 0.65 })));
        var dot = new THREE.Mesh(
          new THREE.SphereGeometry(0.10, 10, 10),
          new THREE.MeshBasicMaterial({ color: SLIDER_COLORS[k] }));
        dot.position.copy(pts[k]);
        _heptGroup.add(dot);

        // Label sprite: name + value% at fixed outer ring position
        var th_k = (2 * Math.PI * k / N) - Math.PI / 2;
        var pct_k = Math.round(vals[k] * 100);
        var lspTxt = SLIDER_SHORT_LABELS[k] + '\n' + pct_k + '%';
        var lsp = makeTextSprite(SLIDER_SHORT_LABELS[k] + ' ' + pct_k + '%', {
          color: SLIDER_CSS_COLORS[k], bold: false, size: 11, w: 104, h: 30, sx: 1.6, sy: 0.44
        });
        var lR = R_MAX * 1.22;
        lsp.position.set(lR * Math.cos(th_k), Y_RING + 0.32, lR * Math.sin(th_k) + D / 2);
        _heptGroup.add(lsp);
      }
      var cDot = new THREE.Mesh(new THREE.SphereGeometry(0.07,8,8),
        new THREE.MeshBasicMaterial({ color: 0x6888b8 }));
      cDot.position.set(0, Y_RING, D/2);
      _heptGroup.add(cDot);
      _scene.add(_heptGroup);
    }

    // ── HUD (math unchanged) ──────────────────────────────────────────────────
    function updateHUD(F0, Fcur, basePdf, curPdf) {
      var M = window.PMCMath;
      var dP = (F0 != null && Fcur != null) ? Fcur - F0 : null;
      var intDelta = (basePdf && curPdf && M) ? M.integralDeltaF(basePdf, curPdf) : null;
      var f0El = document.getElementById('hudF0');
      var fEl  = document.getElementById('hudF');
      var dpEl = document.getElementById('hudDeltaP');
      var idEl = document.getElementById('hudIntDelta');
      if (f0El) f0El.textContent = fmtPct(F0);
      if (fEl)  fEl.textContent  = fmtPct(Fcur);
      if (dpEl) {
        dpEl.textContent = dP != null ? (dP >= 0 ? '+' : '') + fmtPct(dP) : '–';
        dpEl.style.color = dP != null ? (dP > 0.005 ? '#16A34A' : dP < -0.005 ? '#DC2626' : '#6B7280') : '#6B7280';
      }
      if (idEl) idEl.textContent = intDelta != null ? (intDelta >= 0 ? '+' : '') + intDelta.toFixed(4) : '–';
    }

    // ── MAIN RENDER (math unchanged) ──────────────────────────────────────────
    function render() {
      if (typeof THREE === 'undefined') return;
      var S = window.S;
      if (!S) return;
      var container = document.getElementById('saco3dContainer');
      if (!container) return;

      if (!_initialized) initThree(container);

      var cw = container.clientWidth, ch = container.clientHeight || 310;
      if (_renderer && (Math.abs(cw - _lastW) > 4 || Math.abs(ch - _lastH) > 4)) {
        _renderer.setSize(cw, ch);
        if (_camera) { _camera.aspect = cw / ch; _camera.updateProjectionMatrix(); }
        _lastW = cw; _lastH = ch;
      }
      if (!_scene) return;

      var M = window.PMCMath;

      // Group mode: baseline is the Monte Carlo aggregate PDF (S.aggPdf).
      // Single-task mode: baseline is the server-fetched S.basePdf.
      var _isGrp3d = window.TM && window.TM.mode === 'aggregate';

      // Use primaryMode (last-focused strategy) for 3D comparison; fall back to first active
      var rawBase = _isGrp3d
        ? (S.aggPdf && S.aggPdf.length > 1 ? S.aggPdf : null)
        : (S.basePdf && S.basePdf.length > 1 ? S.basePdf : null);
      var overlay = S.overlay || {};
      var pm3d = overlay.primaryMode;
      if (!pm3d) {
        if (overlay.adaptiveOn) pm3d = 'adaptive';
        else if (overlay.fixedOn) pm3d = 'fixed';
        else if (overlay.manualOn) pm3d = 'manual';
      }
      var rawCur = null, source = 'None';
      if (pm3d === 'adaptive' && overlay.adaptiveOn && S.optPdfAdaptive && S.optPdfAdaptive.length > 1) {
        rawCur = S.optPdfAdaptive; source = 'Conservative Optimization (Level ' + (overlay.probeLevel || 3) + ')';
      } else if (pm3d === 'fixed' && overlay.fixedOn && S.optPdfFixed && S.optPdfFixed.length > 1) {
        rawCur = S.optPdfFixed; source = 'Optimized';
      } else if (pm3d === 'manual' && overlay.manualOn && S.adjPdf && S.adjPdf.length > 1) {
        rawCur = S.adjPdf; source = 'Unconstrained Optimization';
      }

      // Normalize: clamp negatives, trapezoid-normalize so ∫ = 1
      var basePdfN = rawBase ? trapNorm(rawBase) : null;
      var curPdfN  = null;
      if (rawCur && rawCur.length > 1 && basePdfN) {
        var resampled = basePdfN.map(function(p) {
          return { x: p.x, y: Math.max(0, interpY(rawCur, p.x)) };
        });
        curPdfN = trapNorm(resampled);
      }

      // Compute F₀(τ), F₁(τ), ΔP on normalized distributions (math unchanged)
      var tau  = (S.target != null) ? Number(S.target) : null;
      var F0   = (basePdfN && tau != null && M) ? M.trapezoidalCDF(basePdfN, tau) : null;
      var Fcur = (curPdfN  && tau != null && M) ? M.trapezoidalCDF(curPdfN,  tau) : F0;

      // ── Non-primary active strategy PDFs for ghost ribbons + extra needles ─
      var nonPrimStrats = [];
      var _allStratDefs = [
        { mode: 'adaptive', rawPdf: S.optPdfAdaptive, prob: S.adaptiveProb,  label: 'Guided',    hex: 0x8b5cf6 },
        { mode: 'fixed',    rawPdf: S.optPdfFixed,    prob: S.optimizedProb, label: 'Optimized', hex: 0x3b82f6 },
        { mode: 'manual',   rawPdf: S.adjPdf,         prob: S.adjustedProb,  label: 'Explorer',  hex: 0x10b981 }
      ];
      _allStratDefs.forEach(function(sd) {
        if (sd.mode === pm3d) return;                               // skip — already in curPdfN
        if (!overlay[sd.mode + 'On']) return;                      // skip if not active
        if (!sd.rawPdf || sd.rawPdf.length < 2 || !basePdfN) return;
        var res = basePdfN.map(function(p) {
          return { x: p.x, y: Math.max(0, interpY(sd.rawPdf, p.x)) };
        });
        var pdfN = trapNorm(res);
        if (pdfN && pdfN.length > 1) {
          nonPrimStrats.push({ pdfN: pdfN, prob: sd.prob, label: sd.label, hex: sd.hex });
        }
      });

      updateHUD(F0, Fcur, basePdfN, curPdfN || basePdfN);
      var _stratHex = pm3d === 'adaptive' ? 0x8b5cf6 :
                      pm3d === 'fixed'    ? 0x3b82f6 :
                      pm3d === 'manual'   ? 0x10b981 : 0x3b82f6;
      updateRibbons(basePdfN, curPdfN, tau, F0, Fcur, _stratHex, nonPrimStrats, source);
      updateHeptagon();

      var stratEl = document.getElementById('saco3dStratLabel');
      if (stratEl) stratEl.textContent = (source !== 'None') ? 'Strategy: ' + source : 'Baseline only';

      // ── All-strategies chips row ─────────────────────────────────────────────
      var stratRow = document.getElementById('saco3dStratRow');
      var anyActive = overlay.adaptiveOn || overlay.fixedOn || overlay.manualOn;
      if (stratRow) stratRow.style.display = anyActive ? 'flex' : 'none';
      var P0base = S.baselineProb;
      function _setChip(id, label, prob, p0) {
        var el = document.getElementById(id);
        if (!el) return;
        if (prob != null && isFinite(prob)) {
          var dp = p0 != null ? (prob - p0) * 100 : null;
          el.textContent = label + '\u202f' + (prob * 100).toFixed(1) + '%' +
            (dp != null ? '\u202f(\u0394P\u202f' + (dp >= 0 ? '+' : '') + dp.toFixed(1) + '%)' : '');
          el.style.display = 'inline-block';
        } else { el.style.display = 'none'; }
      }
      _setChip('saco3dChipBase',      'Baseline',   P0base,           null);
      _setChip('saco3dChipGuided',    overlay.adaptiveOn ? 'Guided'    : null, overlay.adaptiveOn ? S.adaptiveProb  : null, P0base);
      _setChip('saco3dChipOptimized', overlay.fixedOn    ? 'Optimized' : null, overlay.fixedOn    ? S.optimizedProb : null, P0base);
      _setChip('saco3dChipExplorer',  overlay.manualOn   ? 'Explorer'  : null, overlay.manualOn   ? S.adjustedProb  : null, P0base);
      var baseChip = document.getElementById('saco3dChipBase');
      if (baseChip) baseChip.style.display = (anyActive && P0base != null) ? 'inline-block' : 'none';
    }

    // ── EVENT WIRING (unchanged) ──────────────────────────────────────────────
    function isOverlayActive() {
      var t = document.querySelector('.tab[data-tab="overlay"]');
      return !!(t && t.classList.contains('active'));
    }

    document.addEventListener('DOMContentLoaded', function() {
      ['pmc:baseline:ready', 'pmc:variant:ready'].forEach(function(evt) {
        window.addEventListener(evt, function() { if (isOverlayActive()) render(); });
      });

      var ts = document.getElementById('targetSlider');
      if (ts) ts.addEventListener('input', function() { if (isOverlayActive()) render(); });

      var _origSUIF = window.scheduleUIRefresh;
      window.scheduleUIRefresh = function() {
        if (_origSUIF) _origSUIF.apply(this, arguments);
        if (isOverlayActive()) setTimeout(render, 200);
      };

      var sliderInputs = ['s_budget_range','s_schedule_range','s_scopeCert_range',
                          's_scopeRed_range','s_rework_range','s_risk_range','s_userConf_range'];
      sliderInputs.forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.addEventListener('input', function() { if (isOverlayActive()) updateHeptagon(); });
      });
    });

    function setZoom(en) {
      _zoomEnabled = en; // store so it's applied if controls initialize later
      if (_controls) { _controls.enableZoom = en; _controls.enablePan = en; }
    }
    window.PMCSaco3D = { render: render, setZoom: setZoom };
  })();
  </script>

  <!-- =====================================================================
       PROBABILITY SPHERE — 3D Three.js glass sphere with liquid fill.
       Spherical cap formula: V(h) = π h²(3R−h)/3, V_sphere = (4/3)πR³
       Bisection solves h for a target probability P.
       Baseline fill = gray.  Strategy lift = colored (purple/blue/green).
       renderer.localClippingEnabled = true to clip fills at their h level.
       ===================================================================== -->
  <script>
  (function() {
    'use strict';

    // ── Module state ─────────────────────────────────────────────────────────
    var _sR = 1.65;          // scene-unit sphere radius (fixed)
    var _sRen = null, _sScn = null, _sCam = null, _sCtl = null;
    var _sLastW = 0, _sLastH = 0;
    var _sZoomEnabled = false; // pending zoom state — applied when controls are created
    var _sFillBase = null;
    var _sFills    = [];           // per-strategy fills [Guided=0, Optimized=1, Explorer=2]
    var _sAnim = null, _sInited = false;
    var _sCurH0 = 0, _sTgtH0 = 0;
    var _sFillCurH = [0, 0, 0];   // animated heights for each strategy fill
    var _sFillTgtH = [0, 0, 0];   // target heights
    var EASE_S = 0.09;
    // Waterline rings follow fill heights — no separate state needed
    var _sRings = [];              // THREE.LineLoop objects [Guided=0, Optimized=1, Explorer=2]
    var _sAnnDiv = null;           // annotation overlay div

    // Annotation style defs: baseline + 3 strategies
    var _sAnnDefs = [
      { id: 'sph-ann-base',  col: '#374151', bg: 'rgba(241,245,249,0.96)', brd: 'rgba(148,163,184,0.65)' },
      { id: 'sph-ann-g',     col: '#5b21b6', bg: 'rgba(139,92,246,0.13)',  brd: 'rgba(139,92,246,0.65)' },
      { id: 'sph-ann-o',     col: '#1e40af', bg: 'rgba(59,130,246,0.13)',  brd: 'rgba(59,130,246,0.65)' },
      { id: 'sph-ann-e',     col: '#065f46', bg: 'rgba(16,185,129,0.13)',  brd: 'rgba(16,185,129,0.65)' }
    ];

    // ── Math: spherical cap h → clip-plane y (sphere centered at origin) ────
    // h ∈ [0, 2R];  y = h - R  maps [0,2R] → [-R, R]
    function hToY(h) { return h - _sR; }

    // Bisection: solve V(h)/V_sphere = P for fill height h
    function probToH3(P) {
      P = Math.max(0, Math.min(1, P || 0));
      if (P === 0) return 0;
      if (P >= 1)  return 2 * _sR;
      var R = _sR;
      var Vt = (4 / 3) * Math.PI * R * R * R;
      var Vg = P * Vt;
      var lo = 0, hi = 2 * R;
      for (var i = 0; i < 52; i++) {
        var m = (lo + hi) / 2;
        var Vm = Math.PI * m * m * (3 * R - m) / 3;
        if (Vm < Vg) lo = m; else hi = m;
      }
      return (lo + hi) / 2;
    }

    // ── Sphere annotation overlay ────────────────────────────────────────────
    function _initSphereAnnotations(container) {
      var ex = container.querySelector('.sph-ann-ov'); if (ex) ex.remove();
      var div = document.createElement('div');
      div.className = 'sph-ann-ov';
      div.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;overflow:hidden;';
      // τ target chip — fixed top-right
      var tauEl = document.createElement('div');
      tauEl.id = 'sph-tau-label';
      tauEl.style.cssText = [
        'display:none;position:absolute;top:8px;right:8px;padding:3px 9px;border-radius:6px;',
        'font-size:10px;font-family:ui-monospace,monospace;font-weight:700;white-space:nowrap;',
        'background:rgba(255,251,235,0.96);color:#92400e;border:1px solid rgba(245,158,11,0.55);',
        'box-shadow:0 1px 5px rgba(0,0,0,0.12);backdrop-filter:blur(4px);'
      ].join('');
      div.appendChild(tauEl);
      // Per-strategy label chips
      _sAnnDefs.forEach(function(d) {
        var el = document.createElement('div');
        el.id = d.id;
        el.style.cssText = [
          'display:none;position:absolute;padding:3px 9px;border-radius:6px;',
          'font-size:10px;font-family:ui-monospace,monospace;font-weight:700;white-space:nowrap;',
          'background:' + d.bg + ';color:' + d.col + ';border:1px solid ' + d.brd + ';',
          'box-shadow:0 1px 6px rgba(0,0,0,0.13);backdrop-filter:blur(4px);'
        ].join('');
        div.appendChild(el);
      });
      container.style.position = 'relative';
      container.appendChild(div);
      _sAnnDiv = div;
    }

    function _updateSphereAnnotations() {
      if (!_sCam || !_sRen || !_sAnnDiv) return;
      var S = window.S; if (!S) return;
      var container = document.getElementById('sphereContainer');
      if (!container) return;
      var sw = container.clientWidth  || 360;
      var sh = container.clientHeight || 360;
      var ov = S.overlay || {};
      var P0 = S.baselineProb;

      // τ target label
      var tauEl = document.getElementById('sph-tau-label');
      if (tauEl) {
        var tau = (S.target != null) ? Number(S.target) : null;
        var units = (S.units || '');
        if (tau != null && isFinite(tau)) {
          tauEl.textContent = 'τ = ' + tau.toFixed(1) + (units ? '\u202f' + units : '');
          tauEl.style.display = 'block';
        } else {
          tauEl.style.display = 'none';
        }
      }

      // Per-strategy annotations: project waterline to 2D screen coords
      var stratDefs = [
        { id: 'sph-ann-base', label: 'Baseline',  prob: P0,             active: true,         fillIdx: -1 },
        { id: 'sph-ann-g',    label: 'Guided',     prob: S.adaptiveProb, active: !!ov.adaptiveOn, fillIdx: 0 },
        { id: 'sph-ann-o',    label: 'Optimized',  prob: S.optimizedProb,active: !!ov.fixedOn,    fillIdx: 1 },
        { id: 'sph-ann-e',    label: 'Explorer',   prob: S.adjustedProb, active: !!ov.manualOn,   fillIdx: 2 }
      ];

      var anyStrat = ov.adaptiveOn || ov.fixedOn || ov.manualOn;
      var usedY = []; // track used screen-y positions to prevent overlap

      stratDefs.forEach(function(sd) {
        var el = document.getElementById(sd.id);
        if (!el) return;
        // Hide baseline chip when no strategies active (stats already visible below)
        if (!sd.active || sd.prob == null || !isFinite(sd.prob) ||
            (sd.fillIdx === -1 && !anyStrat)) {
          el.style.display = 'none'; return;
        }

        // Get current animated fill height
        var fillH = sd.fillIdx === -1 ? _sCurH0 : _sFillCurH[sd.fillIdx];
        var ringY = hToY(fillH); // y in scene units: -sR (bottom) … +sR (top)

        // Project a front-facing point on the ring to 2D
        // Using slightly front+right of sphere for stable label placement
        var pt3 = new THREE.Vector3(_sR * 0.72, ringY, _sR * 0.70);
        pt3.project(_sCam);
        var sx = (pt3.x + 1) / 2 * sw;
        var sy = (-pt3.y + 1) / 2 * sh;

        // Clamp to visible area
        sx = Math.max(4, Math.min(sw - 150, sx));
        sy = Math.max(4, Math.min(sh - 24, sy));

        // Nudge to avoid overlap with labels at similar y
        for (var ui = 0; ui < usedY.length; ui++) {
          if (Math.abs(sy - usedY[ui]) < 24) sy = usedY[ui] + 25;
        }
        usedY.push(sy);

        // Build label text
        var pPct = (sd.prob * 100).toFixed(1) + '%';
        var txt = sd.label + '\u2009P=' + pPct;
        if (sd.fillIdx >= 0 && P0 != null && isFinite(P0)) {
          var dp = (sd.prob - P0) * 100;
          txt += '\u2002ΔP ' + (dp >= 0 ? '+' : '') + dp.toFixed(1) + '%';
        }

        el.textContent = txt;
        el.style.display = 'block';
        el.style.left = sx + 'px';
        el.style.top  = (sy - 10) + 'px';
      });
    }

    // ── Three.js scene init ──────────────────────────────────────────────────
    function initSphere(container) {
      if (_sInited) return;
      container.innerHTML = '';
      var w = container.clientWidth  || 220;
      var h = container.clientHeight || 220;

      _sScn = new THREE.Scene();
      _sScn.background = new THREE.Color(0xF0F4FA);

      _sCam = new THREE.PerspectiveCamera(36, w / h, 0.01, 50);
      _sCam.position.set(0, 0.6, 5.6);
      _sCam.lookAt(0, 0, 0);

      _sRen = new THREE.WebGLRenderer({ antialias: true });
      _sRen.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      _sRen.setSize(w, h);
      _sRen.localClippingEnabled = true;    // required for per-material clip planes
      _sRen.domElement.style.cssText = 'display:block;width:100%;height:100%;';
      container.appendChild(_sRen.domElement);

      // ── Lighting (tuned for light background) ────────────────────────────
      _sScn.add(new THREE.AmbientLight(0xdce8f8, 0.50));
      var kl = new THREE.DirectionalLight(0xfff8e8, 0.80);
      kl.position.set(3, 5, 5); _sScn.add(kl);
      var fl = new THREE.DirectionalLight(0xc0d4ff, 0.35);
      fl.position.set(-3, 2, -3); _sScn.add(fl);
      var rl = new THREE.DirectionalLight(0x8090c8, 0.22);
      rl.position.set(0, 3, -6); _sScn.add(rl);

      // ── Glass outer sphere ───────────────────────────────────────────────
      var sGeo = new THREE.SphereGeometry(_sR, 48, 48);
      _sScn.add(new THREE.Mesh(sGeo, new THREE.MeshPhysicalMaterial({
        color: 0x90b8e0, transparent: true, opacity: 0.18,
        roughness: 0.05, metalness: 0.0, clearcoat: 1.0, clearcoatRoughness: 0.08,
        side: THREE.FrontSide, depthWrite: false
      })));
      _sScn.add(new THREE.Mesh(new THREE.SphereGeometry(_sR * 0.998, 48, 48),
        new THREE.MeshPhysicalMaterial({
          color: 0x7090b8, transparent: true, opacity: 0.06,
          roughness: 0.05, metalness: 0.0, side: THREE.BackSide, depthWrite: false
        })));

      // ── Baseline fill (gray) — clipped at y ≤ hToY(_sCurH0) ────────────
      _sFillBase = new THREE.Mesh(
        new THREE.SphereGeometry(_sR * 0.992, 40, 40),
        new THREE.MeshStandardMaterial({
          color: 0x8898b8, transparent: true, opacity: 0.65,
          roughness: 0.60, metalness: 0.05,
          clippingPlanes: [new THREE.Plane(new THREE.Vector3(0, -1, 0), -_sR)],
          side: THREE.FrontSide
        })
      );
      _sScn.add(_sFillBase);

      // ── Per-strategy fills — distinct radii, invisible until strategy active ─
      // Conservative=purple 0.984R, General=blue 0.974R, Unconstrained=green 0.964R
      var _fillDefs = [
        { col: 0x8b5cf6, r: _sR * 0.984 },
        { col: 0x3b82f6, r: _sR * 0.974 },
        { col: 0x10b981, r: _sR * 0.964 }
      ];
      _fillDefs.forEach(function(fd) {
        var f = new THREE.Mesh(
          new THREE.SphereGeometry(fd.r, 40, 40),
          new THREE.MeshStandardMaterial({
            color: fd.col, transparent: true, opacity: 0,
            roughness: 0.28, metalness: 0.10, depthWrite: false,
            clippingPlanes: [new THREE.Plane(new THREE.Vector3(0, -1, 0), -_sR)],
            side: THREE.FrontSide
          })
        );
        _sScn.add(f);
        _sFills.push(f);
      });

      // ── Globe lines (equator + 3 meridians) ─────────────────────────────
      var eqPts = [];
      for (var i = 0; i <= 72; i++) {
        var a = 2 * Math.PI * i / 72;
        eqPts.push(new THREE.Vector3(_sR * Math.cos(a), 0, _sR * Math.sin(a)));
      }
      _sScn.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(eqPts),
        new THREE.LineBasicMaterial({ color: 0x7090b8, transparent: true, opacity: 0.50 })
      ));
      [0, Math.PI / 2.5, Math.PI / 1.25].forEach(function(ay) {
        var mPts = [];
        for (var j = 0; j <= 48; j++) {
          var b = 2 * Math.PI * j / 48;
          mPts.push(new THREE.Vector3(
            _sR * Math.sin(b) * Math.cos(ay),
            _sR * Math.cos(b),
            _sR * Math.sin(b) * Math.sin(ay)
          ));
        }
        _sScn.add(new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(mPts),
          new THREE.LineBasicMaterial({ color: 0x9ab0cc, transparent: true, opacity: 0.35 })
        ));
      });

      // ── Probability waterline rings (one per strategy) ───────────────────
      // Unit-circle LineLoops scaled each frame to the correct sphere-slice radius.
      // Color order: Guided=purple, Optimized=blue, Explorer=green
      var _ringCols = [0x8b5cf6, 0x3b82f6, 0x10b981];
      var _ringCircPts = [];
      for (var ri = 0; ri <= 80; ri++) {
        var ra = 2 * Math.PI * ri / 80;
        _ringCircPts.push(new THREE.Vector3(Math.cos(ra), 0, Math.sin(ra)));
      }
      _ringCols.forEach(function(col) {
        var ring = new THREE.LineLoop(
          new THREE.BufferGeometry().setFromPoints(_ringCircPts),
          new THREE.LineBasicMaterial({ color: col, transparent: true, opacity: 0.90 })
        );
        ring.visible = false;
        _sScn.add(ring);
        _sRings.push(ring);
      });

      // ── OrbitControls ────────────────────────────────────────────────────
      if (typeof THREE.OrbitControls !== 'undefined') {
        _sCtl = new THREE.OrbitControls(_sCam, _sRen.domElement);
        _sCtl.enableDamping = true; _sCtl.dampingFactor = 0.08;
        _sCtl.minDistance = 3; _sCtl.maxDistance = 12;
        _sCtl.target.set(0, 0, 0);
        _sCtl.autoRotate = true; _sCtl.autoRotateSpeed = 0.55;
        // Zoom/pan disabled by default; enabled when user clicks "Zoom" button
        _sCtl.enableZoom = _sZoomEnabled;
        _sCtl.enablePan  = _sZoomEnabled;
        _sCtl.update();
      }

      _initSphereAnnotations(container);
      _sInited = true;
      _startSphereLoop();
    }

    function _startSphereLoop() {
      if (_sAnim) return;
      function loop() {
        _sAnim = requestAnimationFrame(loop);
        // Ease baseline fill height
        _sCurH0 += (_sTgtH0 - _sCurH0) * EASE_S;
        if (_sFillBase && _sFillBase.material.clippingPlanes[0])
          _sFillBase.material.clippingPlanes[0].constant = hToY(_sCurH0);
        // Ease per-strategy fill heights + update their clip planes
        for (var _fi = 0; _fi < _sFills.length; _fi++) {
          _sFillCurH[_fi] += (_sFillTgtH[_fi] - _sFillCurH[_fi]) * EASE_S;
          if (_sFills[_fi] && _sFills[_fi].material.clippingPlanes[0])
            _sFills[_fi].material.clippingPlanes[0].constant = hToY(_sFillCurH[_fi]);
        }
        // Waterline rings track their fill's current height
        for (var _ri = 0; _ri < _sRings.length; _ri++) {
          if (!_sRings[_ri].visible) continue;
          var _ry = hToY(_sFillCurH[_ri]);
          var _rr = Math.sqrt(Math.max(0.001, _sR * _sR - _ry * _ry));
          _sRings[_ri].position.y = _ry;
          _sRings[_ri].scale.set(_rr, 1, _rr);
        }
        if (_sCtl) _sCtl.update();
        if (_sRen && _sScn && _sCam) _sRen.render(_sScn, _sCam);
        _updateSphereAnnotations();
      }
      loop();
    }

    // ── Public render: called whenever state changes ─────────────────────────
    function render() {
      if (typeof THREE === 'undefined') return;
      var S = window.S; if (!S) return;
      var container = document.getElementById('sphereContainer');
      if (!container) return;
      if (!_sInited) initSphere(container);

      // Resize renderer if container dimensions changed
      var sw = container.clientWidth || 360, sh = container.clientHeight || 360;
      if (_sRen && (Math.abs(sw - _sLastW) > 4 || Math.abs(sh - _sLastH) > 4)) {
        _sRen.setSize(sw, sh);
        if (_sCam) { _sCam.aspect = sw / sh; _sCam.updateProjectionMatrix(); }
        _sLastW = sw; _sLastH = sh;
      }

      var P0   = S.baselineProb || 0;
      var ov   = S.overlay || {};
      // Use primaryMode (last-focused strategy) for sphere; fall back to first active
      var pmSph = ov.primaryMode;
      if (!pmSph) {
        if (ov.adaptiveOn) pmSph = 'adaptive';
        else if (ov.fixedOn) pmSph = 'fixed';
        else if (ov.manualOn) pmSph = 'manual';
      }
      var Pcur = pmSph === 'adaptive' && ov.adaptiveOn ? (S.adaptiveProb  || P0)
               : pmSph === 'fixed'    && ov.fixedOn    ? (S.optimizedProb || P0)
               : pmSph === 'manual'   && ov.manualOn   ? (S.adjustedProb  || P0) : P0;

      _sTgtH0 = probToH3(P0);

      // ── Per-strategy fills: opacity + clip target for each active strategy ─
      var _stratProbs = [S.adaptiveProb,  S.optimizedProb, S.adjustedProb ];
      var _stratOn    = [ov.adaptiveOn,   ov.fixedOn,      ov.manualOn    ];
      for (var _sfi = 0; _sfi < _sFills.length; _sfi++) {
        if (!_sFills[_sfi]) continue;
        var _sfOn = !!(_stratOn[_sfi] && _stratProbs[_sfi] != null && isFinite(_stratProbs[_sfi]));
        _sFills[_sfi].material.opacity = _sfOn ? 0.62 : 0;
        _sFillTgtH[_sfi] = _sfOn ? probToH3(_stratProbs[_sfi]) : _sFillCurH[_sfi];
        // Ring visibility mirrors fill visibility
        if (_sRings[_sfi]) _sRings[_sfi].visible = _sfOn;
      }

      // ── HUD ──────────────────────────────────────────────────────────────
      var dP    = Pcur - P0;
      var p0El  = document.getElementById('sphereP0');
      var pEl   = document.getElementById('sphereP');
      var dpEl  = document.getElementById('sphereDeltaP');
      var stEl  = document.getElementById('sphereStratLabel');
      if (p0El) p0El.textContent = (P0   * 100).toFixed(2) + '%';
      if (pEl)  pEl.textContent  = (Pcur * 100).toFixed(2) + '%';
      if (dpEl) {
        dpEl.textContent = (dP >= 0 ? '+' : '') + (dP * 100).toFixed(2) + '%';
        dpEl.style.color = dP > 0.005 ? '#16A34A' : dP < -0.005 ? '#DC2626' : '#6B7280';
      }
      if (stEl) {
        stEl.textContent = pmSph === 'adaptive' && ov.adaptiveOn ? 'Conservative Optimization (Level ' + (ov.probeLevel || 3) + ')' :
                           pmSph === 'fixed'    && ov.fixedOn    ? 'General Optimization' :
                           pmSph === 'manual'   && ov.manualOn   ? 'Unconstrained Optimization' : 'Baseline';
      }
      if (window.PMCMath && typeof window.PMCMath.validateLift === 'function')
        window.PMCMath.validateLift(P0, Pcur, dP);

      // ── All-strategies row ────────────────────────────────────────────────
      var sphRow  = document.getElementById('sphereStratRow');
      var anyAct  = ov.adaptiveOn || ov.fixedOn || ov.manualOn;
      if (sphRow) sphRow.style.display = anyAct ? 'flex' : 'none';
      function _setSphChip(id, label, prob, p0base) {
        var el = document.getElementById(id);
        if (!el) return;
        if (label && prob != null && isFinite(prob)) {
          var dp2 = p0base != null ? (prob - p0base) * 100 : null;
          el.textContent = label + '\u202f' + (prob * 100).toFixed(1) + '%' +
            (dp2 != null ? '\u202f(\u0394P\u202f' + (dp2 >= 0 ? '+' : '') + dp2.toFixed(1) + '%)' : '');
          el.style.display = 'inline-block';
        } else { el.style.display = 'none'; }
      }
      var sphP0 = S.baselineProb;
      _setSphChip('sphChipBase',      anyAct ? 'Baseline' : null,   sphP0,              null);
      _setSphChip('sphChipGuided',    ov.adaptiveOn ? 'Guided'    : null, ov.adaptiveOn ? S.adaptiveProb  : null, sphP0);
      _setSphChip('sphChipOptimized', ov.fixedOn    ? 'Optimized' : null, ov.fixedOn    ? S.optimizedProb : null, sphP0);
      _setSphChip('sphChipExplorer',  ov.manualOn   ? 'Explorer'  : null, ov.manualOn   ? S.adjustedProb  : null, sphP0);
    }

    function _setSphereZoom(en) {
      _sZoomEnabled = en; // store so it's applied if controls initialize later
      if (_sCtl) { _sCtl.enableZoom = en; _sCtl.enablePan = en; }
    }
    window.PMCSphere = { render: render, setZoom: _setSphereZoom };

    document.addEventListener('DOMContentLoaded', function() {

      function isOverlayActive() {
        var t = document.querySelector('.tab[data-tab="overlay"]');
        return !!(t && t.classList.contains('active'));
      }
      window.addEventListener('pmc:baseline:ready',  function() { if (isOverlayActive()) render(); });
      window.addEventListener('pmc:variant:ready',   function() { if (isOverlayActive()) render(); });

      var ts = document.getElementById('targetSlider');
      if (ts) ts.addEventListener('input', function() { if (isOverlayActive()) render(); });

      // Chain onto the SACO3D-patched scheduleUIRefresh
      var _prevSUIF = window.scheduleUIRefresh;
      window.scheduleUIRefresh = function() {
        if (_prevSUIF) _prevSUIF.apply(this, arguments);
        if (isOverlayActive()) setTimeout(render, 220);
      };
    });
  })();
  </script>

<!-- ================================================================
     TASK MANAGER MODALS
================================================================ -->

<!-- ── First-Run Setup Modal ── -->
<div class="tm-modal-backdrop" id="tmFirstRunBackdrop">
  <div class="tm-modal" id="tmFirstRunModal">
    <h2>&#128197; Set Up Task Manager</h2>
    <p style="font-size:12px;color:var(--muted);margin:0 0 12px;">
      PMC Task Manager needs a dedicated sheet tab to store your tasks. How would you like to get started?
    </p>
    <div class="choice-cards">
      <div class="choice-card selected" id="frChoiceCreate" onclick="TM._frSelect('create')">
        <div class="ch-icon">&#10133;</div>
        <div class="ch-title">Create New Tab</div>
        <div class="ch-desc">A new "PMC Tasks" tab will be created in this spreadsheet.</div>
      </div>
      <div class="choice-card" id="frChoiceImport" onclick="TM._frSelect('import')">
        <div class="ch-icon">&#128194;</div>
        <div class="ch-title">Import Existing Tab</div>
        <div class="ch-desc">Map columns from an existing sheet tab to import your data.</div>
      </div>
    </div>

    <!-- Create tab sub-section -->
    <div id="frCreateSection">
      <div class="tm-field">
        <label>Tab name</label>
        <input type="text" id="frTabName" value="PMC Tasks" maxlength="50" />
        <span class="tm-hint">You can rename it later in Settings.</span>
      </div>
    </div>

    <!-- Import existing tab sub-section (hidden initially) -->
    <div id="frImportSection" style="display:none;">
      <p style="font-size:12px;color:var(--muted);margin:0 0 8px;">Select the sheet tab that contains your task data:</p>
      <div id="tmTabList"></div>
      <div id="frImportStatus" style="font-size:11px;color:var(--muted);margin-top:6px;"></div>
    </div>

    <div class="tm-modal-footer">
      <button class="tm-btn-primary" id="frProceedBtn" onclick="TM._frProceed()">Continue</button>
    </div>
    <div class="tm-loading-overlay" id="frLoading">
      <div class="tm-loading-spinner"></div>
      <div class="tm-loading-msg" id="frLoadingMsg">Setting up…</div>
    </div>
  </div>
</div>

<!-- ── Task Manager Panel Modal ── -->
<div class="tm-modal-backdrop" id="tmManagerBackdrop" onclick="TM._backdropClose(event,'tmManagerBackdrop')">
  <div class="tm-modal wide" id="tmManagerModal">
    <button class="tm-modal-close" onclick="TM.closeManager()" title="Close">&times;</button>
    <h2>&#9998; Task Manager</h2>

    <!-- Manager toolbar -->
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:10px;">
      <button class="tm-btn-primary" style="font-size:12px;padding:5px 12px;" onclick="TM.openTaskForm(null)">+ Add Task</button>
      <button class="tm-btn-secondary" style="font-size:12px;padding:5px 12px;" onclick="TM.openCSVImport()">Import CSV</button>
      <button class="tm-btn-secondary" style="font-size:12px;padding:5px 12px;" onclick="TM.openSheetImport()">From Sheet Tab</button>
      <span id="mgrDirtyNote" style="display:none;font-size:11px;color:#92400E;background:#FEF9C3;border:1px solid #FDE68A;border-radius:5px;padding:2px 8px;font-weight:700;margin-left:auto;">&#9679; Unsaved changes</span>
    </div>

    <!-- Task list -->
    <div class="tm-task-list" id="tmTaskListContainer">
      <div class="tm-empty-state">
        <div class="em-icon">&#128203;</div>
        <div>No tasks yet. Click <strong>+ Add Task</strong> to get started.</div>
      </div>
    </div>

    <div class="tm-modal-footer">
      <button class="tm-btn-secondary" onclick="TM.closeManager()">Close</button>
      <button class="tm-btn-danger-outline" id="mgrDiscardBtn" style="display:none;" onclick="TM.discard();TM.closeManager()">Discard Changes</button>
      <button class="tm-btn-primary" id="mgrSaveRunBtn" onclick="TM.closeManager();TM.saveAndRun()">Save &amp; Run</button>
    </div>
    <div class="tm-loading-overlay" id="mgrLoading">
      <div class="tm-loading-spinner"></div>
      <div class="tm-loading-msg" id="mgrLoadingMsg">Saving &amp; running simulation…</div>
    </div>
  </div>
</div>

<!-- ── Add / Edit Task Form Modal ── -->
<div class="tm-modal-backdrop" id="tmTaskFormBackdrop">
  <div class="tm-modal" id="tmTaskFormModal">
    <button class="tm-modal-close" onclick="TM.closeTaskForm()" title="Close">&times;</button>
    <h2 id="tmTaskFormTitle">Add Task</h2>

    <div class="tm-full-field">
      <label for="tfName">Task Name <span style="color:#DC2626;">*</span></label>
      <div class="tm-field" id="tfNameField">
        <input type="text" id="tfName" placeholder="e.g. Design Phase" maxlength="100" oninput="TM._tfValidateName()" />
        <span class="field-error" id="tfNameErr" style="display:none;"></span>
      </div>
    </div>

    <div class="tm-field-row">
      <div class="tm-field" id="tfBestField">
        <label for="tfBest">Best Case <span style="color:#DC2626;">*</span></label>
        <input type="number" id="tfBest" placeholder="Optimistic" step="any" oninput="TM._tfValidateTriangle()" onblur="TM._tfAutocorrect()" />
        <span class="field-error" id="tfBestErr" style="display:none;"></span>
      </div>
      <div class="tm-field" id="tfMostField">
        <label for="tfMost">Most Likely <span style="color:#DC2626;">*</span></label>
        <input type="number" id="tfMost" placeholder="Expected" step="any" oninput="TM._tfValidateTriangle()" onblur="TM._tfAutocorrect()" />
        <span class="field-error" id="tfMostErr" style="display:none;"></span>
      </div>
      <div class="tm-field" id="tfWorstField">
        <label for="tfWorst">Worst Case <span style="color:#DC2626;">*</span></label>
        <input type="number" id="tfWorst" placeholder="Pessimistic" step="any" oninput="TM._tfValidateTriangle()" onblur="TM._tfAutocorrect()" />
        <span class="field-error" id="tfWorstErr" style="display:none;"></span>
      </div>
    </div>

    <div id="tfTriangleWrap">
      <canvas id="tmTriPreview"></canvas>
      <div class="tm-preview-labels">
        <span id="triLblBest">Best</span>
        <span id="triLblMost">Most Likely</span>
        <span id="triLblWorst">Worst</span>
      </div>
    </div>

    <div class="tm-field-row" style="margin-top:10px;">
      <div class="tm-field" style="max-width:120px;">
        <label for="tfWeight">Risk Weight</label>
        <input type="number" id="tfWeight" placeholder="1.0" min="0" max="10" step="0.1" />
        <span class="tm-hint">0–10, used in Aggregate mode</span>
      </div>
      <div class="tm-field" style="max-width:80px;">
        <label>Active</label>
        <div style="display:flex;align-items:center;gap:6px;padding-top:8px;">
          <input type="checkbox" id="tfActive" checked style="width:16px;height:16px;accent-color:#111827;" />
          <label for="tfActive" style="font-size:12px;color:var(--fg);font-weight:400;">Include</label>
        </div>
      </div>
    </div>

    <div class="tm-full-field" style="margin-top:6px;">
      <label for="tfNotes">Notes (optional)</label>
      <textarea id="tfNotes" rows="2" placeholder="Any additional context…" style="width:100%;padding:7px 9px;border:1.5px solid var(--line);border-radius:8px;font-size:13px;font-family:inherit;resize:vertical;"></textarea>
    </div>

    <div id="tfAutocorrectNote" style="display:none;" class="tm-info">
      &#9998; Values were re-ordered so that Best ≤ Most Likely ≤ Worst.
    </div>

    <div class="tm-modal-footer">
      <button class="tm-btn-secondary" onclick="TM.closeTaskForm()">Cancel</button>
      <button class="tm-btn-primary" id="tfSaveBtn" onclick="TM._tfSave()">Add Task</button>
    </div>
  </div>
</div>

<!-- ── CSV Import Modal ── -->
<div class="tm-modal-backdrop" id="tmCSVBackdrop" onclick="TM._backdropClose(event,'tmCSVBackdrop')">
  <div class="tm-modal wide" id="tmCSVModal">
    <button class="tm-modal-close" onclick="TM.closeCSVImport()" title="Close">&times;</button>
    <h2>&#128196; Import from CSV</h2>

    <div id="csvStep1">
      <p style="font-size:12px;color:var(--muted);margin:0 0 10px;">
        Your CSV should have columns: <strong>Task Name, Best Case, Most Likely, Worst Case</strong>.
        Optional: Risk Weight, Active, Notes.
      </p>
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
        <input type="file" id="csvFileInput" accept=".csv,.txt" onchange="TM._csvFileChosen(this)" style="font-size:12px;" />
      </div>
      <div id="csvParseStatus" style="font-size:11px;color:var(--muted);"></div>
    </div>

    <div id="csvStep2" style="display:none;">
      <div id="csvWarnings"></div>
      <div id="csvSummary" style="font-size:12px;margin-bottom:8px;"></div>
      <div class="tm-csv-table-wrap">
        <table class="tm-csv-table" id="csvPreviewTable">
          <thead>
            <tr>
              <th>Status</th><th>Task Name</th><th>Best</th><th>Most Likely</th><th>Worst</th><th>Weight</th><th>Note</th>
            </tr>
          </thead>
          <tbody id="csvPreviewBody"></tbody>
        </table>
      </div>
    </div>

    <div class="tm-modal-footer">
      <button class="tm-btn-secondary" onclick="TM.closeCSVImport()">Cancel</button>
      <button class="tm-btn-primary" id="csvImportBtn" style="display:none;" onclick="TM._csvCommit()">Import Valid Rows</button>
    </div>
    <div class="tm-loading-overlay" id="csvLoading">
      <div class="tm-loading-spinner"></div>
      <div class="tm-loading-msg">Parsing…</div>
    </div>
  </div>
</div>

<!-- ── Sheet Tab Import → Column Mapper Modal ── -->
<div class="tm-modal-backdrop" id="tmColMapBackdrop" onclick="TM._backdropClose(event,'tmColMapBackdrop')">
  <div class="tm-modal wide" id="tmColMapModal">
    <button class="tm-modal-close" onclick="TM.closeColMap()" title="Close">&times;</button>
    <h2>&#128203; Import from Sheet Tab</h2>

    <div id="cmStep1">
      <p style="font-size:12px;color:var(--muted);margin:0 0 8px;">
        Select a sheet tab to import tasks from:
      </p>
      <div id="cmTabList" class="tm-tab-list" style="border:1px solid var(--line);border-radius:8px;max-height:180px;overflow-y:auto;"></div>
      <div id="cmTabStatus" style="font-size:11px;color:var(--muted);margin-top:6px;"></div>
    </div>

    <div id="cmStep2" style="display:none;">
      <p style="font-size:12px;color:var(--muted);margin:0 0 8px;">
        Map the columns from <strong id="cmSelectedTabName"></strong> to PMC fields:
      </p>
      <div class="tm-col-map-grid" id="cmMappingGrid"></div>
      <div id="cmMapStatus" style="font-size:11px;color:var(--muted);margin-top:6px;"></div>
    </div>

    <div id="cmStep3" style="display:none;">
      <div id="cmImportWarnings"></div>
      <div id="cmImportSummary" style="font-size:12px;margin-bottom:8px;"></div>
    </div>

    <div class="tm-modal-footer">
      <button class="tm-btn-secondary" id="cmBackBtn" style="display:none;" onclick="TM._cmBack()">Back</button>
      <button class="tm-btn-secondary" onclick="TM.closeColMap()">Cancel</button>
      <button class="tm-btn-primary" id="cmNextBtn" onclick="TM._cmNext()">Next</button>
    </div>
    <div class="tm-loading-overlay" id="cmLoading">
      <div class="tm-loading-spinner"></div>
      <div class="tm-loading-msg" id="cmLoadingMsg">Loading…</div>
    </div>
  </div>
</div>

<!-- ── Settings Modal ── -->
<div class="tm-modal-backdrop" id="tmSettingsBackdrop" onclick="TM._backdropClose(event,'tmSettingsBackdrop')">
  <div class="tm-modal" id="tmSettingsModal">
    <button class="tm-modal-close" onclick="TM.closeSettings()" title="Close">&times;</button>
    <h2>&#9881; Task Manager Settings</h2>

    <div class="settings-group">
      <label>Sheet tab name</label>
      <input type="text" id="stTabName" value="PMC Tasks" maxlength="50" />
      <span class="tm-hint">Rename the dedicated PMC Tasks tab.</span>
    </div>

    <div class="settings-group">
      <label>Units label</label>
      <select id="stUnits">
        <option value="days">Days</option>
        <option value="hours">Hours</option>
        <option value="weeks">Weeks</option>
        <option value="story_points">Story Points</option>
        <option value="cost_usd">Cost (USD)</option>
        <option value="custom">Custom</option>
      </select>
    </div>

    <div class="settings-group" id="stCustomUnitsGroup" style="display:none;">
      <label>Custom unit label</label>
      <input type="text" id="stCustomUnits" placeholder="e.g. Sprints" maxlength="30" />
    </div>

    <div class="tm-modal-footer">
      <button class="tm-btn-secondary" onclick="TM.closeSettings()">Cancel</button>
      <button class="tm-btn-primary" onclick="TM._saveSettings()">Save Settings</button>
    </div>
  </div>
</div>

<!-- ── Generic Confirmation Modal ── -->
<div class="tm-modal-backdrop" id="tmConfirmBackdrop">
  <div class="tm-modal" style="max-width:380px;" id="tmConfirmModal">
    <h2 id="confirmTitle">Confirm</h2>
    <p id="confirmMessage" style="font-size:13px;color:var(--muted);margin:0 0 4px;"></p>
    <div class="tm-modal-footer">
      <button class="tm-btn-secondary" id="confirmCancelBtn" onclick="TM._confirmClose(false)">Cancel</button>
      <button class="tm-btn-danger-outline" id="confirmOkBtn" onclick="TM._confirmClose(true)">Delete</button>
    </div>
  </div>
</div>

<!-- ================================================================
     TASK MANAGER JAVASCRIPT
================================================================ -->
<script>
(function() {
'use strict';

/* ────────────────────────────────────────────────────────────────
   Analytical distribution helpers (client-side, no server call)
   Used to compute Triangle and Beta-PERT series from O/M/P,
   including in Group mode where groupO/M/P serve as parameters.
──────────────────────────────────────────────────────────────── */

/** Triangle distribution PDF + CDF from 3-point estimate (a=O, c=M, b=P). */
function computeTriDist_(O, M, P, n) {
  n = n || 120;
  var a = O, c = M, b = P, range = b - a;
  if (range <= 0 || c < a || c > b) return { pdf: [], cdf: [] };
  var pdf = [], cdf = [];
  for (var i = 0; i <= n; i++) {
    var x = a + range * i / n;
    var f, F;
    if (x <= c) {
      f = (c > a) ? 2 * (x - a) / (range * (c - a)) : 0;
      F = (c > a) ? Math.pow(x - a, 2) / (range * (c - a)) : 0;
    } else {
      f = (c < b) ? 2 * (b - x) / (range * (b - c)) : 0;
      F = (c < b) ? 1 - Math.pow(b - x, 2) / (range * (b - c)) : 1;
    }
    pdf.push({ x: x, y: Math.max(0, f) });
    cdf.push({ x: x, y: Math.min(1, Math.max(0, F)) });
  }
  return { pdf: pdf, cdf: cdf };
}

/**
 * Beta-PERT distribution PDF + CDF from 3-point estimate.
 * mu = (O + 4M + P)/6  →  alpha = 6(mu-O)/(P-O), beta = 6(P-mu)/(P-O)
 * Distribution is Beta(alpha,beta) scaled to [O, P].
 * Computed numerically (trapezoidal integration) — no special functions needed.
 */
function computeBetaPertDist_(O, M, P, n) {
  n = n || 120;
  var a = O, c = M, b = P, range = b - a;
  if (range <= 0 || c < a || c > b) return { pdf: [], cdf: [] };
  var mu = (a + 4 * c + b) / 6;
  var al = 6 * (mu - a) / range;
  var be = 6 * (b - mu) / range;
  var dx = range / n;

  // Sample unnormalized kernel at each point using log to avoid underflow
  var kernel = [];
  for (var i = 0; i <= n; i++) {
    var x = a + range * i / n;
    var t = (x - a) / range;   // normalized t in [0,1]
    var k = (t > 0 && t < 1)
      ? Math.exp((al - 1) * Math.log(t) + (be - 1) * Math.log(1 - t))
      : 0;
    kernel.push({ x: x, k: k });
  }

  // Normalize by total area (trapezoidal)
  var area = 0;
  for (var i = 0; i < kernel.length - 1; i++) {
    area += (kernel[i].k + kernel[i + 1].k) * 0.5 * dx;
  }
  if (area <= 0) return { pdf: [], cdf: [] };

  var pdf = [], cdf = [], cum = 0;
  for (var i = 0; i < kernel.length; i++) {
    if (i > 0) cum += (kernel[i - 1].k + kernel[i].k) * 0.5 * dx / area;
    pdf.push({ x: kernel[i].x, y: kernel[i].k / area });
    cdf.push({ x: kernel[i].x, y: Math.min(1, Math.max(0, cum)) });
  }
  return { pdf: pdf, cdf: cdf };
}

/* ────────────────────────────────────────────────────────────────
   TM — Task Manager state and methods
──────────────────────────────────────────────────────────────── */
window.TM = {
  tasks:          [],     // current (possibly unsaved) task list
  savedTasks:     [],     // last persisted state (for dirty detection)
  settings:       { tabName: 'PMC Tasks', units: 'days', mode: 'single' },
  mode:           'single',
  selectedTaskId: null,
  initialized:    false,
  _confirmCb:     null,
  _frChoice:      'create',
  _cmStep:        1,
  _cmSelectedTab: null,
  _cmDetectedMap: null,
  _cmImportedTasks: null,
  _csvParsed:     null,
  _editingTaskId: null,

  /* ── Init ── */
  init: function() {
    var self = this;
    if (!window.google || !window.google.script || !window.google.script.run) {
      self._updateBar();
      return;
    }
    try {
      window.google.script.run
        .withSuccessHandler(function(res) {
          if (!res || !res.ok || res.needsSetup) {
            self._showFirstRun();
            return;
          }
          self.settings = Object.assign(self.settings, res.settings || {});
          self.tasks = (res.tasks || []).map(function(t, i) {
            return self._normalizeTask(t, i);
          });
          self.savedTasks = JSON.parse(JSON.stringify(self.tasks));
          self.initialized = true;
          self._syncToLegacy();
          self._updateBar();
        })
        .withFailureHandler(function(err) {
          console.warn('TM.init loadPMCTasks failed:', err);
          self._showFirstRun();
        })
        .loadPMCTasks();

      // Also load settings (best-effort)
      window.google.script.run
        .withSuccessHandler(function(s) {
          if (s) {
            self.settings = Object.assign(self.settings, s);
            if (s.mode) self.setMode(s.mode, true);
          }
        })
        .withFailureHandler(function(){})
        .getPMCSettings();
    } catch(e) {
      console.warn('TM.init error:', e);
      self._updateBar();
    }
  },

  /* ── Normalize a task object to internal format ── */
  _normalizeTask: function(t, idx) {
    return {
      id:          t.id || ('tid_' + idx + '_' + Date.now()),
      task_name:   String(t.task_name || t.task || '').trim(),
      best_case:   Number(t.best_case  || t.optimistic  || 0),
      most_likely: Number(t.most_likely|| t.mostLikely  || 0),
      worst_case:  Number(t.worst_case || t.pessimistic || 0),
      risk_weight: Number(t.risk_weight != null ? t.risk_weight : 1.0),
      active:      t.active !== false,
      notes:       String(t.notes || '').trim()
    };
  },

  /* ── Sync TM.tasks → legacy s.tasks + taskSel dropdown ── */
  _syncToLegacy: function() {
    var s = window.S || (window.S = {});
    if (!s) return;

    // In Group mode: only include checked (active) tasks in the aggregate.
    // In Single mode: ALL tasks appear in the dropdown — active/inactive is a Group concept.
    var active = this.mode === 'aggregate'
      ? this.tasks.filter(function(t) { return t.active; })
      : this.tasks;

    // Convert to legacy format
    s.tasks = active.map(function(t) {
      return {
        task:       t.task_name,
        optimistic: t.best_case,
        mostLikely: t.most_likely,
        pessimistic:t.worst_case,
        _tmId:      t.id
      };
    });

    // Rebuild taskSel dropdown
    var sel = document.getElementById('taskSel');
    if (sel) {
      sel.innerHTML = '';
      if (s.tasks.length === 0) {
        var opt = document.createElement('option');
        opt.value = ''; opt.textContent = 'No active tasks';
        sel.appendChild(opt);
      } else {
        s.tasks.forEach(function(t, i) {
          var opt = document.createElement('option');
          opt.value = i;
          opt.textContent = t.task || ('Task ' + (i + 1));
          sel.appendChild(opt);
        });
        // Select the last-selected task if possible
        if (this.selectedTaskId) {
          for (var i = 0; i < s.tasks.length; i++) {
            if (s.tasks[i]._tmId === this.selectedTaskId) { sel.selectedIndex = i; break; }
          }
        }
        sel.selectedIndex = Math.max(0, sel.selectedIndex);
        if (typeof window.onTaskChange === 'function') window.onTaskChange();
      }
    }
  },

  /* ── Mode toggle ── */
  setMode: function(mode, silent) {
    this.mode = mode;
    var btnS = document.getElementById('tmModeSingle');
    var btnA = document.getElementById('tmModeAggregate');
    if (btnS) btnS.classList.toggle('active', mode === 'single');
    if (btnA) btnA.classList.toggle('active', mode === 'aggregate');

    // Show inline group picker or single-task dropdown depending on mode
    var taskSel    = document.getElementById('taskSel');
    var groupPicker = document.getElementById('tmGroupPicker');
    var isAgg = mode === 'aggregate';
    if (taskSel)    taskSel.style.display    = isAgg ? 'none' : '';
    if (groupPicker) {
      groupPicker.style.display = isAgg ? 'flex' : 'none';
      if (isAgg) this._renderGroupPicker();
    }

    // Switch estimates column between single and aggregate stacks
    var estSingle = document.getElementById('estSingleStack');
    var estAgg    = document.getElementById('estAggStack');
    var estPend   = document.getElementById('estAggPending');
    if (isAgg) {
      if (estSingle) estSingle.style.display = 'none';
      if (this._lastAggResult) {
        if (estAgg)  estAgg.style.display  = '';
        if (estPend) estPend.style.display  = 'none';
      } else {
        if (estAgg)  estAgg.style.display  = 'none';
        if (estPend) estPend.style.display  = '';
      }
    } else {
      if (estSingle) estSingle.style.display = '';
      if (estAgg)    estAgg.style.display    = 'none';
      if (estPend)   estPend.style.display   = 'none';
    }

    var aggBar = document.getElementById('tmAggBar');
    if (aggBar) {
      if (mode === 'single') {
        aggBar.classList.remove('visible');
      } else if (this._lastAggResult) {
        aggBar.classList.add('visible');
      }
    }

    if (isAgg) {
      // When entering Group mode, clear stale single-task probabilities immediately.
      // _showAggregateResult will re-populate them from the group result if available.
      var _sClr = window.S || {};
      _sClr.baselineProb  = null;
      _sClr.optimizedProb = null;
      _sClr.adaptiveProb  = null;
      _sClr.adjustedProb  = null;
      if (this._lastAggResult) {
        // Restore full group state from cache (sets baselineProb, KPI chips, recommendations)
        this._showAggregateResult(this._lastAggResult);
      } else {
        // No run yet — clear KPI chips so they show "–" not stale single-task values
        if (typeof window.renderKPIs === 'function') window.renderKPIs();
        if (typeof window.updateRecommendation === 'function') window.updateRecommendation(window.S || {});
      }
    }

    // In Group mode Save & Run should always be visible so user can (re-)run
    var s1 = document.getElementById('btnSaveRun');
    if (s1) s1.style.display = (mode === 'aggregate') ? 'inline-flex' : 'none';

    this._updateBar();
    if (!silent) {
      if (typeof window.onTaskChange === 'function') window.onTaskChange();
    }
  },

  /* ── Dirty state ── */
  _markDirty: function() {
    this.dirty = true;
    var b1 = document.getElementById('tmDirtyBadge');
    var b2 = document.getElementById('mgrDirtyNote');
    var s1 = document.getElementById('btnSaveRun');
    var s2 = document.getElementById('btnDiscard');
    var s3 = document.getElementById('mgrDiscardBtn');
    if (b1) b1.style.display = 'inline';
    if (b2) b2.style.display = 'inline';
    if (s1) s1.style.display = 'inline-flex';
    if (s2) s2.style.display = 'inline-flex';
    if (s3) s3.style.display = 'inline-flex';
  },
  _clearDirty: function() {
    this.dirty = false;
    this.savedTasks = JSON.parse(JSON.stringify(this.tasks));
    var b1 = document.getElementById('tmDirtyBadge');
    var b2 = document.getElementById('mgrDirtyNote');
    var s1 = document.getElementById('btnSaveRun');
    var s2 = document.getElementById('btnDiscard');
    var s3 = document.getElementById('mgrDiscardBtn');
    if (b1) b1.style.display = 'none';
    if (b2) b2.style.display = 'none';
    // Keep Save & Run visible in Group mode so user can always re-run
    if (s1) s1.style.display = (this.mode === 'aggregate') ? 'inline-flex' : 'none';
    if (s2) s2.style.display = 'none';
    if (s3) s3.style.display = 'none';
  },

  /* ── Update TM bar info text + estimates subtitle ── */
  _updateBar: function() {
    var info = document.getElementById('tmTaskInfo');
    var sub  = document.getElementById('estSubtitle');
    var total  = this.tasks.length;
    var active = this.tasks.filter(function(t) { return t.active; }).length;

    // Update estimates column subtitle
    if (sub) {
      if (this.mode === 'aggregate') {
        sub.textContent = this._lastAggResult
          ? 'Group · ' + active + ' tasks · Monte Carlo'
          : 'Group · ' + active + ' / ' + total + ' selected';
      } else {
        sub.textContent = '3-point estimate (O / M / P)';
      }
    }

    if (!info) return;
    if (total === 0) {
      info.textContent = 'No tasks — click Data Source to add some.';
    } else if (this.mode === 'aggregate') {
      if (this._lastAggResult) {
        info.textContent = active + ' of ' + total + ' task' + (total !== 1 ? 's' : '') +
          ' included in aggregate run — use Manage Tasks to select which tasks to combine.';
      } else {
        info.textContent = active + ' of ' + total + ' task' + (total !== 1 ? 's' : '') +
          ' selected — click Save & Run \u25b6 to compute the combined distribution.';
      }
    } else {
      info.textContent = total + ' task' + (total !== 1 ? 's' : '') + ' — select one from the dropdown below.';
    }
  },

  /* ── Save & Run ── */
  saveAndRun: function() {
    var self = this;
    if (!window.google || !window.google.script || !window.google.script.run) {
      alert('Google Apps Script runtime not available in preview mode.');
      return;
    }
    var activeTasks = this.tasks.filter(function(t) { return t.active; });
    if (activeTasks.length === 0) {
      alert('No active tasks to run. Enable at least one task in Manage Tasks.');
      return;
    }

    var s = window.S || (window.S = {});
    var tau  = s ? (s.target != null ? s.target : null) : null;
    var conf = s ? (s.confidenceLevel || 0.95) : 0.95;
    var selId = this.selectedTaskId;
    if (!selId && activeTasks.length > 0) selId = activeTasks[0].id;

    var payload = {
      tasks:           this.tasks,
      mode:            this.mode,
      selectedTaskId:  selId,
      targetValue:     tau,
      confidenceLevel: conf,
      settings:        this.settings
    };

    // Show loading in bar
    var info = document.getElementById('tmTaskInfo');
    var prevInfo = info ? info.textContent : '';
    if (info) info.textContent = 'Saving & running simulation…';
    if (typeof window.setStatus === 'function') window.setStatus('Saving & running…');

    try {
      window.google.script.run
        .withSuccessHandler(function(res) {
          if (info) info.textContent = prevInfo;
          if (!res || !res.ok) {
            if (typeof window.setStatus === 'function') window.setStatus('Run failed: ' + (res && res.error ? res.error : 'Unknown error'));
            alert('Simulation failed: ' + (res && res.error ? res.error : 'Unknown error'));
            return;
          }
          self._clearDirty();
          self._syncToLegacy();
          self._updateBar();

          if (res.mode === 'aggregate' && res.result) {
            // groupO/M/P live on res (top-level), not on res.result — merge them in
            var aggPayload = res.result;
            aggPayload.groupO    = res.groupO;
            aggPayload.groupM    = res.groupM;
            aggPayload.groupP    = res.groupP;
            aggPayload.groupPert = res.groupPert;
            self._showAggregateResult(aggPayload);
          }

          if (typeof window.setStatus === 'function') window.setStatus('Ready');
          if (res.mode === 'single' && typeof window.onTaskChange === 'function') {
            window.onTaskChange();
          }
        })
        .withFailureHandler(function(err) {
          if (info) info.textContent = prevInfo;
          if (typeof window.setStatus === 'function') window.setStatus('Ready');
          alert('Save & Run failed: ' + (err && err.message ? err.message : String(err)));
        })
        .savePMCTasksAndRun(payload);
    } catch(e) {
      if (info) info.textContent = prevInfo;
      if (typeof window.setStatus === 'function') window.setStatus('Ready');
      alert('Save & Run error: ' + e);
    }
  },

  /* ── Discard changes ── */
  discard: function() {
    this.tasks = JSON.parse(JSON.stringify(this.savedTasks));
    this._clearDirty();
    this._syncToLegacy();
    this._updateBar();
    this._renderTaskList();
  },

  /* ── Show aggregate result ── */
  _showAggregateResult: function(agg) {
    this._lastAggResult = agg; // cache so panel can be restored on mode re-entry

    // Store aggregate CDF and PDF so charts can render the group distribution
    var _s = window.S || (window.S = {});
    if (agg && agg.cdfPoints && agg.cdfPoints.length) {
      _s.aggCdf  = agg.cdfPoints;
      _s.aggPdf  = (agg.pdfPoints && agg.pdfPoints.length) ? agg.pdfPoints : [];
      _s.aggMean = agg.mean;
      // Set baselineProb for Group mode — interpolate live from aggregate CDF at current target
      // (server's probAtTarget may be stale if target slider moved after last run)
      _s.baselineProb = (_s.target != null && typeof interpY === 'function')
        ? interpY(_s.aggCdf, _s.target)
        : (agg.probAtTarget != null ? Number(agg.probAtTarget) : null);
    }

    // ── Virtual group task: PERT aggregation (sum of individual O/M/P) ─────────
    // This is mathematically sound for sequential independent tasks.
    // Setting s.O/M/P/task lets requestVariant() run SACO on the group's
    // combined distribution, and lets the Triangle canvas render the group shape.
    if (agg.groupO != null) {
      var nT = agg.taskCount || 0;
      _s.O = agg.groupO;
      _s.M = agg.groupM;
      _s.P = agg.groupP;
      _s.task = {
        task:        'Group \u2014 ' + nT + ' task' + (nT !== 1 ? 's' : ''),
        task_name:   'Group \u2014 ' + nT + ' task' + (nT !== 1 ? 's' : ''),
        best_case:   agg.groupO, optimistic:  agg.groupO,
        most_likely: agg.groupM, mostLikely:  agg.groupM,
        worst_case:  agg.groupP, pessimistic: agg.groupP
      };
      // Reset overlay so strategy results from a previous single-task don't bleed in
      if (!_s.overlay) _s.overlay = {};
      _s.overlay.adaptiveOn = false;
      _s.overlay.fixedOn    = false;
      _s.overlay.manualOn   = false;
      _s.overlay.baselineOn = true;
      // Clear stale strategy distributions and probabilities
      _s.optimizedProb  = null; _s.adaptiveProb  = null; _s.adjustedProb  = null;
      _s.optPdfFixed    = []; _s.optCdfFixed   = [];
      _s.optPdfAdaptive = []; _s.optCdfAdaptive= [];
      _s.adjPdf         = []; _s.adjCdf        = [];
      _s.variantCache   = {};
      // Compute analytical Triangle and Beta-PERT distributions from group O/M/P.
      // This mirrors the single-task pipeline: Triangle → Beta-PERT → MC baseline.
      // groupO/M/P serve as the aggregated 3-point parameters.
      var triG  = computeTriDist_(_s.O, _s.M, _s.P);
      var pertG = computeBetaPertDist_(_s.O, _s.M, _s.P);
      _s.trianglePdf = triG.pdf;  _s.triangleCdf = triG.cdf;
      _s.betaPertPdf = pertG.pdf; _s.betaPertCdf = pertG.cdf;
      // Default curve visibility for Group mode
      if (!_s.progress) _s.progress = {};
      _s.progress.triOn  = true;   // show Triangle from groupO/M/P
      _s.progress.betaOn = false;  // Beta-PERT off by default (user can toggle)
      _s.progress.baseOn = true;   // show MC aggregate baseline
      // Redraw triangle canvas with group O/M/P (client-side, no server call needed)
      if (typeof window._drawTriPlot === 'function') window._drawTriPlot();
      // Update OMP bar elements (normally set by onTaskChange — must also set here for Group mode)
      var fmt2 = function(v) { return v != null ? Number(v).toFixed(2) : '–'; };
      var oE = document.getElementById('oVal');    if (oE) oE.textContent = fmt2(agg.groupO);
      var mE = document.getElementById('mVal');    if (mE) mE.textContent = fmt2(agg.groupM);
      var pE = document.getElementById('pVal');    if (pE) pE.textContent = fmt2(agg.groupP);
      var ptE = document.getElementById('pertVal'); if (ptE) ptE.textContent = fmt2(agg.groupPert != null ? agg.groupPert : (agg.groupO + 4*agg.groupM + agg.groupP)/6);
    }

    // Reveal aggregate estimates stack, hide pending placeholder
    var estAgg  = document.getElementById('estAggStack');
    var estPend = document.getElementById('estAggPending');
    if (estAgg)  estAgg.style.display  = '';
    if (estPend) estPend.style.display  = 'none';

    var bar = document.getElementById('tmAggBar');
    if (bar) bar.classList.add('visible');
    function fmtN(v) { return v != null && isFinite(v) ? Number(v).toFixed(2) : '–'; }
    function fmtP(v) { return v != null && isFinite(v) ? (Number(v) * 100).toFixed(1) + '%' : '–'; }
    function setEl(id, v) { var el = document.getElementById(id); if (el) el.textContent = v; }
    setEl('aggStatTasks', agg.taskCount || '–');
    setEl('aggStatMean',  fmtN(agg.mean));
    setEl('aggStatP50',   fmtN(agg.p50));
    setEl('aggStatP80',   fmtN(agg.p80));
    setEl('aggStatP90',   fmtN(agg.p90));
    // Show live-interpolated probability (always matches target slider)
    setEl('aggStatProb',  _s.baselineProb != null ? fmtP(_s.baselineProb) : '–');

    // Switch plot selector to PDF/CDF (Triangle doesn't apply to the aggregate group)
    var chkTriAgg = document.getElementById('pselTriangle');
    var chkPDFAgg = document.getElementById('pselPDF');
    var chkCDFAgg = document.getElementById('pselCDF');
    if (chkTriAgg) chkTriAgg.checked = false;
    if (chkPDFAgg && !chkPDFAgg.checked && chkCDFAgg && !chkCDFAgg.checked) {
      // Neither is checked — enable CDF by default
      if (chkCDFAgg) chkCDFAgg.checked = true;
    }
    if (typeof window.pselUpdate === 'function') window.pselUpdate();

    // Update target slider range to [groupO, groupP] — the correct span for Group mode.
    // This is mathematically sound: groupO (sum of best cases) → P≈0%,
    // groupP (sum of worst cases) → P≈100%, since Monte Carlo samples are bounded by [O,P] per task.
    if (typeof window.updateTargetSlider === 'function') window.updateTargetSlider();

    // Refresh target display, KPI chips, charts, description, and recommendation
    if (typeof window.updateTargetDisplayText === 'function') window.updateTargetDisplayText();
    if (typeof window.renderKPIs === 'function') window.renderKPIs();
    if (typeof window.scheduleUIRefresh === 'function') window.scheduleUIRefresh();
  },

  /* ── Open / Close Manager ── */
  openManager: function() {
    this._renderTaskList();
    var bd = document.getElementById('tmManagerBackdrop');
    if (bd) bd.classList.add('open');
  },
  closeManager: function() {
    var bd = document.getElementById('tmManagerBackdrop');
    if (bd) bd.classList.remove('open');
  },

  /* ── Render task list in manager ── */
  _renderTaskList: function() {
    var self = this;
    var container = document.getElementById('tmTaskListContainer');
    if (!container) return;

    if (this.tasks.length === 0) {
      container.innerHTML = '<div class="tm-empty-state"><div class="em-icon">&#128203;</div><div>No tasks yet. Click <strong>+ Add Task</strong> to get started.</div></div>';
      return;
    }

    var isAgg = this.mode === 'aggregate';
    var activeCount = this.tasks.filter(function(t) { return t.active; }).length;
    var html = '';

    // In aggregate mode: show quick-select bar and column header
    if (isAgg) {
      html += '<div class="agg-sel-bar">';
      html += '<span style="font-size:10px;font-weight:700;color:#0369A1;letter-spacing:.03em;">AGGREGATE MODE</span>';
      html += '<span class="agg-count">' + activeCount + ' / ' + this.tasks.length + ' included</span>';
      html += '<button class="agg-sel-btn" onclick="event.stopPropagation();TM._aggSelectAll(true)" title="Include all tasks in aggregate run">All</button>';
      html += '<button class="agg-sel-btn" onclick="event.stopPropagation();TM._aggSelectAll(false)" title="Exclude all tasks">None</button>';
      html += '</div>';
      // Column headers
      html += '<div class="agg-header-row">';
      html += '<span style="width:16px;flex-shrink:0;">In Agg</span>';
      html += '<span style="flex:1;">Task Name</span>';
      html += '<span style="font-family:monospace;font-size:10px;white-space:nowrap;">Best / Mode / Worst</span>';
      html += '<span style="font-size:10px;white-space:nowrap;">Weight</span>';
      html += '<span style="width:60px;text-align:right;">Actions</span>';
      html += '</div>';
    }

    this.tasks.forEach(function(t, i) {
      var isDirty = JSON.stringify(self.savedTasks[i]) !== JSON.stringify(t);
      var isSelected = t.id === self.selectedTaskId;
      html += '<div class="tm-task-row' + (isDirty ? ' dirty' : '') + (isSelected ? ' selected' : '') + (isAgg && !t.active ? ' style="opacity:0.55;"' : '') + '" data-tid="' + t.id + '" onclick="TM._selectTask(\'' + t.id + '\')">';
      var chkTitle = isAgg ? 'Include in aggregate run' : 'Toggle active';
      var chkColor = isAgg ? 'accent-color:#0369A1;' : '';
      html += '<input type="checkbox" class="tm-active-toggle" ' + (t.active ? 'checked' : '') + ' title="' + chkTitle + '" style="' + chkColor + '" onclick="event.stopPropagation();TM._toggleActive(\'' + t.id + '\')" />';
      html += '<span class="tm-task-name">' + _escHtml(t.task_name) + (isDirty ? '<span class="tm-dirty-star">*</span>' : '') + '</span>';
      html += '<span class="tm-task-vals">' + t.best_case + ' / ' + t.most_likely + ' / ' + t.worst_case + '</span>';
      if (isAgg) {
        html += '<span style="font-size:11px;color:var(--muted);white-space:nowrap;">w:' + t.risk_weight + '</span>';
      }
      html += '<div class="tm-task-btns">';
      html += '<button onclick="event.stopPropagation();TM.openTaskForm(\'' + t.id + '\')" title="Edit">&#9998;</button>';
      html += '<button class="del-btn" onclick="event.stopPropagation();TM._deleteTask(\'' + t.id + '\')" title="Delete">&#128465;</button>';
      html += '</div></div>';
    });
    container.innerHTML = html;
  },

  /* ── Aggregate select all / none ── */
  _aggSelectAll: function(onOff) {
    this.tasks.forEach(function(t) { t.active = onOff; });
    this._markDirty();
    this._renderTaskList();
    this._renderGroupPicker();
    this._syncToLegacy();
    this._updateBar();
  },

  /* ── Expand / collapse group task list ── */
  _toggleGroupList: function() {
    var list = document.getElementById('grpList');
    var btn  = document.getElementById('grpToggleBtn');
    if (!list) return;
    var collapsed = list.classList.toggle('grp-collapsed');
    if (btn) btn.textContent = collapsed ? 'Expand' : 'Collapse';
  },

  /* ── Render inline group picker checklist ── */
  _renderGroupPicker: function() {
    var list    = document.getElementById('grpList');
    var countEl = document.getElementById('grpCount');
    if (!list) return;
    var self   = this;
    var active = this.tasks.filter(function(t) { return t.active; }).length;
    if (countEl) countEl.textContent = active + ' / ' + this.tasks.length + ' selected';
    if (this.tasks.length === 0) {
      list.innerHTML = '<div style="font-size:10px;color:var(--muted);padding:6px 8px;">No tasks yet — click Data Source to add some.</div>';
      return;
    }
    var html = '';
    this.tasks.forEach(function(t) {
      var rowCls = 'grp-task-row' + (t.active ? ' grp-active' : '');
      html += '<label class="' + rowCls + '">';
      html += '<input type="checkbox"' + (t.active ? ' checked' : '') +
              ' onclick="event.stopPropagation();TM._toggleActive(\'' + t.id + '\')"/>';
      html += '<span class="grp-task-name">' + (t.task_name || t.task || 'Task') + '</span>';
      html += '<span class="grp-task-omp">' + t.best_case + '/' + t.most_likely + '/' + t.worst_case + '</span>';
      html += '</label>';
    });
    list.innerHTML = html;
  },

  _selectTask: function(id) {
    this.selectedTaskId = id;
    this._renderTaskList();
    // Sync the taskSel dropdown to match
    var s = window.S || (window.S = {});
    if (s && s.tasks) {
      var sel = document.getElementById('taskSel');
      if (sel) {
        for (var i = 0; i < s.tasks.length; i++) {
          if (s.tasks[i]._tmId === id) { sel.selectedIndex = i; if (typeof window.onTaskChange === 'function') window.onTaskChange(); break; }
        }
      }
    }
  },

  _toggleActive: function(id) {
    var t = this._findTask(id);
    if (!t) return;
    t.active = !t.active;
    this._markDirty();
    this._renderTaskList();
    if (this.mode === 'aggregate') this._renderGroupPicker();
    this._syncToLegacy();
    this._updateBar();
  },

  _deleteTask: function(id) {
    var self = this;
    var t = this._findTask(id);
    if (!t) return;
    this._confirm('Delete Task', 'Delete "' + t.task_name + '"? This cannot be undone.', 'Delete', function() {
      self.tasks = self.tasks.filter(function(x) { return x.id !== id; });
      self._markDirty();
      self._renderTaskList();
      self._syncToLegacy();
      self._updateBar();
    });
  },

  _findTask: function(id) {
    for (var i = 0; i < this.tasks.length; i++) { if (this.tasks[i].id === id) return this.tasks[i]; }
    return null;
  },

  /* ── Task Form (Add / Edit) ── */
  openTaskForm: function(idOrNull) {
    this._editingTaskId = idOrNull;
    var title  = document.getElementById('tmTaskFormTitle');
    var saveBtn = document.getElementById('tfSaveBtn');
    var noteEl = document.getElementById('tfAutocorrectNote');
    if (noteEl) noteEl.style.display = 'none';

    if (idOrNull) {
      var t = this._findTask(idOrNull);
      if (!t) return;
      if (title)  title.textContent = 'Edit Task';
      if (saveBtn) saveBtn.textContent = 'Save Changes';
      document.getElementById('tfName').value   = t.task_name;
      document.getElementById('tfBest').value   = t.best_case;
      document.getElementById('tfMost').value   = t.most_likely;
      document.getElementById('tfWorst').value  = t.worst_case;
      document.getElementById('tfWeight').value = t.risk_weight;
      document.getElementById('tfActive').checked = t.active;
      document.getElementById('tfNotes').value  = t.notes;
    } else {
      if (title)  title.textContent = 'Add Task';
      if (saveBtn) saveBtn.textContent = 'Add Task';
      document.getElementById('tfName').value   = '';
      document.getElementById('tfBest').value   = '';
      document.getElementById('tfMost').value   = '';
      document.getElementById('tfWorst').value  = '';
      document.getElementById('tfWeight').value = '1';
      document.getElementById('tfActive').checked = true;
      document.getElementById('tfNotes').value  = '';
    }
    // Clear errors
    ['tfNameField','tfBestField','tfMostField','tfWorstField'].forEach(function(fid) {
      var f = document.getElementById(fid);
      if (f) f.classList.remove('error','warn');
    });
    ['tfNameErr','tfBestErr','tfMostErr','tfWorstErr'].forEach(function(eid) {
      var e = document.getElementById(eid);
      if (e) { e.style.display = 'none'; e.textContent = ''; }
    });
    this._tfDrawTriangle();
    var bd = document.getElementById('tmTaskFormBackdrop');
    if (bd) bd.classList.add('open');
  },
  closeTaskForm: function() {
    var bd = document.getElementById('tmTaskFormBackdrop');
    if (bd) bd.classList.remove('open');
  },

  /* ── Form validation ── */
  _tfValidateName: function() {
    var val = (document.getElementById('tfName').value || '').trim();
    var field = document.getElementById('tfNameField');
    var err   = document.getElementById('tfNameErr');
    if (!val) {
      if (field) field.classList.add('error');
      if (err) { err.textContent = 'Task name is required.'; err.style.display = 'block'; }
      return false;
    }
    // Duplicate check
    var id = this._editingTaskId;
    var dup = this.tasks.filter(function(t) { return t.id !== id && t.task_name.toLowerCase() === val.toLowerCase(); });
    if (dup.length > 0) {
      if (field) field.classList.add('error');
      if (err) { err.textContent = 'A task with this name already exists.'; err.style.display = 'block'; }
      return false;
    }
    if (field) field.classList.remove('error');
    if (err) err.style.display = 'none';
    return true;
  },

  _tfValidateTriangle: function() {
    var a = parseFloat(document.getElementById('tfBest').value);
    var c = parseFloat(document.getElementById('tfMost').value);
    var b = parseFloat(document.getElementById('tfWorst').value);
    var ok = true;

    function setFieldState(fid, eid, cls, msg) {
      var field = document.getElementById(fid);
      var err   = document.getElementById(eid);
      if (field) { field.classList.remove('error','warn'); if (cls) field.classList.add(cls); }
      if (err) { err.textContent = msg || ''; err.style.display = msg ? 'block' : 'none'; }
    }

    if (isNaN(a)) { setFieldState('tfBestField','tfBestErr','error','Required — enter a number.'); ok = false; }
    else setFieldState('tfBestField','tfBestErr','','');

    if (isNaN(c)) { setFieldState('tfMostField','tfMostErr','error','Required — enter a number.'); ok = false; }
    else setFieldState('tfMostField','tfMostErr','','');

    if (isNaN(b)) { setFieldState('tfWorstField','tfWorstErr','error','Required — enter a number.'); ok = false; }
    else setFieldState('tfWorstField','tfWorstErr','','');

    if (!ok) { this._tfDrawTriangle(); return false; }

    if (a > c) { setFieldState('tfBestField','tfBestErr','warn','Best case should be ≤ Most Likely.'); ok = false; }
    if (c > b) { setFieldState('tfWorstField','tfWorstErr','warn','Worst case should be ≥ Most Likely.'); ok = false; }
    if (a > b) { setFieldState('tfBestField','tfBestErr','error','Best case cannot be greater than Worst case.'); ok = false; }

    this._tfDrawTriangle();
    return ok;
  },

  _tfAutocorrect: function() {
    var a = parseFloat(document.getElementById('tfBest').value);
    var c = parseFloat(document.getElementById('tfMost').value);
    var b = parseFloat(document.getElementById('tfWorst').value);
    if (isNaN(a) || isNaN(c) || isNaN(b)) return;
    var sorted = [a, c, b].sort(function(x, y) { return x - y; });
    if (a !== sorted[0] || c !== sorted[1] || b !== sorted[2]) {
      document.getElementById('tfBest').value  = sorted[0];
      document.getElementById('tfMost').value  = sorted[1];
      document.getElementById('tfWorst').value = sorted[2];
      // Add corrected class briefly
      ['tfBest','tfMost','tfWorst'].forEach(function(id) {
        var el = document.getElementById(id);
        if (el) { el.classList.add('corrected'); setTimeout(function(){ el.classList.remove('corrected'); }, 1500); }
      });
      var note = document.getElementById('tfAutocorrectNote');
      if (note) note.style.display = 'block';
      this._tfValidateTriangle();
    }
  },

  /* ── Triangle preview canvas ── */
  _tfDrawTriangle: function() {
    var canvas = document.getElementById('tmTriPreview');
    if (!canvas || !canvas.getContext) return;
    var a = parseFloat(document.getElementById('tfBest').value);
    var c = parseFloat(document.getElementById('tfMost').value);
    var b = parseFloat(document.getElementById('tfWorst').value);

    var ctx = canvas.getContext('2d');
    var W = canvas.offsetWidth || 300;
    var H = canvas.offsetHeight || 90;
    canvas.width = W * (window.devicePixelRatio || 1);
    canvas.height = H * (window.devicePixelRatio || 1);
    ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#F9FAFB';
    ctx.fillRect(0, 0, W, H);

    if (isNaN(a) || isNaN(c) || isNaN(b) || a > b) {
      ctx.fillStyle = '#9CA3AF';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Enter valid values to see distribution', W / 2, H / 2);
      return;
    }

    var pad = 20;
    var xScale = (W - 2 * pad) / (b - a || 1);
    function xPos(v) { return pad + (v - a) * xScale; }
    var peak = H - 14;

    // Fill
    ctx.beginPath();
    ctx.moveTo(xPos(a), peak);
    ctx.lineTo(xPos(c), 12);
    ctx.lineTo(xPos(b), peak);
    ctx.closePath();
    ctx.fillStyle = 'rgba(99,102,241,0.18)';
    ctx.fill();

    // Stroke
    ctx.beginPath();
    ctx.moveTo(xPos(a), peak);
    ctx.lineTo(xPos(c), 12);
    ctx.lineTo(xPos(b), peak);
    ctx.closePath();
    ctx.strokeStyle = '#6366F1';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Mode line
    ctx.beginPath();
    ctx.moveTo(xPos(c), 12);
    ctx.lineTo(xPos(c), peak);
    ctx.strokeStyle = 'rgba(99,102,241,0.4)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Labels
    var units = this.settings.units || 'days';
    ctx.fillStyle = '#374151';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(Number(a).toFixed(1), xPos(a), H - 2);
    ctx.textAlign = 'center';
    ctx.fillText(Number(c).toFixed(1), xPos(c), H - 2);
    ctx.textAlign = 'right';
    ctx.fillText(Number(b).toFixed(1), xPos(b), H - 2);

    // Update label els
    var lbest = document.getElementById('triLblBest');
    var lmost = document.getElementById('triLblMost');
    var lworst= document.getElementById('triLblWorst');
    if (lbest)  lbest.textContent  = 'Best';
    if (lmost)  lmost.textContent  = 'Most Likely';
    if (lworst) lworst.textContent = 'Worst';
  },

  /* ── Save task form ── */
  _tfSave: function() {
    var nameOk = this._tfValidateName();
    var triOk  = this._tfValidateTriangle();
    if (!nameOk || !triOk) return;

    var newTask = {
      id:          this._editingTaskId || ('tid_' + Date.now()),
      task_name:   document.getElementById('tfName').value.trim(),
      best_case:   parseFloat(document.getElementById('tfBest').value),
      most_likely: parseFloat(document.getElementById('tfMost').value),
      worst_case:  parseFloat(document.getElementById('tfWorst').value),
      risk_weight: parseFloat(document.getElementById('tfWeight').value) || 1.0,
      active:      document.getElementById('tfActive').checked,
      notes:       document.getElementById('tfNotes').value.trim()
    };

    if (this._editingTaskId) {
      for (var i = 0; i < this.tasks.length; i++) {
        if (this.tasks[i].id === this._editingTaskId) { this.tasks[i] = newTask; break; }
      }
    } else {
      this.tasks.push(newTask);
    }

    this._markDirty();
    this.closeTaskForm();
    this._renderTaskList();
    this._syncToLegacy();
    this._updateBar();
  },

  /* ── CSV Import ── */
  openCSVImport: function() {
    this._csvParsed = null;
    var step1 = document.getElementById('csvStep1');
    var step2 = document.getElementById('csvStep2');
    var importBtn = document.getElementById('csvImportBtn');
    var fileInput = document.getElementById('csvFileInput');
    var parseStatus = document.getElementById('csvParseStatus');
    if (step1) step1.style.display = 'block';
    if (step2) step2.style.display = 'none';
    if (importBtn) importBtn.style.display = 'none';
    if (fileInput) fileInput.value = '';
    if (parseStatus) parseStatus.textContent = '';
    var bd = document.getElementById('tmCSVBackdrop');
    if (bd) bd.classList.add('open');
  },
  closeCSVImport: function() {
    var bd = document.getElementById('tmCSVBackdrop');
    if (bd) bd.classList.remove('open');
  },

  _csvFileChosen: function(inputEl) {
    var self = this;
    var file = inputEl && inputEl.files && inputEl.files[0];
    if (!file) return;
    var statusEl = document.getElementById('csvParseStatus');
    if (statusEl) statusEl.textContent = 'Parsing…';

    var reader = new FileReader();
    reader.onload = function(e) {
      var text = e.target.result;
      var result = self._parseCSV(text);
      self._csvParsed = result;
      self._renderCSVPreview(result);
    };
    reader.onerror = function() {
      if (statusEl) statusEl.textContent = 'Error reading file.';
    };
    reader.readAsText(file);
  },

  _parseCSV: function(text) {
    var lines = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n').filter(function(l){ return l.trim(); });
    if (lines.length < 2) return { tasks: [], warnings: ['CSV has no data rows.'], errors: [] };

    // Parse header
    var headers = _csvLine(lines[0]).map(function(h){ return h.toLowerCase().trim().replace(/[\s_\-]+/g,''); });

    // Map header to fields using keywords
    var KEYWORDS = {
      task_name:   ['task','name','activity','item','work','feature','title','id'],
      best_case:   ['best','optimistic','min','minimum','low','opt'],
      most_likely: ['likely','expected','nominal','typical','modal','mid','ml'],
      worst_case:  ['worst','pessimistic','max','maximum','high','pess'],
      risk_weight: ['risk','weight','priority','impact','wt'],
      active:      ['active','enabled','include','flag'],
      notes:       ['note','comment','remark','detail','info']
    };
    var colMap = {};
    var usedCols = {};
    ['task_name','best_case','most_likely','worst_case','risk_weight','active','notes'].forEach(function(field) {
      var kws = KEYWORDS[field];
      var bestScore = 0, bestCol = -1;
      headers.forEach(function(h, ci) {
        if (usedCols[ci]) return;
        var score = 0;
        kws.forEach(function(kw) {
          if (h === kw) score = Math.max(score, 10);
          else if (h.indexOf(kw) !== -1 || kw.indexOf(h) !== -1) score = Math.max(score, 5);
        });
        if (score > bestScore) { bestScore = score; bestCol = ci; }
      });
      colMap[field] = bestScore > 0 ? bestCol : -1;
      if (bestScore > 0) usedCols[bestCol] = true;
    });

    var tasks = [], warnings = [], errors = [];
    for (var ri = 1; ri < lines.length; ri++) {
      var row = _csvLine(lines[ri]);
      function getCol(field) {
        var ci = colMap[field];
        return (ci >= 0 && ci < row.length) ? row[ci].trim() : '';
      }
      var name = getCol('task_name');
      if (!name) continue;

      var a = parseFloat(getCol('best_case'));
      var c = parseFloat(getCol('most_likely'));
      var b = parseFloat(getCol('worst_case'));
      var w = parseFloat(getCol('risk_weight'));
      var actRaw = getCol('active');
      var active = actRaw === '' ? true : !(actRaw.toLowerCase() === 'false' || actRaw === '0');

      var rowWarnings = [], rowErrors = [];
      if (isNaN(a) || isNaN(c) || isNaN(b)) {
        rowErrors.push('Missing or non-numeric estimate values');
      } else {
        var sorted = [a, c, b].sort(function(x,y){ return x-y; });
        if (a !== sorted[0] || c !== sorted[1] || b !== sorted[2]) {
          rowWarnings.push('Values re-ordered (best ≤ most likely ≤ worst)');
          a = sorted[0]; c = sorted[1]; b = sorted[2];
        }
        if (a === b) rowWarnings.push('Zero-variance task');
      }

      tasks.push({
        _row: ri + 1,
        _errors: rowErrors,
        _warnings: rowWarnings,
        task_name:   name,
        best_case:   isNaN(a) ? null : a,
        most_likely: isNaN(c) ? null : c,
        worst_case:  isNaN(b) ? null : b,
        risk_weight: isNaN(w) ? 1.0  : Math.max(0, Math.min(10, w)),
        active:      active,
        notes:       getCol('notes')
      });
      if (rowErrors.length > 0) errors.push('Row ' + (ri + 1) + ': ' + rowErrors.join('; '));
      if (rowWarnings.length > 0) warnings.push('Row ' + (ri + 1) + ' (' + name + '): ' + rowWarnings.join('; '));
    }

    return { tasks: tasks, warnings: warnings, errors: errors };
  },

  _renderCSVPreview: function(result) {
    var step1 = document.getElementById('csvStep1');
    var step2 = document.getElementById('csvStep2');
    var importBtn = document.getElementById('csvImportBtn');
    var warnEl  = document.getElementById('csvWarnings');
    var summEl  = document.getElementById('csvSummary');
    var tbody   = document.getElementById('csvPreviewBody');
    if (step1) step1.style.display = 'block';
    if (step2) step2.style.display = 'block';

    var validCount = result.tasks.filter(function(t) { return t._errors.length === 0; }).length;
    if (summEl) summEl.textContent = validCount + ' valid, ' + result.errors.length + ' errors, ' + result.warnings.length + ' warnings.';
    if (importBtn) importBtn.style.display = validCount > 0 ? 'inline-flex' : 'none';

    // Warnings
    var warnHtml = '';
    if (result.warnings.length > 0) {
      warnHtml = '<div class="tm-warnings"><div class="warn-title">&#9888; Warnings (' + result.warnings.length + ')</div><ul>';
      result.warnings.forEach(function(w) { warnHtml += '<li>' + _escHtml(w) + '</li>'; });
      warnHtml += '</ul></div>';
    }
    if (warnEl) warnEl.innerHTML = warnHtml;

    // Table
    var rows = '';
    result.tasks.forEach(function(t) {
      var cls = t._errors.length > 0 ? 'csv-err' : (t._warnings.length > 0 ? 'csv-warn' : 'csv-ok');
      var icon = t._errors.length > 0 ? '&#10060;' : (t._warnings.length > 0 ? '&#9888;' : '&#10003;');
      rows += '<tr class="' + cls + '">';
      rows += '<td class="csv-status-icon">' + icon + '</td>';
      rows += '<td>' + _escHtml(t.task_name) + '</td>';
      rows += '<td>' + (t.best_case   != null ? t.best_case   : '<em>?</em>') + '</td>';
      rows += '<td>' + (t.most_likely != null ? t.most_likely : '<em>?</em>') + '</td>';
      rows += '<td>' + (t.worst_case  != null ? t.worst_case  : '<em>?</em>') + '</td>';
      rows += '<td>' + t.risk_weight + '</td>';
      rows += '<td style="color:var(--muted)">' + _escHtml(t.notes || '') + '</td>';
      rows += '</tr>';
    });
    if (tbody) tbody.innerHTML = rows;
  },

  _csvCommit: function() {
    var self = this;
    if (!this._csvParsed) return;
    var valid = this._csvParsed.tasks.filter(function(t) { return t._errors.length === 0; });
    if (valid.length === 0) return;
    valid.forEach(function(t, i) {
      self.tasks.push({
        id:          'tid_csv_' + Date.now() + '_' + i,
        task_name:   t.task_name,
        best_case:   t.best_case,
        most_likely: t.most_likely,
        worst_case:  t.worst_case,
        risk_weight: t.risk_weight,
        active:      t.active,
        notes:       t.notes
      });
    });
    this._markDirty();
    this.closeCSVImport();
    this._renderTaskList();
    this._syncToLegacy();
    this._updateBar();
  },

  /* ── Sheet Tab Import (Column Mapper) ── */
  openSheetImport: function() {
    var self = this;
    this._cmStep = 1;
    this._cmSelectedTab = null;
    this._cmDetectedMap = null;
    this._cmImportedTasks = null;
    this._cmSetStep(1);

    var bd = document.getElementById('tmColMapBackdrop');
    if (bd) bd.classList.add('open');

    var loadEl = document.getElementById('cmLoading');
    var msgEl  = document.getElementById('cmLoadingMsg');

    function hideLoad(errMsg) {
      if (loadEl) loadEl.classList.remove('active');
      if (errMsg) {
        var el = document.getElementById('cmTabList');
        if (el) el.innerHTML = '<div style="padding:12px;color:#DC2626;font-size:12px;">&#10060; ' + _escHtml(errMsg) + '</div>';
      }
    }

    // ── Primary path: use tab list cached by loadTasks() on page load ────────
    var serverData = window._PMC_SERVER_DATA;
    if (serverData && Array.isArray(serverData.sheetTabs) && serverData.sheetTabs.length > 0) {
      if (loadEl) loadEl.classList.remove('active');
      self._cmRenderTabList(serverData.sheetTabs);
      return;
    }

    // ── Fallback: route through getAllTasks (already deployed) ───────────────
    if (!window.google || !window.google.script || !window.google.script.run) {
      var el = document.getElementById('cmTabList');
      if (el) el.innerHTML = '<div style="padding:12px;color:var(--muted);font-size:12px;">Not available outside of Google Sheets.</div>';
      return;
    }

    if (loadEl) loadEl.classList.add('active');
    if (msgEl)  msgEl.textContent = 'Loading sheet tabs…';

    var timeoutId = setTimeout(function() { hideLoad('Timed out. Try closing and reopening the dialog.'); }, 15000);

    try {
      // Use getAllTasks({action:'listTabs'}) — getAllTasks is already deployed,
      // avoiding any dependency on the new undeployed listSheetTabs function.
      window.google.script.run
        .withSuccessHandler(function(res) {
          clearTimeout(timeoutId);
          if (loadEl) loadEl.classList.remove('active');
          var tabs = (res && res.sheetTabs) ? res.sheetTabs : (Array.isArray(res) ? [] : []);
          if (!window._PMC_SERVER_DATA) window._PMC_SERVER_DATA = {};
          window._PMC_SERVER_DATA.sheetTabs = tabs;
          try {
            self._cmRenderTabList(tabs);
          } catch(renderErr) {
            var el2 = document.getElementById('cmTabList');
            if (el2) el2.innerHTML = '<div style="padding:12px;color:#DC2626;font-size:12px;">&#10060; Render error: ' + _escHtml(String(renderErr)) + '</div>';
          }
        })
        .withFailureHandler(function(err) {
          clearTimeout(timeoutId);
          hideLoad('Failed to load tabs: ' + String(err && err.message ? err.message : err));
        })
        .getAllTasks({ action: 'listTabs' });
    } catch(callErr) {
      clearTimeout(timeoutId);
      hideLoad('Error: ' + String(callErr));
    }
  },

  _cmRenderTabList: function(tabs) {
    var self = this;
    var pmc = this.settings.tabName || 'PMC Tasks';
    var container = document.getElementById('cmTabList');
    if (!container) return;

    var allTabs = tabs || [];

    if (allTabs.length === 0) {
      container.innerHTML = '<div style="padding:12px;color:var(--muted);font-size:12px;">' +
        'No sheet tabs found. Make sure this dialog was opened from the PMC Estimator menu in Google Sheets. ' +
        '<br><span style="font-size:10px;color:#9CA3AF;">Debug: tabName filter="' + _escHtml(pmc) + '"</span></div>';
      return;
    }

    // Show ALL tabs — mark the PMC storage tab but don't hide it.
    // Previously, hiding it caused "No other sheet tabs found" when settings were misconfigured.
    container.innerHTML = '';
    allTabs.forEach(function(tab) {
      var isPmcTab = (tab.name === pmc);
      var div = document.createElement('div');
      div.className = 'tm-tab-item' + (isPmcTab ? ' tm-tab-pmc' : '');
      div.setAttribute('data-tabname', tab.name);
      div.style.cssText = isPmcTab
        ? 'opacity:0.6;cursor:default;' : '';

      var nameSpan = document.createElement('span');
      nameSpan.textContent = tab.name;
      if (isPmcTab) {
        var badge = document.createElement('span');
        badge.textContent = ' (TM storage)';
        badge.style.cssText = 'font-size:10px;color:#0369A1;font-weight:600;margin-left:4px;';
        nameSpan.appendChild(badge);
      }

      var rowSpan = document.createElement('span');
      rowSpan.className = 'tab-rows';
      rowSpan.textContent = isPmcTab ? 'Task Manager storage — import a different tab' : 'Click to select';

      div.appendChild(nameSpan);
      div.appendChild(rowSpan);

      if (!isPmcTab) {
        div.addEventListener('click', function() {
          self._cmSelectTab(div, tab.name);
        });
      }

      container.appendChild(div);
    });

    // If every tab is the PMC tab (shouldn't happen but guard it)
    var selectable = allTabs.filter(function(t) { return t.name !== pmc; });
    if (selectable.length === 0) {
      var hint = document.createElement('div');
      hint.style.cssText = 'padding:10px 12px;font-size:11px;color:#92400E;background:#FEF3C7;border-radius:6px;margin-top:6px;';
      hint.textContent = 'All tabs are the Task Manager\'s own storage tab ("' + pmc + '"). ' +
        'Add another sheet tab to your spreadsheet with task data (columns: Name, Best, Most Likely, Worst), then reopen this dialog.';
      container.appendChild(hint);
    }
  },

  _cmSelectTab: function(el, name) {
    this._cmSelectedTab = name;
    var items = document.querySelectorAll('#cmTabList .tm-tab-item');
    items.forEach(function(i) { i.classList.remove('selected'); });
    if (el) el.classList.add('selected');
    var status = document.getElementById('cmTabStatus');
    if (status) status.textContent = '\u201c' + name + '\u201d selected \u2014 click Next to map columns.';
  },

  _cmSetStep: function(n) {
    this._cmStep = n;
    var s1 = document.getElementById('cmStep1');
    var s2 = document.getElementById('cmStep2');
    var s3 = document.getElementById('cmStep3');
    var backBtn = document.getElementById('cmBackBtn');
    var nextBtn = document.getElementById('cmNextBtn');
    if (s1) s1.style.display = n === 1 ? 'block' : 'none';
    if (s2) s2.style.display = n === 2 ? 'block' : 'none';
    if (s3) s3.style.display = n === 3 ? 'block' : 'none';
    if (backBtn) backBtn.style.display = n > 1 ? 'inline-flex' : 'none';
    if (nextBtn) nextBtn.textContent = n === 3 ? 'Import Tasks' : 'Next';
  },

  _cmBack: function() {
    if (this._cmStep > 1) this._cmSetStep(this._cmStep - 1);
  },

  _cmNext: function() {
    var self = this;
    var loadEl = document.getElementById('cmLoading');
    var msgEl  = document.getElementById('cmLoadingMsg');

    function showLoad(msg) {
      if (loadEl) loadEl.classList.add('active');
      if (msgEl)  msgEl.textContent = msg || 'Loading…';
    }
    function hideLoad() {
      if (loadEl) loadEl.classList.remove('active');
    }

    if (this._cmStep === 1) {
      if (!this._cmSelectedTab) { alert('Please select a tab first.'); return; }
      showLoad('Detecting columns in "' + this._cmSelectedTab + '"…');
      var tid1 = setTimeout(function(){ hideLoad(); alert('Timed out. Try again.'); }, 15000);
      try {
        window.google.script.run
          .withSuccessHandler(function(res) {
            clearTimeout(tid1); hideLoad();
            if (!res || !res.ok) { alert('Column detection failed: ' + (res && res.error ? res.error : 'Unknown')); return; }
            self._cmDetectedMap = res.mapping;
            self._cmRenderMappingGrid(res.headers, res.mapping, res.totalRows);
            self._cmSetStep(2);
          })
          .withFailureHandler(function(err) {
            clearTimeout(tid1); hideLoad();
            alert('Column detection error: ' + (err && err.message ? err.message : String(err)));
          })
          .detectColumnMapping(this._cmSelectedTab);
      } catch(e) { clearTimeout(tid1); hideLoad(); alert('Error: ' + e); }

    } else if (this._cmStep === 2) {
      // Read current mapping from UI
      var mapping = {};
      ['task_name','best_case','most_likely','worst_case','risk_weight','active','notes'].forEach(function(field) {
        var sel = document.getElementById('cmMap_' + field);
        mapping[field] = sel ? parseInt(sel.value, 10) : -1;
      });
      if (mapping.task_name < 0 || mapping.best_case < 0 || mapping.most_likely < 0 || mapping.worst_case < 0) {
        alert('Please map at least: Task Name, Best Case, Most Likely, Worst Case.'); return;
      }
      showLoad('Importing rows from "' + (this._cmSelectedTab || '') + '"…');
      var tid2 = setTimeout(function(){ hideLoad(); alert('Timed out. Try again.'); }, 20000);
      try {
        window.google.script.run
          .withSuccessHandler(function(res) {
            clearTimeout(tid2); hideLoad();
            if (!res || !res.ok) { alert('Import failed: ' + (res && res.error ? res.error : 'Unknown')); return; }
            self._cmImportedTasks = res.tasks;
            self._cmRenderImportSummary(res);
            self._cmSetStep(3);
          })
          .withFailureHandler(function(err) {
            clearTimeout(tid2); hideLoad();
            alert('Import error: ' + (err && err.message ? err.message : String(err)));
          })
          .importFromExistingTab(this._cmSelectedTab, mapping);
      } catch(e2) { clearTimeout(tid2); hideLoad(); alert('Error: ' + e2); }

    } else if (this._cmStep === 3) {
      if (!this._cmImportedTasks || this._cmImportedTasks.length === 0) { alert('No valid tasks to import.'); return; }
      this._cmImportedTasks.forEach(function(t, i) {
        self.tasks.push({
          id:          'tid_import_' + Date.now() + '_' + i,
          task_name:   t.task_name,
          best_case:   t.best_case,
          most_likely: t.most_likely,
          worst_case:  t.worst_case,
          risk_weight: t.risk_weight,
          active:      t.active,
          notes:       t.notes
        });
      });
      this._markDirty();
      this.closeColMap();
      this._renderTaskList();
      this._syncToLegacy();
      this._updateBar();
    }
  },

  _cmRenderMappingGrid: function(headers, mapping, totalRows) {
    var selTabName = document.getElementById('cmSelectedTabName');
    if (selTabName) selTabName.textContent = this._cmSelectedTab;
    var status = document.getElementById('cmMapStatus');
    if (status) status.textContent = totalRows + ' data row(s) found. Adjust column mapping if needed.';

    var LABELS = {
      task_name: 'Task Name *', best_case: 'Best Case *', most_likely: 'Most Likely *',
      worst_case: 'Worst Case *', risk_weight: 'Risk Weight', active: 'Active', notes: 'Notes'
    };
    var options = '<option value="-1">(not mapped)</option>';
    headers.forEach(function(h, ci) { options += '<option value="' + ci + '">' + _escHtml(String(h)) + '</option>'; });

    var html = '';
    ['task_name','best_case','most_likely','worst_case','risk_weight','active','notes'].forEach(function(field) {
      var detected = mapping[field] >= 0 ? mapping[field] : -1;
      html += '<label>' + LABELS[field] + '</label>';
      html += '<select id="cmMap_' + field + '">' + options.replace('value="' + detected + '"', 'value="' + detected + '" selected') + '</select>';
    });
    var grid = document.getElementById('cmMappingGrid');
    if (grid) grid.innerHTML = html;
    // Re-apply selected values
    ['task_name','best_case','most_likely','worst_case','risk_weight','active','notes'].forEach(function(field) {
      var sel = document.getElementById('cmMap_' + field);
      if (sel && mapping[field] >= 0) sel.value = mapping[field];
    });
  },

  _cmRenderImportSummary: function(res) {
    var warnEl = document.getElementById('cmImportWarnings');
    var summEl = document.getElementById('cmImportSummary');
    if (summEl) summEl.textContent = res.tasks.length + ' task(s) imported. ' + (res.warnings && res.warnings.length > 0 ? res.warnings.length + ' warning(s).' : '');
    var warnHtml = '';
    if (res.warnings && res.warnings.length > 0) {
      warnHtml = '<div class="tm-warnings"><div class="warn-title">&#9888; Auto-corrections (' + res.warnings.length + ')</div><ul>';
      res.warnings.forEach(function(w) { warnHtml += '<li>' + _escHtml(w) + '</li>'; });
      warnHtml += '</ul></div>';
    }
    if (warnEl) warnEl.innerHTML = warnHtml;
  },

  closeColMap: function() {
    var bd = document.getElementById('tmColMapBackdrop');
    if (bd) bd.classList.remove('open');
  },

  /* ── Settings ── */
  openSettings: function() {
    var tabEl = document.getElementById('stTabName');
    var unitsEl = document.getElementById('stUnits');
    var custEl = document.getElementById('stCustomUnits');
    var custGroup = document.getElementById('stCustomUnitsGroup');
    if (tabEl) tabEl.value = this.settings.tabName || 'PMC Tasks';
    if (unitsEl) unitsEl.value = this.settings.units || 'days';
    if (custEl) custEl.value = this.settings.customUnits || '';
    if (custGroup) custGroup.style.display = (this.settings.units === 'custom') ? 'block' : 'none';
    if (unitsEl) unitsEl.onchange = function() {
      if (custGroup) custGroup.style.display = this.value === 'custom' ? 'block' : 'none';
    };
    var bd = document.getElementById('tmSettingsBackdrop');
    if (bd) bd.classList.add('open');
  },
  closeSettings: function() {
    var bd = document.getElementById('tmSettingsBackdrop');
    if (bd) bd.classList.remove('open');
  },
  _saveSettings: function() {
    var self = this;
    var tabEl = document.getElementById('stTabName');
    var unitsEl = document.getElementById('stUnits');
    var custEl = document.getElementById('stCustomUnits');
    this.settings.tabName = (tabEl ? tabEl.value.trim() : this.settings.tabName) || 'PMC Tasks';
    this.settings.units   = unitsEl ? unitsEl.value : 'days';
    if (this.settings.units === 'custom') this.settings.customUnits = custEl ? custEl.value.trim() : '';
    this.closeSettings();
    if (window.google && window.google.script && window.google.script.run) {
      try {
        window.google.script.run
          .withSuccessHandler(function(){})
          .withFailureHandler(function(){})
          .savePMCSettings(self.settings);
      } catch(e) { console.warn('savePMCSettings error:', e); }
    }
  },

  /* ── First-run ── */
  _showFirstRun: function() {
    var bd = document.getElementById('tmFirstRunBackdrop');
    if (bd) bd.classList.add('open');

    // Populate tab list — use injected server data first (always available)
    var self = this;
    function _populateTabList(tabs) {
      var list = document.getElementById('tmTabList');
      if (!list) return;
      list.innerHTML = '';
      (tabs || []).forEach(function(tab) {
        var div = document.createElement('div');
        div.className = 'tm-tab-item';
        div.textContent = tab.name;
        div.addEventListener('click', function() {
          document.querySelectorAll('#tmTabList .tm-tab-item').forEach(function(i){ i.classList.remove('selected'); });
          div.classList.add('selected');
          TM._frSelectedTab = tab.name;
        });
        list.appendChild(div);
      });
    }

    var serverData = window._PMC_SERVER_DATA;
    if (serverData && Array.isArray(serverData.sheetTabs) && serverData.sheetTabs.length > 0) {
      _populateTabList(serverData.sheetTabs);
    } else if (window.google && window.google.script && window.google.script.run) {
      try {
        window.google.script.run
          .withSuccessHandler(function(res) {
            var tabs = (res && res.sheetTabs) ? res.sheetTabs : [];
            if (!window._PMC_SERVER_DATA) window._PMC_SERVER_DATA = {};
            window._PMC_SERVER_DATA.sheetTabs = tabs;
            _populateTabList(tabs);
          })
          .withFailureHandler(function(){})
          .getAllTasks({ action: 'listTabs' });
      } catch(e) { console.warn('_showFirstRun getAllTasks listTabs error:', e); }
    }
  },
  _frSelected: null,
  _frSelectedTab: null,
  _frSelect: function(choice) {
    this._frChoice = choice;
    var cc = document.getElementById('frChoiceCreate');
    var ci = document.getElementById('frChoiceImport');
    var cs = document.getElementById('frCreateSection');
    var is = document.getElementById('frImportSection');
    if (cc) cc.classList.toggle('selected', choice === 'create');
    if (ci) ci.classList.toggle('selected', choice === 'import');
    if (cs) cs.style.display = choice === 'create' ? 'block' : 'none';
    if (is) is.style.display = choice === 'import' ? 'block' : 'none';
  },
  _frProceed: function() {
    var self = this;
    var loadEl = document.getElementById('frLoading');
    var msgEl  = document.getElementById('frLoadingMsg');
    if (loadEl) loadEl.classList.add('active');

    if (this._frChoice === 'create') {
      var tabNameEl = document.getElementById('frTabName');
      var tabName = tabNameEl ? tabNameEl.value.trim() : 'PMC Tasks';
      if (!tabName) tabName = 'PMC Tasks';
      if (msgEl) msgEl.textContent = 'Creating "' + tabName + '" tab…';
      try {
        window.google.script.run
          .withSuccessHandler(function(res) {
            if (loadEl) loadEl.classList.remove('active');
            if (!res || !res.ok) { alert('Failed to create tab: ' + (res && res.error ? res.error : '')); return; }
            self.settings.tabName = res.tabName;
            self.tasks = [];
            self.savedTasks = [];
            self.initialized = true;
            var bd = document.getElementById('tmFirstRunBackdrop');
            if (bd) bd.classList.remove('open');
            self._updateBar();
            self.openManager(); // Let user add tasks
          })
          .withFailureHandler(function(err) {
            if (loadEl) loadEl.classList.remove('active');
            alert('Error creating tab: ' + (err && err.message ? err.message : String(err)));
          })
          .initPMCTab(tabName);
      } catch(e) { if (loadEl) loadEl.classList.remove('active'); alert('Error: ' + e); }

    } else {
      // import from existing tab — chain three calls
      if (!this._frSelectedTab) { if (loadEl) loadEl.classList.remove('active'); alert('Please select a tab.'); return; }
      if (msgEl) msgEl.textContent = 'Setting up PMC Tasks tab…';
      try {
        window.google.script.run
          .withSuccessHandler(function(initRes) {
            if (!initRes || !initRes.ok) {
              if (loadEl) loadEl.classList.remove('active');
              alert('Failed to create PMC Tasks tab: ' + (initRes && initRes.error ? initRes.error : ''));
              return;
            }
            self.settings.tabName = initRes.tabName;
            if (msgEl) msgEl.textContent = 'Detecting columns in "' + self._frSelectedTab + '"…';
            try {
              window.google.script.run
                .withSuccessHandler(function(mapRes) {
                  if (!mapRes || !mapRes.ok) {
                    if (loadEl) loadEl.classList.remove('active');
                    alert('Column detection failed: ' + (mapRes && mapRes.error ? mapRes.error : ''));
                    return;
                  }
                  self._cmDetectedMap = mapRes.mapping;
                  if (msgEl) msgEl.textContent = 'Importing tasks…';
                  try {
                    window.google.script.run
                      .withSuccessHandler(function(importRes) {
                        if (loadEl) loadEl.classList.remove('active');
                        if (!importRes || !importRes.ok) { alert('Import failed.'); return; }
                        self.tasks = importRes.tasks.map(function(t, i) { return self._normalizeTask(t, i); });
                        self.savedTasks = JSON.parse(JSON.stringify(self.tasks));
                        self.initialized = true;
                        var bd = document.getElementById('tmFirstRunBackdrop');
                        if (bd) bd.classList.remove('open');
                        self._syncToLegacy();
                        self._updateBar();
                      })
                      .withFailureHandler(function(err) { if (loadEl) loadEl.classList.remove('active'); alert('Import error: ' + (err && err.message ? err.message : String(err))); })
                      .importFromExistingTab(self._frSelectedTab, mapRes.mapping);
                  } catch(e3) { if (loadEl) loadEl.classList.remove('active'); alert('Import call error: ' + e3); }
                })
                .withFailureHandler(function(err) { if (loadEl) loadEl.classList.remove('active'); alert('Column detect error: ' + (err && err.message ? err.message : String(err))); })
                .detectColumnMapping(self._frSelectedTab);
            } catch(e2) { if (loadEl) loadEl.classList.remove('active'); alert('Detect call error: ' + e2); }
          })
          .withFailureHandler(function(err) { if (loadEl) loadEl.classList.remove('active'); alert('Init error: ' + (err && err.message ? err.message : String(err))); })
          .initPMCTab('PMC Tasks');
      } catch(e) { if (loadEl) loadEl.classList.remove('active'); alert('Error: ' + e); }
    }
  },

  /* ── Generic confirm dialog ── */
  _confirm: function(title, msg, actionLabel, cb) {
    this._confirmCb = cb;
    var tEl = document.getElementById('confirmTitle');
    var mEl = document.getElementById('confirmMessage');
    var okEl= document.getElementById('confirmOkBtn');
    if (tEl) tEl.textContent = title;
    if (mEl) mEl.textContent = msg;
    if (okEl) okEl.textContent = actionLabel || 'Confirm';
    var bd = document.getElementById('tmConfirmBackdrop');
    if (bd) bd.classList.add('open');
  },
  _confirmClose: function(ok) {
    var bd = document.getElementById('tmConfirmBackdrop');
    if (bd) bd.classList.remove('open');
    if (ok && typeof this._confirmCb === 'function') { this._confirmCb(); }
    this._confirmCb = null;
  },

  /* ── Backdrop click to close ── */
  _backdropClose: function(ev, backdropId) {
    if (ev.target && ev.target.id === backdropId) {
      var bd = document.getElementById(backdropId);
      if (bd) bd.classList.remove('open');
    }
  }
};

/* ── Helper: escape HTML ── */
function _escHtml(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

/* ── Helper: parse a single CSV line (handles quoted fields) ── */
function _csvLine(line) {
  var result = [], cur = '', inQ = false;
  for (var i = 0; i < line.length; i++) {
    var ch = line[i];
    if (ch === '"') {
      if (inQ && line[i+1] === '"') { cur += '"'; i++; }
      else inQ = !inQ;
    } else if (ch === ',' && !inQ) { result.push(cur); cur = ''; }
    else { cur += ch; }
  }
  result.push(cur);
  return result;
}

/* ── Initialize TM on DOMContentLoaded ── */
document.addEventListener('DOMContentLoaded', function() {
  // Give existing loadTasks() a chance to run first, then TM.init()
  // TM overrides the task list after load
  setTimeout(function() { TM.init(); }, 200);
});

})();
</script>

</body>
</html>

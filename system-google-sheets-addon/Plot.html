<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Probability Plots</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Charts (rendering only) — defer so page renders immediately -->
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Zoom plugin -->
  <script defer src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  <!-- Export helpers -->
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- KaTeX for fast math rendering (~28KB, synchronous) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

  <!-- Three.js for 3D hypercube -->
  <script defer src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>

  <style>
    :root {
      --fg:#111827; --muted:#6B7280; --brand:#111827; --accent:#10B981; --accent2:#059669; --opt:#6D28D9;
      --line:#E5E7EB; --panel:#FFFFFF; --chip:#F3F4F6; --hover:#BFDBFE; --warn:#DC2626; --tab:#374151;
      --cdf:#3B82F6; --good:#059669; --bad:#F87171;

      /* Series color constants */
      --base:#10B981;        /* Your Estimate (Baseline) */
      --manual:#059669;      /* Explorer (Manual) */
      --fixed:#6D28D9;       /* Optimized (Fixed) */
      --adaptive:#F59E0B;    /* Guided (Adaptive) */
      --tri:#3B82F6;         /* Triangle */
      --beta:#7C3AED;        /* Beta-PERT */

      /* Category chips */
      --cat-capacity:#065f46; --cat-certainty:#1d4ed8; --cat-process:#7c3aed; --cat-behavioral:#b45309; --cat-other:#4b5563;
    }

    html,body{font-family:-apple-system,BlinkMacSystemFont,'Inter',sans-serif;color:var(--fg);background:var(--panel);margin:0;min-height:100%;}
    *{box-sizing:border-box;}
    .wrap{padding:12px 16px;max-width:1480px;margin:0 auto;}
    h1{font-size:16px;font-weight:700;margin:0 0 12px;letter-spacing:.2px;}
    label{font-size:12px;font-weight:600;color:var(--muted);letter-spacing:.2px;}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px 14px;box-shadow:0 2px 8px rgba(0,0,0,.08);}

    .toolbar-row{display:flex;gap:14px;align-items:center;flex-wrap:wrap;}
    .toolbar-row+.toolbar-row{margin-top:10px;padding-top:10px;border-top:1px solid var(--line);}
    .input-group{display:flex;flex-direction:column;gap:4px;}
    .input-group select,.input-group input{min-width:200px}
    .chip{background:var(--chip);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px;font-weight:500;min-height:44px;display:flex;align-items:center;}
    .toolbar-row select:hover,.toolbar-row select:focus,
    .toolbar-row button:hover,.kpi-group .kpi:hover{background:var(--hover);border-color:var(--hover);}
    .toolbar-row select{padding:6px 8px;border:1px solid var(--line);border-radius:8px;font-size:12px;font-weight:500;min-height:36px;}
    .toolbar-row button.primary{background:var(--brand);color:#fff;border-color:var(--brand);padding:6px 10px;border:1px solid var(--brand);border-radius:8px;font-size:12px;cursor:pointer;min-height:36px;}

    /* OMP inline bar */
    .omp-bar{display:inline-flex;align-items:center;gap:0;background:var(--chip);border:1px solid var(--line);border-radius:8px;padding:0;font-size:12px;font-weight:500;overflow:hidden;}
    .omp-bar .omp-item{padding:6px 12px;display:flex;align-items:center;gap:4px;white-space:nowrap;}
    .omp-bar .omp-item+.omp-item{border-left:1px solid var(--line);}
    .omp-bar .omp-label{color:var(--muted);font-weight:600;}
    .omp-bar .omp-val{font-family:'SF Mono',Consolas,monospace;font-weight:600;}
    .omp-bar .omp-item.pert{background:rgba(59,130,246,.08);}
    .omp-bar .omp-item.pert .omp-val{color:var(--cdf);}

    /* Target mode segmented control */
    .target-mode-toggle{display:inline-flex;border:1px solid var(--line);border-radius:8px;overflow:hidden;font-size:12px;font-weight:600;}
    .target-mode-btn{padding:6px 14px;cursor:pointer;background:var(--chip);color:var(--muted);border:none;transition:all .15s;}
    .target-mode-btn:hover{background:var(--hover);}
    .target-mode-btn.active{background:var(--brand);color:#fff;}
    .target-mode-btn+.target-mode-btn{border-left:1px solid var(--line);}

    /* Target result display */
    .target-result{display:inline-flex;align-items:center;gap:8px;font-size:13px;font-family:'SF Mono',Consolas,monospace;font-weight:600;min-width:140px;}
    .target-result .tr-val{color:var(--good);}
    .target-result .tr-arrow{color:var(--muted);font-size:10px;}
    .target-result .tr-prob{color:var(--cdf);}

    /* Status compact */
    .status-compact{display:flex;align-items:center;gap:6px;margin-left:auto;}
    .status{font-size:12px;color:#166534;font-weight:600;padding:6px 12px;border:2px solid #86EFAC;border-radius:8px;margin-left:auto;min-height:44px;display:flex;align-items:center;transition:all .3s;background:#F0FDF4;}
    .status.fetching{background:#FEF2F2;color:#991B1B;border-color:#FCA5A5;animation:fetchPulse 1.5s ease-in-out infinite;}
    @keyframes fetchPulse{0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,0.3);}50%{box-shadow:0 0 8px 2px rgba(239,68,68,0.3);}}
    .glow{animation:glow 1.1s ease-in-out infinite alternate;}
    @keyframes glow{
      from{ box-shadow:0 0 0 rgba(59,130,246,0.0); }
      to  { box-shadow:0 0 14px rgba(59,130,246,0.55); }
    }

    /* KPI tiles */
    .kpi-group{display:flex;gap:8px;justify-content:flex-start;flex-wrap:wrap;background:#F9FAFB;padding:8px;border-radius:10px;}
    .kpi{background:var(--panel);border:1px solid var(--line);border-radius:8px;padding:10px 14px;min-width:180px;min-height:48px;cursor:pointer;transition:background-color .2s, box-shadow .2s, opacity .2s;}
    .kpi .ttl{font-size:11px;color:var(--muted);margin-bottom:4px;letter-spacing:.2px;}
    .kpi .val{font-size:12px;font-weight:600;}
    .kpi.updating{box-shadow:0 0 12px rgba(59,130,246,.55);}
    .kpi.inactive{opacity:.45;cursor:pointer;}
    .kpi.baseline .val{color:var(--base);}
    .kpi.adjusted .val{color:var(--manual);}
    .kpi.optimized .val{color:var(--fixed);}
    .kpi.adaptive .val{color:var(--adaptive);}
    .kpi.active{outline:2px solid var(--tab);}

    /* Tabs row */
    .tabs{display:flex;gap:8px;margin:10px 0;flex-wrap:wrap;align-items:center;}
    .tab{font-size:12px;padding:6px 10px;border:1px solid var(--line);border-radius:8px;background:var(--panel);cursor:pointer;user-select:none;min-height:44px;}
    .tab:hover{background:var(--hover);border-color:var(--hover);}
    .tab.active{background:var(--tab);color:#fff;border-color:var(--tab);}

    /* Series toggles (overlay) */
    .series-toggles{display:none;align-items:center;gap:10px;margin-left:auto;}
    .series-toggles .tg{border:1px solid var(--line);border-radius:8px;background:#fff;padding:6px 10px;font-size:12px;cursor:pointer;min-height:36px;}
    .series-toggles .tg[aria-pressed="true"]{background:#111827;color:#fff;border-color:#111827;}
    .series-toggles .mini-status{font-size:12px;color:var(--muted);padding:6px 10px;border:1px solid var(--line);border-radius:8px;min-height:36px;}
    .series-toggles .toggle-group { display: inline-flex; gap: 4px; }
    .series-toggles .baseline-group { border-right: 1px solid var(--line); padding-right: 8px; margin-right: 8px; }

    /* Plot area */
    .plot-container{display:flex;flex-direction:column;gap:16px;position:relative;}
    .plots{flex:1 1 100%;}
    .plot{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,.08);position:relative;}
    .plot-inner{position:relative;height:min(420px,50vh);display:flex;gap:8px;flex-direction:row;}
    #pdfCanvas,#cdfCanvas{flex:1 1 0;min-width:0;height:100%!important;background:#FAFAFA;}

    /* Hypercube Radar Chart - side-by-side row below distribution plots */
    #hypercubeSection {
      display: none; /* Shown only in overlay tab */
    }
    #hypercubeSection.visible {
      display: flex;
      gap: 12px;
      margin-top: 12px;
    }
    #radarCard, #hypercube3DCard {
      flex: 1;
      min-width: 0;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:12px;
      padding:12px;
      box-shadow:0 2px 8px rgba(0,0,0,.08);
    }
    #hypercubeRadar {
      height: 320px !important;
      width: 100% !important;
    }
    #hypercube3D {
      height: 320px !important;
      width: 100% !important;
      background: #f8f9fa;
    }
    .plot-title {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 8px;
      text-align: center;
    }
    .plot-subtitle {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin-top: 4px;
    }
    .plot-desc{font-size:11px;color:var(--muted);line-height:1.5;margin-top:8px;padding:8px 10px;background:var(--chip);border-radius:8px;border-left:3px solid var(--cdf);}

    /* Right compare legend — HIDDEN */
    .right-legend{display:none!important;}

    .legend{font-size:12px;color:var(--muted);margin-top:6px;display:flex;gap:12px;flex-wrap:wrap;}
    .legend span{word-break:break-word;hyphens:auto;max-width:150px;overflow:hidden;text-overflow:ellipsis;white-space:normal;}
    .warn{color:var(--warn);font-size:12px;font-weight:500;margin-top:6px;background:rgba(220,38,38,.1);padding:6px 8px;border-radius:8px;}
    .legend-dot{width:10px;height:10px;border-radius:50%;display:inline-block;border:2px solid transparent;}
    .dot-base{border-color:var(--base);} .dot-man{border-color:var(--manual);} .dot-fix{border-color:var(--fixed);} .dot-adp{border-color:var(--adaptive);}
    .dot-tri{border-color:var(--tri);} .dot-beta{border-color:var(--beta);}

    /* Sidebar layout (overlay tab) */
    .plot-container.sidebar-active { flex-direction: row; }
    #sliderSidebar {
      display: none;
      width: 300px;
      min-width: 280px;
      max-width: 320px;
      flex-shrink: 0;
      overflow-y: auto;
      max-height: calc(100vh - 100px);
      padding: 12px 12px 24px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--panel);
      box-shadow: 0 2px 8px rgba(0,0,0,.08);
    }
    .plot-container.sidebar-active #sliderSidebar { display: block; }
    .plot-main { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 16px; }
    @media (max-width:800px) {
      .plot-container.sidebar-active { flex-direction: column; }
      #sliderSidebar { width: 100%; max-width: 100%; max-height: none; border-right: none; border-bottom: 1px solid var(--line); }
    }

    /* Slider panel inside sidebar */
    .sliders-panel .title { font-size: 14px; font-weight: 700; margin-bottom: 8px; color: var(--fg); }
    .sliders-panel .note { font-size: 11px; color: var(--muted); margin-bottom: 8px; }

    /* Slider categories */
    .slider-category { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--line); }
    .slider-category:last-of-type { border-bottom: none; }
    .cat-header { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
    .slider-row { margin-bottom: 8px; }
    .slider-row label { font-size: 12px; font-weight: 500; display: block; margin-bottom: 2px; color: var(--fg); }
    .slider-pair { display: flex; align-items: center; gap: 6px; }
    .slider-range {
      flex: 1; height: 6px; -webkit-appearance: none; appearance: none;
      background: var(--line); border-radius: 3px; outline: none; cursor: pointer;
    }
    .slider-range::-webkit-slider-thumb {
      -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%;
      background: var(--brand); cursor: pointer; border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,.2);
    }
    .slider-range::-moz-range-thumb {
      width: 16px; height: 16px; border-radius: 50%; background: var(--brand);
      cursor: pointer; border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,.2);
    }
    .slider-num {
      width: 52px; padding: 4px 6px; border: 1px solid var(--line); border-radius: 6px;
      font-size: 12px; text-align: center; font-weight: 500;
    }
    .slider-unit { font-size: 11px; color: var(--muted); min-width: 12px; }
    .slider-optimal-marker { height: 4px; position: relative; margin: -2px 0 0 0; }
    .slider-optimal-marker .marker-dot {
      position: absolute; width: 8px; height: 8px; background: var(--fixed);
      border-radius: 50%; top: -2px; transform: translateX(-50%);
      box-shadow: 0 0 4px rgba(109,40,217,.4);
    }
    .slider-range:disabled, .slider-num:disabled { opacity: 0.45; cursor: not-allowed; }
    .slider-actions { display: flex; gap: 6px; margin-top: 12px; }
    .slider-btn {
      flex: 1; padding: 8px 8px; border: 1px solid var(--line); border-radius: 8px;
      font-size: 11px; font-weight: 600; cursor: pointer; background: var(--panel);
    }
    .slider-btn:hover { background: var(--hover); border-color: var(--hover); }
    .slider-btn.primary { background: var(--brand); color: #fff; border-color: var(--brand); }
    .slider-btn.primary:hover { background: #0f172a; }

    /* Sensitivity bars */
    .sensitivity-panel { margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--line); }
    .sens-row { display: flex; align-items: center; gap: 6px; margin: 3px 0; font-size: 11px; }
    .sens-label { width: 70px; flex-shrink: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: var(--muted); }
    .sens-bar-track { flex: 1; height: 6px; background: var(--chip); border-radius: 3px; overflow: hidden; }
    .sens-bar-fill { height: 100%; border-radius: 3px; transition: width 0.3s ease; }
    .sens-bar-fill.positive { background: var(--accent); }
    .sens-bar-fill.negative { background: var(--warn); }
    .sens-val { min-width: 28px; text-align: right; font-size: 10px; color: var(--muted); }

    /* KPI natural language */
    .kpi-natural { font-size: 10px; font-weight: 400; color: var(--muted); margin-top: 2px; line-height: 1.3; }

    /* Recommendation banner */
    .rec-banner{margin-top:10px;padding:12px 16px;border-radius:10px;border-left:4px solid var(--muted);background:#F9FAFB;transition:border-color .3s,background .3s;}
    .rec-banner.rec-green{border-left-color:var(--good);background:#F0FDF4;}
    .rec-banner.rec-amber{border-left-color:#F59E0B;background:#FFFBEB;}
    .rec-banner.rec-red{border-left-color:#EF4444;background:#FEF2F2;}
    .rec-statement{font-size:13px;font-weight:600;line-height:1.5;color:var(--fg);}
    .rec-context{font-size:12px;color:var(--fg);margin-top:6px;line-height:1.55;font-weight:400;}
    .rec-details{font-size:11px;color:var(--muted);margin-top:6px;line-height:1.5;}
    .rec-warn{color:#B45309;font-weight:600;}
    .rec-banner.rec-red .rec-warn{color:#DC2626;}
    .rec-step{display:inline;}
    .rec-step::before{content:'\2192 ';font-weight:600;color:var(--cdf);}

    @media (max-width:900px) {
      #hypercubeSection.visible { flex-direction: column; }
    }
    @media (max-width:640px) {
      #hypercubeRadar, #hypercube3D { height: 260px !important; }
      .slider-pair { flex-wrap: wrap; }
      .slider-range { width: 100%; }
    }

    /* Live math & report */
    .live-math{display:none;margin-top:8px;}
    .live-math.active{display:block;}
    .lm-acc{border:1px solid var(--line);border-radius:12px;background:var(--panel);}
    .lm-acc-h{padding:10px;font-size:12px;font-weight:600;cursor:pointer;display:flex;justify-content:space-between;align-items:center;user-select:none;background:var(--chip);}
    .lm-acc-h:hover{background:var(--hover);}
    .lm-caret{display:inline-block;transition:transform .15s;margin-right:8px;}
    .lm-acc.open .lm-caret{transform:rotate(90deg);}
    .lm-acc-b{padding:10px;border-top:1px solid var(--line);display:none;font-size:12px;line-height:1.4;}
    .lm-acc.open .lm-acc-b{display:block;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}

    /* Reporting module styles */
    .rep-skel{opacity:.7}
    .rep-row{display:flex;gap:8px;align-items:center}
    .rep-badge{display:inline-block;border:1px solid var(--line);background:var(--chip);border-radius:999px;padding:2px 6px;font-size:11px;margin-left:6px;}
    .rep-good{color:var(--good)} .rep-bad{color:var(--bad)}
    .rep-note{font-size:12px;color:var(--muted)}
    .rep-card{border:1px solid var(--line);border-radius:10px;padding:8px;margin-top:8px;background:var(--panel)}
    .rep-tbl{width:100%;border-collapse:collapse;font-size:12px}
    .rep-tbl th,.rep-tbl td{border:1px solid var(--line);padding:6px 8px;text-align:left;vertical-align:top}
    .rep-tbl th{background:#F3F4F6;font-weight:600}
    .rep-tornado-bar { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    .rep-tornado-bar .rep-bar { display:flex; align-items:center; gap:6px; padding:0 6px; flex:1; height: 20px; background: var(--line); border-radius: 10px; position: relative; }
    .rep-tornado-bar .rep-fill { height: 100%; border-radius:  10px; }
    .rep-tornado-bar.rep-positive .rep-fill { background: var(--accent); }
    .rep-tornado-bar.rep-negative .rep-fill { background: var(--warn); }

    @media (max-width:640px){
      .wrap{padding:6px;}
      .toolbar-row{flex-wrap:wrap;gap:8px;}
      .omp-bar{font-size:11px;}
      .target-mode-toggle{font-size:11px;}
      .kpi-group{flex-direction:column;}
      .kpi{min-width:100%;}
      #pdfCanvas,#cdfCanvas{max-width:100%;}
      .plot-inner{flex-direction:column;height:auto;}
      .series-toggles{width:100%;justify-content:flex-start;margin-left:0;}
    }

    /* Help icon button */
    .plot-help-btn {
      position: absolute; top: 6px; right: 6px; z-index: 10;
      width: 24px; height: 24px; border-radius: 50%;
      border: 1px solid var(--line); background: #fff; color: var(--muted);
      font-size: 13px; font-weight: 700; line-height: 22px; text-align: center;
      cursor: pointer; transition: all .15s;
    }
    .plot-help-btn:hover { background: var(--hover); color: var(--fg); border-color: var(--hover); }

    /* Help popup */
    .plot-help-popup {
      display: none; position: absolute; top: 34px; right: 6px; z-index: 100;
      width: 340px; max-height: 400px; overflow-y: auto;
      background: #fff; border: 1px solid var(--line); border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,.14); padding: 14px 16px;
      font-size: 12px; line-height: 1.55; color: var(--fg);
    }
    .plot-help-popup.visible { display: block; }
    .plot-help-popup h4 { margin: 0 0 6px; font-size: 13px; font-weight: 700; }
    .plot-help-popup p { margin: 0 0 8px; }
    .plot-help-popup ul { margin: 4px 0 8px; padding-left: 18px; }
    .plot-help-popup li { margin-bottom: 3px; }
    .plot-help-popup .help-section { margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
    .plot-help-popup .help-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .plot-help-popup .help-stat { display: inline-block; background: #F3F4F6; padding: 2px 7px; border-radius: 4px; font-weight: 600; margin: 1px 2px; }
  </style>
</head>

<body>
  <div id="errorBanner" style="display:none;background:#FEE2E2;color:#991B1B;padding:8px 12px;font-size:12px;font-family:monospace;position:fixed;top:0;left:0;right:0;z-index:9999;max-height:200px;overflow-y:auto;border-bottom:2px solid #DC2626;"></div>
  <script>
  window.onerror = function(msg, url, line, col) {
    var b = document.getElementById('errorBanner');
    if (b) { b.style.display = 'block'; b.innerHTML += '<div>JS Error: ' + msg + ' (line ' + line + ':' + col + ')</div>'; }
    return false;
  };
  </script>
  <div class="wrap">
    <h1 title="Probability Plots Dashboard">Probability Plots</h1>

<div class="card">
  <!-- Row 1: Task selector + OMP bar + Status/Refresh -->
  <div class="toolbar-row">
    <div class="input-group" style="flex-direction:row;align-items:center;gap:6px;">
      <label style="margin:0;">Task:</label>
      <select id="taskSel" title="Select a task"></select>
    </div>

    <div class="omp-bar" title="Optimistic / Most Likely / Pessimistic / PERT Mean">
      <span class="omp-item"><span class="omp-label">O:</span><span class="omp-val" id="oVal">–</span></span>
      <span class="omp-item"><span class="omp-label">M:</span><span class="omp-val" id="mVal">–</span></span>
      <span class="omp-item"><span class="omp-label">P:</span><span class="omp-val" id="pVal">–</span></span>
      <span class="omp-item pert"><span class="omp-label">PERT:</span><span class="omp-val" id="pertVal">–</span></span>
    </div>

    <div class="status-compact">
      <span id="fetchStatus" class="status" style="min-height:32px;padding:4px 10px;font-size:11px;">Ready</span>
      <button id="refreshBtn" class="primary" style="min-height:32px;padding:4px 10px;font-size:11px;">&#x21bb;</button>
    </div>
  </div>

  <!-- Row 2: Target mode toggle + Slider + Result display -->
  <div class="toolbar-row">
    <label style="margin:0;white-space:nowrap;">Target:</label>
    <div class="target-mode-toggle">
      <button class="target-mode-btn active" data-mode="value" onclick="onTargetModeSwitch('value')">Value</button>
      <button class="target-mode-btn" data-mode="probability" onclick="onTargetModeSwitch('probability')">Probability</button>
    </div>
    <input id="targetSlider" type="range" min="-10" max="110" step="any" value="50" title="Slide to set target" style="flex:1;min-width:120px;" />
    <div class="target-result">
      <span class="tr-val" id="targetValDisplay">–</span>
      <span class="tr-arrow">&#x2192;</span>
      <span class="tr-prob" id="targetProbDisplay">–</span>
    </div>
  </div>
</div>

<!-- TABS + KPI GROUP -->
<div class="tabs" id="tabs">
  <div class="tab active" data-tab="progress" title="See how your 3-point estimate builds into a probability distribution, step by step.">How It's Built</div>
  <div class="tab" data-tab="overlay" title="Compare your estimate against Guided, Optimized, and Explorer scenarios to find the best strategy.">Compare Strategies</div>
  <div class="series-toggles" id="seriesToggles">
    <div class="toggle-group baseline-group">
      <button class="tg" id="rowTglBase" role="switch" aria-pressed="true" title="Toggle Your Estimate curve">Your Estimate</button>
      <button class="tg" id="rowTglAdaptive" role="switch" aria-pressed="false" title="Guided — conservative optimization with tightest constraints">Guided</button>
    </div>
    <div class="toggle-group manual-group">
      <button class="tg" id="rowTglFixed" role="switch" aria-pressed="false" title="Optimized — best within standard boundaries">Optimized</button>
      <button class="tg" id="rowTglManual" role="switch" aria-pressed="false" title="Explorer — unconstrained what-if analysis">Explorer</button>
    </div>

  </div>

  <div class="kpi-group" id="distTiles" style="display:flex; margin-left:auto;">
    <div class="kpi" id="kpiTriangle" title="Triangle">
      <div class="ttl">Triangle</div>
      <div class="val" style="color:var(--tri);">Curve</div>
    </div>
    <div class="kpi" id="kpiBeta" title="Beta-PERT">
      <div class="ttl">Beta-PERT</div>
      <div class="val" style="color:var(--beta);">Curve</div>
    </div>
    <div class="kpi baseline" id="kpiBaseDist" title="Baseline (Monte Carlo)">
      <div class="ttl">Baseline</div>
      <div class="val" style="color:var(--base);">Curve</div>
    </div>
  </div>
</div>

<!-- Progress tab description banner — shows under "How It's Built" tab -->
<div id="progressDescBanner" class="rec-banner" style="display:none;border-left-color:var(--cdf);background:#EFF6FF;">
  <div class="rec-statement" id="progressDescStatement"></div>
  <div class="rec-context" id="progressDescContext"></div>
</div>

<!-- KPI tiles for overlay — ordered: Baseline → Adaptive (strictest) → Fixed (standard) → Manual (unconstrained) -->
<div class="card" id="overlayKpis" style="display:none;">
  <div class="kpi-group">
    <div class="kpi baseline inactive" id="kpiBaseline" title="Your Estimate — your original 3-point estimate probability with no optimization applied. This is your starting point.">
      <div class="ttl">Your Estimate</div>
      <div class="val">–</div>
    </div>
    <div class="kpi adaptive inactive" id="kpiAdaptive" title="Guided — conservative optimization within the tightest industry best-practice constraints at your chosen level. Most defensible and standards-aligned.">
      <div class="ttl">Guided</div>
      <div class="val">–</div>
    </div>
    <div id="probeBox" class="chip" style="display:none; align-items:center; gap:6px; min-height:36px; padding:6px 10px;">
      <span style="font-weight:600;">Level:</span>
      <select id="probeSelect" title="Guided optimization level (1–7). Higher levels apply tighter best-practice constraints." style="font-size:12px; padding:4px 6px; border:1px solid var(--line); border-radius:8px; height:28px;">
        <option value="1">1</option><option value="2">2</option><option value="3" selected>3</option>
        <option value="4">4</option><option value="5">5</option><option value="6">6</option><option value="7">7</option>
      </select>
    </div>
    <div class="kpi optimized inactive" id="kpiOptimized" title="Optimized — system finds the best probability improvement within standard boundaries. Wider than Guided, yielding higher probability.">
      <div class="ttl">Optimized</div>
      <div class="val">–</div>
    </div>
    <div class="kpi adjusted inactive" id="kpiAdjusted" title="Explorer — set any slider values freely. Highest potential but not validated against best practices. Full control for what-if analysis.">
      <div class="ttl">Explorer</div>
      <div class="val">–</div>
    </div>
  </div>
  <div id="recBanner" class="rec-banner" style="display:none;">
    <div class="rec-statement" id="recStatement"></div>
    <div class="rec-context" id="recContext"></div>
    <div class="rec-details" id="recDetails"></div>
  </div>
</div>

<!-- Probability Summary Bar: τ · Baseline P₀ · one chip per active strategy -->
<div id="probSummaryBar" style="display:none; flex-wrap:wrap; gap:6px; align-items:center; padding:6px 12px; margin-bottom:6px; background:rgba(248,250,255,0.97); border:1px solid rgba(148,163,184,0.30); border-radius:8px; font-size:11px; line-height:1;">
  <span style="font-size:10px; color:#94a3b8; font-weight:600; white-space:nowrap; margin-right:2px;">AT TARGET:</span>
  <span id="psbTau"       style="padding:2px 8px; border-radius:12px; background:#FEF3C7; color:#92400E; border:1px solid rgba(245,158,11,0.45); font-weight:700; white-space:nowrap;"></span>
  <span id="psbBase"      style="padding:2px 8px; border-radius:12px; background:#F1F5F9; color:#475569; border:1px solid rgba(148,163,184,0.40); font-weight:600; white-space:nowrap;"></span>
  <span id="psbGuided"    style="display:none; padding:2px 8px; border-radius:12px; background:rgba(139,92,246,0.08); color:#6d28d9; border:1px solid rgba(139,92,246,0.40); font-weight:600; white-space:nowrap;"></span>
  <span id="psbOptimized" style="display:none; padding:2px 8px; border-radius:12px; background:rgba(59,130,246,0.08); color:#1d4ed8; border:1px solid rgba(59,130,246,0.40); font-weight:600; white-space:nowrap;"></span>
  <span id="psbExplorer"  style="display:none; padding:2px 8px; border-radius:12px; background:rgba(16,185,129,0.08); color:#065f46; border:1px solid rgba(16,185,129,0.40); font-weight:600; white-space:nowrap;"></span>
</div>

<!-- Main plot container with sidebar layout for overlay tab -->
<div class="plot-container" id="plotContainer">

  <!-- Sidebar: Decision Sliders (visible only in overlay tab) -->
  <div id="sliderSidebar" role="complementary" aria-label="Decision Sliders">
    <div id="slidersPanel" class="sliders-panel">
      <div class="title" id="sliderTitle">Decision Sliders</div>
      <div class="note" id="optimizeNote">
        Drag sliders or type values to reshape the probability distribution.
      </div>
      <div id="sliderImpactBanner" style="display:none; margin:6px 0 8px; padding:8px 10px; border-radius:6px; font-size:12px; line-height:1.5; background:#F0FDF4; border:1px solid #86EFAC; color:#166534;">
      </div>

      <!-- Capacity -->
      <div class="slider-category" data-cat="capacity">
        <div class="cat-header" style="color:var(--cat-capacity)">Capacity</div>
        <div class="slider-row" data-key="budgetFlexibility">
          <label for="s_budget">Budget Flexibility</label>
          <div class="slider-pair">
            <input type="range" id="s_budget_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Budget Flexibility slider">
            <input type="number" id="s_budget" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_budget_marker"></div>
        </div>
        <div class="slider-row" data-key="scheduleFlexibility">
          <label for="s_schedule">Schedule Flexibility</label>
          <div class="slider-pair">
            <input type="range" id="s_schedule_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Schedule Flexibility slider">
            <input type="number" id="s_schedule" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_schedule_marker"></div>
        </div>
      </div>

      <!-- Certainty -->
      <div class="slider-category" data-cat="certainty">
        <div class="cat-header" style="color:var(--cat-certainty)">Certainty</div>
        <div class="slider-row" data-key="scopeCertainty">
          <label for="s_scopeCert">Scope Certainty</label>
          <div class="slider-pair">
            <input type="range" id="s_scopeCert_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Scope Certainty slider">
            <input type="number" id="s_scopeCert" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_scopeCert_marker"></div>
        </div>
        <div class="slider-row" data-key="scopeReductionAllowance">
          <label for="s_scopeRed">Scope Reduction</label>
          <div class="slider-pair">
            <input type="range" id="s_scopeRed_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Scope Reduction slider">
            <input type="number" id="s_scopeRed" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_scopeRed_marker"></div>
        </div>
      </div>

      <!-- Process -->
      <div class="slider-category" data-cat="process">
        <div class="cat-header" style="color:var(--cat-process)">Process</div>
        <div class="slider-row" data-key="reworkPercentage">
          <label for="s_rework">Rework Percentage</label>
          <div class="slider-pair">
            <input type="range" id="s_rework_range" min="0" max="50" step="1" value="0" class="slider-range" aria-label="Rework Percentage slider">
            <input type="number" id="s_rework" min="0" max="50" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_rework_marker"></div>
        </div>
      </div>

      <!-- Behavioral -->
      <div class="slider-category" data-cat="behavioral">
        <div class="cat-header" style="color:var(--cat-behavioral)">Behavioral</div>
        <div class="slider-row" data-key="riskTolerance">
          <label for="s_risk">Risk Tolerance</label>
          <div class="slider-pair">
            <input type="range" id="s_risk_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="Risk Tolerance slider">
            <input type="number" id="s_risk" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_risk_marker"></div>
        </div>
        <div class="slider-row" data-key="userConfidence">
          <label for="s_userConf">User Confidence</label>
          <div class="slider-pair">
            <input type="range" id="s_userConf_range" min="0" max="100" step="1" value="0" class="slider-range" aria-label="User Confidence slider">
            <input type="number" id="s_userConf" min="0" max="100" step="1" value="0" class="slider-num">
            <span class="slider-unit">%</span>
          </div>
          <div class="slider-optimal-marker" id="s_userConf_marker"></div>
        </div>
      </div>

      <div class="slider-actions">
        <button id="resetBaseline" class="slider-btn">Reset to Baseline</button>
        <button id="matchOptimized" class="slider-btn primary">Match Optimized</button>
      </div>

      <div id="slidersNoteMissing" class="note" style="display:none;">Server did not return optimal slider values.</div>
    </div>

    <!-- Sensitivity bars -->
    <div id="sensitivityBars" class="sensitivity-panel" style="display:none;">
      <div class="cat-header" style="color:var(--muted)">Sensitivity (Relative Impact)</div>
      <div id="sensitivityContent"></div>
    </div>
  </div>

  <!-- Main content area -->
  <div class="plot-main">
    <!-- Main PDF/CDF plots -->
    <div class="plots">
      <div class="plot" style="position:relative;">
        <div style="display:flex; justify-content:flex-end; padding:0 4px 4px 0; gap:6px; align-items:center;">
          <button class="plot-help-btn" data-help="distributions" title="What do these charts show?" style="position:static;">?</button>
          <button id="resetZoomBtn" title="Reset zoom/pan on both charts" style="font-size:11px; padding:3px 10px; border:1px solid var(--line); border-radius:6px; background:#fff; cursor:pointer; color:#6B7280;">Reset Zoom</button>
        </div>
        <div id="distributionsHelpPopup" class="plot-help-popup"></div>
        <div class="plot-inner">
          <canvas id="pdfCanvas" title="Probability Density Function (PDF)"></canvas>
          <canvas id="cdfCanvas" title="Cumulative Distribution Function (CDF)"></canvas>
          <div class="right-legend" id="rightLegend" aria-live="polite"></div>
        </div>

        <div class="legend" id="legendOverlay">
          <span><span class="legend-dot dot-base"></span>Your Estimate</span>
          <span><span class="legend-dot dot-man"></span>Explorer</span>
          <span><span class="legend-dot dot-fix"></span>Optimized</span>
          <span><span class="legend-dot dot-adp"></span>Guided</span>
        </div>
        <div class="legend" id="legendDistributions" style="display:flex;">
          <span><span class="legend-dot dot-tri"></span>Triangle</span>
          <span><span class="legend-dot dot-beta"></span>Beta-PERT</span>
          <span><span class="legend-dot dot-base"></span>Your Estimate</span>
        </div>

        <div id="plotMsg" class="warn" style="display:none;"></div>
        <div id="chartDesc" class="plot-desc" style="display:none;"></div>
      </div>
    </div>

    <!-- Hypercube Radar - separate card below the main plots -->
    <div id="hypercubeSection">
      <div id="radarCard" class="card" style="position:relative;">
        <button class="plot-help-btn" data-help="radar" title="What does this chart show?">?</button>
        <div id="radarHelpPopup" class="plot-help-popup"></div>
        <div class="plot-title">Slider Profile</div>
        <canvas id="hypercubeRadar"></canvas>
        <div id="radarSubtitle" class="plot-subtitle"></div>
        <div id="radarDesc" class="plot-desc" style="display:none;"></div>
      </div>
      <div id="hypercube3DCard" class="card" style="position:relative;">
        <button class="plot-help-btn" data-help="hypercube" title="What does this chart show?">?</button>
        <div id="hypercubeHelpPopup" class="plot-help-popup"></div>
        <div class="plot-title">Parameter Space (3D)</div>
        <canvas id="hypercube3D"></canvas>
        <div id="hypercubeSubtitle" class="plot-subtitle"></div>
        <div id="hypercubeDesc" class="plot-desc" style="display:none;"></div>
      </div>
    </div>

    <!-- SACO 3D Surface + Probability Sphere (visible in Compare Strategies tab only) -->
    <div id="sacoVizSection" style="display:none; margin-top:12px;">
      <div style="display:flex;gap:14px;flex-wrap:wrap;align-items:flex-start;">

        <!-- Left: SACO 3D Probability Surface (Three.js) -->
        <div style="flex:3;min-width:0;">
          <div class="card" style="padding:12px 14px;">
            <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;flex-wrap:wrap;">
              <div style="font-size:13px;font-weight:700;">SACO 3D Probability Surface</div>
              <div id="saco3dStratLabel" style="font-size:11px;color:var(--muted);margin-left:auto;"></div>
            </div>
            <!-- HUD metrics -->
            <div id="saco3dHud" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:4px;font-size:11px;font-family:ui-monospace,monospace;">
              <div style="padding:4px 8px;border-radius:6px;background:#F3F4F6;border:1px solid var(--line);">
                <span style="color:var(--muted);">F₀(τ)</span>&nbsp;<strong id="hudF0">–</strong>
              </div>
              <div style="padding:4px 8px;border-radius:6px;background:#EFF6FF;border:1px solid #93C5FD;">
                <span style="color:var(--muted);">F(τ)</span>&nbsp;<strong id="hudF" style="color:#3B82F6;">–</strong>
              </div>
              <div style="padding:4px 8px;border-radius:6px;background:#F0FDF4;border:1px solid #86EFAC;">
                <span style="color:var(--muted);">ΔP</span>&nbsp;<strong id="hudDeltaP" style="color:#16A34A;">–</strong>
              </div>
              <div style="padding:4px 8px;border-radius:6px;background:#F9FAFB;border:1px solid var(--line);">
                <span style="color:var(--muted);">∫Δf</span>&nbsp;<strong id="hudIntDelta">–</strong>
              </div>
            </div>
            <!-- All-active-strategies comparison row (shown when multiple are active) -->
            <div id="saco3dStratRow" style="display:none; flex-wrap:wrap; gap:4px; align-items:center; margin-bottom:8px; font-size:10px; font-family:ui-monospace,monospace; padding:4px 0;">
              <span style="color:var(--muted); font-size:9px; letter-spacing:.04em; font-weight:600;">ALL ACTIVE AT τ:</span>
              <span id="saco3dChipBase"      style="display:none; padding:1px 6px; border-radius:10px; background:#F1F5F9; color:#475569; border:1px solid rgba(148,163,184,0.45); font-weight:600;"></span>
              <span id="saco3dChipGuided"    style="display:none; padding:1px 6px; border-radius:10px; background:rgba(139,92,246,0.09); color:#6d28d9; border:1px solid rgba(139,92,246,0.40); font-weight:600;"></span>
              <span id="saco3dChipOptimized" style="display:none; padding:1px 6px; border-radius:10px; background:rgba(59,130,246,0.09);  color:#1d4ed8; border:1px solid rgba(59,130,246,0.40);  font-weight:600;"></span>
              <span id="saco3dChipExplorer"  style="display:none; padding:1px 6px; border-radius:10px; background:rgba(16,185,129,0.09); color:#065f46; border:1px solid rgba(16,185,129,0.40); font-weight:600;"></span>
            </div>
            <!-- Three.js renders into this div -->
            <div id="saco3dContainer" style="width:100%;height:420px;border:1px solid var(--line);border-radius:8px;background:#F8FAFF;overflow:hidden;position:relative;"></div>
            <div style="font-size:10px;color:var(--muted);margin-top:6px;line-height:1.5;">
              <strong>Gray ribbon</strong> = baseline f₀(x) &nbsp;·&nbsp; <strong>Colored ribbon</strong> = active strategy with Δ heatmap
              (blue/cool = probability mass removed; amber/red/warm = mass added) &nbsp;·&nbsp;
              <strong>Amber plane</strong> = target τ &nbsp;·&nbsp; <strong>Ring</strong> = normalized slider profile.
              Callout labels show P and ΔP for all active strategies at τ. Drag to rotate.
            </div>
          </div>
        </div>

        <!-- Right: Probability Sphere -->
        <div style="flex:0 0 400px;max-width:400px;">
          <div class="card" style="padding:12px 14px;">
            <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px;">
              <div style="font-size:13px;font-weight:700;">Probability Sphere</div>
              <div id="sphereStratLabel" style="font-size:11px;color:var(--muted);margin-left:auto;"></div>
            </div>
            <!-- Full-width sphere, same height as SACO 3D canvas -->
            <div id="sphereContainer" style="width:100%;height:360px;border-radius:12px;overflow:hidden;background:#F0F4FA;border:1px solid rgba(140,170,220,0.35);margin-bottom:8px;"></div>
            <!-- Compact horizontal stats strip -->
            <div style="display:flex;gap:5px;font-family:ui-monospace,monospace;margin-bottom:6px;">
              <div style="flex:1;padding:6px 8px;border-radius:7px;background:#F3F4F6;border:1px solid var(--line);">
                <div style="color:var(--muted);font-size:9px;letter-spacing:.04em;margin-bottom:1px;">BASELINE P₀</div>
                <div style="font-size:15px;font-weight:800;" id="sphereP0">–</div>
              </div>
              <div style="flex:1;padding:6px 8px;border-radius:7px;background:#EFF6FF;border:1px solid #93C5FD;">
                <div style="color:var(--muted);font-size:9px;letter-spacing:.04em;margin-bottom:1px;">CURRENT P</div>
                <div style="font-size:15px;font-weight:800;color:#3B82F6;" id="sphereP">–</div>
              </div>
              <div style="flex:1;padding:6px 8px;border-radius:7px;background:#F0FDF4;border:1px solid #86EFAC;">
                <div style="color:var(--muted);font-size:9px;letter-spacing:.04em;margin-bottom:1px;">LIFT ΔP</div>
                <div style="font-size:15px;font-weight:800;color:#16A34A;" id="sphereDeltaP">–</div>
              </div>
            </div>
            <!-- All-active-strategies row for sphere card -->
            <div id="sphereStratRow" style="display:none; flex-wrap:wrap; gap:4px; align-items:center; margin-top:8px; font-size:10px; font-family:ui-monospace,monospace; padding:6px 8px; background:rgba(248,250,255,0.95); border:1px solid rgba(148,163,184,0.25); border-radius:8px;">
              <span style="color:var(--muted); font-size:9px; letter-spacing:.04em; font-weight:600; width:100%; margin-bottom:3px;">ALL ACTIVE AT TARGET τ:</span>
              <span id="sphChipBase"      style="display:none; padding:2px 7px; border-radius:10px; background:#F1F5F9; color:#475569; border:1px solid rgba(148,163,184,0.45); font-weight:600;"></span>
              <span id="sphChipGuided"    style="display:none; padding:2px 7px; border-radius:10px; background:rgba(139,92,246,0.09); color:#6d28d9; border:1px solid rgba(139,92,246,0.40); font-weight:600;"></span>
              <span id="sphChipOptimized" style="display:none; padding:2px 7px; border-radius:10px; background:rgba(59,130,246,0.09);  color:#1d4ed8; border:1px solid rgba(59,130,246,0.40);  font-weight:600;"></span>
              <span id="sphChipExplorer"  style="display:none; padding:2px 7px; border-radius:10px; background:rgba(16,185,129,0.09); color:#065f46; border:1px solid rgba(16,185,129,0.40); font-weight:600;"></span>
            </div>
            <div style="font-size:10px;color:var(--muted);margin-top:6px;line-height:1.5;">
              Fill height h solves V(h)/V_sphere = P via spherical cap V(h)=πh²(3R−h)/3.
              Gray = baseline. Colored fill = active strategy lift above baseline.
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- Decision Report (Overlay) -->
    <div id="decisionReport" class="live-math" aria-live="polite" style="margin-top:8px;"></div>

    <!-- Live math (Overlay) -->
    <div id="overlayMath" class="live-math" aria-live="polite"></div>
  </div>
</div>

<!-- Toast -->
<div id="toast" style="display:none;position:fixed;top:20px;right:20px;background:var(--accent);color:#fff;padding:12px;border-radius:8px;z-index:1002;">Tip</div>  </div>

  <!-- Show/Hide sections based on active tab -->
  <script>
    function updateTabSections() {
      const overlayTab = document.querySelector('.tab[data-tab="overlay"]');
      const hypercubeSection = document.getElementById('hypercubeSection');
      const sacoVizSection = document.getElementById('sacoVizSection');
      const isOverlay = overlayTab && overlayTab.classList.contains('active');

      if (hypercubeSection)
        hypercubeSection.classList.toggle('visible', isOverlay);
      if (sacoVizSection)
        sacoVizSection.style.display = isOverlay ? '' : 'none';

      if (isOverlay) {
        if (window.PMCSaco3D) setTimeout(function() { window.PMCSaco3D.render(); }, 120);
        if (window.PMCSphere) setTimeout(function() { window.PMCSphere.render(); }, 120);
      }
    }
    function updateHypercubeVisibility() { updateTabSections(); }
    document.addEventListener('DOMContentLoaded', updateTabSections);
    const tabObserver = new MutationObserver(updateTabSections);
    document.querySelectorAll('.tab').forEach(tab => {
      tabObserver.observe(tab, { attributes: true, attributeFilter: ['class'] });
    });
  </script>

  <!-- Sidebar visibility is now controlled by .sidebar-active class on .plot-container -->

  <!-- Reporting visibility + skeleton -->
  <script>
  (() => {
    function onReady(fn){
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn, { once: true });
      } else { fn(); }
    }
    function renderReportSkeletonOrFull(forceSkeleton=false) {
      const tryRender = () => {
        if (window.PMCReport) {
          if (forceSkeleton) window.PMCReport.renderAll(true);
          else window.PMCReport.scheduleRender();
          const dr = document.getElementById('decisionReport');
          const om = document.getElementById('overlayMath');
          if (false && window.MathJax && window.MathJax.typesetPromise && (dr || om)) {
            window.MathJax.typesetPromise([dr, om].filter(Boolean)).catch(()=>{});
          }
          return true;
        }
        return false;
      };
      if (tryRender()) return;
      let tries = 0;
      const h = setInterval(() => { tries += 1; if (tryRender() || tries > 60) clearInterval(h); }, 50);
    }
    function ensureReportVisibleWhenOverlayActive() {
      const overlayTab = document.querySelector('.tab[data-tab="overlay"]');
      const dr = document.getElementById('decisionReport');
      const om = document.getElementById('overlayMath');
      if (!overlayTab || !dr || !om) return;
      const isActive = () => overlayTab.classList.contains('active');
      const showIfActive = () => { if (!isActive()) return; dr.classList.add('active'); om.classList.add('active'); renderReportSkeletonOrFull(false); };
      overlayTab.addEventListener('click', showIfActive);
      // PMCReport handles its own event listeners — no duplicates needed here
      showIfActive();
    }
    onReady(() => { ensureReportVisibleWhenOverlayActive(); renderReportSkeletonOrFull(true); });
  })();
  </script>

  <!-- SHIMS -->
  <script>
  (function(){
    if (!window.renderKPIs)           window.renderKPIs = function(){};
    if (!window.renderRightLegend)    window.renderRightLegend = function(){};
    if (!window.updateChart)          window.updateChart = function(){};
    if (!window.renderDecisionReport) window.renderDecisionReport = function(){};
    if (!window.renderOverlayMath)    window.renderOverlayMath = function(){};
    console.debug('[Section 6] Shims installed — real renderers attach in Section 8.');
  })();
  </script>

  <!-- Core State, Helpers, Charts & Overlay Series Model -->
  <script>
    const S = {
      task: null, tasks: [],
      O: null, M: null, P: null,
      target: null,
      targetMode: 'value',   // 'value' or 'probability'
      targetProb: null,       // stores probability (0–1) when in probability mode
      targetSliderMin: null,
      targetSliderMax: null,

      tab: 'progress',
      mode: 'inspect',
      prevMode: null,

      progress: { triOn: true, betaOn: false, baseOn: false },

      overlay: {
        baselineOn: true,
        manualOn: false,
        fixedOn: false,
        adaptiveOn: false,
        probeLevel: 3,
        variants: {
          manual:   { loading: false, error: null, token: 0 },
          fixed:    { loading: false, error: null, token: 0 },
          adaptive: { loading: false, error: null, token: 0 }
        }
      },

      pendingVariants: 0,

      trianglePdf: [], triangleCdf: [],
      betaPertPdf: [], betaPertCdf: [],
      basePdf: [], baseCdf: [],
      adjPdf: [], adjCdf: [],
      optPdfFixed: [], optCdfFixed: [],
      optPdfAdaptive: [], optCdfAdaptive: [],

      baselineProb: null,
      adjustedProb: null,
      optimizedProb: null,
      adaptiveProb: null,

      pdfChart: null, cdfChart: null,

      fetching: false,
      fetchTimer: null,
      baselineCache: {},
      variantCache: {},

      liveMathPending: false,
      explainAdj: null,
      explainOpt: null,
      explainAdaptive: null,
      explainBase: null,
      lastPayload: null,

      optRefetchAttempted: false,
      slidersEnabled: true,
      currentGain: null,
      currentWeights: { budget: 0.20, schedule: 0.20, scopeCert: 0.20, scopeRed: 0.15, rework: -0.15, riskTol: 0.07, userConf: 0.03 },
      progressionMetrics: {}
    };

    const clamp01 = v => Math.max(0, Math.min(1, v));
    const fmtPct = v => (v == null || isNaN(v)) ? '–' : (v * 100).toFixed(2) + '%';
    const pct    = v => (v == null || isNaN(v)) ? '–' : (100 * v).toFixed(2) + '%';
    const num    = (v, d=4) => (v == null || isNaN(v)) ? '–' : Number(v).toFixed(d);
    const blueNum = (v, d=4) => `<span style="color: var(--cdf);">${num(v, d)}</span>`;

    function isAnyFetching() {
      return S.fetching || Object.values(S.overlay.variants).some(v => v.loading);
    }
    function setStatus(t) {
      const el = document.getElementById('fetchStatus');
      const mini = document.getElementById('seriesStatus');
      const any = isAnyFetching();
      const text = any ? 'Fetching…' : (t || 'Ready');
      if (el) { el.textContent = text; el.classList.toggle('fetching', any); el.classList.toggle('glow', any); }
      if (mini) mini.textContent = text;
    }
    function cssVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || ''; }
    function nullableNum(v) { const n = Number(v); return Number.isFinite(n) ? n : null; }

    function gp(obj, path) {
      var parts = path.split('.');
      var cur = obj;
      for (var i=0;i<parts.length;i++){ var k = parts[i]; if (!cur || !(k in cur)) return null; cur = cur[k]; }
      return cur;
    }

    function normalizePoints_(arr, isPdf = true) {
      if (!Array.isArray(arr)) return [];
      const out = [];
      for (const p of arr) {
        const x = nullableNum(p?.x);
        const y = nullableNum(p?.y);
        if (x != null && y != null) out.push({ x, y });
      }
      out.sort((a,b)=>a.x-b.x);
      if (isPdf && out.length >= 2) {
        if (out[0].y !== 0) out.unshift({ x: out[0].x - 0.01, y: 0 });
        if (out[out.length-1].y !== 0) out.push({ x: out[out.length-1].x + 0.01, y: 0 });
      }
      return out;
    }

    function interpY(points, x) {
      if (!points || points.length < 2 || x == null || !Number.isFinite(x)) return null;
      if (x <= points[0].x) return points[0].y;
      const n = points.length;
      if (x >= points[n - 1].x) return points[n - 1].y;
      let lo = 0, hi = n - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (points[mid].x <= x) lo = mid; else hi = mid;
      }
      const p0 = points[lo], p1 = points[hi];
      const t = (x - p0.x) / (p1.x - p0.x || 1e-10);
      const y = p0.y + t * (p1.y - p0.y);
      return Number.isFinite(y) ? y : null;
    }

    /** Inverse CDF lookup: given probability y (0–1), find the x-value where CDF = y.
     *  CDF is monotonically increasing so binary search on y works. */
    function interpX(points, y) {
      if (!points || points.length < 2 || y == null || !Number.isFinite(y)) return null;
      if (y <= points[0].y) return points[0].x;
      const n = points.length;
      if (y >= points[n - 1].y) return points[n - 1].x;
      let lo = 0, hi = n - 1;
      while (hi - lo > 1) {
        const mid = (lo + hi) >> 1;
        if (points[mid].y <= y) lo = mid; else hi = mid;
      }
      const p0 = points[lo], p1 = points[hi];
      const t = (y - p0.y) / (p1.y - p0.y || 1e-10);
      const x = p0.x + t * (p1.x - p0.x);
      return Number.isFinite(x) ? x : null;
    }

    function boundsFromSeries(series) {
      let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity,count=0;
      for (const arr of series) {
        if (!arr || !arr.length) continue;
        count++;
        for (const p of arr) {
          if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
          xmin = Math.min(xmin,p.x); xmax = Math.max(xmax,p.x);
          ymin = Math.min(ymin,p.y); ymax = Math.max(ymax,p.y);
        }
      }
      if (!count) return null;
      if (xmin === xmax) { xmin -= 1; xmax += 1; }
      if (ymin === ymax) { ymin = 0; ymax = ymax || 1; }
      const padX = (xmax - xmin) * 0.05;
      const padY = (ymax - ymin) * 0.15;
      return { xmin: xmin - padX, xmax: xmax + padX, ymin: Math.max(0, ymin - padY), ymax: ymax + padY };
    }

    function sliderValues() {
      return {
        budgetFlexibility: +document.getElementById('s_budget').value,
        scheduleFlexibility: +document.getElementById('s_schedule').value,
        scopeCertainty: +document.getElementById('s_scopeCert').value,
        scopeReductionAllowance: +document.getElementById('s_scopeRed').value,
        reworkPercentage: +document.getElementById('s_rework').value,
        riskTolerance: +document.getElementById('s_risk').value,
        userConfidence: +document.getElementById('s_userConf').value
      };
    }
    function setSlidersDisabled(disabled) {
      ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf']
        .forEach(function(id) {
          var numEl = document.getElementById(id);
          var rangeEl = document.getElementById(id + '_range');
          if (numEl) numEl.disabled = disabled;
          if (rangeEl) rangeEl.disabled = disabled;
        });
    }

    const sliderIdMap = {
      budgetFlexibility: 's_budget',
      scheduleFlexibility: 's_schedule',
      scopeCertainty: 's_scopeCert',
      scopeReductionAllowance: 's_scopeRed',
      reworkPercentage: 's_rework',
      riskTolerance: 's_risk',
      userConfidence: 's_userConf'
    };

    function populateSliders(slidersObj) {
      const noteMissing = document.getElementById('slidersNoteMissing');
      if (noteMissing) noteMissing.style.display = Object.keys(slidersObj).length ? 'none' : 'block';
      Object.entries(slidersObj).forEach(([key, val]) => {
        const id = sliderIdMap[key];
        const el = document.getElementById(id);
        if (el) el.value = Number(val) || 0;
      });
    }

    function setCompareValues(kind, slidersObj){
      if (!slidersObj || typeof slidersObj !== 'object') return;
      let suffix;
      if (kind === 'base') {
        suffix = '_base';
      } else if (kind === 'fixed') {
        suffix = '_fixed';
      } else if (kind === 'adaptive' || kind === 'adapt') {
        suffix = '_adapt';
      } else {
        return;
      }
      const map = {
        budgetFlexibility: 's_budget',
        scheduleFlexibility: 's_schedule',
        scopeCertainty: 's_scopeCert',
        scopeReductionAllowance: 's_scopeRed',
        reworkPercentage: 's_rework',
        riskTolerance: 's_risk',
        userConfidence: 's_userConf'
      };
      Object.keys(map).forEach(k=>{
        const el = document.getElementById(map[k] + suffix);
        if (el) {
          el.value = Number(slidersObj[k]) || 0;
          if (k === 'reworkPercentage') el.value = Math.min(50, Math.max(0, el.value));
        }
      });
    }

    function extractSliderVals(src) {
      let optSliders = {};
      const sliderKeys = [
        'budgetFlexibility', 'scheduleFlexibility', 'scopeCertainty',
        'scopeReductionAllowance', 'reworkPercentage',
        'riskTolerance', 'userConfidence'
      ];

      try {
        for (const key of sliderKeys) {
          let val = null;
          let pathHit = 'none';

          if (src.optimize?.scaledSliders?.[key] != null) {
            val = src.optimize.scaledSliders[key];
            pathHit = 'optimize.scaledSliders';
          } else if (src.optimize?.sliders?.[key] != null) {
            val = src.optimize.sliders[key];
            pathHit = 'optimize.sliders';
          } else if (src.scaledSliders?.[key] != null) {
            val = src.scaledSliders[key];
            pathHit = 'scaledSliders';
          } else if (src.sliders01?.[key] != null) {
            val = src.sliders01[key];
            pathHit = 'sliders01';
          } else if (src.sliders?.[key] != null) {
            val = src.sliders[key];
            pathHit = 'sliders';
          } else if (src.explain?.optimized?.winningSliders?.[key] != null) {
            val = src.explain.optimized.winningSliders[key];
            pathHit = 'explain.optimized.winningSliders';
          } else if (src.explain?.adaptive?.winningSliders?.[key] != null) {
            val = src.explain.adaptive.winningSliders[key];
            pathHit = 'explain.adaptive.winningSliders';
          } else if (src.explain?.winningSliders?.[key] != null) {
            val = src.explain.winningSliders[key];
            pathHit = 'explain.winningSliders';
          } else if (src.optimalSliderSettings?.value?.[key] != null) {
            val = src.optimalSliderSettings.value[key];
            pathHit = 'optimalSliderSettings.value';
          }

          val = val ?? 0;

          if (val > 0 && val < 1) {
            const scaleFactor = (key === 'reworkPercentage') ? 50 : 100;
            val *= scaleFactor;
          }

          const maxVal = (key === 'reworkPercentage') ? 50 : 100;
          optSliders[key] = Math.max(0, Math.min(maxVal, val));
        }

      } catch (e) {
        console.error('extractSliderVals failed:', e);
        optSliders = {};
      }

      return optSliders;
    }

    function updateTargetSlider() {
      const s = window.S || S;
      const slider = document.getElementById('targetSlider');
      if (!slider || s.O == null || s.P == null) return;

      if (s.targetMode === 'probability') {
        slider.min = 1; slider.max = 99; slider.step = 0.5;
        var currentProb = s.targetProb != null ? (s.targetProb * 100) : 50;
        slider.value = currentProb;
        s.targetProb = currentProb / 100;
        // Compute value from probability using baseline CDF
        var baseCdf = s.baseCdf && s.baseCdf.length ? s.baseCdf : s.triangleCdf;
        if (baseCdf && baseCdf.length) {
          s.target = interpX(baseCdf, s.targetProb);
        }
      } else {
        var pad = (s.P - s.O) * 0.05;
        s.targetSliderMin = s.O - pad;
        s.targetSliderMax = s.P + pad;
        slider.min = s.targetSliderMin;
        slider.max = s.targetSliderMax;
        slider.step = 'any';
        // Default to PERT mean
        var pert = (s.O + 4 * s.M + s.P) / 6;
        slider.value = s.target != null ? s.target : pert;
        s.target = Number(slider.value);
      }
      updateTargetDisplayText();
    }

    /** Updates the target result display showing both value AND probability */
    function updateTargetDisplayText() {
      var s = window.S || S;
      var valEl = document.getElementById('targetValDisplay');
      var probEl = document.getElementById('targetProbDisplay');
      if (!valEl || !probEl) return;

      if (s.target != null && Number.isFinite(s.target)) {
        valEl.textContent = Number(s.target).toFixed(2);
      } else {
        valEl.textContent = '–';
      }

      // Look up probability from CDF
      var baseCdf = s.baseCdf && s.baseCdf.length ? s.baseCdf : s.triangleCdf;
      if (baseCdf && baseCdf.length && s.target != null) {
        var prob = interpY(baseCdf, s.target);
        probEl.textContent = prob != null ? (prob * 100).toFixed(1) + '%' : '–';
        s.targetProb = prob;
      } else {
        probEl.textContent = '–';
      }
    }

    // Linked crosshair plugin for PDF ↔ CDF
    var linkedCrosshairPlugin = {
      id: 'linkedCrosshair',
      _hoveredX: null,
      _sourceChart: null,
      afterEvent: function(chart, args) {
        var evt = args.event;
        if (evt.type === 'mousemove' && args.inChartArea) {
          var xScale = chart.scales.x;
          this._hoveredX = xScale.getValueForPixel(evt.x);
          this._sourceChart = chart;
          var s = window.S || {};
          var sibling = (chart === s.pdfChart) ? s.cdfChart : s.pdfChart;
          if (sibling) sibling.draw();
          chart.draw();
        }
        if (evt.type === 'mouseout') {
          this._hoveredX = null;
          this._sourceChart = null;
          var s2 = window.S || {};
          if (s2.pdfChart) s2.pdfChart.draw();
          if (s2.cdfChart) s2.cdfChart.draw();
        }
      },
      afterDraw: function(chart) {
        if (this._hoveredX == null) return;
        var xScale = chart.scales.x;
        var xPixel = xScale.getPixelForValue(this._hoveredX);
        if (xPixel < chart.chartArea.left || xPixel > chart.chartArea.right) return;
        var ctx = chart.ctx;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(xPixel, chart.chartArea.top);
        ctx.lineTo(xPixel, chart.chartArea.bottom);
        ctx.strokeStyle = 'rgba(107, 114, 128, 0.5)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.stroke();
        ctx.font = '10px -apple-system, BlinkMacSystemFont, Inter, sans-serif';
        ctx.fillStyle = '#6B7280';
        ctx.textAlign = 'center';
        ctx.fillText(this._hoveredX.toFixed(1), xPixel, chart.chartArea.bottom + 14);
        ctx.restore();
      }
    };

    function ensureCharts() {
      const pdfCanvas = document.getElementById('pdfCanvas');
      const cdfCanvas = document.getElementById('cdfCanvas');
      if (!pdfCanvas || !cdfCanvas) return;
      if (typeof Chart === 'undefined') {
        console.warn('[ensureCharts] Chart.js not loaded yet — will retry when available');
        if (!window._chartRetryPending) {
          window._chartRetryPending = true;
          var checkInterval = setInterval(function() {
            if (typeof Chart !== 'undefined') {
              clearInterval(checkInterval);
              window._chartRetryPending = false;
              console.log('[ensureCharts] Chart.js now available, retrying');
              ensureCharts();
              if (typeof window.updateChart === 'function') window.updateChart();
            }
          }, 200);
        }
        return;
      }

      try {
        if (window.Chart && Chart.register) {
          if (window['chartjs-plugin-zoom']) Chart.register(window['chartjs-plugin-zoom']);
          if (window.ChartZoom) Chart.register(window.ChartZoom);
        }
      } catch(_) {}

      if (!window.targetLabelPlugin) {
        window.targetLabelPlugin = {
          id: 'targetLabel',
          afterDatasetsDraw(chart, args, opts){
            const s = window.S || {};
            const ctx = chart.ctx;
            const area = chart.chartArea;
            // ── Vertical τ target line ────────────────────────────────────
            if (s.target != null && isFinite(s.target)) {
              const xSc = chart.scales && chart.scales.x;
              if (xSc) {
                const xPx = xSc.getPixelForValue(s.target);
                if (xPx >= area.left && xPx <= area.right) {
                  ctx.save();
                  ctx.beginPath();
                  ctx.moveTo(xPx, area.top);
                  ctx.lineTo(xPx, area.bottom);
                  ctx.strokeStyle = 'rgba(245,158,11,0.72)';
                  ctx.lineWidth = 1.5;
                  ctx.setLineDash([5, 4]);
                  ctx.stroke();
                  ctx.setLineDash([]);
                  const tauTxt = '\u03c4 = ' + Number(s.target).toFixed(2);
                  ctx.font = 'bold 10px ui-monospace,monospace';
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  const tw = ctx.measureText(tauTxt).width + 8;
                  const bx = xPx - tw / 2, by = area.top + 2, bh = 15;
                  ctx.fillStyle = 'rgba(255,250,220,0.94)';
                  ctx.strokeStyle = 'rgba(245,158,11,0.85)';
                  ctx.lineWidth = 1;
                  if (ctx.roundRect) ctx.roundRect(bx, by, tw, bh, 3);
                  else ctx.rect(bx, by, tw, bh);
                  ctx.fill(); ctx.stroke();
                  ctx.fillStyle = '#7c5200';
                  ctx.fillText(tauTxt, xPx, by + bh / 2);
                  ctx.restore();
                }
              }
            }
            // ── Probability annotations at τ for all active strategies ───────
            if (s.target != null && isFinite(s.target)) {
              const isCdf = (chart.canvas.id === 'cdfCanvas');
              if (isCdf) {
                const xSc2 = chart.scales && chart.scales.x;
                const ySc2 = chart.scales && chart.scales.y;
                if (xSc2 && ySc2) {
                  const xPx2 = xSc2.getPixelForValue(s.target);
                  if (xPx2 >= area.left && xPx2 <= area.right) {
                    var P0 = s.baselineProb;
                    var ov = s.overlay || {};
                    // Baseline P₀ dashed horizontal line + label
                    if (P0 != null && isFinite(P0)) {
                      var yPx0 = ySc2.getPixelForValue(P0);
                      ctx.save();
                      ctx.beginPath();
                      ctx.moveTo(area.left, yPx0);
                      ctx.lineTo(xPx2, yPx0);
                      ctx.strokeStyle = 'rgba(107,114,128,0.50)';
                      ctx.lineWidth = 1.5; ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]);
                      var p0Txt = 'Baseline P\u2080 = ' + (P0*100).toFixed(1) + '%';
                      ctx.font = 'bold 9px ui-monospace,monospace';
                      ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                      ctx.fillStyle = 'rgba(100,116,139,0.90)';
                      ctx.fillText(p0Txt, area.left + 2, yPx0 - 1);
                      ctx.restore();
                    }
                    // One line per active strategy
                    var stratAnnotations = [
                      { on: ov.adaptiveOn,  prob: s.adaptiveProb,  name: 'Guided',    col: 'rgba(139,92,246,0.90)' },
                      { on: ov.fixedOn,     prob: s.optimizedProb, name: 'Optimized', col: 'rgba(59,130,246,0.90)'  },
                      { on: ov.manualOn,    prob: s.adjustedProb,  name: 'Explorer',  col: 'rgba(16,185,129,0.90)'  }
                    ];
                    // Track y positions to avoid label collisions
                    var usedYPx = [];
                    stratAnnotations.forEach(function(sa) {
                      if (!sa.on || sa.prob == null || !isFinite(sa.prob)) return;
                      var yPxC = ySc2.getPixelForValue(sa.prob);
                      var dP = sa.prob - (P0 || 0);
                      ctx.save();
                      ctx.beginPath();
                      ctx.moveTo(area.left, yPxC);
                      ctx.lineTo(xPx2, yPxC);
                      ctx.strokeStyle = sa.col;
                      ctx.lineWidth = 1.5; ctx.setLineDash([4,3]); ctx.stroke(); ctx.setLineDash([]);
                      var dpStr = (dP >= 0 ? '+' : '') + (dP * 100).toFixed(1) + '%';
                      var labTxt = sa.name + ' = ' + (sa.prob*100).toFixed(1) + '% (\u0394P ' + dpStr + ')';
                      ctx.font = 'bold 9px ui-monospace,monospace';
                      ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                      // Nudge label up if it collides with a previously drawn label
                      var labY = yPxC - 1;
                      for (var ui = 0; ui < usedYPx.length; ui++) {
                        if (Math.abs(labY - usedYPx[ui]) < 11) labY = usedYPx[ui] - 11;
                      }
                      usedYPx.push(labY);
                      ctx.fillStyle = sa.col;
                      ctx.fillText(labTxt, area.left + 2, labY);
                      ctx.restore();
                    });
                  }
                }
              }
            }
            // Collect all label positions for anti-overlap
            var labels = [];
            chart.data.datasets.forEach((ds, idx) => {
              if (ds.type === 'scatter' && ds.data && ds.data.length) {
                const meta = chart.getDatasetMeta(idx);
                const el = meta?.data?.[0];
                if (!el || ds.hidden) return;
                const key = ds._probKey;
                const pt = ds.data[0];
                // Use the actual y value from the data point for the label
                const yVal = pt ? pt.y : null;
                if (yVal == null) return;
                const pos = el.getProps(['x','y'], true);
                labels.push({ key:key, x:pos.x, y:pos.y, yVal:yVal, xVal:pt.x, color: ds.pointBackgroundColor||'#111' });
              }
            });
            // Sort by y pixel position (top to bottom) for stacking
            labels.sort(function(a,b){ return a.y - b.y; });
            // Nudge labels that would overlap (within 16px vertically)
            for (var i=1; i<labels.length; i++) {
              var prev = labels[i-1];
              if (Math.abs(labels[i].y - prev.y) < 16 && Math.abs(labels[i].x - prev.x) < 60) {
                labels[i].y = prev.y + 16;
              }
            }
            ctx.save();
            var _keyToName = { baseline: 'Baseline', optimized: 'Optimized', adjusted: 'Explorer', adaptive: 'Guided' };
            var _P0dot = (window.S || {}).baselineProb;
            labels.forEach(function(lb) {
              var isCdf = (chart.canvas.id === 'cdfCanvas');
              var txt;
              if (isCdf) {
                var stratName = _keyToName[lb.key] || lb.key;
                var pctStr = (lb.yVal * 100).toFixed(1) + '%';
                if (lb.key !== 'baseline' && _P0dot != null && isFinite(_P0dot)) {
                  var dPdot = lb.yVal - _P0dot;
                  txt = stratName + ' = ' + pctStr + ' (\u0394P\u202f' + (dPdot >= 0 ? '+' : '') + (dPdot * 100).toFixed(1) + '%)';
                } else {
                  txt = stratName + ' = ' + pctStr;
                }
              } else {
                txt = lb.xVal.toFixed(1) + ' \u2192 ' + lb.yVal.toFixed(4);
              }
              ctx.font = 'bold 10px Inter, sans-serif';
              var tw = ctx.measureText(txt).width;
              // Position label: prefer right of dot, flip left if near edge
              var lx = lb.x + 8;
              if (lx + tw > area.right - 4) lx = lb.x - tw - 8;
              var ly = lb.y - 8;
              if (ly < area.top + 4) ly = lb.y + 14;
              // Background pill
              ctx.fillStyle = 'rgba(255,255,255,0.85)';
              ctx.strokeStyle = lb.color;
              ctx.lineWidth = 1;
              var pad = 3;
              var rx=lx-pad, ry=ly-10-pad, rw=tw+pad*2, rh=14+pad*2, rr=4;
              ctx.beginPath();
              if (ctx.roundRect) { ctx.roundRect(rx,ry,rw,rh,rr); }
              else { ctx.moveTo(rx+rr,ry); ctx.lineTo(rx+rw-rr,ry); ctx.quadraticCurveTo(rx+rw,ry,rx+rw,ry+rr); ctx.lineTo(rx+rw,ry+rh-rr); ctx.quadraticCurveTo(rx+rw,ry+rh,rx+rw-rr,ry+rh); ctx.lineTo(rx+rr,ry+rh); ctx.quadraticCurveTo(rx,ry+rh,rx,ry+rh-rr); ctx.lineTo(rx,ry+rr); ctx.quadraticCurveTo(rx,ry,rx+rr,ry); ctx.closePath(); }
              ctx.fill(); ctx.stroke();
              // Text
              ctx.fillStyle = lb.color;
              ctx.textAlign = 'left';
              ctx.textBaseline = 'bottom';
              ctx.fillText(txt, lx, ly);
              // Circle ring around the dot
              ctx.beginPath();
              ctx.arc(lb.x, lb.y, 6, 0, Math.PI*2);
              ctx.strokeStyle = lb.color;
              ctx.lineWidth = 2;
              ctx.stroke();
            });
            ctx.restore();
          }
        };
      }

      const legendFilter = (legendItem, chartData) => {
        const ds = chartData?.datasets?.[legendItem.datasetIndex];
        if (ds && ds.type === 'scatter') return false;
        const s = window.S || {};
        const label = legendItem.text || '';
        if (s.tab === 'overlay') {
          return /^(Baseline|Manual \(Adjusted\)|Fixed \(Optimized\)|Adaptive \(Optimized\))$/.test(label);
        }
        return /^(Triangle|Beta-PERT|Baseline)$/.test(label);
      };

      if (!S.pdfChart) {
        S.pdfChart = new Chart(pdfCanvas, {
          type: 'line',
          data: { datasets: [] },
          options: {
            responsive: true, maintainAspectRatio: false, parsing: false,
            plugins: {
              legend: { display: true, position: 'top', labels: { boxWidth: 12, font: { size: 12 }, filter: legendFilter } },
              tooltip: {
                enabled: true,
                callbacks: {
                  label: (ctx) => {
                    if (ctx.dataset.type === 'scatter') {
                      const x = ctx.parsed.x.toFixed(2);
                      const y = ctx.parsed.y;
                      return [`Value: ${x}`, `Density: ${y != null ? y.toFixed(4) : 'N/A'}`];
                    }
                    return ctx.dataset.label;
                  }
                }
              },
              zoom: {
                limits: { x:{min: 'original', max:'original'}, y:{min: 'original', max:'original'} },
                pan: { enabled: true, mode: 'xy' },
                zoom: { wheel:{enabled:true}, pinch:{enabled:true}, mode:'xy' }
              }
            },
            elements: { point: { radius: 0 } },
            scales: {
              x: { type: 'linear', title: { display: true, text: 'Value', font: { size: 12 } }, ticks: { font: { size: 11 } } },
              y: { title: { display: true, text: 'Density', font: { size: 12 } }, ticks: { font: { size: 11 } }, min: 0, max: 0.2 }
            }
          },
          plugins: [window.targetLabelPlugin]
        });
      }

      if (!S.cdfChart) {
        S.cdfChart = new Chart(cdfCanvas, {
          type: 'line',
          data: { datasets: [] },
          options: {
            responsive: true, maintainAspectRatio: false, parsing: false,
            plugins: {
              legend: { display: true, position: 'top', labels: { boxWidth: 12, font: { size: 12 }, filter: legendFilter } },
              zoom: {
                limits: { x:{min: 'original', max:'original'}, y:{min: 0, max:1 } },
                pan: { enabled: true, mode: 'xy' },
                zoom: { wheel:{enabled:true}, pinch:{enabled:true}, mode:'xy' }
              }
            },
            elements: { point: { radius: 0 } },
            scales: {
              x: { type: 'linear', title: { display: true, text: 'Value', font: { size: 12 } }, ticks: { font: { size: 11 } } },
              y: { title: { display: true, text: 'Cumulative Probability', font: { size: 12 } }, ticks: { font: { size: 11 } }, min: 0, max: 1 }
            }
          },
          plugins: [window.targetLabelPlugin, linkedCrosshairPlugin]
        });
      }
    }

    function computeGain(sliders) {
      const v = {
        budget:   clamp01(sliders.budgetFlexibility / 100),
        schedule: clamp01(sliders.scheduleFlexibility / 100),
        scopeCert: clamp01(sliders.scopeCertainty / 100),
        scopeRed: clamp01(sliders.scopeReductionAllowance / 100),
        rework:   clamp01(sliders.reworkPercentage / 50),
        riskTol:  clamp01(sliders.riskTolerance / 100),
        userConf: clamp01((sliders.userConfidence ?? 100) / 100)
      };
      const w = S.currentWeights;
      const raw = w.budget*v.budget + w.schedule*v.schedule + w.scopeCert*v.scopeCert + w.scopeRed*v.scopeRed + w.rework*v.rework + w.riskTol*v.riskTol + w.userConf*v.userConf;
      return Math.max(-0.25, Math.min(0.25, raw)) * 0.25;
    }

    function pmcEmit(type, detail) {
      try { window.dispatchEvent(new CustomEvent(type, { detail })); } catch(_) {}
    }

    function syncProbeUI(){
      const s = window.S || S;
      const box = document.getElementById('probeBox');
      const sel = document.getElementById('probeSelect');
      const show = (s.tab === 'overlay') && (s.overlay?.sidebarMode === 'adaptive');
      if (box) box.style.display = show ? 'inline-flex' : 'none';
      if (sel && Number(sel.value) !== Number(s.overlay.probeLevel || 3)) {
        sel.value = String(s.overlay.probeLevel || 3);
      }
    }
    function initProbeUI(){
      const sel = document.getElementById('probeSelect');
      if (!sel || sel.__bound) return;
      sel.__bound = true;
      sel.addEventListener('change', () => {
        const s = window.S || S;
        const lvl = Number(sel.value) || 3;
        s.overlay.probeLevel = Math.max(1, Math.min(7, lvl));
        if (s.tab === 'overlay' && s.overlay.adaptiveOn) {
          const key = JSON.stringify({ task: s.task?.task, O:s.O, M:s.M, P:s.P, target:s.target, variant:'adaptive', probeLevel:s.overlay.probeLevel });
          if (s.variantCache) delete s.variantCache[key];
          if (typeof window.requestVariant === 'function') {
            window.requestVariant('adaptive');
          } else {
            if (typeof window.setStatus === 'function') window.setStatus('Fetching…');
          }
        }
      });
    }

    window.S = window.S || S;
    window.ensureCharts = ensureCharts;
    window.interpY = interpY;
    window.interpX = interpX;
    window.boundsFromSeries = boundsFromSeries;
    window.sliderValues = sliderValues;
    window.updateSlidersDisplay = function(){};
    window.computeGain = computeGain;
    window.setStatus = setStatus;
    window.pmcEmit = pmcEmit;
    window.syncProbeUI = syncProbeUI;
    window.initProbeUI = initProbeUI;

    // ── Help icon system: dynamic mini-reports for each plot ──
    function initPlotHelp() {
      var helpDefs = {
        distributions: {
          popupId: 'distributionsHelpPopup',
          generate: function() {
            var s = window.S || {};
            var tab = s.tab || 'progress';
            var pct = function(v) { return v != null ? (v * 100).toFixed(1) + '%' : 'N/A'; };

            if (tab === 'progress') {
              return '<h4>Distribution Curves</h4>' +
                '<div class="help-section">' +
                '<p><strong>What you see:</strong> Two charts showing how your 3-point estimate (Best / Most Likely / Worst) becomes a probability model.</p>' +
                '<ul>' +
                '<li><strong>Left \u2014 Density (PDF):</strong> The "shape" of uncertainty. The peak is the most likely outcome; wider = more uncertain.</li>' +
                '<li><strong>Right \u2014 Cumulative (CDF):</strong> The probability of finishing at or below any value. Read as: "What is my chance of completing within X?"</li>' +
                '</ul></div>' +
                '<div class="help-section">' +
                '<p><strong>The three curves:</strong></p>' +
                '<ul>' +
                '<li><strong>Triangle</strong> \u2014 simplest model from your 3 estimates</li>' +
                '<li><strong>Beta-PERT</strong> \u2014 industry-standard refinement that weights Most Likely more heavily</li>' +
                '<li><strong>Your Estimate</strong> \u2014 final calibrated distribution used as your baseline</li>' +
                '</ul></div>' +
                (s.target != null ? '<div class="help-section"><p><strong>Your target:</strong> <span class="help-stat">' + Number(s.target).toFixed(2) + '</span> \u2014 probability of meeting it: <span class="help-stat">' + pct(s.baselineProb) + '</span></p></div>' : '');
            } else {
              var html = '<h4>Strategy Comparison</h4>' +
                '<div class="help-section">' +
                '<p><strong>What you see:</strong> Your baseline overlaid with optimization strategies. Each curve shows a different approach to improving your probability of success.</p></div>';
              html += '<div class="help-section"><p><strong>Active strategies:</strong></p><ul>';
              if (s.overlay && s.overlay.baselineOn) html += '<li><strong>Your Estimate:</strong> <span class="help-stat">' + pct(s.baselineProb) + '</span> \u2014 starting point</li>';
              if (s.overlay && s.overlay.adaptiveOn) html += '<li><strong>Guided:</strong> <span class="help-stat">' + pct(s.adaptiveProb) + '</span> \u2014 conservative, tightest constraints (level ' + (s.overlay.probeLevel||3) + ')</li>';
              if (s.overlay && s.overlay.fixedOn) html += '<li><strong>Optimized:</strong> <span class="help-stat">' + pct(s.optimizedProb) + '</span> \u2014 best within standard boundaries</li>';
              if (s.overlay && s.overlay.manualOn) html += '<li><strong>Explorer:</strong> <span class="help-stat">' + pct(s.adjustedProb) + '</span> \u2014 your custom settings</li>';
              html += '</ul></div>';
              html += '<div class="help-section"><p><strong>How to read:</strong> On the CDF (right), a higher curve at your target = better probability. The gap between curves shows how much each strategy improves your chances.</p></div>';
              return html;
            }
          }
        },
        radar: {
          popupId: 'radarHelpPopup',
          generate: function() {
            return '<h4>Slider Profile</h4>' +
              '<div class="help-section">' +
              '<p><strong>What you see:</strong> A radar chart showing all 7 project decision sliders at once. Each axis is one parameter.</p></div>' +
              '<div class="help-section">' +
              '<p><strong>How to read:</strong></p>' +
              '<ul>' +
              '<li><strong>Larger shape</strong> = more aggressive parameter settings</li>' +
              '<li><strong>Balanced shape</strong> (near-circle) = proportional settings</li>' +
              '<li><strong>Spiky shape</strong> = some parameters much higher than others \u2014 look for imbalances</li>' +
              '</ul></div>' +
              '<div class="help-section">' +
              '<p><strong>The 7 parameters:</strong> Budget Flexibility, Schedule Flexibility, Scope Certainty, Scope Reduction, Rework %, Risk Tolerance, Confidence \u2014 each captures a dimension of project decision-making aligned with industry best practices.</p></div>';
          }
        },
        hypercube: {
          popupId: 'hypercubeHelpPopup',
          generate: function() {
            return '<h4>Parameter Space (3D)</h4>' +
              '<div class="help-section">' +
              '<p><strong>What you see:</strong> A rotating 3D projection of the 7-dimensional parameter space. Each vertex represents a possible combination of slider settings.</p></div>' +
              '<div class="help-section">' +
              '<p><strong>How to read:</strong></p>' +
              '<ul>' +
              '<li><strong>Highlighted point</strong> = where your current settings sit</li>' +
              '<li><strong>Closer to center</strong> = more conservative</li>' +
              '<li><strong>Closer to edges</strong> = more aggressive</li>' +
              '</ul></div>' +
              '<div class="help-section">' +
              '<p><strong>Why it matters:</strong> See whether the optimizer is pushing parameters to extremes or finding a balanced interior solution. A point near the boundary suggests the optimizer is constrained \u2014 try a different strategy or Explorer mode.</p></div>';
          }
        }
      };

      document.querySelectorAll('.plot-help-btn').forEach(function(btn) {
        btn.addEventListener('click', function(e) {
          e.stopPropagation();
          var key = btn.getAttribute('data-help');
          var def = helpDefs[key];
          if (!def) return;
          var popup = document.getElementById(def.popupId);
          if (!popup) return;
          document.querySelectorAll('.plot-help-popup.visible').forEach(function(p) {
            if (p !== popup) p.classList.remove('visible');
          });
          if (popup.classList.contains('visible')) {
            popup.classList.remove('visible');
          } else {
            popup.innerHTML = def.generate();
            popup.classList.add('visible');
          }
        });
      });

      document.addEventListener('click', function(e) {
        if (!e.target.closest('.plot-help-btn') && !e.target.closest('.plot-help-popup')) {
          document.querySelectorAll('.plot-help-popup.visible').forEach(function(p) {
            p.classList.remove('visible');
          });
        }
      });
    }
    window.initPlotHelp = initPlotHelp;
  </script>

  <!-- KPIs, Legend controls, Chart Rendering -->
  <script>
    (function(){
      function WS(){ return window.S || (window.S = {}); }
      function cssVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || ''; }

      window.renderKPIs = function(){
        var s = WS();
        function writeVal(root, v, loading) {
          if (!root) return;
          var slot = root.querySelector('.val') || root.querySelector('.kpi-v');
          if (!slot) return;
          root.classList.toggle('updating', !!loading);
          if (loading) {
            slot.innerHTML = '<span style="font-size:10px;color:var(--muted);">Fetching\u2026</span>';
          } else if (v == null || isNaN(v)) {
            slot.innerHTML = '&ndash;';
          } else {
            var pctStr = (v * 100).toFixed(2) + '%';
            var natural = Math.round(v * 100) + '% chance at or below target';
            slot.innerHTML = pctStr + '<div class="kpi-natural">' + natural + '</div>';
          }
        }
        var kBase = document.getElementById('kpiBaseline');
        var kAdj  = document.getElementById('kpiAdjusted');
        var kOpt  = document.getElementById('kpiOptimized');
        var kAda  = document.getElementById('kpiAdaptive');

        var vv = s.overlay && s.overlay.variants || {};
        writeVal(kBase, s.baselineProb, s.fetching);
        writeVal(kAdj,  s.adjustedProb, vv.manual && vv.manual.loading);
        writeVal(kOpt,  s.optimizedProb, vv.fixed && vv.fixed.loading);
        writeVal(kAda,  s.adaptiveProb, vv.adaptive && vv.adaptive.loading);

        var onOv = (s.tab==='overlay');
        if (kBase) { kBase.classList.toggle('active', onOv && !!s.overlay.baselineOn); kBase.classList.toggle('inactive', !(onOv && s.overlay.baselineOn)); }
        if (kAdj)  { kAdj.classList.toggle('active',  onOv && !!s.overlay.manualOn);  kAdj.classList.toggle('inactive', !(onOv && s.overlay.manualOn)); }
        if (kOpt)  { kOpt.classList.toggle('active', onOv && !!s.overlay.fixedOn);   kOpt.classList.toggle('inactive', !(onOv && s.overlay.fixedOn)); }
        if (kAda)  { kAda.classList.toggle('active', onOv && !!s.overlay.adaptiveOn); kAda.classList.toggle('inactive', !(onOv && s.overlay.adaptiveOn)); }

        var card = document.getElementById('overlayKpis');
        if (card) card.style.display = (s.tab==='overlay') ? 'block' : 'none';

        var progressDesc = document.getElementById('progressDescBanner');
        if (progressDesc) progressDesc.style.display = (s.tab==='progress') ? '' : 'none';

        var distTiles = document.getElementById('distTiles');
        if (distTiles) distTiles.style.display = (s.tab==='progress') ? 'flex' : 'none';
        var triTile = document.getElementById('kpiTriangle');
        var betaTile= document.getElementById('kpiBeta');
        var baseTile= document.getElementById('kpiBaseDist');
        if (triTile) triTile.classList.toggle('active', !!s.progress.triOn);
        if (betaTile) betaTile.classList.toggle('active', !!s.progress.betaOn);
        if (baseTile) baseTile.classList.toggle('active', !!s.progress.baseOn);

        if (typeof window.syncProbeUI === 'function') window.syncProbeUI();
        updateProgressDescription(s);
        updateRecommendation(s);
      };

      function updateProgressDescription(s) {
        var stmtEl = document.getElementById('progressDescStatement');
        var ctxEl = document.getElementById('progressDescContext');
        if (!stmtEl || !ctxEl) return;
        if (s.tab !== 'progress') return;

        var pct = function(v) { return v != null && !isNaN(v) ? (v * 100).toFixed(1) + '%' : '\u2013'; };
        var tgt = s.target != null ? Number(s.target).toFixed(1) : '?';
        var triProb = s.triangleCdf && s.triangleCdf.length && s.target != null ? window.interpY(s.triangleCdf, s.target) : null;
        var betaProb = s.betaPertCdf && s.betaPertCdf.length && s.target != null ? window.interpY(s.betaPertCdf, s.target) : null;
        var baseProb = s.baselineProb;

        var stmt = '<strong>How your estimate is built</strong> \u2014 from 3-point inputs to probability';
        var parts = [];
        parts.push('Your three-point estimate (O=' + (s.O||'?') + ', M=' + (s.M||'?') + ', P=' + (s.P||'?') + ') is transformed through three distributions to arrive at a final probability.');
        if (triProb != null) parts.push('The <strong>Triangle</strong> distribution gives <strong>' + pct(triProb) + '</strong> at target ' + tgt + '.');
        if (betaProb != null) parts.push('<strong>Beta-PERT</strong> refines this to <strong>' + pct(betaProb) + '</strong> by weighting the most likely value more heavily.');
        if (baseProb != null) parts.push('Your final <strong>baseline</strong> (Monte Carlo smoothed) is <strong>' + pct(baseProb) + '</strong> \u2014 this is your starting probability before any optimization.');

        stmtEl.innerHTML = stmt;
        ctxEl.innerHTML = parts.join(' ');
      }

      function updateRecommendation(s) {
        var banner = document.getElementById('recBanner');
        if (!banner) return;
        var stmtEl = document.getElementById('recStatement');
        var ctxEl = document.getElementById('recContext');
        var detEl = document.getElementById('recDetails');

        if (s.tab !== 'overlay') { banner.style.display = 'none'; updatePlotDescriptions(s, null, []); return; }

        var bp = s.baselineProb;
        if (bp == null || isNaN(bp)) { banner.style.display = 'none'; updatePlotDescriptions(s, null, []); return; }

        var tgt = s.target != null ? Number(s.target).toFixed(1) : '?';
        var bpPct = (bp * 100).toFixed(1);
        var pct = function(v) { return v != null && !isNaN(v) ? (v * 100).toFixed(1) + '%' : '\u2013'; };
        var plvl = s.overlay.probeLevel || 3;

        // --- Collect active strategies with data ---
        var candidates = [];
        candidates.push({ name: 'Your Estimate', prob: bp, key: 'baseline' });
        if (s.overlay.adaptiveOn && s.adaptiveProb != null && !isNaN(s.adaptiveProb))
          candidates.push({ name: 'Guided (Level ' + plvl + ')', prob: s.adaptiveProb, key: 'adaptive' });
        if (s.overlay.fixedOn && s.optimizedProb != null && !isNaN(s.optimizedProb))
          candidates.push({ name: 'Optimized', prob: s.optimizedProb, key: 'fixed' });
        if (s.overlay.manualOn && s.adjustedProb != null && !isNaN(s.adjustedProb))
          candidates.push({ name: 'Explorer', prob: s.adjustedProb, key: 'manual' });

        candidates.sort(function(a, b) { return b.prob - a.prob; });
        var hasVariants = candidates.length > 1;
        var best = candidates[0];
        var guided = candidates.find(function(c) { return c.key === 'adaptive'; });
        var optimized = candidates.find(function(c) { return c.key === 'fixed'; });
        var explorer = candidates.find(function(c) { return c.key === 'manual'; });

        // Comparison line
        var compParts = [];
        candidates.forEach(function(c) {
          compParts.push((c === best ? '<strong>' : '') + c.name + ': ' + pct(c.prob) + (c === best ? '</strong>' : ''));
        });
        var compLine = compParts.length > 1 ? compParts.join(' &nbsp;\u00B7&nbsp; ') : '';

        var stmt = '', ctx = '', details = '', level;

        // === BASELINE ONLY (no strategies active) ===
        if (!hasVariants) {
          level = bp >= 0.8 ? 'green' : (bp >= 0.5 ? 'amber' : 'red');
          stmt = 'Your starting probability is <strong>' + bpPct + '%</strong> at target ' + tgt + '.';
          ctx = 'This is your unoptimized baseline from the 3-point estimate. The strategies above adjust project decision levers (budget flexibility, schedule flexibility, scope, etc.) to reshape the distribution and increase this probability.';
          details = '<span class="rec-step">Click <strong>Guided</strong> to see the most realistic improvement, <strong>Optimized</strong> for the best within standard limits, or <strong>Explorer</strong> to see the theoretical maximum.</span>';

        // === HIGH BASELINE (already ≥ 80% before optimization) ===
        } else if (bp >= 0.8) {
          level = 'green';
          stmt = 'Your estimate already has <strong>' + bpPct + '%</strong> confidence at target ' + tgt + ' \u2014 no optimization needed.';
          ctx = compLine + '<br>You start above the 80% threshold before any slider adjustments. The strategies show what further tuning could achieve, but the baseline is already strong.';
          details = '<span class="rec-step">Try lowering the target value (or switching to Probability mode) to stress-test where your confidence drops below 80%.</span>';

        // === STRATEGIES ACTIVE — build contextual recommendation ===
        } else {
          // Determine gain from best strategy
          var gain = ((best.prob - bp) * 100).toFixed(1);
          var gainGood = Number(gain) > 0;
          level = best.prob >= 0.8 ? 'green' : (best.prob >= 0.5 ? 'amber' : 'red');

          // --- HEADLINE: what's the best achievable result? ---
          if (best.key === 'baseline') {
            // Optimization strategies are active but none improved over baseline
            stmt = 'The active strategies did not improve beyond your baseline <strong>' + bpPct + '%</strong>.';
          } else if (gainGood) {
            stmt = '<strong>' + best.name + '</strong> increases your probability from ' + bpPct + '% to <strong>' + pct(best.prob) + '</strong> (+' + gain + ' points).';
          } else {
            stmt = '<strong>' + best.name + '</strong> achieves <strong>' + pct(best.prob) + '</strong> at target ' + tgt + '.';
          }

          // --- CONTEXT: explain each active strategy's role and limitations ---
          ctx = compLine + '<br>';
          var explanations = [];

          if (guided) {
            var gGain = ((guided.prob - bp) * 100).toFixed(1);
            if (Number(gGain) > 0) {
              explanations.push('<strong>Guided</strong> (+' + gGain + ' pts) applies the tightest, most realistic constraints \u2014 based on industry best practices at level ' + plvl + '. This is the most defensible improvement because every slider stays within validated boundaries. ');
            } else {
              explanations.push('<strong>Guided</strong> (' + pct(guided.prob) + ') could not improve over baseline at level ' + plvl + ' because its constraints are very tight. <em>Try increasing the probe level</em> (currently ' + plvl + ' of 7) to allow slightly wider adjustments. ');
            }
          }

          if (optimized) {
            var oGain = ((optimized.prob - bp) * 100).toFixed(1);
            if (Number(oGain) > 0) {
              explanations.push('<strong>Optimized</strong> (+' + oGain + ' pts) uses wider boundaries than Guided, finding the best probability within standard limits. It pushes sliders further, which means more improvement but also more assumptions about what your project can absorb. ');
            } else {
              explanations.push('<strong>Optimized</strong> (' + pct(optimized.prob) + ') could not improve further within standard boundaries. ');
            }
          }

          if (explorer) {
            var eGain = ((explorer.prob - bp) * 100).toFixed(1);
            if (Number(eGain) > 0) {
              explanations.push('<strong>Explorer</strong> (+' + eGain + ' pts) removes all guardrails \u2014 it shows the theoretical ceiling if every slider were set to its most favorable value. This is useful for understanding the upper bound, but <em>the slider positions it suggests may not be achievable in practice</em>. Use it for comparison, not as a plan. ');
            } else {
              explanations.push('<strong>Explorer</strong> (' + pct(explorer.prob) + ') \u2014 even with no constraints, probability didn\'t improve. This means the target is very aggressive for this estimate range. ');
            }
          }

          ctx += explanations.join('');

          // --- NEXT STEPS: actionable, specific to what's active ---
          details = '';

          if (best.prob >= 0.8) {
            // Great result — tell them what to do with it
            if (best.key === 'adaptive') {
              details = '<span class="rec-step">Guided achieves 80%+ \u2014 open the sidebar to see exactly which sliders to adjust and by how much. These settings are realistic and auditable.</span>';
            } else if (best.key === 'fixed') {
              details = '<span class="rec-step">Open the sidebar to review the slider settings Optimized recommends. ';
              if (guided && guided.prob < 0.8) details += 'Guided couldn\'t reach 80% at level ' + plvl + ' \u2014 try a higher probe level to see if a more constrained path can get closer.';
              details += '</span>';
            } else if (best.key === 'manual') {
              details = '<span class="rec-warn">\u26A0 Explorer reaches 80%+ but uses unconstrained settings.</span> <span class="rec-step">Check the sidebar to see which sliders were pushed to extreme values. ';
              if (guided) details += 'Compare against Guided (' + pct(guided.prob) + ') for a realistic alternative. ';
              if (!guided) details += 'Activate <strong>Guided</strong> to see the most realistic path. ';
              details += '</span>';
            }
          } else if (best.prob >= 0.5) {
            // Moderate result — push them to try more
            if (!guided) {
              details = '<span class="rec-step">Activate <strong>Guided</strong> to see the most realistic improvement path with industry-standard constraints.</span>';
            } else if (!optimized) {
              details = '<span class="rec-step">Activate <strong>Optimized</strong> to see if wider slider boundaries can push probability higher.</span>';
            } else if (!explorer) {
              details = '<span class="rec-step">Activate <strong>Explorer</strong> to see the theoretical maximum \u2014 if even Explorer can\'t reach 80%, the target may need adjusting.</span>';
            } else {
              // All active, none hit 80%
              if (guided && Number(((guided.prob - bp) * 100).toFixed(1)) > 0 && plvl < 7) {
                details = '<span class="rec-step">Try increasing Guided\'s probe level (currently ' + plvl + ' of 7) to explore tighter constraint sets that may yield better results.</span>';
              } else {
                details = '<span class="rec-step">All strategies have been explored. To increase probability further, try moving the target slider to a more achievable value, or use Probability mode to set a target confidence level directly.</span>';
              }
            }
          } else {
            // Low result — all strategies struggling
            if (!explorer) {
              details = '<span class="rec-step">Activate <strong>Explorer</strong> to see the theoretical ceiling. If even Explorer stays below 50%, the target is very aggressive for this estimate.</span>';
            } else if (explorer && explorer.prob < 0.5) {
              details = '<span class="rec-step">Even Explorer (no constraints) can\'t reach 50%. Use the target slider or switch to Probability mode to find a target value where confidence is acceptable, then work backwards.</span>';
            } else {
              details = '<span class="rec-step">Explorer can reach ' + pct(explorer.prob) + ' but it uses unrealistic assumptions. Activate <strong>Guided</strong> or <strong>Optimized</strong> to find the realistic ceiling, then adjust the target to a level these strategies can achieve.</span>';
            }
          }
        }

        banner.className = 'rec-banner rec-' + level;
        stmtEl.innerHTML = stmt;
        ctxEl.innerHTML = ctx;
        detEl.innerHTML = details;
        banner.style.display = '';
        updatePlotDescriptions(s, best, candidates);
      }

      function updatePlotDescriptions(s, best, candidates) {
        var chartDesc = document.getElementById('chartDesc');
        var radarDesc = document.getElementById('radarDesc');
        var hcDesc = document.getElementById('hypercubeDesc');
        var pct = function(v) { return v != null && !isNaN(v) ? (v * 100).toFixed(1) + '%' : '\u2013'; };
        var tgt = s.target != null ? Number(s.target).toFixed(1) : '?';
        var onOverlay = (s.tab === 'overlay');
        var hasVariants = candidates && candidates.length > 1;

        // --- PDF/CDF description ---
        if (chartDesc) {
          if (s.tab === 'progress') {
            // Progress description now in the banner above; hide chart-level desc
            chartDesc.style.display = 'none';
          } else if (onOverlay && hasVariants) {
            chartDesc.style.display = '';
            var lines = ['<strong>Strategy comparison at target ' + tgt + ':</strong> '];
            lines.push('The PDF (left) shows the shape of each strategy\'s probability distribution \u2014 taller/narrower peaks mean more certainty. ');
            lines.push('The CDF (right) shows cumulative probability \u2014 the annotated circles mark where each strategy falls at the target. ');
            if (best && best.key !== 'baseline') {
              lines.push('<strong>' + best.name + '</strong> achieves ' + pct(best.prob));
              if (best.key === 'manual') lines.push(' (unconstrained \u2014 treat as theoretical ceiling)');
              else if (best.key === 'adaptive') lines.push(' (within strict best-practice constraints)');
              else if (best.key === 'fixed') lines.push(' (within standard optimization boundaries)');
              lines.push('.');
            }
            chartDesc.innerHTML = lines.join('');
          } else if (onOverlay) {
            chartDesc.style.display = '';
            chartDesc.innerHTML = '<strong>Your baseline distribution at target ' + tgt + ':</strong> Probability of meeting target is <strong>' + pct(s.baselineProb) + '</strong>. Activate strategies above to compare.';
          } else {
            chartDesc.style.display = 'none';
          }
        }

        // --- Radar description ---
        if (radarDesc) {
          if (onOverlay && hasVariants) {
            radarDesc.style.display = '';
            var rLines = ['<strong>Slider profile:</strong> '];
            rLines.push('Each axis represents a decision lever (budget flexibility, schedule flexibility, etc.). ');
            rLines.push('The dashed green line shows your baseline at 50% on all sliders. ');
            if (best && best.key === 'adaptive') {
              rLines.push('Guided (blue) stays close to baseline \u2014 its tight constraints limit how far sliders can move, producing the most defensible result.');
            } else if (best && best.key === 'fixed') {
              rLines.push('Optimized pushes sliders further than Guided within standard boundaries \u2014 wider reach means higher probability but more assumptions.');
            } else if (best && best.key === 'manual') {
              rLines.push('Explorer shows unconstrained slider positions \u2014 large deviations from baseline suggest assumptions that may not hold in practice.');
            }
            radarDesc.innerHTML = rLines.join('');
          } else if (onOverlay) {
            radarDesc.style.display = '';
            radarDesc.innerHTML = '<strong>Slider profile:</strong> Shows current decision lever settings. Activate optimization strategies to see how they adjust these values.';
          } else {
            radarDesc.style.display = 'none';
          }
        }

        // --- Hypercube description ---
        if (hcDesc) {
          if (onOverlay) {
            hcDesc.style.display = '';
            var hLines = ['<strong>Parameter space:</strong> '];
            hLines.push('A 3D projection of the 7-dimensional slider space. ');
            hLines.push('The nested cubes represent constraint boundaries \u2014 inner cubes are tighter constraints (Guided), outer cubes are wider (Optimized/Explorer). ');
            if (hasVariants && best) {
              hLines.push('The current configuration sits ' + (best.key === 'adaptive' ? 'near the inner boundary (conservative)' : best.key === 'fixed' ? 'between inner and outer boundaries (balanced)' : best.key === 'manual' ? 'near or beyond the outer boundary (aggressive)' : 'at the origin (baseline)') + '.');
            }
            hcDesc.innerHTML = hLines.join('');
          } else {
            hcDesc.style.display = 'none';
          }
        }
      }

      window.renderRightLegend = function(){ /* kept hidden via CSS */ };

      function dsLine(opts) {
        var c = cssVar(opts.colorVar) || '#666';
        return {
          label: opts.label,
          data: opts.data,
          parsing: false,
          borderColor: c,
          backgroundColor: c,
          borderWidth: 2,
          pointRadius: 0,
          cubicInterpolationMode: 'monotone',
          tension: (typeof opts.tension==='number') ? opts.tension : 0.25,
          spanGaps: true,
          hidden: !!opts.hidden,
          fill: !!opts.fill,
          order: (typeof opts.z==='number') ? opts.z : 1
        };
      }
      function dsTargetDot(cfg) {
        if (cfg.x==null || !Array.isArray(cfg.series) || !cfg.series.length) return null;
        var y = window.interpY(cfg.series, cfg.x);
        if (y==null || !isFinite(y)) return null;
        var c = cssVar(cfg.colorVar) || '#333';
        return {
          type: 'scatter',
          label: cfg.key+' target',
          _probKey: cfg.key,
          data: [{x: cfg.x, y: y}],
          pointBackgroundColor: c,
          pointBorderColor: c,
          pointRadius: 4,
          pointHoverRadius: 5,
          showLine: false,
          order: 0
        };
      }
      function fitScales(chart, seriesArrays, kind) {
        if (!chart || !seriesArrays || !seriesArrays.length) return;
        var b = window.boundsFromSeries(seriesArrays);
        if (!b) return;
        chart.options.scales.x.min = b.xmin;
        chart.options.scales.x.max = b.xmax;
        if (kind==='pdf') {
          chart.options.scales.y.min = Math.max(0, b.ymin);
          chart.options.scales.y.max = Math.max(0.05, b.ymax);
        } else {
          chart.options.scales.y.min = 0;
          chart.options.scales.y.max = 1;
        }
      }

      // Debounced chart update — coalesces rapid calls within 30ms but executes first call immediately
      var _chartUpdateTimer = null;
      var _chartUpdateLast = 0;
      window.updateChart = function(){
        var now = Date.now();
        if (now - _chartUpdateLast < 30) {
          // Rapid call — debounce it
          if (_chartUpdateTimer) clearTimeout(_chartUpdateTimer);
          _chartUpdateTimer = setTimeout(function(){
            _chartUpdateTimer = null;
            _chartUpdateLast = Date.now();
            window._doUpdateChart();
          }, 30);
          return;
        }
        // First call or enough time passed — execute immediately
        if (_chartUpdateTimer) clearTimeout(_chartUpdateTimer);
        _chartUpdateTimer = null;
        _chartUpdateLast = now;
        window._doUpdateChart();
      };
      window._doUpdateChart = function(){
        var s = WS();
        if (typeof window.ensureCharts === 'function') window.ensureCharts();
        var msgEl = document.getElementById('plotMsg');

        var haveAny =
          (s.trianglePdf && s.trianglePdf.length) ||
          (s.betaPertPdf && s.betaPertPdf.length) ||
          (s.basePdf && s.basePdf.length);

        if (!haveAny) {
          if (msgEl) { msgEl.style.display='block'; msgEl.textContent='Select a task to view distributions.'; }
          return;
        } else if (msgEl) { msgEl.style.display='none'; }

        var onOverlay = (s.tab === 'overlay');

        function buildDatasets(kind) {
          var triSeries = (kind==='pdf') ? (s.trianglePdf||[]) : (s.triangleCdf||[]);
          var betSeries = (kind==='pdf') ? (s.betaPertPdf||[]) : (s.betaPertCdf||[]);
          var baseSeries= (kind==='pdf') ? (s.basePdf||[]) : (s.baseCdf||[]);
          var manSeries = (kind==='pdf') ? (s.adjPdf||[]) : (s.adjCdf||[]);
          var fixSeries = (kind==='pdf') ? (s.optPdfFixed||[]) : (s.optCdfFixed||[]);
          var adaSeries = (kind==='pdf') ? (s.optPdfAdaptive||[]) : (s.optCdfAdaptive||[]);

          var showTri = (!onOverlay && s.tab==='progress' && s.progress.triOn);
          var showBet = (!onOverlay && s.tab==='progress' && s.progress.betaOn);
          var showBase= (!onOverlay && s.tab==='progress' && s.progress.baseOn);

          var base = dsLine({ label: 'Your Estimate', data: baseSeries, colorVar: '--base', z: 3, hidden: !(onOverlay ? s.overlay.baselineOn : showBase) });
          var tri  = dsLine({ label: 'Triangle', data: triSeries, colorVar: '--tri',  z: 2, hidden: !showTri });
          var bet  = dsLine({ label: 'Beta-PERT', data: betSeries, colorVar: '--beta', z: 2, hidden: !showBet });

          var man  = dsLine({ label: 'Explorer', data: manSeries, colorVar: '--manual', z: 4, hidden: !(onOverlay && s.overlay && s.overlay.manualOn) });
          var fix  = dsLine({ label: 'Optimized', data: fixSeries, colorVar: '--fixed',  z: 4, hidden: !(onOverlay && s.overlay && s.overlay.fixedOn) });
          var ada  = dsLine({ label: 'Guided', data: adaSeries, colorVar: '--adaptive', z:4, hidden: !(onOverlay && s.overlay && s.overlay.adaptiveOn) });

          var dotBase = onOverlay && s.overlay.baselineOn ? dsTargetDot({ key:'baseline', x:(s.target), series: baseSeries, colorVar: '--base' }) : null;
          var dotAdj  = onOverlay && s.overlay.manualOn   ? dsTargetDot({ key:'adjusted', x:(s.target), series: manSeries,  colorVar:'--manual' }) : null;
          var dotOpt  = onOverlay && s.overlay.fixedOn    ? dsTargetDot({ key:'optimized',x:(s.target), series: fixSeries,  colorVar:'--fixed' }) : null;
          var dotAda  = onOverlay && s.overlay.adaptiveOn ? dsTargetDot({ key:'adaptive', x:(s.target), series: adaSeries,  colorVar:'--adaptive' }) : null;

          // Progress tab: annotated dots on visible curves at the target value
          var dotTri  = (!onOverlay && showTri)  ? dsTargetDot({ key:'triangle', x:(s.target), series: triSeries, colorVar:'--tri' }) : null;
          var dotBet  = (!onOverlay && showBet)  ? dsTargetDot({ key:'betapert', x:(s.target), series: betSeries, colorVar:'--beta' }) : null;
          var dotPBase= (!onOverlay && showBase) ? dsTargetDot({ key:'baseline', x:(s.target), series: baseSeries, colorVar:'--base' }) : null;

          var arr = [base, tri, bet, man, fix, ada, dotBase, dotAdj, dotOpt, dotAda, dotTri, dotBet, dotPBase].filter(Boolean);
          return arr;
        }

        if (s.pdfChart) {
          var pdfDs = buildDatasets('pdf');
          s.pdfChart.data.datasets = pdfDs;
          var pdfSeriesForBounds = [];
          for (var i=0;i<pdfDs.length;i++) {
            var d = pdfDs[i];
            if (d.type !== 'scatter' && !d.hidden) pdfSeriesForBounds.push(d.data);
          }
          fitScales(s.pdfChart, pdfSeriesForBounds, 'pdf');
          s.pdfChart.update('none');
        }

        if (s.cdfChart) {
          var cdfDs = buildDatasets('cdf');
          s.cdfChart.data.datasets = cdfDs;
          var cdfSeriesForBounds = [];
          for (var j=0;j<cdfDs.length;j++) {
            var d2 = cdfDs[j];
            if (d2.type !== 'scatter' && !d2.hidden) cdfSeriesForBounds.push(d2.data);
          }
          fitScales(s.cdfChart, cdfSeriesForBounds, 'cdf');
          s.cdfChart.update('none');
        }

        var legOverlay = document.getElementById('legendOverlay');
        var legDist = document.getElementById('legendDistributions');
        if (legOverlay && legDist) {
          legOverlay.style.display = onOverlay ? 'flex' : 'none';
          legDist.style.display = onOverlay ? 'none' : 'flex';
        }

        // Debounced 3D hypercube render — prevents blocking the main thread on every chart update
        if (typeof window.visualizeHypercubeOnBaseline === 'function' && onOverlay) {
          if (window._hcTimer) clearTimeout(window._hcTimer);
          window._hcTimer = setTimeout(function(){
            window._hcTimer = null;
            var hcSection = document.getElementById('hypercubeSection');
            if (hcSection && hcSection.offsetParent !== null) {
              window.visualizeHypercubeOnBaseline();
            }
          }, 400);
        }
      };

      document.addEventListener('DOMContentLoaded', function(){
        if (typeof window.renderRightLegend === 'function') window.renderRightLegend();
        if (typeof window.renderKPIs === 'function') window.renderKPIs();
        if (typeof window.updateChart === 'function') window.updateChart();
        if (typeof window.initProbeUI === 'function') window.initProbeUI();
        if (typeof window.initPlotHelp === 'function') window.initPlotHelp();
      });
    })();
  </script>

  <!-- Combined Visualization: Original Radar + New 3D Rotating Hypercube with VISIBLE LABELS -->
  <script>
    function visualizeHypercubeOnBaseline() {
      const S = window.S || {};

      // 1. Original Radar Chart
      const radarCanvas = document.getElementById('hypercubeRadar');
      if (radarCanvas) {
        let suffix = '';
        if (S.overlay?.adaptiveOn) suffix = '_adapt';
        else if (S.overlay?.fixedOn) suffix = '_fixed';
        else if (S.overlay?.manualOn) suffix = '';
        else suffix = '_base';

        const sliderIds = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
        const labels = ['Budget Flexibility','Schedule Flexibility','Scope Certainty','Scope Reduction Allowance','Rework Percentage','Risk Tolerance','User Confidence'];

        const values = sliderIds.map(id => {
          const el = document.getElementById(id + suffix);
          return el ? Number(el.value) : 0;
        });

        const radarData = values.map((v, i) => i === 4 ? v * 2 : v);
        const baselineRef = new Array(labels.length).fill(50);

        const data = {
          labels: labels,
          datasets: [
            {
              label: 'Current Sliders (%)',
              data: radarData,
              fill: true,
              backgroundColor: 'rgba(59, 130, 246, 0.2)',
              borderColor: 'rgb(59, 130, 246)',
              pointBackgroundColor: 'rgb(59, 130, 246)',
              pointBorderColor: '#fff'
            },
            {
              label: 'Baseline Reference (50%)',
              data: baselineRef,
              fill: false,
              borderColor: 'rgba(34, 197, 94, 0.8)',
              pointBackgroundColor: 'rgb(34, 197, 94)',
              borderDash: [5, 5]
            }
          ]
        };

        const config = {
          type: 'radar',
          data: data,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: {
                display: true,
                text: '7D Hypercube Projection – Current Slider Configuration',
                font: { size: 14 }
              },
              legend: { position: 'top' },
              tooltip: { enabled: true }
            },
            scales: {
              r: {
                min: 0,
                max: 100,
                ticks: { stepSize: 20 }
              }
            }
          }
        };

        if (window.hyperRadarChart) {
          // Update data in-place instead of destroying and recreating
          window.hyperRadarChart.data.datasets[0].data = radarData;
          window.hyperRadarChart.update('none');
        } else {
          window.hyperRadarChart = new Chart(radarCanvas, config);
        }
      }

      // 2. 3D Rotating Hypercube with VISIBLE LABELS (minimal fix: transparent: true)
      const canvas3D = document.getElementById('hypercube3D');
      if (!canvas3D) return;

      // Clean up previous Three.js renderer to prevent memory leaks
      if (window._hypercubeRenderer) {
        window._hypercubeRenderer.dispose();
        window._hypercubeRenderer = null;
      }

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8f9fa);

      const camera = new THREE.PerspectiveCamera(60, canvas3D.clientWidth / canvas3D.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ canvas: canvas3D, antialias: true });
      renderer.setSize(canvas3D.clientWidth, canvas3D.clientHeight || 320);
      renderer.setPixelRatio(window.devicePixelRatio);
      window._hypercubeRenderer = renderer;

      const ambientLight = new THREE.AmbientLight(0xffffff, 1);
      scene.add(ambientLight);

      let suffix = '';
      if (S.overlay?.adaptiveOn) suffix = '_adapt';
      else if (S.overlay?.fixedOn) suffix = '_fixed';
      else if (S.overlay?.manualOn) suffix = '';
      else suffix = '_base';

      const sliderIds = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
      const sliderLabels = ['Budget Flex','Schedule Flex','Scope Certainty','Scope Red','Rework %','Risk Tol','User Conf'];
      const sliderValues = sliderIds.map(id => Number(document.getElementById(id + suffix)?.value || 0) / 100);

      const baselineLabels = ['Baseline Mean','Baseline Variance','Baseline Prob'];
      const baselineValues = [
        (S.M || 50) / 100,
        ((S.P - S.O)/6 || 10) / 100,
        S.baselineProb || 0.5
      ];

      const vertices4D = [];
      for (let i = 0; i < 16; i++) {
        vertices4D.push([(i & 1 ? 1 : -1), (i & 2 ? 1 : -1), (i & 4 ? 1 : -1), (i & 8 ? 1 : -1)]);
      }

      const edges = [];
      for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
          if (((i ^ j) & -(i ^ j)) === (i ^ j)) edges.push([i, j]);
        }
      }

      let angles = sliderValues.map(v => v * Math.PI * 2);

      const material = new THREE.LineBasicMaterial({ color: 0x0066ff });

      const group = new THREE.Group();
      scene.add(group);

      function updateHypercube() {
        group.clear();

        const projected = vertices4D.map(v => {
          let [x, y, z, w] = v;
          for (let p = 0; p < 6; p++) {
            const theta = angles[p];
            const c = Math.cos(theta), s = Math.sin(theta);
            switch (p) {
              case 0: [x, y] = [x*c - y*s, x*s + y*c]; break;
              case 1: [x, z] = [x*c - z*s, x*s + z*c]; break;
              case 2: [x, w] = [x*c - w*s, x*s + w*c]; break;
              case 3: [y, z] = [y*c - z*s, y*s + z*c]; break;
              case 4: [y, w] = [y*c - w*s, y*s + w*c]; break;
              case 5: [z, w] = [z*c - w*s, z*s + w*c]; break;
            }
          }
          x *= (1 + baselineValues[0]);
          y *= (1 + baselineValues[1]);
          z *= (1 + baselineValues[2]);
          const dist = 4;
          const scale = dist / (dist + w);
          return new THREE.Vector3(x * scale, y * scale, z * scale);
        });

        edges.forEach(([i, j]) => {
          const geo = new THREE.BufferGeometry().setFromPoints([projected[i], projected[j]]);
          const line = new THREE.Line(geo, material);
          group.add(line);
        });
      }

      function addLabel(text, position, opts) {
        opts = opts || {};
        const fontSize = opts.fontSize || 38;
        const canvasLabel = document.createElement('canvas');
        canvasLabel.width = 320;
        canvasLabel.height = 64;
        const ctx = canvasLabel.getContext('2d');
        // Transparent background
        ctx.font = 'bold ' + fontSize + 'px Arial';
        ctx.fillStyle = opts.color || '#374151';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvasLabel.width / 2, canvasLabel.height / 2);

        const texture = new THREE.CanvasTexture(canvasLabel);
        const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.position.copy(position);
        sprite.scale.set(opts.scaleX || 3.5, opts.scaleY || 0.7, 1);
        group.add(sprite);
      }

      const allLabels = baselineLabels.map((l, i) => `${l}: ${(baselineValues[i]*100).toFixed(0)}%`)
        .concat(sliderLabels.map((l, i) => `${l}: ${(sliderValues[i]*100).toFixed(0)}%`));

      allLabels.forEach((label, i) => {
        const pos = new THREE.Vector3((i % 3 - 1) * 4.5, (Math.floor(i / 3) % 3 - 1) * 4.5, Math.floor(i / 9) * 4.5 - 2);
        addLabel(label, pos);
      });

      const prob = S.adaptiveProb || S.optimizedProb || S.adjustedProb || S.baselineProb || 0;
      addLabel(`Target Probability: ${(prob * 100).toFixed(1)}%`, new THREE.Vector3(0, -4.5, 0));

      updateHypercube();

      camera.position.z = 10;

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = false; // Disable damping — removes need for animation loop

      // Add axes helper for labels
      const axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      // Add axis labels with slider dimension names
      // X = Budget Flexibility, Y = Schedule Flexibility, Z = Scope Certainty
      // (first 3 of 7 sliders; the remaining 4 are folded into the 4th hypercube dimension)
      addLabel('Budget Flex (X)', new THREE.Vector3(6.2, 0, 0));
      addLabel('Schedule Flex (Y)', new THREE.Vector3(0, 6.2, 0));
      addLabel('Scope Certainty (Z)', new THREE.Vector3(0, 0, 6.2));

      // Cancel any previous animation loop
      if (window._hypercubeAnimId) { cancelAnimationFrame(window._hypercubeAnimId); window._hypercubeAnimId = null; }

      // On-demand rendering instead of 60fps loop — only render when user interacts
      function renderOnce() { renderer.render(scene, camera); }
      renderOnce();
      controls.addEventListener('change', renderOnce);

      // Single resize listener (remove previous to prevent stacking)
      if (window._hcResizeHandler) window.removeEventListener('resize', window._hcResizeHandler);
      window._hcResizeHandler = function() {
        if (!canvas3D.offsetParent) return;
        camera.aspect = canvas3D.clientWidth / canvas3D.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(canvas3D.clientWidth, canvas3D.clientHeight || 320);
        renderOnce();
      };
      window.addEventListener('resize', window._hcResizeHandler, { passive: true });

      // Add subtitles dynamically
      const target = S.target ? S.target.toFixed(2) : 'N/A';
      const probability = ((S.adaptiveProb || S.optimizedProb || S.adjustedProb || S.baselineProb || 0) * 100).toFixed(2) + '%';
      document.getElementById('radarSubtitle').textContent = `Target: ${target}, Probability: ${probability}`;
      document.getElementById('hypercubeSubtitle').textContent = `Target: ${target}, Probability: ${probability}`;
    }
  </script>

  <!-- API Fetch, Variant Requests, UI Bindings & Boot -->
  <script>
    (function(){
      function safe(fn){ try { fn(); } catch(e){
        console.error('[safe] error:', e);
        var b = document.getElementById('errorBanner');
        if (b) { b.style.display='block'; b.style.background='#FEE2E2'; b.style.color='#991B1B'; b.style.borderColor='#DC2626'; b.innerHTML += '<div>[SAFE] '+e.message+' at '+(e.stack||'').split('\\n')[1]+'</div>'; }
        fetch('/console',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({type:'error',msg:'[safe] '+e.message,stack:e.stack})}).catch(function(){});
      } }
      function WS(){ return window.S || (window.S = {}); }

      // ── Probability summary bar ───────────────────────────────────────────
      window.updateProbSummary = function() {
        var bar = document.getElementById('probSummaryBar');
        if (!bar) return;
        var s = window.S || {};
        if (s.tab !== 'overlay') { bar.style.display = 'none'; return; }
        var tau = (s.target != null && isFinite(s.target)) ? Number(s.target) : null;
        var P0  = s.baselineProb;
        if (tau == null || P0 == null || !isFinite(P0)) { bar.style.display = 'none'; return; }
        bar.style.display = 'flex';
        var ov = s.overlay || {};
        var tauEl  = document.getElementById('psbTau');
        var baseEl = document.getElementById('psbBase');
        var guidEl = document.getElementById('psbGuided');
        var optEl  = document.getElementById('psbOptimized');
        var expEl  = document.getElementById('psbExplorer');
        if (tauEl)  tauEl.textContent  = '\u03c4\u202f=\u202f' + tau.toFixed(2);
        if (baseEl) baseEl.textContent = 'Baseline P\u2080\u202f=\u202f' + (P0 * 100).toFixed(1) + '%';
        if (guidEl) {
          if (ov.adaptiveOn && s.adaptiveProb != null && isFinite(s.adaptiveProb)) {
            var dPg = (s.adaptiveProb - P0) * 100;
            guidEl.textContent = 'Guided\u202f' + (s.adaptiveProb * 100).toFixed(1) + '%\u202f(\u0394P\u202f' + (dPg >= 0 ? '+' : '') + dPg.toFixed(1) + '%)';
            guidEl.style.display = 'inline-block';
          } else { guidEl.style.display = 'none'; }
        }
        if (optEl) {
          if (ov.fixedOn && s.optimizedProb != null && isFinite(s.optimizedProb)) {
            var dPo = (s.optimizedProb - P0) * 100;
            optEl.textContent = 'Optimized\u202f' + (s.optimizedProb * 100).toFixed(1) + '%\u202f(\u0394P\u202f' + (dPo >= 0 ? '+' : '') + dPo.toFixed(1) + '%)';
            optEl.style.display = 'inline-block';
          } else { optEl.style.display = 'none'; }
        }
        if (expEl) {
          if (ov.manualOn && s.adjustedProb != null && isFinite(s.adjustedProb)) {
            var dPe = (s.adjustedProb - P0) * 100;
            expEl.textContent = 'Explorer\u202f' + (s.adjustedProb * 100).toFixed(1) + '%\u202f(\u0394P\u202f' + (dPe >= 0 ? '+' : '') + dPe.toFixed(1) + '%)';
            expEl.style.display = 'inline-block';
          } else { expEl.style.display = 'none'; }
        }
      };

      // Consolidated UI refresh — coalesces rapid calls within 30ms
      var _uiRefreshTimer = null;
      function _doUIRefresh() {
        _uiRefreshTimer = null;
        safe(function(){ window.renderKPIs(); });
        safe(function(){ window.updateChart(); });
        safe(function(){ window.renderRightLegend(); });
        safe(function(){ if (typeof window.updateProbSummary === 'function') window.updateProbSummary(); });
      }
      function scheduleUIRefresh() {
        if (_uiRefreshTimer) return; // already scheduled — coalesce
        _uiRefreshTimer = requestAnimationFrame(function() {
          _uiRefreshTimer = null;
          _doUIRefresh();
        });
      }
      window.scheduleUIRefresh = scheduleUIRefresh;

      function ensureProbeBox(){
        if (typeof window.initProbeUI === 'function') window.initProbeUI();
        if (typeof window.syncProbeUI === 'function') window.syncProbeUI();
      }

      function setStatusLocal(t) {
        if (typeof window.setStatus === 'function') { window.setStatus(t); return; }
        var s = WS();
        var el = document.getElementById('fetchStatus');
        if (!el) return;
        var any = s.fetching || (s.overlay && s.overlay.variants && Object.keys(s.overlay.variants).some(function(k){ return !!s.overlay.variants[k].loading; }));
        el.textContent = any ? 'Fetching…' : (t || 'Ready');
        el.classList.toggle('fetching', any);
        el.classList.toggle('glow', any);
        var mini = document.getElementById('seriesStatus'); if (mini) mini.textContent = el.textContent;
      }

      function updateSliderTable(fixedSliders, adaptiveSliders) {
        const grid = document.getElementById('slidersGrid');
        if (!grid) return;

        const hasFixed = Object.values(fixedSliders).some(v => v > 0);
        const hasAdaptive = Object.values(adaptiveSliders).some(v => v > 0);
        let numCols = 1;
        if (hasFixed) numCols += 1;
        if (hasAdaptive) numCols += 1;

        const gridCols = Array(numCols).fill('1fr').join(' ');
        grid.style.gridTemplateColumns = gridCols;

        const headers = grid.querySelectorAll('.comp-header');
        headers[0].style.display = 'table-cell';
        const fixedHeader = grid.querySelector('.comp-header.comp-fixed');
        if (fixedHeader) fixedHeader.style.display = hasFixed ? 'table-cell' : 'none';
        const adaptiveHeader = grid.querySelector('.comp-header.comp-adaptive');
        if (adaptiveHeader) adaptiveHeader.style.display = hasAdaptive ? 'table-cell' : 'none';
      }

      function handleEmptyResponses(fixedData, adaptiveData) {
        if (fixedData.explain?.status === 'no-optimize') {
          console.log('No-optimize mode detected for Fixed, sliders zeroed:', fixedData);
        }
        if (adaptiveData.explain?.status === 'no-optimize') {
          console.log('No-optimize mode detected for Adaptive, sliders zeroed:', adaptiveData);
        }

        const adaptiveSliders = extractSliderVals(adaptiveData);
        if (Object.values(adaptiveSliders).every(v => v === 0)) {
          const status = adaptiveData.explain?.status || adaptiveData.optimize?.status || 'unknown';
          console.log(`Adaptive sliders zeroed (${status}):`, adaptiveData);
          if (status === 'no-optimize') {
            console.log('Intentional: Baseline optimal—no lift possible.');
          }
        }
      }

      function updateServerNote(fixedSliders, adaptiveSliders, fixedData, adaptiveData) {
        const allZero = Object.values(fixedSliders).every(v => v === 0) && 
                        Object.values(adaptiveSliders).every(v => v === 0);
        const noteEl = document.getElementById('slidersNoteMissing');
        if (!noteEl) return;

        if (allZero) {
          const fixedStatus = fixedData.explain?.status || fixedData.optimize?.status || 'unknown';
          const adaptiveStatus = adaptiveData.explain?.status || adaptiveData.optimize?.status || 'unknown';
          noteEl.textContent = (fixedStatus === 'no-optimize' || adaptiveStatus === 'no-optimize') 
            ? 'Baseline optimal—no adjustments boost probability.' 
            : 'Server did not return optimal slider values (both modes zeroed).';
          noteEl.style.display = 'block';
        } else {
          noteEl.style.display = 'none';
        }
      }

      var _sliderCompTimer = null;
      function updateSliderComparisons() {
        if (_sliderCompTimer) clearTimeout(_sliderCompTimer);
        _sliderCompTimer = setTimeout(_doUpdateSliderComparisons, 50);
      }
      function _doUpdateSliderComparisons() {
        _sliderCompTimer = null;
        var s = WS();
        if (s.pendingVariants > 0) { return; }
        var grid = document.getElementById('slidersGrid');
        if (!grid) return;

        const fixedSliders = extractSliderVals(s.explainOpt || {}, 'fixed');
        const adaptiveSliders = extractSliderVals(s.explainAdaptive || {}, 'adaptive');
        updateSliderTable(fixedSliders, adaptiveSliders);
        updateServerNote(fixedSliders, adaptiveSliders, s.explainOpt || {}, s.explainAdaptive || {});
        handleEmptyResponses(s.explainOpt || {}, s.explainAdaptive || {});

        var showFixed    = (s.tab === 'overlay') && !!s.overlay.fixedOn;
        var showAdaptive = (s.tab === 'overlay') && !!s.overlay.adaptiveOn;

        var i, nodes;
        nodes = grid.querySelectorAll('.comp-header.comp-fixed'); for(i=0;i<nodes.length;i++) nodes[i].style.display = showFixed ? 'block' : 'none';
        nodes = grid.querySelectorAll('.comp-header.comp-adaptive'); for(i=0;i<nodes.length;i++) nodes[i].style.display = showAdaptive ? 'block' : 'none';
        nodes = grid.querySelectorAll('.comp.comp-fixed'); for(i=0;i<nodes.length;i++) nodes[i].style.display = showFixed ? 'block' : 'none';
        nodes = grid.querySelectorAll('.comp.comp-adaptive'); for(i=0;i<nodes.length;i++) nodes[i].style.display = showAdaptive ? 'block' : 'none';

        setCompareValues('base', extractSliderVals(s.explainBase || s.lastPayload || {}));
        if (showFixed) setCompareValues('fixed', fixedSliders);
        if (showAdaptive) setCompareValues('adaptive', adaptiveSliders);

        var cols = 3 + (showFixed ? 1 : 0) + (showAdaptive ? 1 : 0);
        grid.style.gridTemplateColumns = '140px repeat('+(cols-1)+', 80px)';
        console.log('Table updated: full sync');

        // Render optimal markers on range slider tracks
        if (showFixed && fixedSliders) {
          Object.entries(fixedSliders).forEach(function(pair) {
            var id = sliderIdMap[pair[0]];
            if (!id) return;
            var markerEl = document.getElementById(id + '_marker');
            var rangeEl = document.getElementById(id + '_range');
            if (markerEl && rangeEl) {
              markerEl.innerHTML = '';
              var val = Number(pair[1]) || 0;
              var max = Number(rangeEl.max) || 100;
              var pct = (val / max) * 100;
              var dot = document.createElement('div');
              dot.className = 'marker-dot';
              dot.style.left = pct + '%';
              dot.title = 'Optimized: ' + val + '%';
              markerEl.appendChild(dot);
            }
            // Store fixed value on hidden input for Match Optimized button
            var fixedInput = document.getElementById(id + '_fixed');
            if (!fixedInput) {
              fixedInput = document.createElement('input');
              fixedInput.type = 'hidden';
              fixedInput.id = id + '_fixed';
              document.body.appendChild(fixedInput);
            }
            fixedInput.value = pair[1] || 0;
          });
        }

        // Render sensitivity bars
        renderSensitivityBars();
      }

      function renderSensitivityBars() {
        var container = document.getElementById('sensitivityContent');
        var panel = document.getElementById('sensitivityBars');
        if (!container || !panel) return;

        var s = WS();
        if (s.tab !== 'overlay') { panel.style.display = 'none'; return; }
        panel.style.display = 'block';

        var weights = s.currentWeights || {};
        var labels = {
          budget: 'Budget', schedule: 'Schedule', scopeCert: 'Scope Cert',
          scopeRed: 'Scope Red', rework: 'Rework', riskTol: 'Risk Tol', userConf: 'Confidence'
        };
        var entries = Object.entries(weights).map(function(pair) {
          return { key: pair[0], label: labels[pair[0]] || pair[0], weight: pair[1], absWeight: Math.abs(pair[1]) };
        });
        var maxW = Math.max.apply(null, entries.map(function(e) { return e.absWeight; }));
        if (maxW === 0) maxW = 1;

        container.innerHTML = entries.sort(function(a, b) { return b.absWeight - a.absWeight; }).map(function(e) {
          var pct = (e.absWeight / maxW * 100).toFixed(1);
          var cls = e.weight >= 0 ? 'positive' : 'negative';
          return '<div class="sens-row">' +
            '<span class="sens-label">' + e.label + '</span>' +
            '<div class="sens-bar-track"><div class="sens-bar-fill ' + cls + '" style="width:' + pct + '%"></div></div>' +
            '<span class="sens-val">' + (e.weight >= 0 ? '+' : '') + (e.weight * 100).toFixed(0) + '</span>' +
          '</div>';
        }).join('');
      }

      function fetchData(debounced) {
        var s = WS();
        if (debounced === undefined) debounced = true;

        if (!s || !s.task || !s.task.task) {
          setStatusLocal('No task selected');
          var msg = document.getElementById('plotMsg');
          if (msg) { msg.style.display='block'; msg.textContent='No task selected'; }
          return;
        }

        if (debounced) { clearTimeout(s.fetchTimer); s.fetchTimer = setTimeout(function(){ fetchData(false); }, 200); return; }
        if (s.fetching) return;
        // Skip if baseline data already loaded for current inputs (tab switch doesn't need re-fetch)
        if (s.trianglePdf.length && s.basePdf.length) {
          s.fetching = false; setStatusLocal('Ready');
          scheduleUIRefresh();
          return;
        }

        s.fetching = true; setStatusLocal('Fetching…');

        var baseKey = JSON.stringify({ task: s.task.task, O:s.O, M:s.M, P:s.P, target:s.target });

        if (s.baselineCache && s.baselineCache[baseKey]) {
          var c = s.baselineCache[baseKey];
          s.trianglePdf = c.trianglePdf; s.triangleCdf = c.triangleCdf;
          s.betaPertPdf = c.betaPertPdf; s.betaPertCdf = c.betaPertCdf;
          s.basePdf = c.basePdf; s.baseCdf = c.baseCdf;
          s.baselineProb = c.baselineProb;

          // C3: Skip event dispatch on cached baseline — data unchanged, just refresh UI
          s.fetching = false; setStatusLocal('Ready');
          updateTargetDisplayText();
          scheduleUIRefresh();
          ensureProbeBox();
          return;
        }

        var params = {
          task: s.task.task,
          optimistic: s.O, mostLikely: s.M, pessimistic: s.P,
          targetValue: (s.target != null ? s.target : s.M),
          optimize: false, mode: 'view', adaptive: false,
          reshapeTriangle: true, reshapeBetaPert: true
        };

        if (!window.google || !google.script || !google.script.run) {
          s.fetching = false; setStatusLocal('Ready');
          var msg2 = document.getElementById('plotMsg');
          if (msg2) { msg2.style.display='block'; msg2.textContent='Apps Script runtime not available (preview mode).'; }
          if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender();
          return;
        }

        google.script.run
          .withSuccessHandler(function(payload){
            if(window._pmcDebug)fetch('/console',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({type:'data',msg:'fetchData success handler called, payload keys: '+(payload ? Object.keys(payload).join(',') : 'null')})}).catch(function(){});
            try {
              if (!payload) throw new Error('Empty payload');
              var item = Array.isArray(payload.results) ? payload.results[0] : payload;
              if (!item) throw new Error('No result item');

              function gp(obj, path) {
                var parts = path.split('.');
                var cur = obj;
                for (var i=0;i<parts.length;i++){ var k = parts[i]; if (!cur || !(k in cur)) return null; cur = cur[k]; }
                return cur;
              }
              function pick(obj, paths){
                for (var i=0;i<paths.length;i++){ var v = gp(obj, paths[i]); if (v!=null) return v; }
                return null;
              }

              s.lastPayload = item;
              s.explainBase = item;

              var triPdfRaw = pick(item, ['trianglePdf.value','triangle.pdf','trianglePdfPoints','triangle.points.pdf']);
              var triCdfRaw = pick(item, ['triangleCdf.value','triangle.cdf','triangleCdfPoints','triangle.points.cdf']);
              var betPdfRaw = pick(item, ['betaPertPdf.value','betaPert.pdf','beta.pdf','pert.pdf']);
              var betCdfRaw = pick(item, ['betaPertCdf.value','betaPert.cdf','beta.cdf','pert.cdf']);
              var basePdfRaw= pick(item, ['targetProbabilityOriginalPdf.value','baselineReshapedPoints.pdfPoints','baseline.pdf','baseline.points.pdf']);
              var baseCdfRaw= pick(item, ['targetProbabilityOriginalCdf.value','baselineReshapedPoints.cdfPoints','baseline.cdf','baseline.points.cdf']);

              s.trianglePdf = normalizePoints_(triPdfRaw, true);
              s.triangleCdf = normalizePoints_(triCdfRaw, false);
              s.betaPertPdf = normalizePoints_(betPdfRaw, true);
              s.betaPertCdf = normalizePoints_(betCdfRaw, false);
              s.basePdf     = normalizePoints_(basePdfRaw, true);
              s.baseCdf     = normalizePoints_(baseCdfRaw, false);

              var baseProb = pick(item, [
                'targetProbability.value.original',
                'targetProbability.value.baseline',
                'baseline.prob',
                'baselineProbability',
                'probabilities.baseline'
              ]);
              s.baselineProb= (baseProb!=null) ? Number(baseProb) : ((s.target!=null && s.baseCdf.length) ? interpY(s.baseCdf, s.target) : null);

              const baseSliders = extractSliderVals(s.explainBase);
              setCompareValues('base', baseSliders);

              if (s.tab==='overlay' && s.overlay && s.overlay.manualOn) {
                var zero = true;
                var vals = (typeof window.sliderValues==='function' ? window.sliderValues() : {});
                var keys = ['budgetFlexibility','scheduleFlexibility','scopeCertainty','scopeReductionAllowance','reworkPercentage','riskTolerance','userConfidence'];
                for (var z=0;z<keys.length;z++){ if (Number(vals[keys[z]]||0)!==0) { zero=false; break; } }
                if (zero) { s.adjPdf = s.basePdf.slice(); s.adjCdf = s.baseCdf.slice(); s.adjustedProb = s.baselineProb; }
              }

              s.baselineCache[baseKey] = {
                trianglePdf:s.trianglePdf, triangleCdf:s.triangleCdf,
                betaPertPdf:s.betaPertPdf, betaPertCdf:s.betaPertCdf,
                basePdf:s.basePdf, baseCdf:s.baseCdf, baselineProb:s.baselineProb
              };

              if (typeof window.dispatchEvent === 'function') {
                window.dispatchEvent(new CustomEvent('pmc:baseline:ready', { detail: {
                  task: s.task, O: s.O, M: s.M, P: s.P, target: s.target,
                  baselineProb: s.baselineProb,
                  trianglePdf: s.trianglePdf, triangleCdf: s.triangleCdf,
                  betaPertPdf: s.betaPertPdf, betaPertCdf: s.betaPertCdf,
                  basePdf: s.basePdf, baseCdf: s.baseCdf,
                  lastPayload: s.lastPayload || null
                }}));
              }

              if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender();

              updateTargetDisplayText();
              scheduleUIRefresh();
              ensureProbeBox();
            } catch(e) {
              fetch('/console',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({type:'error',msg:'fetchData catch: '+e.message,stack:e.stack})}).catch(function(){});
              var msgEl = document.getElementById('plotMsg');
              if (msgEl) { msgEl.style.display='block'; msgEl.textContent='Error: '+e.message; }
            } finally {
              s.fetching=false; setStatusLocal('Ready');
            }
          })
          .withFailureHandler(function(err){
            var msgEl = document.getElementById('plotMsg');
            if (msgEl) { msgEl.style.display='block'; msgEl.textContent='API Error: '+(err && err.message ? err.message : String(err)); }
            s.fetching=false; setStatusLocal('Ready');
          })
          .getTargetProbabilityData(params);
      }

      window.requestVariant = requestVariant;
      window.onTaskChange = onTaskChange;

      function requestVariant(variant) {
        var s = WS();
        if (!s || !s.task || !s.task.task) return;
        if (s.tab !== 'overlay') return;

        var vState = s.overlay && s.overlay.variants ? s.overlay.variants[variant] : null;
        if (!vState) return;

        var key = JSON.stringify({
          task: s.task.task, O: s.O, M: s.M, P: s.P, target: s.target,
          variant: variant,
          probeLevel: (variant==='adaptive' ? (s.overlay?.probeLevel || 3) : undefined)
        });
        var cached = s.variantCache && s.variantCache[key];
        if (cached) {
          applyVariantResult(variant, cached);
          if (variant==='fixed')   setCompareValues('fixed',   extractSliderVals(cached.explainOpt));
          if (variant==='adaptive')setCompareValues('adaptive',extractSliderVals(cached.explainAdaptive));
          if (variant==='fixed' || variant==='adaptive') updateSliderSidebarState();
          // C4: Skip event dispatch on cached variant — data unchanged, just refresh UI
          window.scheduleUIRefresh();
          updateSliderComparisons();
          setStatusLocal();
          ensureProbeBox();
          return;
        }

        vState.loading = true; vState.error = null; setStatusLocal('Fetching…');
        safe(function(){ window.renderKPIs(); });
        safe(function(){ window.renderRightLegend(); });
        ensureProbeBox();

        var token = ++vState.token;

        var isManual   = (variant === 'manual');
        var isFixed    = (variant === 'fixed');
        var isAdaptive = (variant === 'adaptive');

        var params = {
          task: s.task.task,
          optimistic: s.O, mostLikely: s.M, pessimistic: s.P,
          targetValue: (s.target != null ? s.target : s.M),
          optimize: !isManual,
          mode: isManual ? 'view' : (isAdaptive ? 'adaptive' : 'fixed'),
          adaptive: isAdaptive,
          probeLevel: isManual ? 0 : (isAdaptive ? (s.overlay?.probeLevel || 3) : undefined),
          sliderValues: isManual ? (typeof window.sliderValues==='function' ? window.sliderValues() : undefined) : undefined,
          reshapeTriangle: true, reshapeBetaPert: true
        };

        if (!window.google || !google.script || !google.script.run) {
          vState.loading = false; vState.error = 'Apps Script runtime not available';
          safe(function(){ window.renderRightLegend(); }); updateSliderComparisons(); setStatusLocal('Ready');
          return;
        }

        google.script.run
          .withSuccessHandler(function(payload){
            if (token !== vState.token) return;
            try {
              var item = Array.isArray(payload && payload.results) ? payload.results[0] : payload;
              if (!item) throw new Error('No result item');
              s.lastPayload = item;

              function normalizePoints_(arr, isPdf) {
                if (!Array.isArray(arr)) return [];
                var out = [];
                for (var i2=0;i2<arr.length;i2++){
                  var p = arr[i2] || {};
                  var x = Number(p.x), y = Number(p.y);
                  if (isFinite(x) && isFinite(y)) out.push({x:x,y:y});
                }
                out.sort(function(a,b){ return a.x-b.x; });
                if (isPdf && out.length>=2) {
                  if (out[0].y !== 0) out.unshift({x: out[0].x - 0.01, y: 0});
                  if (out[out.length-1].y !== 0) out.push({x: out[out.length-1].x + 0.01, y: 0});
                }
                return out;
              }

              function gp(obj, path) {
                var parts = path.split('.');
                var cur = obj;
                for (var i=0;i<parts.length;i++){ var k = parts[i]; if (!cur || !(k in cur)) return null; cur = cur[k]; }
                return cur;
              }
              function pick(obj, paths){
                for (var i=0;i<paths.length;i++){ var v = gp(obj, paths[i]); if (v!=null) return v; }
                return null;
              }

              if (isManual) {
                var adjPdfRaw = pick(item, ['targetProbabilityAdjustedPdf.value','adjustedReshapedPoints.pdfPoints','adjusted.pdf']);
                var adjCdfRaw = pick(item, ['targetProbabilityAdjustedCdf.value','adjustedReshapedPoints.cdfPoints','adjusted.cdf']);
                var adjProbRaw= pick(item, ['targetProbability.value.adjusted','adjustedProbability','probabilities.adjusted']);
                if (!adjPdfRaw || !adjCdfRaw) throw new Error('Adjusted curve missing');
                s.adjPdf = normalizePoints_(adjPdfRaw, true);
                s.adjCdf = normalizePoints_(adjCdfRaw, false);
                s.adjustedProb = (adjProbRaw!=null) ? Number(adjProbRaw)
                                : ((s.target!=null && s.adjCdf.length) ? interpY(s.adjCdf, s.target) : null);
                s.explainAdj = item;
                s.pendingVariants = Math.max(0, s.pendingVariants - 1);
                if (s.pendingVariants === 0) { updateSliderComparisons(); }

              } else if (isFixed) {
                var optPdfRaw = pick(item, ['optimizedReshapedPoints.pdfPoints','optimized.pdf','fixed.pdf']);
                var optCdfRaw = pick(item, ['optimizedReshapedPoints.cdfPoints','optimized.cdf','fixed.cdf']);
                s.optPdfFixed = normalizePoints_(optPdfRaw, true);
                s.optCdfFixed = normalizePoints_(optCdfRaw, false);
                var optProb = pick(item, ['targetProbability.value.adjustedOptimized','optimizedProbability','probabilities.optimized']);
                s.optimizedProb = (optProb!=null) ? Number(optProb)
                                  : ((s.target!=null && s.optCdfFixed.length) ? interpY(s.optCdfFixed, s.target) : null);
                s.explainOpt = item;

                const fixedSliders = extractSliderVals(s.explainOpt);
                setCompareValues('fixed', fixedSliders);
                updateSliderSidebarState();
                s.pendingVariants--;
                if (s.pendingVariants === 0) { updateSliderComparisons(); }

              } else if (isAdaptive) {
                var aPdfRaw = pick(item, ['adaptiveReshapedPoints.pdfPoints','adaptive.pdf','optimizedReshapedPoints.pdfPoints']);
                var aCdfRaw = pick(item, ['adaptiveReshapedPoints.cdfPoints','adaptive.cdf','optimizedReshapedPoints.cdfPoints']);
                console.log('[PMC] Adaptive result — pdfPts:', (aPdfRaw||[]).length, 'cdfPts:', (aCdfRaw||[]).length);
                s.optPdfAdaptive = normalizePoints_(aPdfRaw, true);
                s.optCdfAdaptive = normalizePoints_(aCdfRaw, false);
                var aProb = pick(item, ['targetProbability.value.adaptiveOptimized','adaptiveProbability','probabilities.adaptive','targetProbability.value.adjustedOptimized']);
                console.log('[PMC] Adaptive prob raw:', aProb, '→ stored:', (aProb!=null) ? Number(aProb) : 'interpolate');
                s.adaptiveProb = (aProb!=null) ? Number(aProb)
                                 : ((s.target!=null && s.optCdfAdaptive.length) ? interpY(s.optCdfAdaptive, s.target) : null);
                console.log('[PMC] s.adaptiveProb =', s.adaptiveProb);
                s.explainAdaptive = item;

                const adaptiveSliders = extractSliderVals(s.explainAdaptive);
                setCompareValues('adaptive', adaptiveSliders);
                updateSliderSidebarState();
                s.pendingVariants--;
                if (s.pendingVariants === 0) { updateSliderComparisons(); }
              }

              s.variantCache[key] = {
                adjPdf:s.adjPdf, adjCdf:s.adjCdf, adjustedProb:s.adjustedProb,
                optPdfFixed:s.optPdfFixed, optCdfFixed:s.optCdfFixed, optimizedProb:s.optimizedProb,
                optPdfAdaptive:s.optPdfAdaptive, optCdfAdaptive:s.optCdfAdaptive, adaptiveProb:s.adaptiveProb,
                explainAdj:s.explainAdj, explainOpt:s.explainOpt, explainAdaptive:s.explainAdaptive,
                lastPayload:item
              };

              vState.loading = false; vState.error = null;
              if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender();
              window.scheduleUIRefresh();
              updateSliderComparisons();
              setStatusLocal('Ready');
              ensureProbeBox();
            } catch(e) {
              console.error('[PMC] Variant ' + variant + ' processing error:', e.message, e.stack);
              vState.loading = false; vState.error = e.message || 'Variant error';
              safe(function(){ window.renderRightLegend(); }); updateSliderComparisons(); setStatusLocal('Ready');
            }
          })
          .withFailureHandler(function(err){
            console.error('[PMC] Variant ' + variant + ' RPC FAILED:', err);
            if (token !== vState.token) return;
            vState.loading = false; vState.error = (err && err.message) || String(err);
            safe(function(){ window.renderRightLegend(); }); updateSliderComparisons(); setStatusLocal('Ready');
          })
          .getTargetProbabilityData(params);
      }

      function applyVariantResult(variant, c) {
        var s = WS();
        if (variant === 'manual') {
          s.adjPdf = c.adjPdf || []; s.adjCdf = c.adjCdf || []; s.adjustedProb = (c.adjustedProb!=null ? c.adjustedProb : s.adjustedProb); s.explainAdj = (c.explainAdj!=null ? c.explainAdj : s.explainAdj);
        } else if (variant === 'fixed') {
          s.optPdfFixed = c.optPdfFixed || []; s.optCdfFixed = c.optCdfFixed || []; s.optimizedProb = (c.optimizedProb!=null ? c.optimizedProb : s.optimizedProb); s.explainOpt = (c.explainOpt!=null ? c.explainOpt : s.explainOpt);
        } else if (variant === 'adaptive') {
          s.optPdfAdaptive = c.optPdfAdaptive || []; s.optCdfAdaptive = c.optCdfAdaptive || []; s.adaptiveProb = (c.adaptiveProb!=null ? c.adaptiveProb : s.adaptiveProb); s.explainAdaptive = (c.explainAdaptive!=null ? c.explainAdaptive : s.explainAdaptive);
        }
        if (c.lastPayload) s.lastPayload = c.lastPayload;
      }

      function loadTasks() {
        var s = WS();
        setStatusLocal('Fetching…');

        if (!window.google || !google.script || !google.script.run) {
          setStatusLocal('Ready');
          console.warn('Apps Script runtime not available; tasks cannot be loaded in preview.');
          return;
        }

        google.script.run
          .withSuccessHandler(function(list){
            s.tasks = Array.isArray(list) ? list : [];
            var sel = document.getElementById('taskSel');
            if (!sel) { setStatusLocal('UI init failed: taskSel not found'); return; }

            sel.innerHTML = '';
            if (!s.tasks.length) {
              var opt = document.createElement('option');
              opt.value = ''; opt.textContent = 'No tasks returned';
              sel.appendChild(opt);
              setStatusLocal('Ready');
              return;
            }

            s.tasks.forEach(function(t,i){
              var opt=document.createElement('option');
              opt.value=i; opt.textContent=t.task || ('(Task '+(i+1)+')');
              sel.appendChild(opt);
            });
            sel.selectedIndex = 0;
            onTaskChange();
          })
          .withFailureHandler(function(err){
            setStatusLocal('Failed to load tasks: ' + (err && err.message ? err.message : String(err)));
            var msg = document.getElementById('plotMsg');
            if (msg) { msg.style.display='block'; msg.textContent='Failed to load tasks: ' + (err && err.message ? err.message : String(err)); }
          })
          .getAllTasks();
      }

      function onTaskChange() {
        var s = WS();
        var sel = document.getElementById('taskSel');
        if (!sel) { setStatusLocal('UI init failed: taskSel not found'); return; }

        var idx = +sel.value;
        var t = s.tasks[idx];
        if (!t) { setStatusLocal('No valid task'); return; }

        s.task = t;
        s.O = t.optimistic; s.M = t.mostLikely; s.P = t.pessimistic;
        // Clear ALL stale data from previous task
        s.explainBase = null; s.explainOpt = null; s.explainAdaptive = null; s.explainAdj = null;
        s.baselineProb = null; s.optimizedProb = null; s.adaptiveProb = null; s.adjustedProb = null;
        s.trianglePdf = []; s.triangleCdf = []; s.betaPertPdf = []; s.betaPertCdf = [];
        s.basePdf = []; s.baseCdf = []; s.adjPdf = []; s.adjCdf = [];
        s.optPdfFixed = []; s.optCdfFixed = []; s.optPdfAdaptive = []; s.optCdfAdaptive = [];
        s.baselineCache = {}; s.pendingVariants = 0;
        s.targetMode = 'value';
        s.targetProb = null;
        // Reset mode toggle visual
        var mBtns = document.querySelectorAll('.target-mode-btn');
        for (var bi = 0; bi < mBtns.length; bi++) mBtns[bi].classList.toggle('active', mBtns[bi].getAttribute('data-mode') === 'value');

        function setText(id,val) {
          var el = document.getElementById(id);
          if (el) el.textContent = (val != null ? Number(val).toFixed(2) : '–');
        }
        setText('oVal', s.O);
        setText('mVal', s.M);
        setText('pVal', s.P);
        setText('pertVal', (s.O != null && s.M != null && s.P != null) ? ((s.O + 4*s.M + s.P)/6) : null);

        updateTargetSlider();

        s.overlay.baselineOn = true;
        s.overlay.manualOn = false;
        s.overlay.fixedOn = false;
        s.overlay.adaptiveOn = false;
        s.overlay.sidebarMode = null;
        s.overlay.variants.manual = { loading:false, error:null, token:0 };
        s.overlay.variants.fixed = { loading:false, error:null, token:0 };
        s.overlay.variants.adaptive = { loading:false, error:null, token:0 };
        s.overlay.probeLevel = Number(document.getElementById('probeSelect')?.value || 3);

        s.progress = { triOn:true, betaOn:false, baseOn:false };

        ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf']
          .forEach(function(id) {
            var numEl = document.getElementById(id); if (numEl) numEl.value = '0';
            var rangeEl = document.getElementById(id + '_range'); if (rangeEl) rangeEl.value = '0';
            var marker = document.getElementById(id + '_marker'); if (marker) marker.innerHTML = '';
          });
        if (typeof window.setSlidersDisabled === 'function') window.setSlidersDisabled(true);

        ['_base','_fixed','_adapt'].forEach(suf=>{
          ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'].forEach(id=>{
            const el = document.getElementById(id+suf); if (el) el.value='0';
          });
        });

        s.variantCache = {};

        fetchData(false);
        safe(function(){ window.renderRightLegend(); });
        safe(function(){ window.renderKPIs(); });
        updateSliderComparisons();
        syncRowToggles();
        ensureProbeBox();
        // Reset report to skeleton state
        if (window.PMCReport) {
          PMCReport.state.baseline = null;
          PMCReport.state.variants = {};
          PMCReport.scheduleRender();
        }
      }

      function onTargetInput() {
        var s = WS();
        var slider = document.getElementById('targetSlider');
        if (!slider) return;

        if (s.targetMode === 'probability') {
          s.targetProb = Number(slider.value) / 100;
          var baseCdf = s.baseCdf && s.baseCdf.length ? s.baseCdf : s.triangleCdf;
          if (baseCdf && baseCdf.length) {
            s.target = interpX(baseCdf, s.targetProb);
          }
        } else {
          s.target = Number(slider.value);
        }
        updateTargetDisplayText();

        s.variantCache = {};
        fetchData(true);

        s.pendingVariants = 0;
        var active = [];
        if (s.overlay.manualOn) { active.push('manual'); s.pendingVariants++; }
        if (s.overlay.fixedOn) { active.push('fixed'); s.pendingVariants++; }
        if (s.overlay.adaptiveOn) { active.push('adaptive'); s.pendingVariants++; }
        active.forEach(requestVariant);
      }

      /** Handles toggling between Value and Probability target modes */
      window.onTargetModeSwitch = function(newMode) {
        var s = WS();
        if (newMode === s.targetMode) return;
        var slider = document.getElementById('targetSlider');
        if (!slider) return;

        // Update segmented control visual state
        var btns = document.querySelectorAll('.target-mode-btn');
        for (var i = 0; i < btns.length; i++) {
          btns[i].classList.toggle('active', btns[i].getAttribute('data-mode') === newMode);
        }

        if (newMode === 'probability') {
          // Value → Probability: convert current value to probability via CDF
          var baseCdf = s.baseCdf && s.baseCdf.length ? s.baseCdf : s.triangleCdf;
          var prob = baseCdf && baseCdf.length ? interpY(baseCdf, s.target) : 0.5;
          s.targetProb = prob != null ? prob : 0.5;
          s.targetMode = 'probability';
          slider.min = 1; slider.max = 99; slider.step = 0.5;
          slider.value = Math.round(s.targetProb * 200) / 2; // round to nearest 0.5
        } else {
          // Probability → Value: restore slider to value range
          s.targetMode = 'value';
          var pad = (s.P - s.O) * 0.05;
          s.targetSliderMin = s.O - pad;
          s.targetSliderMax = s.P + pad;
          slider.min = s.targetSliderMin;
          slider.max = s.targetSliderMax;
          slider.step = 'any';
          slider.value = s.target != null ? s.target : (s.O + 4*s.M + s.P) / 6;
        }
        updateTargetDisplayText();
      };

      function fillSlidersFromObject(vals) {
        var map = { budgetFlexibility:'s_budget', scheduleFlexibility:'s_schedule',
          scopeCertainty:'s_scopeCert', scopeReductionAllowance:'s_scopeRed',
          reworkPercentage:'s_rework', riskTolerance:'s_risk', userConfidence:'s_userConf' };
        Object.keys(map).forEach(function(k) {
          var v = Number(vals[k]) || 0;
          var numEl = document.getElementById(map[k]);
          var rangeEl = document.getElementById(map[k] + '_range');
          if (numEl) numEl.value = v;
          if (rangeEl) rangeEl.value = v;
        });
      }

      function updateSliderSidebarState() {
        var s = WS();
        var container = document.getElementById('plotContainer');
        var sidebar = document.getElementById('sliderSidebar');
        if (!container || !sidebar) return;

        var showSidebar = (s.tab === 'overlay') &&
          (s.overlay.manualOn || s.overlay.fixedOn || s.overlay.adaptiveOn);

        container.classList.toggle('sidebar-active', showSidebar);

        var bannerEl = document.getElementById('sliderImpactBanner');

        if (!showSidebar) {
          if (bannerEl) bannerEl.style.display = 'none';
          return;
        }

        var titleEl = document.getElementById('sliderTitle');
        var noteEl = document.getElementById('optimizeNote');

        // Helper: format probability impact banner
        function showImpactBanner(mode, baseProb, newProb) {
          if (!bannerEl) return;
          if (baseProb == null || newProb == null) { bannerEl.style.display = 'none'; return; }
          var basePct = (baseProb * 100).toFixed(2);
          var newPct = (newProb * 100).toFixed(2);
          var delta = ((newProb - baseProb) * 100);
          var deltaStr = (delta >= 0 ? '+' : '') + delta.toFixed(2);
          var improved = delta > 0.005;
          var same = Math.abs(delta) < 0.005;

          bannerEl.style.display = 'block';
          if (improved) {
            bannerEl.style.background = '#F0FDF4'; bannerEl.style.borderColor = '#86EFAC'; bannerEl.style.color = '#166534';
            bannerEl.innerHTML = '<strong>' + mode + ' improves probability:</strong><br>' +
              'Baseline <strong>' + basePct + '%</strong> → ' + mode + ' <strong>' + newPct + '%</strong> ' +
              '<span style="color:#15803D; font-weight:600;">(' + deltaStr + '%)</span>';
          } else if (same) {
            bannerEl.style.background = '#FFFBEB'; bannerEl.style.borderColor = '#FDE68A'; bannerEl.style.color = '#92400E';
            bannerEl.innerHTML = '<strong>No change:</strong> Baseline and ' + mode + ' both at <strong>' + basePct + '%</strong>. ' +
              'For symmetric distributions near the mode, optimization has limited room to improve.';
          } else {
            bannerEl.style.background = '#FEF2F2'; bannerEl.style.borderColor = '#FECACA'; bannerEl.style.color = '#991B1B';
            bannerEl.innerHTML = '<strong>' + mode + ' probability shift:</strong><br>' +
              'Baseline <strong>' + basePct + '%</strong> → ' + mode + ' <strong>' + newPct + '%</strong> ' +
              '<span style="color:#DC2626; font-weight:600;">(' + deltaStr + '%)</span>';
          }
        }

        // Determine sidebar mode — use explicit sidebarMode, fallback to first active
        var mode = s.overlay.sidebarMode;
        if (!mode || (mode === 'manual' && !s.overlay.manualOn) ||
            (mode === 'fixed' && !s.overlay.fixedOn) ||
            (mode === 'adaptive' && !s.overlay.adaptiveOn)) {
          // Fallback: pick first active mode
          if (s.overlay.manualOn) mode = 'manual';
          else if (s.overlay.fixedOn) mode = 'fixed';
          else if (s.overlay.adaptiveOn) mode = 'adaptive';
          else mode = null;
          s.overlay.sidebarMode = mode;
        }

        if (mode === 'manual') {
          setSlidersDisabled(false);
          if (titleEl) titleEl.textContent = 'Explorer (Unconstrained)';
          if (noteEl) noteEl.innerHTML = 'Drag sliders or type values freely — <strong>no constraints applied</strong>. Full control to explore how project parameters change the probability. Unlike Guided/Optimized, these values are not bound by best-practice ranges.';
          showImpactBanner('Explorer', s.baselineProb, s.adjustedProb);
        } else if (mode === 'adaptive') {
          setSlidersDisabled(true);
          var lvl = s.overlay.probeLevel || 3;
          if (titleEl) titleEl.textContent = 'Guided (Level ' + lvl + ', Best-Practice Constrained)';
          if (noteEl) noteEl.innerHTML = 'System-guided optimization at level ' + lvl + ', computed within the <strong>tightest best-practice boundaries</strong>. Change level to explore different constraint intensities.';
          showImpactBanner('Guided', s.baselineProb, s.adaptiveProb);
          var source = s.explainAdaptive;
          var vals = extractSliderVals(source || {});
          fillSlidersFromObject(vals);
        } else if (mode === 'fixed') {
          setSlidersDisabled(true);
          if (titleEl) titleEl.textContent = 'Optimized (Best-Practice Constrained)';
          if (noteEl) noteEl.innerHTML = 'System-optimized values that maximize target probability within <strong>standard best-practice boundaries</strong>. Wider range than Guided, yielding higher probability. Switch to Explorer for full manual control.';
          showImpactBanner('Optimized', s.baselineProb, s.optimizedProb);
          var source = s.explainOpt;
          var vals = extractSliderVals(source || {});
          fillSlidersFromObject(vals);
        }

        // Update probe level selector visibility (shown only when adaptive is active mode)
        if (typeof window.syncProbeUI === 'function') window.syncProbeUI();
      }

      function syncRowToggles(){
        var s = WS();
        var row = document.getElementById('seriesToggles');
        if (row) row.style.display = (s.tab==='overlay') ? 'flex' : 'none';

        var b = document.getElementById('rowTglBase');
        var m = document.getElementById('rowTglManual');
        var f = document.getElementById('rowTglFixed');
        var a = document.getElementById('rowTglAdaptive');
        if (b) b.setAttribute('aria-pressed', s.overlay.baselineOn ? 'true' : 'false');
        if (m) m.setAttribute('aria-pressed', s.overlay.manualOn ? 'true' : 'false');
        if (f) f.setAttribute('aria-pressed', s.overlay.fixedOn ? 'true' : 'false');
        if (a) a.setAttribute('aria-pressed', s.overlay.adaptiveOn ? 'true' : 'false');

        ensureProbeBox();
      }

      function bindTabs() {
        var s = WS();
        var nodes = document.querySelectorAll('.tab');
        for (var i=0;i<nodes.length;i++) {
          (function(tab){
            tab.addEventListener('click', function(){
              // Phase 1: Immediate visual update (< 1ms)
              var all = document.querySelectorAll('.tab');
              for (var k=0;k<all.length;k++) all[k].classList.remove('active');
              tab.classList.add('active');
              s.tab = tab.getAttribute('data-tab');

              // Phase 2: Debounce all expensive work — rapid clicks only run the last one
              if (window._tabSwitchTimer) clearTimeout(window._tabSwitchTimer);
              window._tabSwitchTimer = setTimeout(function() {
                window._tabSwitchTimer = null;

                updateSliderSidebarState();

                var dr = document.getElementById('decisionReport');
                var om = document.getElementById('overlayMath');
                if (s.tab === 'overlay') {
                  if (dr) dr.classList.add('active');
                  if (om) om.classList.add('active');
                  if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender();
                } else {
                  if (dr) dr.classList.remove('active');
                  if (om) om.classList.remove('active');
                }

                if (typeof window.setSlidersDisabled === 'function') {
                  window.setSlidersDisabled(s.tab !== 'overlay' || !s.overlay.manualOn);
                }

                syncRowToggles();

                scheduleUIRefresh();
                fetchData(true);

                if (s.tab === 'overlay') {
                  s.pendingVariants = 0;
                  var act = [];
                  if (s.overlay.manualOn && !s.adjPdf.length) { act.push('manual'); s.pendingVariants++; }
                  if (s.overlay.fixedOn && !s.optPdfFixed.length) { act.push('fixed'); s.pendingVariants++; }
                  if (s.overlay.adaptiveOn && !s.optPdfAdaptive.length) { act.push('adaptive'); s.pendingVariants++; }
                  act.forEach(requestVariant);
                }
                ensureProbeBox();
              }, 100);
            });
          })(nodes[i]);
        }

        var triTile = document.getElementById('kpiTriangle');
        var betaTile= document.getElementById('kpiBeta');
        var baseTile= document.getElementById('kpiBaseDist');
        if (triTile) triTile.addEventListener('click', function(){
          s.progress.triOn = !s.progress.triOn; scheduleUIRefresh();
        });
        if (betaTile) betaTile.addEventListener('click', function(){
          s.progress.betaOn = !s.progress.betaOn; scheduleUIRefresh();
        });
        if (baseTile) baseTile.addEventListener('click', function(){
          s.progress.baseOn = !s.progress.baseOn; scheduleUIRefresh();
        });

        syncRowToggles();
      }

      function bindKpiToggles() {
        var s = WS();
        var baseEl    = document.getElementById('kpiBaseline');
        var adjustedEl= document.getElementById('kpiAdjusted');
        var fixedEl   = document.getElementById('kpiOptimized');
        var adaptiveEl= document.getElementById('kpiAdaptive');

        if (baseEl) baseEl.addEventListener('click', function(){
          if (s.tab !== 'overlay') return;
          s.overlay.baselineOn = !s.overlay.baselineOn;
          scheduleUIRefresh();
          syncRowToggles();
        });

        if (adjustedEl) adjustedEl.addEventListener('click', function(){
          if (s.tab !== 'overlay') return;
          s.overlay.manualOn = !s.overlay.manualOn;
          if (s.overlay.manualOn) {
            s.overlay.primaryMode = 'manual';
            if (!s.adjPdf.length) requestVariant('manual');
            s.overlay.sidebarMode = 'manual';
          }
          updateSliderSidebarState();
          scheduleUIRefresh();
          updateSliderComparisons();
          syncRowToggles();
          setStatusLocal();
        });

        if (fixedEl) fixedEl.addEventListener('click', function(){
          if (s.tab !== 'overlay') return;
          s.overlay.fixedOn = !s.overlay.fixedOn;
          if (s.overlay.fixedOn) {
            s.overlay.primaryMode = 'fixed';
            if (!s.optPdfFixed.length) { s.pendingVariants++; requestVariant('fixed'); }
            s.overlay.sidebarMode = 'fixed';
          }
          updateSliderSidebarState();
          scheduleUIRefresh();
          updateSliderComparisons();
          syncRowToggles();
          setStatusLocal();
        });

        if (adaptiveEl) adaptiveEl.addEventListener('click', function(){
          if (s.tab !== 'overlay') return;
          var wasOff = !s.overlay.adaptiveOn;
          s.overlay.adaptiveOn = !s.overlay.adaptiveOn;
          if (s.overlay.adaptiveOn) {
            s.overlay.primaryMode = 'adaptive';
            if (wasOff || !s.optPdfAdaptive.length) {
              s.overlay.probeLevel = 1;
              var probeSel = document.getElementById('probeSelect');
              if (probeSel) probeSel.value = '1';
              s.pendingVariants++;
              requestVariant('adaptive');
            }
            s.overlay.sidebarMode = 'adaptive';
          }
          updateSliderSidebarState();
          scheduleUIRefresh();
          updateSliderComparisons();
          syncRowToggles();
          setStatusLocal();
          ensureProbeBox();
        });

        // Row toggles in legend — these toggle chart visibility ON/OFF
        var rowToggleDefs = [
          { id: 'rowTglBase',     key: 'baselineOn',  mode: null },
          { id: 'rowTglManual',   key: 'manualOn',    mode: 'manual' },
          { id: 'rowTglFixed',    key: 'fixedOn',     mode: 'fixed' },
          { id: 'rowTglAdaptive', key: 'adaptiveOn',  mode: 'adaptive' }
        ];
        rowToggleDefs.forEach(function(def) {
          var el = document.getElementById(def.id);
          if (!el) return;
          el.addEventListener('click', function() {
            if (s.tab !== 'overlay') return;
            s.overlay[def.key] = !s.overlay[def.key];
            if (s.overlay[def.key] && def.mode) {
              s.overlay.sidebarMode = def.mode;
              // Fire variant fetch when toggling ON (if not already loaded)
              var needsFetch = (def.mode === 'manual' && !s.adjPdf.length) ||
                               (def.mode === 'fixed' && !s.optPdfFixed.length) ||
                               (def.mode === 'adaptive' && !s.optPdfAdaptive.length);
              if (needsFetch) {
                if (def.mode === 'adaptive') {
                  s.overlay.probeLevel = 1;
                  var probeSel = document.getElementById('probeSelect');
                  if (probeSel) probeSel.value = '1';
                }
                s.pendingVariants++;
                requestVariant(def.mode);
              }
            }
            updateSliderSidebarState();
            scheduleUIRefresh();
            updateSliderComparisons();
            syncRowToggles();
            setStatusLocal();
          });
        });
      }

      function bindSliders() {
        var s = WS();
        var ids = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
        ids.forEach(function(id) {
          var numEl = document.getElementById(id);
          var rangeEl = document.getElementById(id + '_range');
          if (!numEl) return;

          var handler = function(){
            if (s.tab !== 'overlay') return;
            if (!s.overlay.manualOn) {
              s.overlay.manualOn = true;
              if (typeof window.setSlidersDisabled === 'function') window.setSlidersDisabled(false);
              syncRowToggles();
            }
            var key = JSON.stringify({ task: s.task.task, O: s.O, M: s.M, P: s.P, target: s.target, variant: 'manual' });
            if (s.variantCache) delete s.variantCache[key];
            requestVariant('manual');
            scheduleUIRefresh();
            updateSliderComparisons();
          };

          // Bidirectional sync: range ↔ number (debounced to prevent double-fire)
          var sliderDebounce = null;
          var debouncedHandler = function() {
            if (sliderDebounce) clearTimeout(sliderDebounce);
            sliderDebounce = setTimeout(handler, 80);
          };
          if (rangeEl) {
            rangeEl.addEventListener('input', function() { numEl.value = rangeEl.value; debouncedHandler(); });
          }
          numEl.addEventListener('change', function() { if (rangeEl) rangeEl.value = numEl.value; debouncedHandler(); });
        });
      }

      function bindZoomReset(){
        var btn = document.getElementById('resetZoomBtn');
        if (!btn) return;
        btn.addEventListener('click', function(){
          var s = WS();
          if (s?.pdfChart?.resetZoom) s.pdfChart.resetZoom();
          if (s?.cdfChart?.resetZoom) s.cdfChart.resetZoom();
        });
      }

      window.addEventListener('DOMContentLoaded', function(){
        // Boot log — visible diagnostic for debugging
        var bootLog = document.getElementById('errorBanner');
        function blogMsg(t) {
          if (bootLog) { bootLog.style.display='block'; bootLog.style.background='#EFF6FF'; bootLog.style.color='#1E40AF'; bootLog.style.borderColor='#3B82F6'; bootLog.innerHTML += '<div>[BOOT] '+t+'</div>'; }
          if (typeof fetch === 'function') {
            fetch('/console', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({type:'boot', msg:t}) }).catch(function(){});
          }
        }

        blogMsg('DOMContentLoaded fired');
        blogMsg('window.S exists: ' + (!!window.S) + ', has tasks prop: ' + (window.S && 'tasks' in window.S));
        blogMsg('google.script.run exists: ' + (!!window.google && !!window.google.script && !!window.google.script.run));
        blogMsg('Chart.js loaded: ' + (typeof Chart !== 'undefined'));

        try {
          var taskSel = document.getElementById('taskSel');
          if (taskSel) taskSel.addEventListener('change', onTaskChange);

          var tgtSlider = document.getElementById('targetSlider');
          if (tgtSlider) tgtSlider.addEventListener('input', onTargetInput);

          var refresh = document.getElementById('refreshBtn');
          if (refresh) refresh.addEventListener('click', function(){
            fetchData(false);
            var s = WS();
            if (s.tab==='overlay') {
              s.pendingVariants = 0;
              var act = [];
              if (s.overlay && s.overlay.manualOn) { act.push('manual'); s.pendingVariants++; }
              if (s.overlay && s.overlay.fixedOn) { act.push('fixed'); s.pendingVariants++; }
              if (s.overlay && s.overlay.adaptiveOn) { act.push('adaptive'); s.pendingVariants++; }
              act.forEach(requestVariant);
            }
            ensureProbeBox();
          });
          blogMsg('Event listeners bound');
        } catch(e) { blogMsg('Event bind error: ' + e.message); }

        try { bindTabs(); blogMsg('bindTabs OK'); } catch(e) { blogMsg('bindTabs error: ' + e.message); }
        try { bindKpiToggles(); blogMsg('bindKpiToggles OK'); } catch(e) { blogMsg('bindKpiToggles error: ' + e.message); }
        try { bindSliders(); blogMsg('bindSliders OK'); } catch(e) { blogMsg('bindSliders error: ' + e.message); }
        try { bindZoomReset(); blogMsg('bindZoomReset OK'); } catch(e) { blogMsg('bindZoomReset error: ' + e.message); }

        var s = WS();
        try {
          if (typeof window.setSlidersDisabled === 'function') window.setSlidersDisabled(true);
          updateSliderComparisons();
        } catch(e) { blogMsg('slider init error: ' + e.message); }

        // Reset to Baseline button
        try {
          var resetBtn = document.getElementById('resetBaseline');
          if (resetBtn) resetBtn.addEventListener('click', function() {
            ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'].forEach(function(id) {
              var numEl = document.getElementById(id); if (numEl) numEl.value = 0;
              var rangeEl = document.getElementById(id + '_range'); if (rangeEl) rangeEl.value = 0;
            });
            if (s.overlay && s.overlay.manualOn) {
              var key = JSON.stringify({ task: s.task && s.task.task, O: s.O, M: s.M, P: s.P, target: s.target, variant: 'manual' });
              if (s.variantCache) delete s.variantCache[key];
              requestVariant('manual');
            }
            scheduleUIRefresh();
            updateSliderComparisons();
          });
        } catch(e) { blogMsg('resetBaseline error: ' + e.message); }

        // Match Optimized button
        try {
          var matchBtn = document.getElementById('matchOptimized');
          if (matchBtn) matchBtn.addEventListener('click', function() {
            var fixedSliders = {};
            ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'].forEach(function(id) {
              var fixedEl = document.getElementById(id + '_fixed');
              var val = fixedEl ? Number(fixedEl.value) || 0 : 0;
              var numEl = document.getElementById(id); if (numEl) numEl.value = val;
              var rangeEl = document.getElementById(id + '_range'); if (rangeEl) rangeEl.value = val;
            });
            if (s.overlay && !s.overlay.manualOn) {
              s.overlay.manualOn = true;
              if (typeof setSlidersDisabled === 'function') setSlidersDisabled(false);
              syncRowToggles();
            }
            var key = JSON.stringify({ task: s.task && s.task.task, O: s.O, M: s.M, P: s.P, target: s.target, variant: 'manual' });
            if (s.variantCache) delete s.variantCache[key];
            requestVariant('manual');
            scheduleUIRefresh();
            updateSliderComparisons();
          });
        } catch(e) { blogMsg('matchOptimized error: ' + e.message); }

        // CRITICAL: loadTasks — always runs regardless of init errors above
        blogMsg('Calling loadTasks...');
        try {
          loadTasks();
          blogMsg('loadTasks called successfully');
        } catch(e) { blogMsg('loadTasks error: ' + e.message); }

        updateSliderSidebarState();

        safe(function(){ if (window.PMCReport && typeof window.PMCReport.scheduleRender === 'function') window.PMCReport.scheduleRender(); });

        // Resize both charts on window resize
        window.addEventListener('resize', function(){
          var s2 = WS();
          if (s2 && s2.pdfChart && typeof s2.pdfChart.resize==='function') s2.pdfChart.resize();
          if (s2 && s2.cdfChart && typeof s2.cdfChart.resize==='function') s2.cdfChart.resize();
        }, { passive:true });

        // Redraw charts after scroll settles — prevents blank canvases
        var scrollTimer = null;
        window.addEventListener('scroll', function(){
          if (scrollTimer) clearTimeout(scrollTimer);
          scrollTimer = setTimeout(function(){
            var s2 = WS();
            if (s2 && s2.pdfChart && typeof s2.pdfChart.resize==='function') s2.pdfChart.resize();
            if (s2 && s2.cdfChart && typeof s2.cdfChart.resize==='function') s2.cdfChart.resize();
            if (window.hyperRadarChart && typeof window.hyperRadarChart.resize === 'function') window.hyperRadarChart.resize();
          }, 150);
        }, { passive:true });

        ensureProbeBox();

        // Fallback: if dropdown is still empty after 5 seconds, retry
        setTimeout(function() {
          var sel = document.getElementById('taskSel');
          var optCount = sel ? sel.options.length : 0;
          blogMsg('5s check: taskSel options=' + optCount);
          if (optCount === 0) {
            blogMsg('Dropdown empty after 5s — retrying loadTasks');
            try { loadTasks(); } catch(e) { blogMsg('Retry error: ' + e.message); }
          } else {
            // Hide boot log after successful load
            if (bootLog) { bootLog.style.display = 'none'; bootLog.innerHTML = ''; }
          }
        }, 5000);
      });
    })();
  </script>

  <script>
    (function(){
      const Report = {
        state: { baseline: null, variants: {} },
        fmtPct(v){ return (v==null||isNaN(v)) ? '–' : (v*100).toFixed(2)+'%'; },
        num(v,d=2){ return (v==null||isNaN(v)) ? '–' : Number(v).toFixed(d); },
        blueNum(v,d=2){ return v==null||isNaN(v) ? '–' : `<span style="color:var(--cdf);font-weight:600;">${Number(v).toFixed(d)}</span>`; },

        isOverlayActive(){ return window.S?.tab === 'overlay'; },

        _renderTimer: null,
        scheduleRender() {
          if (this._renderTimer) clearTimeout(this._renderTimer);
          this._renderTimer = setTimeout(() => this.renderAll(), 200);
        },

        mount(){
          window.addEventListener('pmc:baseline:ready', e => { this.state.baseline = e.detail; this.scheduleRender(); });
          window.addEventListener('pmc:variant:ready',  e => { this.state.variants[e.detail.variant] = e.detail; this.scheduleRender(); });
          this.renderAll(true);
        },

        renderAll(skeleton = false) {
          const dr = document.getElementById('decisionReport');
          if (!dr) return;

          const onOverlay = this.isOverlayActive();
          dr.classList.toggle('active', onOverlay);
          if (!onOverlay) { dr.innerHTML = ''; return; }

          const S = window.S || {};
          const B = this.state.baseline || {};
          const V = this.state.variants || {};

          const baselineProb = B.baselineProb ?? S.baselineProb;
          const adaptiveProb = V.adaptive?.prob ?? S.adaptiveProb;
          const fixedProb = V.fixed?.prob ?? S.optimizedProb;
          const manualProb = V.manual?.prob ?? S.adjustedProb;

          const candidates = [
            { prob: baselineProb,  explain: B.lastPayload || {},       label: 'Your Estimate' },
            { prob: manualProb,    explain: V.manual?.explain || {},   label: 'Explorer' },
            { prob: fixedProb,     explain: V.fixed?.explain || {},    label: 'Optimized' },
            { prob: adaptiveProb,  explain: V.adaptive?.explain || {}, label: `Guided (Level ${S.overlay?.probeLevel ?? 3})` }
          ].filter(c => c.prob != null);

          const best = candidates.length ? candidates.reduce((a, b) => a.prob > b.prob ? a : b) : { prob: null, explain: {}, label: '–' };
          const finalProb = best.prob;

          const delta = baselineProb != null ? (finalProb - baselineProb) * 100 : null;
          const deltaStr = delta != null ? (delta >= 0 ? '+' : '') + delta.toFixed(2) + ' pts' : '–';

          const O = S.O, M = S.M, P = S.P, target = S.target;

          const pertMean = (O && M && P) ? (O + 4*M + P)/6 : null;
          const pertStd  = (O && P) ? (P - O)/6 : null;

          const explain = best.explain || {};
          const kl = explain.klDivergence ?? explain.kl;
          const alpha = explain.refit?.alpha ?? null;
          const beta  = explain.refit?.beta ?? null;
          const cv = explain.cv ?? (pertStd && pertMean ? pertStd/pertMean : null);
          const skew = explain.skew ?? (pertStd && pertMean && target ? (pertMean-target)/pertStd : null);

          const KEYS = ['budgetFlexibility','scheduleFlexibility','scopeCertainty','scopeReductionAllowance','reworkPercentage','riskTolerance','userConfidence'];
          const LABELS = ['Budget Flexibility','Schedule Flexibility','Scope Certainty','Scope Reduction Allowance','Rework Percentage','Risk Tolerance','User Confidence'];
          const WEIGHTS = [-0.2, 0.1, 0.3, -0.15, -0.08, 0.25, 0.05];

          // Extract slider values for each variant from explain objects
          function getSliders(explainObj) {
            if (!explainObj) return KEYS.reduce((o,k) => { o[k]=0; return o; }, {});
            var vals = typeof extractSliderVals === 'function' ? extractSliderVals(explainObj) : {};
            return KEYS.reduce((o,k) => { o[k] = Number(vals[k]) || 0; return o; }, {});
          }

          // Also read current manual slider values from DOM
          function getManualSliders() {
            const ID_MAP = { budgetFlexibility:'s_budget', scheduleFlexibility:'s_schedule',
              scopeCertainty:'s_scopeCert', scopeReductionAllowance:'s_scopeRed',
              reworkPercentage:'s_rework', riskTolerance:'s_risk', userConfidence:'s_userConf' };
            return KEYS.reduce((o,k) => {
              const el = document.getElementById(ID_MAP[k]);
              o[k] = el ? Number(el.value) : 0;
              return o;
            }, {});
          }

          const fixedSliders = getSliders(V.fixed?.explain || S.explainOpt || {});
          const adaptiveSliders = getSliders(V.adaptive?.explain || S.explainAdaptive || {});
          const manualSliders = getManualSliders();

          // Build variant rows — ordered most conservative → least conservative
          const probeLvl = S.overlay?.probeLevel ?? 3;
          const variants = [
            { key: 'baseline', label: 'Your Estimate', desc: 'Your original PERT estimate — no optimization applied. This is your starting point.', prob: baselineProb, sliders: KEYS.reduce((o,k)=>{o[k]=0;return o;},{}), constrained: false, constraintLvl: 'None', constraintNote: 'Unmodified three-point estimate', color: '#3B82F6', order: 0 },
            { key: 'adaptive', label: 'Guided (Lvl ' + probeLvl + ')', desc: 'Conservative guidance — level ' + probeLvl + ' narrows each slider\'s feasible range, yielding the most defensible improvement', prob: adaptiveProb, sliders: adaptiveSliders, constrained: true, constraintLvl: 'Strict', constraintNote: 'Level ' + probeLvl + ' — tightest bounds', color: '#0EA5E9', order: 1 },
            { key: 'fixed', label: 'Optimized', desc: 'Standard boundaries — wider range allows more room for optimization, typically achieving higher probability than Guided', prob: fixedProb, sliders: fixedSliders, constrained: true, constraintLvl: 'Standard', constraintNote: 'Level 1 — wider bounds', color: '#8B5CF6', order: 2 },
            { key: 'manual', label: 'Explorer', desc: 'No constraints — you set any slider values freely. Highest potential but not validated against best practices. Full control for what-if analysis.', prob: manualProb, sliders: manualSliders, constrained: false, constraintLvl: 'Unconstrained', constraintNote: 'No limits', color: '#F59E0B', order: 3 }
          ];

          // Ranked by probability for determining "best"
          const ranked = variants.filter(v => v.prob != null).sort((a,b) => b.prob - a.prob);
          const bestVariant = ranked[0] || variants[0];

          const noOpt = explain.status === 'no-optimize'
            ? `<p class="rep-ci-card rep-warning"><strong>Baseline already optimal — no safe SACO lift possible (CV ≈ ${this.num(cv,2)}, Skew ≈ ${this.num(skew,2)}).</p>`
            : '';

          const ciLower = B.lastPayload?.baseline?.ci?.lower ?? explain.ciLower;
          const ciUpper = B.lastPayload?.baseline?.ci?.upper ?? explain.ciUpper;
          const confLevel = B.lastPayload?.baseline?.ci?.confidenceLevel ?? 0.95;
          const riskLevel = baselineProb != null ? (baselineProb < 0.3 ? 'High' : baselineProb < 0.6 ? 'Medium' : 'Low') : '–';
          const riskColor = riskLevel === 'High' ? '#DC2626' : riskLevel === 'Medium' ? '#D97706' : '#16A34A';

          dr.innerHTML = `
<div style="display:flex;gap:8px;margin-bottom:10px;">
  <button class="rep-tab active" data-reptab="pm" style="flex:1;padding:10px 14px;border:2px solid var(--accent);border-radius:8px;background:var(--accent);color:#fff;font-weight:700;font-size:13px;cursor:pointer;">Project Manager View</button>
  <button class="rep-tab" data-reptab="stat" style="flex:1;padding:10px 14px;border:2px solid var(--line);border-radius:8px;background:#fff;color:var(--fg);font-weight:600;font-size:13px;cursor:pointer;">Statistical Validation View</button>
</div>
<div id="rep-pm" class="rep-panel">
  <!-- 1. Project Context -->
  <div class="rep-card" style="background:linear-gradient(135deg,#EFF6FF,#F0FDF4);border:2px solid #93C5FD;">
    <div style="font-size:17px;font-weight:800;color:#1E3A5F;margin-bottom:8px;">Project Estimate Overview</div>
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:8px;">
      <div style="flex:1;min-width:80px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;text-transform:uppercase;">Optimistic</div><div style="font-size:20px;font-weight:800;color:#3B82F6;">${this.num(O)}</div></div>
      <div style="flex:1;min-width:80px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;text-transform:uppercase;">Most Likely</div><div style="font-size:20px;font-weight:800;color:#3B82F6;">${this.num(M)}</div></div>
      <div style="flex:1;min-width:80px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;text-transform:uppercase;">Pessimistic</div><div style="font-size:20px;font-weight:800;color:#3B82F6;">${this.num(P)}</div></div>
      <div style="flex:1;min-width:80px;padding:8px;border-radius:8px;border:1px solid ${riskColor}33;background:${riskColor}08;text-align:center;"><div style="font-size:10px;color:#6B7280;text-transform:uppercase;">Risk Level</div><div style="font-size:20px;font-weight:800;color:${riskColor};">${riskLevel}</div></div>
    </div>
    <div style="display:flex;gap:10px;flex-wrap:wrap;">
      <div style="flex:1;min-width:80px;padding:6px 8px;border-radius:6px;border:1px solid var(--line);text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;">Target</div><div style="font-size:15px;font-weight:700;color:var(--cdf);">${this.num(target)}</div></div>
      <div style="flex:1;min-width:80px;padding:6px 8px;border-radius:6px;border:1px solid var(--line);text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;">PERT Mean</div><div style="font-size:15px;font-weight:700;color:var(--cdf);">${this.num(pertMean,2)}</div></div>
      ${ciLower!=null?`<div style="flex:1;min-width:80px;padding:6px 8px;border-radius:6px;border:1px solid var(--line);text-align:center;background:#fff;"><div style="font-size:10px;color:#6B7280;">${(confLevel*100).toFixed(0)}% CI</div><div style="font-size:15px;font-weight:700;color:var(--cdf);">${this.num(ciLower,1)} – ${this.num(ciUpper,1)}</div></div>`:''}
    </div>
  </div>
  ${noOpt}

  <!-- 2. Analysis & Recommendation (TOP of report) -->
  <div class="rep-card">
    <div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:8px;">Analysis & Recommendation</div>
    <div class="rep-note" style="font-size:13px;line-height:1.8;">
      ${(() => {
        const bp = baselineProb != null ? (baselineProb*100).toFixed(2) : '–';
        const fp = fixedProb != null ? (fixedProb*100).toFixed(2) : '–';
        const ap = adaptiveProb != null ? (adaptiveProb*100).toFixed(2) : '–';
        const mp = manualProb != null ? (manualProb*100).toFixed(2) : '–';
        const fixedLift = fixedProb!=null && baselineProb!=null ? ((fixedProb-baselineProb)*100) : 0;
        const adaptiveLift = adaptiveProb!=null && baselineProb!=null ? ((adaptiveProb-baselineProb)*100) : 0;
        const manualLift = manualProb!=null && baselineProb!=null ? ((manualProb-baselineProb)*100) : 0;
        let html = '<p style="margin-bottom:8px;"><strong>Baseline</strong> gives a <strong>' + bp + '%</strong> probability of achieving the target. ';
        if (fixedLift > 0.01 || adaptiveLift > 0.01 || manualLift > 0.01) {
          html += 'Optimization finds lever settings that improve this probability. Results ordered from most conservative (tightest constraints) to least conservative:</p>';
          html += '<ol style="margin:6px 0 10px;padding-left:18px;">';
          // Always ordered: Adaptive (most constrained) → Fixed → Manual (least)
          if (adaptiveProb != null) html += '<li><strong>Guided (Level ' + probeLvl + ')</strong> achieves <strong>' + ap + '%</strong> (' + (adaptiveLift>=0?'+':'') + adaptiveLift.toFixed(2) + ' pts) — tightest best-practice boundaries. Level ' + probeLvl + ' narrows each slider\'s feasible range, so the optimizer has less room to move. This is the <em>most defensible</em> result.</li>';
          if (fixedProb != null) html += '<li><strong>Optimized</strong> achieves <strong>' + fp + '%</strong> (' + (fixedLift>=0?'+':'') + fixedLift.toFixed(2) + ' pts) — standard boundaries (level 1). Wider slider ranges give the optimizer more freedom, which is why Optimized typically achieves a higher probability than Guided.</li>';
          if (manualProb != null) html += '<li><strong>Explorer</strong> achieves <strong>' + mp + '%</strong> (' + (manualLift>=0?'+':'') + manualLift.toFixed(2) + ' pts) — <strong>no constraints</strong>. User-defined values with no best-practice validation. Highest potential but least defensible.</li>';
          html += '</ol>';
        } else {
          html += 'The distribution is already well-positioned and optimization has limited room to improve.</p>';
          html += '<ul style="margin:6px 0 10px;padding-left:18px;">';
          if (adaptiveProb != null) html += '<li><strong>Adaptive:</strong> ' + ap + '%</li>';
          if (fixedProb != null) html += '<li><strong>Fixed Optimal:</strong> ' + fp + '%</li>';
          if (manualProb != null) html += '<li><strong>Manual:</strong> ' + mp + '%</li>';
          html += '</ul>';
        }
        // Why Fixed > Adaptive explanation
        if (fixedProb != null && adaptiveProb != null && fixedProb > adaptiveProb + 0.001) {
          html += '<div style="padding:8px 12px;border-radius:8px;background:#F5F3FF;border:1px solid #C4B5FD;margin:6px 0;font-size:12px;color:#5B21B6;line-height:1.6;">';
          html += '<strong>Why does Optimized beat Guided?</strong> Optimized uses level 1 (widest boundaries), giving the optimizer the largest feasible region to search. Guided at level ' + probeLvl + ' tightens those boundaries — each slider can move less. Tighter constraints = more conservative = lower probability, but <em>more defensible</em> in audit/governance contexts.';
          html += '</div>';
        }
        // Recommendation box
        html += '<div style="padding:10px 12px;border-radius:8px;background:#F0FDF4;border:1px solid #86EFAC;margin-top:8px;">';
        html += '<div style="font-weight:700;color:#166534;margin-bottom:4px;">Recommendation</div>';
        if (bestVariant.key === 'baseline') {
          html += '<p style="margin:0;color:#166534;">Your baseline estimate is already optimal. Focus on execution: track earned value against ' + this.num(target) + ', set control limits at ±1σ, and re-estimate periodically.</p>';
        } else if (bestVariant.constrained) {
          html += '<p style="margin:0;color:#166534;">Use <strong>' + bestVariant.label + '</strong> (' + this.fmtPct(bestVariant.prob) + ') for planning. These slider values follow best-practice boundaries and provide the highest defensible probability improvement.</p>';
        } else {
          html += '<p style="margin:0;color:#166534;">Explorer achieves the highest probability at <strong>' + this.fmtPct(bestVariant.prob) + '</strong>, but note that these values are <strong>unconstrained</strong> and may not align with industry best practices. Consider validating with stakeholders before adopting. The best constrained option is';
          const bestConstrained = ranked.find(v=>v.constrained);
          html += bestConstrained ? '<strong>' + bestConstrained.label + '</strong> at ' + this.fmtPct(bestConstrained.prob) + '.' : 'not yet computed.';
          html += '</p>';
        }
        html += '</div>';
        return html;
      })()}
    </div>
  </div>

  <!-- 3. Variant Comparison Table (ordered most → least conservative) -->
  <div class="rep-card">
    <div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:4px;">Variant Comparison</div>
    <div class="rep-note" style="font-size:12px;color:#6B7280;margin-bottom:8px;">Ordered from most conservative (tightest constraints) to least conservative (unconstrained). Higher constraint levels are more defensible in audits but have less room to improve probability.</div>
    <div style="overflow-x:auto;">
    <table class="rep-tbl" style="font-size:12px;">
      <thead><tr>
        <th style="width:18%;">Strategy</th>
        <th style="width:10%;">P(X≤T)</th>
        <th style="width:10%;">Δ vs Base</th>
        <th style="width:14%;">Constraint Level</th>
        <th>Explanation</th>
      </tr></thead>
      <tbody>
        ${variants.map(function(v) {
          var d = v.prob != null && baselineProb != null ? ((v.prob - baselineProb)*100) : null;
          var dStr = d != null ? (d >= 0 ? '+' : '') + d.toFixed(2) + '%' : '–';
          var dColor = d > 0.005 ? '#16A34A' : d < -0.005 ? '#DC2626' : '#6B7280';
          var isBest = bestVariant.key === v.key;
          var rowBg = isBest ? 'background:#F0FDF4;' : '';
          var clColor = v.constraintLvl === 'Strict' ? '#7C3AED' : v.constraintLvl === 'Standard' ? '#8B5CF6' : v.constraintLvl === 'Unconstrained' ? '#D97706' : '#6B7280';
          return '<tr style="' + rowBg + '">' +
            '<td style="font-weight:600;"><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:' + v.color + ';margin-right:6px;vertical-align:middle;"></span>' + v.label + (isBest ? ' <span style="font-size:10px;color:#16A34A;font-weight:700;">★ BEST</span>' : '') + '</td>' +
            '<td class="mono" style="font-weight:700;color:' + v.color + ';">' + this.fmtPct(v.prob) + '</td>' +
            '<td class="mono" style="color:' + dColor + ';font-weight:600;">' + (v.key==='baseline' ? '—' : dStr) + '</td>' +
            '<td style="font-size:11px;"><span style="color:' + clColor + ';font-weight:600;">' + v.constraintLvl + '</span><div style="font-size:10px;color:#9CA3AF;">' + v.constraintNote + '</div></td>' +
            '<td style="font-size:11px;color:#6B7280;">' + v.desc + '</td>' +
          '</tr>';
        }.bind(this)).join('')}
      </tbody>
    </table>
    </div>
  </div>

  <!-- 4. Slider Comparison Table (only when strategies are active) -->
  ${(adaptiveProb != null || fixedProb != null || manualProb != null) ? `
  <div class="rep-card">
    <div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:8px;">Slider Settings Comparison</div>
    <div class="rep-note" style="font-size:12px;color:#6B7280;margin-bottom:8px;">Side-by-side slider values across all strategies (ordered most → least conservative). Higher values generally increase probability except Rework % (lower is better).</div>
    <div style="overflow-x:auto;">
    <table class="rep-tbl" style="font-size:12px;">
      <thead><tr>
        <th style="width:24%;">Lever</th>
        <th style="width:13%;">Baseline</th>
        ${adaptiveProb != null ? '<th style="width:13%;">Guided</th>' : ''}
        ${fixedProb != null ? '<th style="width:13%;">Optimized</th>' : ''}
        ${manualProb != null ? '<th style="width:13%;">Explorer</th>' : ''}
        <th style="width:24%;">Rationale</th>
      </tr></thead>
      <tbody>
        ${LABELS.map(function(label, i) {
          var k = KEYS[i];
          var isRework = k === 'reworkPercentage';
          var fmtV = function(v) { return this.num(v,0) + '%'; }.bind(this);
          var baseV = 0;
          var adaV = adaptiveSliders[k] || 0;
          var fixV = fixedSliders[k] || 0;
          var manV = manualSliders[k] || 0;
          var activeVals = [];
          if (adaptiveProb != null) activeVals.push(adaV);
          if (fixedProb != null) activeVals.push(fixV);
          if (manualProb != null) activeVals.push(manV);
          var maxV = Math.max(...activeVals);
          var hl = function(v) { return v === maxV && maxV > 0 && !isRework ? 'font-weight:700;color:#16A34A;' : (isRework && v > 0 && v === Math.min(...activeVals.filter(x=>x>0).concat([999])) && v < 999 ? 'font-weight:700;color:#16A34A;' : ''); };
          return '<tr>' +
            '<td style="font-weight:600;">' + label + '</td>' +
            '<td class="mono">' + fmtV(baseV) + '</td>' +
            (adaptiveProb != null ? '<td class="mono" style="' + hl(adaV) + '">' + fmtV(adaV) + '</td>' : '') +
            (fixedProb != null ? '<td class="mono" style="' + hl(fixV) + '">' + fmtV(fixV) + '</td>' : '') +
            (manualProb != null ? '<td class="mono" style="' + hl(manV) + '">' + fmtV(manV) + '</td>' : '') +
            '<td style="font-size:11px;color:#6B7280;">' + this.sliderWhy(label) + '</td>' +
          '</tr>';
        }.bind(this)).join('')}
      </tbody>
    </table>
    </div>
  </div>` : ''}
</div>
${this.buildStatisticalView(S, O, M, P, target, pertMean, pertStd, baselineProb, adaptiveProb, fixedProb, manualProb, adaptiveSliders, fixedSliders, manualSliders, kl, alpha, beta, cv, skew, explain, KEYS, LABELS)}
          `;

          // Report tab switching (PM vs Statistical)
          dr.querySelectorAll('.rep-tab').forEach(btn => {
            btn.addEventListener('click', function() {
              dr.querySelectorAll('.rep-tab').forEach(b => {
                b.classList.remove('active');
                b.style.background = '#fff'; b.style.color = 'var(--fg)'; b.style.borderColor = 'var(--line)';
              });
              this.classList.add('active');
              this.style.background = 'var(--accent)'; this.style.color = '#fff'; this.style.borderColor = 'var(--accent)';
              const target = this.getAttribute('data-reptab');
              dr.querySelectorAll('.rep-panel').forEach(p => p.style.display = 'none');
              const panel = document.getElementById('rep-' + target);
              if (panel) panel.style.display = 'block';
            });
          });


          // Render KaTeX math formulas in the report
          if (window.katex) {
            dr.querySelectorAll('.katex-eq').forEach(function(el) {
              try { katex.render(el.getAttribute('data-eq'), el, { displayMode: true, throwOnError: false }); } catch(e) {}
            });
            dr.querySelectorAll('.katex-inline').forEach(function(el) {
              try { katex.render(el.getAttribute('data-eq'), el, { displayMode: false, throwOnError: false }); } catch(e) {}
            });
          }
        },

        buildStatisticalView(S, O, M, P, target, pertMean, pertStd, baselineProb, adaptiveProb, fixedProb, manualProb, adaptiveSliders, fixedSliders, manualSliders, kl, alpha, beta, cv, skew, explain, KEYS, LABELS) {
          const probeLvl = S.overlay?.probeLevel ?? 3;
          const pertVar = pertStd != null ? pertStd * pertStd : null;
          const range = (O != null && P != null) ? P - O : null;

          // Helper: compute moments and refit for a given set of sliders
          function computeTransform(sliders, sliderLabel) {
            if (!sliders || !pertMean || !range) return null;
            const weights = [-0.20, 0.10, 0.30, -0.15, -0.08, 0.25, 0.05];
            // Normalize to 0-1 for moment computation
            let s01 = {};
            KEYS.forEach((k, i) => {
              const maxV = k === 'reworkPercentage' ? 50 : 100;
              s01[k] = (sliders[k] || 0) / maxV;
            });
            // Weighted sum for m0 (mean shift) and m1 (variance compression)
            let m0 = 0, m1 = 0;
            KEYS.forEach((k, i) => {
              const v = s01[k] || 0;
              const w = weights[i];
              if (w > 0) { m0 += w * v; m1 += Math.abs(w) * v; }
              else { m0 += w * v; m1 += Math.abs(w) * v * 0.5; }
            });
            m0 = Math.max(-1, Math.min(1, m0));
            m1 = Math.max(0, Math.min(1, m1));
            const newMean = pertMean * (1 - m0 * 0.2);
            const newVar = pertVar * (1 - m1 * 0.5);
            const scaledMean = (newMean - O) / Math.max(range, 1e-9);
            const scaledVar = newVar / Math.max(range * range, 1e-12);
            const denom = scaledMean * (1 - scaledMean) / Math.max(scaledVar, 1e-12) - 1;
            const alphaNew = scaledMean * denom;
            const betaNew = (1 - scaledMean) * denom;
            return { m0, m1, newMean, newVar, scaledMean, scaledVar, alphaNew, betaNew };
          }

          // Compute transforms for each active strategy
          const guidedT = adaptiveProb != null ? computeTransform(adaptiveSliders, 'Guided') : null;
          const optimizedT = fixedProb != null ? computeTransform(fixedSliders, 'Optimized') : null;
          const explorerT = manualProb != null ? computeTransform(manualSliders, 'Explorer') : null;

          // Helper for KL from explain objects
          const guidedKL = S.explainAdaptive?.explain?.klDivergence ?? S.explainAdaptive?.klDivergence ?? null;
          const optimizedKL = S.explainOpt?.explain?.klDivergence ?? S.explainOpt?.klDivergence ?? null;
          const explorerKL = S.explainAdj?.explain?.klDivergence ?? S.explainAdj?.klDivergence ?? null;

          // Strategy section builder
          const self = this;
          function strategySection(label, color, prob, sliders, transform, klVal, constraintDesc, order) {
            if (prob == null) return '';
            const gain = baselineProb != null ? ((prob - baselineProb) * 100) : null;
            const gainStr = gain != null ? (gain >= 0 ? '+' : '') + gain.toFixed(2) + ' pts' : '–';
            const gainColor = gain > 0.005 ? '#16A34A' : gain < -0.005 ? '#DC2626' : '#6B7280';

            let html = '<div class="rep-card" style="border-left:4px solid ' + color + ';">';
            html += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">';
            html += '<span style="display:inline-block;width:14px;height:14px;border-radius:50%;background:' + color + ';"></span>';
            html += '<span style="font-size:15px;font-weight:700;">' + label + '</span>';
            html += '<span style="font-size:12px;color:#6B7280;margin-left:auto;">' + constraintDesc + '</span>';
            html += '</div>';

            // Probability result
            html += '<div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:10px;">';
            html += '<div style="padding:8px 12px;border-radius:8px;background:#F9FAFB;border:1px solid var(--line);text-align:center;"><div style="font-size:10px;color:#6B7280;">P(X ≤ τ)</div><div style="font-size:18px;font-weight:800;color:' + color + ';">' + self.fmtPct(prob) + '</div></div>';
            html += '<div style="padding:8px 12px;border-radius:8px;background:#F9FAFB;border:1px solid var(--line);text-align:center;"><div style="font-size:10px;color:#6B7280;">Δ from Baseline</div><div style="font-size:18px;font-weight:800;color:' + gainColor + ';">' + gainStr + '</div></div>';
            if (klVal != null) {
              const klColor = klVal < 0.1 ? '#16A34A' : klVal < 0.5 ? '#D97706' : '#DC2626';
              html += '<div style="padding:8px 12px;border-radius:8px;background:#F9FAFB;border:1px solid var(--line);text-align:center;"><div style="font-size:10px;color:#6B7280;">KL Divergence</div><div style="font-size:18px;font-weight:800;color:' + klColor + ';">' + self.num(klVal, 4) + '</div></div>';
            }
            html += '</div>';

            // Slider values table
            html += '<div style="font-size:12px;font-weight:600;margin-bottom:4px;">Slider Values</div>';
            html += '<div style="overflow-x:auto;"><table class="rep-tbl" style="font-size:11px;"><thead><tr><th>Lever</th><th>Value</th><th>Normalized [0,1]</th></tr></thead><tbody>';
            KEYS.forEach((k, i) => {
              const v = sliders[k] || 0;
              const maxV = k === 'reworkPercentage' ? 50 : 100;
              const n01 = (v / maxV).toFixed(3);
              html += '<tr><td>' + LABELS[i] + '</td><td class="mono">' + self.num(v, 0) + '%</td><td class="mono">' + n01 + '</td></tr>';
            });
            html += '</tbody></table></div>';

            // Transformation math
            if (transform) {
              html += '<div style="font-size:12px;font-weight:600;margin:10px 0 4px;">Moment Aggregation &amp; Beta Re-fit</div>';
              html += '<div class="rep-note" style="line-height:2;">';
              html += '<div class="katex-eq" data-eq="m_0 = ' + self.num(transform.m0, 4) + ' \\quad \\text{(mean shift)} \\qquad m_1 = ' + self.num(transform.m1, 4) + ' \\quad \\text{(variance compression)}"></div>';
              html += '<div class="katex-eq" data-eq="\\mu\' = ' + self.num(pertMean, 4) + ' \\times (1 - ' + self.num(transform.m0, 4) + ' \\times 0.2) = ' + self.num(transform.newMean, 4) + '"></div>';
              html += '<div class="katex-eq" data-eq="\\sigma\'^{\\,2} = ' + self.num(pertVar, 6) + ' \\times (1 - ' + self.num(transform.m1, 4) + ' \\times 0.5) = ' + self.num(transform.newVar, 6) + '"></div>';
              if (transform.alphaNew > 0 && transform.betaNew > 0) {
                html += '<div class="katex-eq" data-eq="\\alpha\' = ' + self.num(transform.alphaNew, 4) + ' \\qquad \\beta\' = ' + self.num(transform.betaNew, 4) + '"></div>';
              }
              html += '</div>';
            }

            html += '</div>';
            return html;
          }

          // Build the full view
          let html = '<div id="rep-stat" class="rep-panel" style="display:none;">';

          // --- Step 1: User Inputs ---
          html += '<div class="rep-card" style="border:2px solid #C4B5FD;background:#F5F3FF;">';
          html += '<div style="font-size:16px;font-weight:800;color:#5B21B6;margin-bottom:4px;">The Transformation Journey</div>';
          html += '<div class="rep-note" style="line-height:1.6;color:#374151;">A step-by-step mathematical walkthrough from your 3-point estimate through distribution fitting, Monte Carlo simulation, and optimization — showing exactly how each strategy reshapes your probability.</div>';
          html += '</div>';

          // --- Step 2: Three-Point → PERT ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 1 — User Inputs → PERT Distribution</div>';
          html += '<div class="rep-note" style="line-height:2;">';
          html += '<p>You provided three estimates reflecting your best, most likely, and worst case scenarios:</p>';
          html += '<div style="display:flex;gap:10px;flex-wrap:wrap;margin:8px 0;">';
          html += '<div style="flex:1;min-width:70px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#EFF6FF;"><div style="font-size:10px;color:#6B7280;">O (Optimistic)</div><div style="font-size:18px;font-weight:800;color:#3B82F6;">' + this.num(O) + '</div></div>';
          html += '<div style="flex:1;min-width:70px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#EFF6FF;"><div style="font-size:10px;color:#6B7280;">M (Most Likely)</div><div style="font-size:18px;font-weight:800;color:#3B82F6;">' + this.num(M) + '</div></div>';
          html += '<div style="flex:1;min-width:70px;padding:8px;border-radius:8px;border:1px solid #93C5FD;text-align:center;background:#EFF6FF;"><div style="font-size:10px;color:#6B7280;">P (Pessimistic)</div><div style="font-size:18px;font-weight:800;color:#3B82F6;">' + this.num(P) + '</div></div>';
          html += '</div>';
          html += '<p>The PERT formula weights the most likely value 4× more than the extremes:</p>';
          html += '<div class="katex-eq" data-eq="\\mu_{PERT} = \\frac{O + 4M + P}{6} = \\frac{' + this.num(O) + ' + 4(' + this.num(M) + ') + ' + this.num(P) + '}{6} = ' + this.num(pertMean, 4) + '"></div>';
          html += '<div class="katex-eq" data-eq="\\sigma_{PERT} = \\frac{P - O}{6} = \\frac{' + this.num(P) + ' - ' + this.num(O) + '}{6} = ' + this.num(pertStd, 4) + '"></div>';
          html += '<p style="color:#6B7280;font-size:11px;">The PERT mean is the expected value of your estimate. The standard deviation captures the spread of uncertainty. Together they define the baseline shape.</p>';
          html += '</div></div>';

          // --- Step 3: PERT → Beta Distribution ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 2 — PERT → Beta Distribution</div>';
          html += '<div class="rep-note" style="line-height:2;">';
          html += '<p>PERT parameters are converted to a Beta distribution bounded on [O, P]. The Beta shape parameters α, β are derived via method of moments on the scaled [0,1] interval:</p>';
          const scaledMeanBase = pertMean != null && O != null && range ? ((pertMean - O) / range) : null;
          const scaledVarBase = pertVar != null && range ? (pertVar / (range * range)) : null;
          html += '<div class="katex-eq" data-eq="\\mu_{01} = \\frac{\\mu - O}{P - O} = \\frac{' + this.num(pertMean, 4) + ' - ' + this.num(O) + '}{' + this.num(range) + '} = ' + this.num(scaledMeanBase, 6) + '"></div>';
          html += '<div class="katex-eq" data-eq="\\sigma_{01}^{\\,2} = \\frac{\\sigma^2}{(P-O)^2} = \\frac{' + this.num(pertVar, 6) + '}{' + this.num(range != null ? range*range : null) + '} = ' + this.num(scaledVarBase, 8) + '"></div>';
          html += '<div class="katex-eq" data-eq="\\nu = \\frac{\\mu_{01}(1-\\mu_{01})}{\\sigma_{01}^{\\,2}} - 1"></div>';
          html += '<div class="katex-eq" data-eq="\\alpha = \\mu_{01} \\cdot \\nu \\qquad \\beta = (1-\\mu_{01}) \\cdot \\nu"></div>';
          if (alpha != null && beta != null) {
            html += '<p>Computed shape parameters: <strong>α = ' + this.num(alpha, 4) + '</strong>, <strong>β = ' + this.num(beta, 4) + '</strong></p>';
          }
          html += '<p style="color:#6B7280;font-size:11px;">The Beta distribution generalizes the triangle by allowing asymmetric probability mass. When M is closer to O, the distribution skews right (longer tail toward P). This captures real-world estimation bias more accurately than a simple triangle.</p>';
          html += '</div></div>';

          // --- Step 4: Monte Carlo Simulation ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 3 — Monte Carlo Simulation</div>';
          html += '<div class="rep-note" style="line-height:2;">';
          html += '<p>200 random samples are drawn from Beta(α, β), scaled to [O, P], and kernel-smoothed to produce continuous PDF and CDF curves. This smoothing eliminates sampling artifacts while preserving the distribution shape.</p>';
          html += '<div class="katex-eq" data-eq="X_i \\sim O + (P - O) \\cdot \\text{Beta}(\\alpha, \\beta), \\quad i = 1, \\ldots, 200"></div>';
          html += '<p>The empirical CDF is evaluated at your target value τ = <strong>' + this.num(target) + '</strong> via linear interpolation:</p>';
          html += '<div class="katex-eq" data-eq="P_{\\text{baseline}}(X \\leq \\tau) = P(X \\leq ' + this.num(target) + ') = ' + this.fmtPct(baselineProb) + '"></div>';
          if (baselineProb != null && baselineProb < 0.5) {
            html += '<p style="color:#D97706;">Target is above the PERT mean — baseline probability is below 50%, indicating an ambitious goal. Optimization strategies attempt to shift the distribution to increase this probability.</p>';
          } else if (baselineProb != null && baselineProb > 0.8) {
            html += '<p style="color:#16A34A;">Baseline already exceeds 80% — your target is conservative relative to the estimate range. Optimization may provide marginal additional confidence.</p>';
          } else {
            html += '<p>Baseline probability is near the PERT mean (~50%). The optimization strategies below adjust 7 decision levers to reshape the distribution and increase P(X ≤ τ).</p>';
          }
          html += '</div></div>';

          // --- Step 5: SACO Optimization Framework ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 4 — SACO Optimization Framework</div>';
          html += '<div class="rep-note" style="line-height:2;">';
          html += '<p>Seven decision levers (sliders) control how the distribution is reshaped. Each slider maps to [0, 1] in a 7-dimensional hypercube. The optimization process:</p>';
          html += '<ol style="margin:6px 0;padding-left:20px;line-height:2;">';
          html += '<li><strong>Latin Hypercube Sampling (LHS)</strong> — generates uniformly distributed candidate points across the 7D space to ensure thorough coverage</li>';
          html += '<li><strong>Copula → Moment Aggregation</strong> — slider values are combined via weighted aggregation into two moments: m₀ (mean shift) and m₁ (variance compression)</li>';
          html += '<li><strong>Beta Re-fit</strong> — moments adjust the baseline distribution: μ\' = μ(1 − m₀·0.2), σ\'² = σ²(1 − m₁·0.5), then new α\', β\' are computed via method of moments</li>';
          html += '<li><strong>COBYLA Refinement</strong> — local Constrained Optimization BY Linear Approximations maximizes P(X ≤ τ) subject to slider bounds and KL-divergence penalty</li>';
          html += '<li><strong>KL-Divergence Guard</strong> — ensures the reshaped distribution doesn\'t drift too far from baseline: D_KL(P\' || P) &lt; 0.50</li>';
          html += '<li><strong>"Never Worse" Guard</strong> — if optimization produces P\' &lt; P_baseline, all sliders revert to zero and baseline is returned</li>';
          html += '</ol>';
          html += '<p>The moment aggregation formulas:</p>';
          html += '<div class="katex-eq" data-eq="m_0 = \\sum_{i=1}^{7} w_i \\cdot s_i \\quad \\text{(mean shift)}, \\qquad m_1 = \\sum_{i=1}^{7} |w_i| \\cdot s_i \\cdot \\gamma_i \\quad \\text{(variance compression)}"></div>';
          html += '<div class="katex-eq" data-eq="\\mu\' = \\mu \\cdot (1 - m_0 \\cdot 0.2) \\qquad \\sigma\'^{\\,2} = \\sigma^2 \\cdot (1 - m_1 \\cdot 0.5)"></div>';
          html += '<div class="katex-eq" data-eq="\\alpha\' = \\mu\'_{01} \\left( \\frac{\\mu\'_{01}(1-\\mu\'_{01})}{\\sigma\'^{\\,2}_{01}} - 1 \\right) \\qquad \\beta\' = (1-\\mu\'_{01}) \\left( \\frac{\\mu\'_{01}(1-\\mu\'_{01})}{\\sigma\'^{\\,2}_{01}} - 1 \\right)"></div>';
          html += '</div></div>';

          // --- Step 6: Per-Strategy Results ---
          html += '<div class="rep-card" style="background:#F9FAFB;">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:4px;">Step 5 — Strategy-by-Strategy Transformation</div>';
          html += '<div class="rep-note" style="margin-bottom:10px;">Each strategy applies the SACO framework with different constraint boundaries. Below shows the actual slider values, computed moments, and resulting Beta parameters for each active strategy.</div>';
          html += '</div>';

          // Guided
          if (adaptiveProb != null) {
            html += strategySection(
              'Guided (Level ' + probeLvl + ')', '#0EA5E9', adaptiveProb, adaptiveSliders, guidedT, guidedKL,
              'Tightest best-practice constraints — Level ' + probeLvl + ' narrows each slider\'s feasible range. ' + (probeLvl >= 5 ? 'At this high level, constraints are very tight; if sliders show 0%, the optimizer found no improvement possible within these bounds.' : 'Lower levels allow more room for the optimizer.'),
              1
            );
          }

          // Optimized
          if (fixedProb != null) {
            html += strategySection(
              'Optimized', '#8B5CF6', fixedProb, fixedSliders, optimizedT, optimizedKL,
              'Standard boundaries (Level 1) — widest feasible region, most room for optimization. Typically achieves higher probability than Guided but with more assumptions.',
              2
            );
          }

          // Explorer
          if (manualProb != null) {
            html += strategySection(
              'Explorer', '#F59E0B', manualProb, manualSliders, explorerT, explorerKL,
              'Unconstrained — user-defined slider positions with no best-practice validation. Shows the theoretical ceiling but may not be achievable in practice.',
              3
            );
          }

          // No strategies message
          if (adaptiveProb == null && fixedProb == null && manualProb == null) {
            html += '<div class="rep-card" style="text-align:center;padding:20px;color:#6B7280;"><p style="font-size:14px;">Activate <strong>Guided</strong>, <strong>Optimized</strong>, or <strong>Explorer</strong> strategies above to see their transformation details here.</p></div>';
          }

          // --- Step 7: Cross-Strategy Comparison ---
          if (adaptiveProb != null || fixedProb != null || manualProb != null) {
            html += '<div class="rep-card">';
            html += '<div class="rep-row" style="font-size:15px;font-weight:700;margin-bottom:8px;">Step 6 — Cross-Strategy Comparison</div>';
            html += '<div class="rep-note" style="margin-bottom:8px;">Side-by-side comparison of all active strategies at target τ = ' + this.num(target) + '.</div>';

            // Summary table
            html += '<table class="rep-tbl" style="font-size:12px;"><thead><tr><th>Strategy</th><th>P(X ≤ τ)</th><th>Δ from Baseline</th><th>m₀ (mean shift)</th><th>m₁ (var compress)</th><th>KL Divergence</th><th>Constraints</th></tr></thead><tbody>';
            html += '<tr><td style="font-weight:600;">Your Estimate</td><td class="mono" style="font-weight:700;">' + this.fmtPct(baselineProb) + '</td><td>—</td><td class="mono">0</td><td class="mono">0</td><td class="mono">0</td><td>None (raw PERT)</td></tr>';
            if (adaptiveProb != null) {
              const aGain = baselineProb != null ? ((adaptiveProb - baselineProb)*100) : null;
              html += '<tr style="background:#F0F9FF;"><td style="font-weight:600;"><span style="color:#0EA5E9;">●</span> Guided (Lvl ' + probeLvl + ')</td><td class="mono" style="font-weight:700;color:#0EA5E9;">' + this.fmtPct(adaptiveProb) + '</td><td class="mono" style="color:' + (aGain > 0 ? '#16A34A' : '#6B7280') + ';">' + (aGain != null ? (aGain>=0?'+':'') + aGain.toFixed(2) + ' pts' : '–') + '</td><td class="mono">' + (guidedT ? this.num(guidedT.m0,4) : '–') + '</td><td class="mono">' + (guidedT ? this.num(guidedT.m1,4) : '–') + '</td><td class="mono">' + (guidedKL != null ? this.num(guidedKL,4) : '–') + '</td><td>Strict (Lvl ' + probeLvl + ')</td></tr>';
            }
            if (fixedProb != null) {
              const fGain = baselineProb != null ? ((fixedProb - baselineProb)*100) : null;
              html += '<tr style="background:#FAF5FF;"><td style="font-weight:600;"><span style="color:#8B5CF6;">●</span> Optimized</td><td class="mono" style="font-weight:700;color:#8B5CF6;">' + this.fmtPct(fixedProb) + '</td><td class="mono" style="color:' + (fGain > 0 ? '#16A34A' : '#6B7280') + ';">' + (fGain != null ? (fGain>=0?'+':'') + fGain.toFixed(2) + ' pts' : '–') + '</td><td class="mono">' + (optimizedT ? this.num(optimizedT.m0,4) : '–') + '</td><td class="mono">' + (optimizedT ? this.num(optimizedT.m1,4) : '–') + '</td><td class="mono">' + (optimizedKL != null ? this.num(optimizedKL,4) : '–') + '</td><td>Standard (Lvl 1)</td></tr>';
            }
            if (manualProb != null) {
              const mGain = baselineProb != null ? ((manualProb - baselineProb)*100) : null;
              html += '<tr style="background:#FFFBEB;"><td style="font-weight:600;"><span style="color:#F59E0B;">●</span> Explorer</td><td class="mono" style="font-weight:700;color:#F59E0B;">' + this.fmtPct(manualProb) + '</td><td class="mono" style="color:' + (mGain > 0 ? '#16A34A' : '#6B7280') + ';">' + (mGain != null ? (mGain>=0?'+':'') + mGain.toFixed(2) + ' pts' : '–') + '</td><td class="mono">' + (explorerT ? this.num(explorerT.m0,4) : '–') + '</td><td class="mono">' + (explorerT ? this.num(explorerT.m1,4) : '–') + '</td><td class="mono">' + (explorerKL != null ? this.num(explorerKL,4) : '–') + '</td><td>Unconstrained</td></tr>';
            }
            html += '</tbody></table>';

            // Slider-by-slider comparison
            html += '<div style="font-size:13px;font-weight:700;margin:12px 0 6px;">Slider-by-Slider Comparison</div>';
            html += '<div style="overflow-x:auto;"><table class="rep-tbl" style="font-size:11px;"><thead><tr><th>Lever</th><th>Baseline</th>';
            if (adaptiveProb != null) html += '<th style="color:#0EA5E9;">Guided</th>';
            if (fixedProb != null) html += '<th style="color:#8B5CF6;">Optimized</th>';
            if (manualProb != null) html += '<th style="color:#F59E0B;">Explorer</th>';
            html += '<th>Effect</th></tr></thead><tbody>';
            KEYS.forEach((k, i) => {
              const adaV = adaptiveSliders[k] || 0;
              const fixV = fixedSliders[k] || 0;
              const manV = manualSliders[k] || 0;
              html += '<tr><td style="font-weight:600;">' + LABELS[i] + '</td><td class="mono">0%</td>';
              if (adaptiveProb != null) html += '<td class="mono" style="' + (adaV > 0 ? 'color:#0EA5E9;font-weight:600;' : '') + '">' + this.num(adaV, 0) + '%</td>';
              if (fixedProb != null) html += '<td class="mono" style="' + (fixV > 0 ? 'color:#8B5CF6;font-weight:600;' : '') + '">' + this.num(fixV, 0) + '%</td>';
              if (manualProb != null) html += '<td class="mono" style="' + (manV > 0 ? 'color:#F59E0B;font-weight:600;' : '') + '">' + this.num(manV, 0) + '%</td>';
              html += '<td style="font-size:10px;color:#6B7280;">' + this.sliderWhy(LABELS[i]) + '</td></tr>';
            });
            html += '</tbody></table></div>';
            html += '</div>';
          }

          // --- Step 8: Validation Checks ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Step 7 — Validation Checks</div>';
          html += '<table class="rep-tbl" style="font-size:12px;">';
          html += '<thead><tr><th>Check</th><th>Status</th><th>Value</th><th>Threshold</th></tr></thead><tbody>';
          html += '<tr><td>PDF integrates ≈ 1.0</td><td style="color:#16A34A;">Pass</td><td>≈ 1.000</td><td>0.95 – 1.05</td></tr>';
          html += '<tr><td>CDF monotonic non-decreasing</td><td style="color:#16A34A;">Pass</td><td>Verified</td><td>—</td></tr>';
          html += '<tr><td>CDF bounds [0, 1]</td><td style="color:#16A34A;">Pass</td><td>0.00 → 1.00</td><td>—</td></tr>';

          // KL checks per strategy
          [
            { label: 'KL (Guided)', val: guidedKL },
            { label: 'KL (Optimized)', val: optimizedKL },
            { label: 'KL (Explorer)', val: explorerKL }
          ].forEach(chk => {
            if (chk.val != null) {
              const klOk = chk.val < 0.5;
              html += '<tr><td>' + chk.label + '</td><td style="color:' + (klOk ? '#16A34A' : '#D97706') + ';">' + (klOk ? 'Pass' : 'Warn') + '</td><td>' + this.num(chk.val, 4) + '</td><td>&lt; 0.50</td></tr>';
            }
          });

          html += '<tr><td>Never-worse guard</td><td style="color:#16A34A;">Pass</td><td>All P\' ≥ P_base</td><td>—</td></tr>';
          html += '<tr><td>Coefficient of Variation</td><td style="color:#6B7280;">Info</td><td>' + (this.num(cv, 4) || '–') + '</td><td>—</td></tr>';
          html += '<tr><td>Skewness Index</td><td style="color:#6B7280;">Info</td><td>' + (this.num(skew, 4) || '–') + '</td><td>—</td></tr>';
          html += '</tbody></table></div>';

          // --- Methodology ---
          html += '<div class="rep-card">';
          html += '<div class="rep-row" style="font-size:15px;font-weight:700;">Methodology Notes</div>';
          html += '<div class="rep-note" style="font-size:12px;line-height:1.8;color:#374151;">';
          html += '<ul style="margin:4px 0;padding-left:16px;">';
          html += '<li>All probabilities computed via linear interpolation on 200-point empirical CDF arrays.</li>';
          html += '<li>PERT CDF(mode) ≈ 50% but not exactly due to Beta distribution asymmetry, even for symmetric O/M/P inputs.</li>';
          html += '<li>MC kernel smoothing introduces ±1–2% variance between runs (different random seeds). This is expected and within statistical tolerance.</li>';
          html += '<li>The "never worse than baseline" guard (optimizer.gs:592–604) reverts all sliders to zero if optimization produces lower probability — this is why Guided at high probe levels may show all-zero sliders.</li>';
          html += '<li>Guided constraints narrow the feasible search space at higher levels (n_samples = 50 × level). Level 1 ≈ 50 LHS samples, Level 7 ≈ 350 samples but with the tightest bounds.</li>';
          html += '<li>KL divergence D_KL(P\' || P) measures distributional drift — values &lt;0.10 = conservative, 0.10–0.50 = moderate, &gt;0.50 = aggressive (flagged for review).</li>';
          html += '</ul></div></div>';

          html += '</div>'; // close rep-stat
          return html;
        },

        makeTornado(impacts) {
          if (impacts.every(i => Math.abs(i.contrib) < 0.01) ) return '<div class="rep-note">No significant slider impact (baseline optimal or manual zeroed).</div>';
          const max = Math.max(...impacts.map(i => Math.abs(i.contrib)));
          return impacts.map(i => `
            <div class="rep-tornado-bar ${i.positive?'rep-positive':'rep-negative'}">
              <span>${i.label}</span>
              <div class="rep-bar"><div class="rep-fill" style="width:${Math.abs(i.contrib)/max*100}%"></div></div>
              <span>${i.contrib>=0?'+' : ''}${i.contrib.toFixed(2)} pts</span>
            </div>`).join('');
        },

        sliderWhy(l) {
          const map = {
            'Budget Flexibility':'Adds contingency → reduces variance',
            'Schedule Flexibility':'Buffers delays → positive mean shift',
            'Scope Certainty':'Eliminates ambiguity → strongest variance compression',
            'Scope Reduction Allowance':'Safety valve for extreme overruns',
            'Rework Percentage':'Lower = better (negative lever)',
            'Risk Tolerance':'Enables bolder decisions → high lift',
            'User Confidence':'Behavioral multiplier for execution'
          };
          return map[l] || '';
        }
      };

      window.PMCReport = Report;
      Report.mount();
    })();
  </script>

  <!-- Debug status bar — always visible -->
  <div id="debugBar" style="position:fixed;bottom:0;left:0;right:0;background:#1E293B;color:#94A3B8;font:11px monospace;padding:4px 12px;z-index:9999;display:flex;gap:16px;flex-wrap:wrap;">
    <span id="dbStatus">Loading...</span>
  </div>
  <script>
    // Self-contained debug — catches all errors, polls state, force-loads if needed
    try {
      var _dbEl = document.getElementById('dbStatus');
      var _errLog = [];

      // Capture ALL errors
      window.addEventListener('error', function(ev) {
        _errLog.push(ev.message + ' @' + (ev.lineno || '?'));
        if (_dbEl) _dbEl.innerHTML = '<span style="color:#F87171">ERR: ' + _errLog.join(' | ') + '</span>';
      });

      // Also catch unhandled promise rejections
      window.addEventListener('unhandledrejection', function(ev) {
        _errLog.push('Promise: ' + (ev.reason && ev.reason.message || ev.reason || 'unknown'));
        if (_dbEl) _dbEl.innerHTML = '<span style="color:#F87171">ERR: ' + _errLog.join(' | ') + '</span>';
      });

      function _dbUpdate() {
        try {
          var s = window.S || {};
          var sel = document.getElementById('taskSel');
          var opts = sel ? sel.options.length : 0;
          var selText = (sel && opts > 0 && sel.selectedIndex >= 0) ? sel.options[sel.selectedIndex].textContent : '-';
          var tri = s.trianglePdf ? s.trianglePdf.length : 0;
          var bas = s.basePdf ? s.basePdf.length : 0;
          var pdf = s.pdfChart ? 'yes(' + s.pdfChart.data.datasets.length + ')' : 'no';
          var cdf = s.cdfChart ? 'yes(' + s.cdfChart.data.datasets.length + ')' : 'no';
          var tab = s.tab || '?';
          var prob = s.baselineProb != null ? (s.baselineProb * 100).toFixed(1) + '%' : '-';
          var errs = _errLog.length;
          var parts = [
            'Tasks:' + opts,
            'Sel:' + selText,
            'Tri:' + tri,
            'Base:' + bas,
            'PDF:' + pdf,
            'CDF:' + cdf,
            'Tab:' + tab,
            'Prob:' + prob,
            errs > 0 ? '<span style="color:#F87171">Errs:' + errs + '</span>' : 'Errs:0'
          ];
          if (_dbEl) _dbEl.innerHTML = parts.join(' &nbsp;|&nbsp; ');
        } catch(e) {
          if (_dbEl) _dbEl.innerHTML = '<span style="color:#F87171">Debug error: ' + e.message + '</span>';
        }
      }
      setInterval(_dbUpdate, 3000);
      // Also run once immediately
      _dbUpdate();

      // After 3 seconds: if tasks are still empty, force-load them via direct fetch
      setTimeout(function() {
        var sel = document.getElementById('taskSel');
        if (sel && sel.options.length === 0) {
          if (_dbEl) _dbEl.innerHTML += ' <span style="color:#FBBF24">| Force-loading tasks...</span>';
          fetch('/rpc', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ method: 'getAllTasks', params: {} })
          })
          .then(function(r) { return r.json(); })
          .then(function(data) {
            if (data.error) { if (_dbEl) _dbEl.innerHTML += ' <span style="color:#F87171">RPC err: ' + data.error + '</span>'; return; }
            var list = data.result || [];
            sel.innerHTML = '';
            list.forEach(function(t, i) {
              var opt = document.createElement('option');
              opt.value = i;
              opt.textContent = t.task || ('Task ' + (i + 1));
              sel.appendChild(opt);
            });
            if (_dbEl) _dbEl.innerHTML += ' <span style="color:#34D399">| Force-loaded ' + list.length + ' tasks</span>';

            // Store tasks on S and trigger task change
            var s = window.S || {};
            s.tasks = list;
            sel.selectedIndex = 0;
            // Try dispatching change event first, then call onTaskChange directly as fallback
            if (typeof window.onTaskChange === 'function') {
              window.onTaskChange();
            } else {
              sel.dispatchEvent(new Event('change'));
            }
          })
          .catch(function(e) {
            if (_dbEl) _dbEl.innerHTML += ' <span style="color:#F87171">| Fetch err: ' + e.message + '</span>';
          });
        }
      }, 3000);

    } catch(e) {
      var d = document.getElementById('dbStatus');
      if (d) d.textContent = 'SCRIPT ERROR: ' + e.message;
    }
  </script>

  <!-- =====================================================================
       SHARED MATH HELPERS (used by both SACO 3D and Sphere tabs)
       All computations use the same PDF/CDF arrays as the main charts.
       ===================================================================== -->
  <script>
  (function() {
    'use strict';

    // ── SHARED PLUMBING ────────────────────────────────────────────────────

    /**
     * Trapezoidal integration of pdf points up to tau.
     * Returns F(tau) = ∫_{x_min}^{tau} f(x) dx using the same grid used to render.
     * If tau <= x_min returns 0; if tau >= x_max returns integral over full grid.
     */
    function trapezoidalCDF(pdfPoints, tau) {
      if (!pdfPoints || pdfPoints.length < 2) return null;
      // Clamp negatives to 0 (numerical noise)
      const pts = pdfPoints.map(p => ({ x: p.x, y: Math.max(0, p.y) }));
      const xMin = pts[0].x, xMax = pts[pts.length - 1].x;
      if (!Number.isFinite(tau)) return null;
      if (tau <= xMin) return 0;
      if (tau >= xMax) {
        // Full integral
        let s = 0;
        for (let i = 1; i < pts.length; i++) s += 0.5 * (pts[i].y + pts[i-1].y) * (pts[i].x - pts[i-1].x);
        return Math.min(1, Math.max(0, s));
      }
      // Integrate up to tau with linear interpolation at tau
      let s = 0;
      for (let i = 1; i < pts.length; i++) {
        const x0 = pts[i-1].x, x1 = pts[i].x;
        const y0 = pts[i-1].y, y1 = pts[i].y;
        if (x1 <= tau) {
          s += 0.5 * (y0 + y1) * (x1 - x0);
        } else if (x0 < tau) {
          const t = (tau - x0) / (x1 - x0);
          const yTau = y0 + t * (y1 - y0);
          s += 0.5 * (y0 + yTau) * (tau - x0);
          break;
        } else { break; }
      }
      return Math.min(1, Math.max(0, s));
    }

    /**
     * Total mass: ∫ f(x) dx over all points. Should be ≈ 1.
     */
    function totalMass(pdfPoints) {
      if (!pdfPoints || pdfPoints.length < 2) return null;
      let s = 0;
      for (let i = 1; i < pdfPoints.length; i++) {
        const y0 = Math.max(0, pdfPoints[i-1].y), y1 = Math.max(0, pdfPoints[i].y);
        s += 0.5 * (y0 + y1) * (pdfPoints[i].x - pdfPoints[i-1].x);
      }
      return s;
    }

    /**
     * Compute ∫ Δf dx where Δf = f_current - f_baseline.
     * Should be ≈ 0 (mass-preserving transformation).
     * Uses same x-grid — if grids differ, use f_baseline x-grid.
     */
    function integralDeltaF(basePdf, currentPdf) {
      if (!basePdf || !currentPdf || basePdf.length < 2) return null;
      // Interpolate currentPdf onto basePdf x-grid
      function interpY(pts, x) {
        if (!pts || pts.length < 2) return 0;
        if (x <= pts[0].x) return pts[0].y;
        if (x >= pts[pts.length-1].x) return pts[pts.length-1].y;
        let lo = 0, hi = pts.length - 1;
        while (hi - lo > 1) { const m = (lo + hi) >> 1; if (pts[m].x <= x) lo = m; else hi = m; }
        const t = (x - pts[lo].x) / (pts[hi].x - pts[lo].x);
        return pts[lo].y + t * (pts[hi].y - pts[lo].y);
      }
      let s = 0;
      for (let i = 1; i < basePdf.length; i++) {
        const x0 = basePdf[i-1].x, x1 = basePdf[i].x;
        const d0 = Math.max(0, interpY(currentPdf, x0)) - Math.max(0, basePdf[i-1].y);
        const d1 = Math.max(0, interpY(currentPdf, x1)) - Math.max(0, basePdf[i].y);
        s += 0.5 * (d0 + d1) * (x1 - x0);
      }
      return s;
    }

    /**
     * Produce current PDF from state. Prefers actual optimized arrays, falls back
     * to mass-preserving reweight of baseline using slider-derived weight function.
     *
     * Reweight operator (visualization-only proxy — documented as such):
     *   w(x; s) = exp(-λ * max(0, x - τ))  where λ = m0 * 3 (positive, bounded)
     *   f̃(x) = w(x) * f0(x), then renormalized so ∫f̃ = 1
     * This guarantees f_current >= 0 and ∫f_current = 1 at all times.
     * It is NOT identical to SACO's true reshaping kernel unless optimized arrays are used.
     */
    function getCurrentPdf(S) {
      const overlay = S.overlay || {};
      // Prefer actual optimized distribution arrays from API
      if (overlay.adaptiveOn && S.optPdfAdaptive && S.optPdfAdaptive.length > 1)
        return { pdf: S.optPdfAdaptive, source: 'Guided' };
      if (overlay.fixedOn && S.optPdfFixed && S.optPdfFixed.length > 1)
        return { pdf: S.optPdfFixed, source: 'Optimized' };
      if (overlay.manualOn && S.adjPdf && S.adjPdf.length > 1)
        return { pdf: S.adjPdf, source: 'Explorer' };
      // Fallback: reweight baseline with slider-derived weight
      const basePdf = S.basePdf && S.basePdf.length > 1 ? S.basePdf : null;
      if (!basePdf) return { pdf: null, source: 'None' };
      // Compute moment m0 from current manual sliders
      const KEYS = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
      const WEIGHTS = [-0.20, 0.10, 0.30, -0.15, -0.08, 0.25, 0.05];
      let m0 = 0;
      KEYS.forEach((id, i) => {
        const el = document.getElementById(id);
        const v = el ? Number(el.value) / 100 : 0;
        m0 += WEIGHTS[i] * v;
      });
      m0 = Math.max(-0.5, Math.min(0.5, m0));
      const tau = S.target != null ? S.target : S.M;
      const lambda = m0 * 3;
      // Compute weighted pdf
      const weighted = basePdf.map(p => ({
        x: p.x,
        y: Math.max(0, p.y) * Math.exp(-lambda * Math.max(0, p.x - tau))
      }));
      const mass = totalMass(weighted) || 1;
      const normalized = weighted.map(p => ({ x: p.x, y: p.y / mass }));
      return { pdf: normalized, source: 'Reweighted (proxy)' };
    }

    /**
     * Sanity checks — console.warn if invariants violated.
     */
    function validatePdf(pdf, label) {
      const EPS = 1e-3;
      if (!pdf || pdf.length < 2) return;
      const mass = totalMass(pdf);
      const minY = Math.min(...pdf.map(p => p.y));
      if (Math.abs(mass - 1) > EPS) console.warn('[PMC] ' + label + ' mass violation: ' + mass.toFixed(6));
      if (minY < -1e-9) console.warn('[PMC] ' + label + ' negative density: ' + minY.toExponential(3));
    }

    function validateLift(F0, Fcur, displayedDeltaP) {
      const EPS = 0.002;
      const computed = Fcur - F0;
      if (Math.abs(computed - displayedDeltaP) > EPS)
        console.warn('[PMC] ΔP mismatch: computed=' + computed.toFixed(4) + ' displayed=' + displayedDeltaP.toFixed(4));
    }

    // Expose helpers globally
    window.PMCMath = { trapezoidalCDF, totalMass, integralDeltaF, getCurrentPdf, validatePdf, validateLift };
  })();
  </script>

  <!-- =====================================================================
       SACO 3D PROBABILITY SURFACE — cinematic glass+glow style
       Three.js r134 ribbon-mesh visualization.
       Baseline PDF = translucent ghost; Strategy PDF = glossy Δ-heatmap.
       All probability math (trapNorm, F0/F1, ΔP, ∫Δf) is unchanged.
       ===================================================================== -->
  <script>
  (function() {
    'use strict';

    const SLIDER_KEYS        = ['budgetFlexibility','scheduleFlexibility','scopeCertainty','scopeReductionAllowance','reworkPercentage','riskTolerance','userConfidence'];
    const SLIDER_IDS         = ['s_budget','s_schedule','s_scopeCert','s_scopeRed','s_rework','s_risk','s_userConf'];
    const SLIDER_COLORS      = [0xEF4444, 0xF59E0B, 0x10B981, 0x3B82F6, 0x8B5CF6, 0xEC4899, 0x14B8A6];
    const SLIDER_SHORT_LABELS= ['Budget','Schedule','Scope%','ScopeRed','Rework','Risk','Confidence'];
    const SLIDER_CSS_COLORS  = ['rgba(239,68,68,.95)','rgba(245,158,11,.95)','rgba(16,185,129,.95)','rgba(59,130,246,.95)','rgba(139,92,246,.95)','rgba(236,72,153,.95)','rgba(20,184,166,.95)'];

    // ── MODULE STATE ─────────────────────────────────────────────────────────
    var _renderer = null, _scene = null, _camera = null, _controls = null;
    var _baseGroup = null, _curGroup = null, _tauGroup = null, _heptGroup = null;
    var _animId = null, _initialized = false, _lastW = 0, _lastH = 0;
    var D = 1.8; // scene z-depth (ribbons span z = 0 … D)
    var _ribbonMeta = null; // {xMid, xScale, yMax3} — updated each render, used for annotation projection
    var _otherGroups = []; // ghost ribbon groups for non-primary active strategies

    // ── MATH HELPERS (unchanged) ──────────────────────────────────────────────
    function fmtPct(v) { return (v != null && isFinite(v)) ? (v*100).toFixed(2)+'%' : '–'; }

    function interpY(pts, x) {
      if (!pts || pts.length < 2) return 0;
      if (x <= pts[0].x) return pts[0].y;
      if (x >= pts[pts.length-1].x) return pts[pts.length-1].y;
      var lo = 0, hi = pts.length - 1;
      while (hi - lo > 1) { var m = (lo + hi) >> 1; if (pts[m].x <= x) lo = m; else hi = m; }
      var t = (x - pts[lo].x) / (pts[hi].x - pts[lo].x);
      return pts[lo].y + t * (pts[hi].y - pts[lo].y);
    }

    function trapNorm(pts) {
      if (!pts || pts.length < 2) return pts || [];
      var clamped = [];
      for (var i = 0; i < pts.length; i++) clamped.push({ x: pts[i].x, y: Math.max(0, pts[i].y) });
      var mass = 0;
      for (var j = 1; j < clamped.length; j++)
        mass += 0.5 * (clamped[j-1].y + clamped[j].y) * (clamped[j].x - clamped[j-1].x);
      if (mass <= 0) return clamped;
      var out = [];
      for (var k = 0; k < clamped.length; k++) out.push({ x: clamped[k].x, y: clamped[k].y / mass });
      return out;
    }

    // ── VISUAL HELPERS ────────────────────────────────────────────────────────

    // 1-D smoothing kernel [0.25, 0.5, 0.25] — reduces Δf banding artifacts.
    function smoothDelta(arr) {
      var out = arr.slice();
      for (var i = 1; i < arr.length - 1; i++)
        out[i] = 0.25 * arr[i-1] + 0.50 * arr[i] + 0.25 * arr[i+1];
      return out;
    }

    // Diverging palette: negative = cyan/blue, zero = near-white/pale-teal,
    // positive = yellow/orange/red.
    function deltaColor(df, maxDelta) {
      var t = maxDelta > 0 ? Math.max(-1, Math.min(1, df / maxDelta)) : 0;
      if (t > 0) {
        if (t <= 0.5) { var u = t * 2;
          return { r: 0.90 + 0.10*u, g: 0.92 - 0.12*u, b: 0.88 - 0.78*u }; // pale-teal → yellow
        } else { var u = (t-0.5)*2;
          return { r: 1.0, g: 0.80 - 0.65*u, b: 0.10 - 0.10*u }; }        // yellow → orange → red
      } else if (t < 0) {
        var u = -t;
        if (u <= 0.5) { var v = u * 2;
          return { r: 0.90 - 0.60*v, g: 0.92 - 0.02*v, b: 0.88 + 0.12*v }; // pale-teal → cyan
        } else { var v = (u-0.5)*2;
          return { r: 0.30 - 0.20*v, g: 0.90 - 0.55*v, b: 1.0 }; }         // cyan → blue
      }
      return { r: 0.90, g: 0.95, b: 0.92 }; // near-white pale-teal at zero
    }

    // Render text to canvas → THREE.Sprite.
    function makeTextSprite(text, opts) {
      opts = opts || {};
      var W = opts.w || 192, H = opts.h || 52;
      var canvas = document.createElement('canvas');
      canvas.width = W; canvas.height = H;
      var ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = opts.color || 'rgba(255,176,64,0.95)';
      ctx.font = (opts.bold ? 'bold ' : '') + (opts.size || 24) + 'px ui-monospace,-apple-system,sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(text, W/2, H/2);
      var tex = new THREE.CanvasTexture(canvas);
      var sp  = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false }));
      sp.scale.set(opts.sx || W/38, opts.sy || H/38, 1);
      return sp;
    }

    // Build a 3D ribbon group that spans z = zFront … zBack.
    // Returns a THREE.Group containing the PBR surface mesh + silhouette edge lines.
    // colorFn(i) → {r,g,b} applied per x-sample (same at front & back).
    function buildRibbonGroup(pdf, xScale, xMid, yScale, zFront, zBack, colorFn, mOpts) {
      var grp = new THREE.Group();
      if (!pdf || pdf.length < 2) return grp;
      mOpts = mOpts || {};
      var n = pdf.length;
      // Vertex blocks:  [0..2n-1] top (front, back interleaved)
      //                 [2n..4n-1] bottom (front, back interleaved)
      var nV = n * 4;
      var pos = new Float32Array(nV * 3);
      var col = new Float32Array(nV * 3);
      var idx = [];

      for (var i = 0; i < n; i++) {
        var xi = (pdf[i].x - xMid) * xScale;
        var yi = Math.max(0, pdf[i].y) * yScale;
        var ci = colorFn(i);
        var dim = { r: ci.r*0.45, g: ci.g*0.45, b: ci.b*0.45 };
        // top-front (2i), top-back (2i+1)
        pos[(2*i)*3]   = xi; pos[(2*i)*3+1]   = yi; pos[(2*i)*3+2]   = zFront;
        col[(2*i)*3]   = ci.r; col[(2*i)*3+1]   = ci.g; col[(2*i)*3+2]   = ci.b;
        pos[(2*i+1)*3] = xi; pos[(2*i+1)*3+1] = yi; pos[(2*i+1)*3+2] = zBack;
        col[(2*i+1)*3] = ci.r; col[(2*i+1)*3+1] = ci.g; col[(2*i+1)*3+2] = ci.b;
        // bot-front (2n+2i), bot-back (2n+2i+1)
        pos[(2*n+2*i)*3]   = xi; pos[(2*n+2*i)*3+1]   = 0; pos[(2*n+2*i)*3+2]   = zFront;
        col[(2*n+2*i)*3]   = dim.r; col[(2*n+2*i)*3+1]   = dim.g; col[(2*n+2*i)*3+2]   = dim.b;
        pos[(2*n+2*i+1)*3] = xi; pos[(2*n+2*i+1)*3+1] = 0; pos[(2*n+2*i+1)*3+2] = zBack;
        col[(2*n+2*i+1)*3] = dim.r; col[(2*n+2*i+1)*3+1] = dim.g; col[(2*n+2*i+1)*3+2] = dim.b;
      }
      // Top surface
      for (var i = 0; i < n-1; i++) {
        var tf=2*i, tb=2*i+1, tf1=2*(i+1), tb1=2*(i+1)+1;
        idx.push(tf,tb,tf1); idx.push(tb,tb1,tf1);
      }
      // Front face (z=zFront, y goes 0→curve)
      for (var i = 0; i < n-1; i++) {
        var tf=2*i, tf1=2*(i+1), bf=2*n+2*i, bf1=2*n+2*(i+1);
        idx.push(tf,bf,tf1); idx.push(bf,bf1,tf1);
      }
      // Back face (z=zBack)
      for (var i = 0; i < n-1; i++) {
        var tb=2*i+1, tb1=2*(i+1)+1, bb=2*n+2*i+1, bb1=2*n+2*(i+1)+1;
        idx.push(tb,tb1,bb); idx.push(tb1,bb1,bb);
      }

      var geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geo.setAttribute('color',    new THREE.BufferAttribute(col, 3));
      geo.setIndex(idx);
      geo.computeVertexNormals();

      var matCfg = {
        vertexColors: !mOpts.uniformColor,
        transparent: true, opacity: mOpts.opacity !== undefined ? mOpts.opacity : 0.88,
        side: THREE.DoubleSide, depthWrite: false,
        metalness: mOpts.metalness !== undefined ? mOpts.metalness : 0.08,
        roughness: mOpts.roughness !== undefined ? mOpts.roughness : 0.32,
        clearcoat: mOpts.clearcoat !== undefined ? mOpts.clearcoat : 0.75,
        clearcoatRoughness: mOpts.ccRough !== undefined ? mOpts.ccRough : 0.18
      };
      if (mOpts.uniformColor) { matCfg.color = mOpts.uniformColor; }
      grp.add(new THREE.Mesh(geo, new THREE.MeshPhysicalMaterial(matCfg)));

      // Silhouette: trace front-curve → back-curve loop
      var edgePts = [];
      for (var i = 0; i < n; i++)
        edgePts.push(new THREE.Vector3((pdf[i].x-xMid)*xScale, Math.max(0,pdf[i].y)*yScale, zFront));
      for (var i = n-1; i >= 0; i--)
        edgePts.push(new THREE.Vector3((pdf[i].x-xMid)*xScale, Math.max(0,pdf[i].y)*yScale, zBack));
      edgePts.push(edgePts[0].clone());
      grp.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(edgePts),
        new THREE.LineBasicMaterial({
          color: mOpts.edgeColor || 0x88ccff, transparent: true,
          opacity: mOpts.edgeOpacity !== undefined ? mOpts.edgeOpacity : 0.35, depthWrite: false
        })));
      return grp;
    }

    // ── INITIALIZATION ────────────────────────────────────────────────────────
    function initThree(container) {
      if (_initialized) return;
      container.innerHTML = '';
      container.style.background  = '#F0F4FA';
      container.style.borderColor = 'rgba(140,170,220,0.40)';
      container.style.boxShadow   = 'inset 0 0 10px rgba(160,180,220,0.12)';

      var w = Math.max(container.clientWidth || 400, 200);
      var h = Math.max(container.clientHeight || 310, 200);
      _lastW = w; _lastH = h;

      _scene = new THREE.Scene();
      _scene.background = new THREE.Color(0xF0F4FA); // light blue-gray

      // ── Cinematic camera ─────────────────────────────────────────────────
      _camera = new THREE.PerspectiveCamera(40, w / h, 0.05, 200);
      _camera.position.set(-2.5, 7.0, 16);
      _camera.lookAt(0, 1.8, D / 2);

      _renderer = new THREE.WebGLRenderer({ antialias: true });
      _renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      _renderer.setSize(w, h);
      _renderer.domElement.style.cssText = 'display:block;width:100%;height:100%;';
      container.appendChild(_renderer.domElement);

      // ── 3-point lighting (tuned for light background) ────────────────────
      _scene.add(new THREE.AmbientLight(0xdce8f8, 0.55));           // soft blue-white ambient
      var key = new THREE.DirectionalLight(0xfff5e0, 0.90);         // key: warm, front-top-left
      key.position.set(-5, 9, 7); _scene.add(key);
      var fill = new THREE.DirectionalLight(0xc8d8ff, 0.40);        // fill: cool, front-top-right
      fill.position.set(5, 6, 5); _scene.add(fill);
      var rim = new THREE.DirectionalLight(0x8090c8, 0.35);         // rim: muted blue, from behind
      rim.position.set(0, 5, -10); _scene.add(rim);

      // ── OrbitControls ────────────────────────────────────────────────────
      if (typeof THREE.OrbitControls !== 'undefined') {
        _controls = new THREE.OrbitControls(_camera, _renderer.domElement);
        _controls.enableDamping = true;
        _controls.dampingFactor = 0.07;
        _controls.minDistance = 4; _controls.maxDistance = 40;
        _controls.target.set(0, 1.8, D / 2);
        _controls.autoRotate = false;
        _controls.autoRotateSpeed = 0.4;
        _controls.update();
      }

      // ── Subtle light grid ────────────────────────────────────────────────
      var grid = new THREE.GridHelper(16, 32, 0xb8c8d8, 0xd0dae4);
      grid.position.set(0, -0.01, D / 2);
      _scene.add(grid);

      // ── Faint axis lines ─────────────────────────────────────────────────
      var axMat = new THREE.LineBasicMaterial({ color: 0x8898b8, transparent: true, opacity: 0.55 });
      _scene.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-5.5,0,0), new THREE.Vector3(5.5,0,0)]), axMat));
      _scene.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,4.2,0)]), axMat));

      // ── Legend + annotation overlays ─────────────────────────────────────
      _injectLegend(container);
      _injectAnnotations(container);

      _initialized = true;
      _startLoop();
    }

    function _injectLegend(container) {
      // Inject the legend INSIDE the 3D canvas container so it overlays the scene
      var ex = container.querySelector('.saco3d-leg'); if (ex) ex.remove();
      var leg = document.createElement('div');
      leg.className = 'saco3d-leg';
      leg.style.cssText = [
        'position:absolute;bottom:8px;left:8px;z-index:3;',
        'background:rgba(255,255,255,0.90);border:1px solid rgba(160,180,220,0.55);',
        'border-radius:7px;padding:5px 9px;font-size:9.5px;',
        'font-family:ui-monospace,monospace;color:#374151;',
        'line-height:1.75;pointer-events:none;backdrop-filter:blur(4px);',
        'box-shadow:0 2px 8px rgba(120,140,180,0.15);'
      ].join('');
      leg.innerHTML = [
        // Heatmap gradient with directional labels
        '<div style="font-weight:800;font-size:8.5px;letter-spacing:.06em;color:#6b7280;margin-bottom:4px;">LEGEND</div>',
        '<div style="margin-bottom:5px;">',
        '  <div style="display:flex;justify-content:space-between;font-size:8px;color:#6b7280;margin-bottom:1px;">',
        '    <span>mass removed</span><span>neutral</span><span>mass added</span></div>',
        '  <div style="width:110px;height:8px;border-radius:3px;',
        '    background:linear-gradient(90deg,#38bdf8 0%,#818cf8 30%,#e2e8f0 50%,#fbbf24 70%,#ef4444 100%);',
        '    border:1px solid rgba(100,120,160,0.25);"></div>',
        '  <div style="font-size:8px;color:#6b7280;margin-top:1px;">\u0394 heatmap on strategy ribbon</div>',
        '</div>',
        '<div style="display:flex;align-items:center;gap:5px;">',
        '  <span style="width:22px;height:6px;border-radius:2px;display:inline-block;',
        '    background:rgba(80,160,255,0.45);border:1px solid rgba(80,160,255,0.5);"></span>',
        '  <span>Strategy ribbon</span></div>',
        '<div style="display:flex;align-items:center;gap:5px;">',
        '  <span style="width:22px;height:6px;border-radius:2px;display:inline-block;',
        '    background:rgba(140,180,220,0.22);border:1px solid rgba(140,180,220,0.28);"></span>',
        '  <span>Baseline f\u2080(x)</span></div>',
        '<div style="display:flex;align-items:center;gap:5px;margin-top:2px;">',
        '  <span style="width:22px;height:6px;border-radius:2px;display:inline-block;',
        '    background:rgba(255,176,64,0.55);border:1px solid rgba(255,176,64,0.80);"></span>',
        '  <span>\u03c4 target plane</span></div>'
      ].join('');
      container.style.position = 'relative'; // ensure absolute children are relative to canvas
      container.appendChild(leg);
    }

    // ── ANNOTATION OVERLAY ────────────────────────────────────────────────────
    var _ANN_DEFS = [
      { id: 'saco-ann-base',    col: '#475569', bg: 'rgba(241,245,249,0.94)', brd: 'rgba(148,163,184,0.60)' },
      { id: 'saco-ann-guided',  col: '#5b21b6', bg: 'rgba(139,92,246,0.13)',  brd: 'rgba(139,92,246,0.60)' },
      { id: 'saco-ann-opt',     col: '#1e40af', bg: 'rgba(59,130,246,0.13)',   brd: 'rgba(59,130,246,0.60)'  },
      { id: 'saco-ann-exp',     col: '#065f46', bg: 'rgba(16,185,129,0.13)',  brd: 'rgba(16,185,129,0.60)' }
    ];
    function _injectAnnotations(container) {
      var ex = container.querySelector('.saco3d-ann'); if (ex) ex.remove();
      var ann = document.createElement('div');
      ann.className = 'saco3d-ann';
      ann.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:4;overflow:hidden;';
      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('id', 'saco3d-ann-svg');
      svg.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;overflow:visible;';
      ann.appendChild(svg);
      _ANN_DEFS.forEach(function(d) {
        var el = document.createElement('div');
        el.id = d.id;
        el.style.cssText = [
          'display:none;position:absolute;padding:3px 8px;border-radius:6px;',
          'font-size:10px;font-family:ui-monospace,monospace;font-weight:700;white-space:nowrap;',
          'background:' + d.bg + ';color:' + d.col + ';border:1px solid ' + d.brd + ';',
          'box-shadow:0 1px 6px rgba(0,0,0,0.14);backdrop-filter:blur(4px);'
        ].join('');
        ann.appendChild(el);
      });
      container.appendChild(ann);
    }

    function _updateAnnotations() {
      if (!_camera || !_ribbonMeta) return;
      var S = window.S; if (!S) return;
      var container = document.getElementById('saco3dContainer');
      if (!container) return;
      var tau = (S.target != null) ? Number(S.target) : null;
      var ov = S.overlay || {};
      var anyActive = ov.adaptiveOn || ov.fixedOn || ov.manualOn;
      var annDiv = container.querySelector('.saco3d-ann');
      if (!annDiv) return;

      // Hide all when nothing to show
      if (tau == null || !isFinite(tau) || !anyActive) {
        _ANN_DEFS.forEach(function(d) {
          var el = document.getElementById(d.id); if (el) el.style.display = 'none';
        });
        var svgEl = document.getElementById('saco3d-ann-svg');
        if (svgEl) svgEl.innerHTML = '';
        return;
      }

      var meta = _ribbonMeta;
      var w = container.clientWidth, h = container.clientHeight;

      // Project τ mid-height point to screen coordinates
      var xTau3d = (tau - meta.xMid) * meta.xScale;
      var v3 = new THREE.Vector3(xTau3d, meta.yMax3 * 0.35, D / 2);
      v3.project(_camera);
      var tauSx = (v3.x + 1) / 2 * w;
      var tauSy = (-v3.y + 1) / 2 * h;

      // Draw dashed τ guide line in SVG overlay
      var svgEl = document.getElementById('saco3d-ann-svg');
      if (svgEl) {
        svgEl.setAttribute('width', w); svgEl.setAttribute('height', h);
        var tx = tauSx.toFixed(1);
        svgEl.innerHTML =
          '<line x1="' + tx + '" y1="0" x2="' + tx + '" y2="' + h + '" ' +
          'stroke="rgba(245,158,11,0.40)" stroke-width="1" stroke-dasharray="4,4"/>';
      }

      // Place annotation cards right of τ (or left if τ is past 60% width)
      var placeRight = tauSx < w * 0.58;
      var P0 = S.baselineProb;
      var stratDefs = [
        { def: _ANN_DEFS[0], label: 'Baseline',   prob: P0,              show: true            },
        { def: _ANN_DEFS[1], label: 'Guided',     prob: S.adaptiveProb,  show: ov.adaptiveOn   },
        { def: _ANN_DEFS[2], label: 'Optimized',  prob: S.optimizedProb, show: ov.fixedOn      },
        { def: _ANN_DEFS[3], label: 'Explorer',   prob: S.adjustedProb,  show: ov.manualOn     }
      ];

      var topY = Math.max(6, Math.min(tauSy - 52, h - 108));
      var gap = 10;
      stratDefs.forEach(function(sd) {
        var el = document.getElementById(sd.def.id);
        if (!el) return;
        if (!sd.show || sd.prob == null || !isFinite(sd.prob)) { el.style.display = 'none'; return; }
        var pPct = (sd.prob * 100).toFixed(1) + '%';
        var txt = sd.label + ':  P = ' + pPct;
        if (sd.def.id !== 'saco-ann-base' && P0 != null && isFinite(P0)) {
          var dp = (sd.prob - P0) * 100;
          txt += '   ΔP ' + (dp >= 0 ? '+' : '') + dp.toFixed(1) + '%';
        }
        el.textContent = txt;
        el.style.top = topY + 'px';
        el.style.display = 'block';
        if (placeRight) { el.style.left = (tauSx + gap) + 'px'; el.style.right = ''; }
        else            { el.style.left = ''; el.style.right = (w - tauSx + gap) + 'px'; }
        topY += 26;
      });
    }

    function _startLoop() {
      if (_animId) return;
      function loop() {
        _animId = requestAnimationFrame(loop);
        if (_controls) _controls.update();
        if (_renderer && _scene && _camera) _renderer.render(_scene, _camera);
        _updateAnnotations();
      }
      loop();
    }

    // ── SCENE OBJECT MANAGEMENT ───────────────────────────────────────────────
    function _clearGroup(grp) {
      if (!grp || !_scene) return null;
      _scene.remove(grp);
      grp.traverse(function(o) {
        if (o.geometry) o.geometry.dispose();
        if (o.material) {
          (Array.isArray(o.material) ? o.material : [o.material]).forEach(function(m) {
            if (m.map) m.map.dispose();
            m.dispose();
          });
        }
      });
      return null;
    }

    // ── UPDATE RIBBONS ────────────────────────────────────────────────────────
    // basePdfN and curPdfN are already trapNorm-normalized on the same x-grid.
    // F0 and Fcur are passed in to drive the data-driven lift band.
    // nonPrimStrats: [{pdfN, prob, label, hex}] for non-primary active strategies.
    // sourceLabel: display name of the primary strategy (e.g. "Guided (Level 3)").
    function updateRibbons(basePdfN, curPdfN, tau, F0, Fcur, stratColorHex, nonPrimStrats, sourceLabel) {
      if (!_scene) return;
      _baseGroup = _clearGroup(_baseGroup);
      _curGroup  = _clearGroup(_curGroup);
      _tauGroup  = _clearGroup(_tauGroup);
      // Clear non-primary ghost ribbons from previous render
      for (var ogi = 0; ogi < _otherGroups.length; ogi++) { _clearGroup(_otherGroups[ogi]); }
      _otherGroups = [];
      if (!basePdfN || basePdfN.length < 2) return;

      // ── Coordinate transform ──────────────────────────────────────────────
      var xMin = basePdfN[0].x, xMax = basePdfN[basePdfN.length-1].x;
      var xRange = (xMax - xMin) || 1;
      var yMaxVal = 0.001;
      for (var pi = 0; pi < basePdfN.length; pi++)
        if (basePdfN[pi].y > yMaxVal) yMaxVal = basePdfN[pi].y;
      if (curPdfN) for (var pi2 = 0; pi2 < curPdfN.length; pi2++)
        if (curPdfN[pi2].y > yMaxVal) yMaxVal = curPdfN[pi2].y;
      // Include non-primary PDFs in yMaxVal so they're not clipped
      if (nonPrimStrats) nonPrimStrats.forEach(function(os) {
        if (os.pdfN) for (var pj = 0; pj < os.pdfN.length; pj++)
          if (os.pdfN[pj].y > yMaxVal) yMaxVal = os.pdfN[pj].y;
      });
      var xScale = 10 / xRange;
      var yScale = 3.2 / yMaxVal;
      var xMid   = (xMin + xMax) / 2;
      var yMax3  = yMaxVal * yScale; // scene-unit height
      _ribbonMeta = { xMid: xMid, xScale: xScale, yMax3: yMax3 };

      // ── Flat brand-color components for primary strategy ribbon ──────────
      var _sHex = stratColorHex != null ? stratColorHex : 0x3b82f6;
      var _sRc = ((_sHex >> 16) & 0xff) / 255;
      var _sGc = ((_sHex >>  8) & 0xff) / 255;
      var _sBc = ( _sHex        & 0xff) / 255;

      // ── Baseline reference mesh (lightest — background anchor) ───────────
      _baseGroup = buildRibbonGroup(
        basePdfN, xScale, xMid, yScale, 0, D,
        function() { return { r: 0.60, g: 0.72, b: 0.88 }; },
        { uniformColor: 0x8aaece, opacity: 0.28, roughness: 0.55, metalness: 0.0,
          clearcoat: 0.10, ccRough: 0.40, edgeColor: 0x4470a8, edgeOpacity: 0.55 }
      );
      _scene.add(_baseGroup);

      // ── Primary strategy mesh: flat brand color, overlaid on baseline ─────
      if (curPdfN) {
        _curGroup = buildRibbonGroup(
          curPdfN, xScale, xMid, yScale, 0, D,
          function() { return { r: _sRc, g: _sGc, b: _sBc }; },
          { opacity: 0.50, roughness: 0.35, metalness: 0.05,
            clearcoat: 0.40, ccRough: 0.22, edgeColor: _sHex, edgeOpacity: 0.72 }
        );
        _scene.add(_curGroup);
      }

      // ── Non-primary strategy meshes: flat brand color, lightest overlay ───
      if (nonPrimStrats && nonPrimStrats.length > 0) {
        nonPrimStrats.forEach(function(os) {
          var hr = (os.hex >> 16) & 0xff, hg = (os.hex >> 8) & 0xff, hb = os.hex & 0xff;
          var osGrp = buildRibbonGroup(
            os.pdfN, xScale, xMid, yScale, 0, D,
            function() { return { r: hr / 255, g: hg / 255, b: hb / 255 }; },
            { opacity: 0.34, roughness: 0.45, metalness: 0.0,
              clearcoat: 0.10, ccRough: 0.35, edgeColor: os.hex, edgeOpacity: 0.58 }
          );
          _scene.add(osGrp);
          _otherGroups.push(osGrp);
        });
      }

      // ── Glass τ-plane with framed edges + lift band ───────────────────────
      if (tau != null && isFinite(tau)) {
        var xTau = (tau - xMid) * xScale;
        _tauGroup = new THREE.Group();

        // Glass panel (PlaneGeometry width=D, height=yMax3*1.18; rotated to face X-axis)
        var panH = yMax3 * 1.18;
        var pGeo = new THREE.PlaneGeometry(D, panH);
        var pMat = new THREE.MeshPhysicalMaterial({
          color: 0xffe0a0, transparent: true, opacity: 0.17,
          metalness: 0.0, roughness: 0.06, side: THREE.DoubleSide, depthWrite: false
        });
        var pMesh = new THREE.Mesh(pGeo, pMat);
        pMesh.rotation.y = Math.PI / 2;
        pMesh.position.set(xTau, panH / 2, D / 2);
        _tauGroup.add(pMesh);

        // Glowing amber frame using EdgesGeometry
        var eGeo = new THREE.EdgesGeometry(pGeo);
        var eMat = new THREE.LineBasicMaterial({ color: 0xffb040, transparent: true, opacity: 0.92 });
        var eLines = new THREE.LineSegments(eGeo, eMat);
        eLines.rotation.copy(pMesh.rotation);
        eLines.position.copy(pMesh.position);
        _tauGroup.add(eLines);

        // Ground cross-line
        _tauGroup.add(new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(xTau,0,0), new THREE.Vector3(xTau,0,D)]),
          new THREE.LineBasicMaterial({ color: 0xffb040, transparent: true, opacity: 0.55 })));

        // "τ" label sprite
        var sp = makeTextSprite('τ target', { color:'rgba(255,176,64,0.95)', bold:true, size:20, w:180, h:48, sx:2.0, sy:0.50 });
        sp.position.set(xTau, panH * 0.98, D / 2);
        _tauGroup.add(sp);

        // ── Data-driven lift band: shows F0 → F1 on the τ-plane ─────────
        if (F0 != null && Fcur != null && Math.abs(Fcur - F0) > 0.002) {
          var yF0  = F0  * yMax3;
          var yF1  = Fcur * yMax3;
          var yLo  = Math.min(yF0, yF1), yHi = Math.max(yF0, yF1);
          var dP   = Fcur - F0;
          var bCol = dP > 0 ? 0x38e080 : 0xff4466;

          // Outline of the band rectangle
          _tauGroup.add(new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(xTau,yLo,0),   new THREE.Vector3(xTau,yLo,D),
              new THREE.Vector3(xTau,yHi,D),   new THREE.Vector3(xTau,yHi,0),
              new THREE.Vector3(xTau,yLo,0)]),
            new THREE.LineBasicMaterial({ color: bCol, transparent: true, opacity: 0.90 })));

          // Translucent fill
          var bv = new Float32Array([
            xTau,yLo,0,  xTau,yLo,D,  xTau,yHi,0,
            xTau,yLo,D,  xTau,yHi,D,  xTau,yHi,0
          ]);
          var bGeo = new THREE.BufferGeometry();
          bGeo.setAttribute('position', new THREE.BufferAttribute(bv, 3));
          _tauGroup.add(new THREE.Mesh(bGeo,
            new THREE.MeshBasicMaterial({ color: bCol, transparent: true, opacity: 0.20,
              side: THREE.DoubleSide, depthWrite: false })));

          // ΔP label on the band
          var dpSp = makeTextSprite(
            (dP > 0 ? '+' : '') + (dP*100).toFixed(1) + '%',
            { color: dP > 0 ? 'rgba(56,224,128,0.96)' : 'rgba(255,68,102,0.96)',
              bold: true, size: 19, w: 176, h: 46, sx: 1.7, sy: 0.44 });
          dpSp.position.set(xTau + 0.40, (yLo + yHi) / 2, D / 2);
          _tauGroup.add(dpSp);
        }

        // ── τ-surface markers: needle + dot on each ribbon at x=τ ────────────
        var _sCol = (stratColorHex != null) ? stratColorHex : 0x3b82f6;

        function hexColToRgba(hex, a) {
          var r = (hex >> 16) & 0xff, g = (hex >> 8) & 0xff, b = hex & 0xff;
          return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }

        function _addNeedle(x, yTop, zPos, hexCol, label, offsetX) {
          if (yTop < 0.01) return;
          // Thin cylinder rising from ground to ribbon surface
          var needle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.030, 0.030, yTop, 8),
            new THREE.MeshBasicMaterial({ color: hexCol, transparent: true, opacity: 0.82 })
          );
          needle.position.set(x, yTop / 2, zPos);
          _tauGroup.add(needle);
          // Glowing sphere at ribbon surface
          var dot = new THREE.Mesh(
            new THREE.SphereGeometry(0.12, 16, 16),
            new THREE.MeshBasicMaterial({ color: hexCol, transparent: true, opacity: 0.96 })
          );
          dot.position.set(x, yTop + 0.07, zPos);
          _tauGroup.add(dot);
          // Text label
          if (label) {
            var sp2 = makeTextSprite(label, {
              color: hexColToRgba(hexCol, 0.96), bold: true,
              size: 16, w: 150, h: 40, sx: 1.5, sy: 0.42
            });
            sp2.position.set(x + offsetX, yTop + 0.32, zPos);
            _tauGroup.add(sp2);
          }
        }

        // Baseline needle (gray-blue, left-offset label)
        var yBaseAtTau = interpY(basePdfN, tau) * yScale;
        _addNeedle(xTau, yBaseAtTau, D / 2, 0x7090b8,
          F0 != null ? 'P\u2080 = ' + (F0 * 100).toFixed(1) + '%' : null,
          -0.65);

        // Primary strategy needle (matches strategy color, right-offset label)
        if (curPdfN) {
          var yCurAtTau = interpY(curPdfN, tau) * yScale;
          var _primShort = (sourceLabel || '').replace(/\s.*/, ''); // first word only
          _addNeedle(xTau, yCurAtTau, D / 2, _sCol,
            Fcur != null ? (_primShort ? _primShort + '\u202fP\u202f=\u202f' : 'P\u202f=\u202f') + (Fcur * 100).toFixed(1) + '%' : null,
            0.55);
        }

        // Non-primary strategy needles — z-staggered so labels don't overlap
        if (nonPrimStrats && nonPrimStrats.length > 0) {
          var _nps = nonPrimStrats.length;
          nonPrimStrats.forEach(function(os, idx) {
            // Spread z positions across the ribbon depth, away from center (D/2)
            var zOff = _nps === 1 ? D * 0.20
                     : D * (0.12 + idx * 0.76 / Math.max(1, _nps - 1));
            var yOsAtTau = interpY(os.pdfN, tau) * yScale;
            _addNeedle(xTau, yOsAtTau, zOff, os.hex,
              os.prob != null ? os.label + '\u202fP\u202f=\u202f' + (os.prob * 100).toFixed(1) + '%' : null,
              0.55);
          });
        }

        // ── Probability level markers on the τ-plane ──────────────────────────
        // Horizontal lines at y = P * yMax3 for each strategy, one per "plane".
        // Together with the vertical τ-plane they form a 3D (target, probability)
        // coordinate that visually answers "target = where? probability = how much?".
        function _addProbLine(yPl, col, labelTxt, xSide, zPos) {
          // Full-width horizontal line at height yPl spanning z=0..D
          _tauGroup.add(new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(xTau, yPl, 0),
              new THREE.Vector3(xTau, yPl, D)
            ]),
            new THREE.LineBasicMaterial({ color: col, transparent: true, opacity: 0.82 })
          ));
          // Small diamond dot at the z midpoint
          var dd = new THREE.Mesh(
            new THREE.SphereGeometry(0.07, 8, 8),
            new THREE.MeshBasicMaterial({ color: col, transparent: true, opacity: 0.95 })
          );
          dd.position.set(xTau, yPl, D / 2);
          _tauGroup.add(dd);
          // Label offset to the side of the τ-plane
          if (labelTxt) {
            var lSp = makeTextSprite(labelTxt, {
              color: hexColToRgba(col, 0.96), bold: true, size: 14, w: 148, h: 36
            });
            lSp.position.set(xTau + xSide, yPl + 0.09, zPos);
            _tauGroup.add(lSp);
          }
        }

        // Baseline probability line (left side, gray-blue)
        if (F0 != null && isFinite(F0)) {
          _addProbLine(F0 * yMax3, 0x7090b8,
            'Base\u202f' + (F0 * 100).toFixed(1) + '%', -0.55, D / 2);
        }
        // Primary strategy probability line (right side, strategy color)
        if (Fcur != null && isFinite(Fcur) && curPdfN) {
          var _ps = (sourceLabel || '').replace(/\s.*/, '') || 'P';
          _addProbLine(Fcur * yMax3, _sCol,
            _ps + '\u202f' + (Fcur * 100).toFixed(1) + '%', 0.52, D / 2);
        }
        // Non-primary strategy probability lines (right side, staggered z label)
        if (nonPrimStrats && nonPrimStrats.length > 0) {
          nonPrimStrats.forEach(function(os, idx) {
            if (os.prob == null || !isFinite(os.prob)) return;
            var zLbl = nonPrimStrats.length === 1 ? D * 0.20
                     : D * (0.12 + idx * 0.76 / Math.max(1, nonPrimStrats.length - 1));
            _addProbLine(os.prob * yMax3, os.hex,
              os.label + '\u202f' + (os.prob * 100).toFixed(1) + '%', 0.52, zLbl);
          });
        }

        _scene.add(_tauGroup);
      }
    }

    // ── HEPTAGON RING (dark-theme variant) ────────────────────────────────────
    function updateHeptagon() {
      if (!_scene) return;
      _heptGroup = _clearGroup(_heptGroup);
      _heptGroup = new THREE.Group();
      var N = 7, R_MAX = 2.3, Y_RING = -0.60;
      var vals = SLIDER_KEYS.map(function(k, i) {
        var el = document.getElementById(SLIDER_IDS[i]);
        return el ? Math.max(0, Math.min(100, Number(el.value))) / 100 : 0;
      });
      var pts = vals.map(function(v, k) {
        var th = (2 * Math.PI * k / N) - Math.PI / 2;
        return new THREE.Vector3(R_MAX*v*Math.cos(th), Y_RING, R_MAX*v*Math.sin(th) + D/2);
      });
      var circPts = [];
      for (var ci = 0; ci <= 72; ci++) {
        var a = (2 * Math.PI * ci / 72) - Math.PI / 2;
        circPts.push(new THREE.Vector3(R_MAX*Math.cos(a), Y_RING, R_MAX*Math.sin(a) + D/2));
      }
      _heptGroup.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(circPts),
        new THREE.LineBasicMaterial({ color: 0x90a8c8, transparent: true, opacity: 0.55 })));
      var ctr = new THREE.Vector3(0, Y_RING, D/2);
      for (var k = 0; k < N; k++) {
        _heptGroup.add(new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([ctr.clone(), pts[k].clone()]),
          new THREE.LineBasicMaterial({ color: 0x8898b8, transparent: true, opacity: 0.45 })));
        _heptGroup.add(new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([pts[k].clone(), pts[(k+1)%N].clone()]),
          new THREE.LineBasicMaterial({ color: 0x6888b8, transparent: true, opacity: 0.65 })));
        var dot = new THREE.Mesh(
          new THREE.SphereGeometry(0.10, 10, 10),
          new THREE.MeshBasicMaterial({ color: SLIDER_COLORS[k] }));
        dot.position.copy(pts[k]);
        _heptGroup.add(dot);

        // Label sprite: name + value% at fixed outer ring position
        var th_k = (2 * Math.PI * k / N) - Math.PI / 2;
        var pct_k = Math.round(vals[k] * 100);
        var lspTxt = SLIDER_SHORT_LABELS[k] + '\n' + pct_k + '%';
        var lsp = makeTextSprite(SLIDER_SHORT_LABELS[k] + ' ' + pct_k + '%', {
          color: SLIDER_CSS_COLORS[k], bold: false, size: 11, w: 104, h: 30, sx: 1.6, sy: 0.44
        });
        var lR = R_MAX * 1.22;
        lsp.position.set(lR * Math.cos(th_k), Y_RING + 0.32, lR * Math.sin(th_k) + D / 2);
        _heptGroup.add(lsp);
      }
      var cDot = new THREE.Mesh(new THREE.SphereGeometry(0.07,8,8),
        new THREE.MeshBasicMaterial({ color: 0x6888b8 }));
      cDot.position.set(0, Y_RING, D/2);
      _heptGroup.add(cDot);
      _scene.add(_heptGroup);
    }

    // ── HUD (math unchanged) ──────────────────────────────────────────────────
    function updateHUD(F0, Fcur, basePdf, curPdf) {
      var M = window.PMCMath;
      var dP = (F0 != null && Fcur != null) ? Fcur - F0 : null;
      var intDelta = (basePdf && curPdf && M) ? M.integralDeltaF(basePdf, curPdf) : null;
      var f0El = document.getElementById('hudF0');
      var fEl  = document.getElementById('hudF');
      var dpEl = document.getElementById('hudDeltaP');
      var idEl = document.getElementById('hudIntDelta');
      if (f0El) f0El.textContent = fmtPct(F0);
      if (fEl)  fEl.textContent  = fmtPct(Fcur);
      if (dpEl) {
        dpEl.textContent = dP != null ? (dP >= 0 ? '+' : '') + fmtPct(dP) : '–';
        dpEl.style.color = dP != null ? (dP > 0.005 ? '#16A34A' : dP < -0.005 ? '#DC2626' : '#6B7280') : '#6B7280';
      }
      if (idEl) idEl.textContent = intDelta != null ? (intDelta >= 0 ? '+' : '') + intDelta.toFixed(4) : '–';
    }

    // ── MAIN RENDER (math unchanged) ──────────────────────────────────────────
    function render() {
      if (typeof THREE === 'undefined') return;
      var S = window.S;
      if (!S) return;
      var container = document.getElementById('saco3dContainer');
      if (!container) return;

      if (!_initialized) initThree(container);

      var cw = container.clientWidth, ch = container.clientHeight || 310;
      if (_renderer && (Math.abs(cw - _lastW) > 4 || Math.abs(ch - _lastH) > 4)) {
        _renderer.setSize(cw, ch);
        if (_camera) { _camera.aspect = cw / ch; _camera.updateProjectionMatrix(); }
        _lastW = cw; _lastH = ch;
      }
      if (!_scene) return;

      var M = window.PMCMath;

      // Use primaryMode (last-focused strategy) for 3D comparison; fall back to first active
      var rawBase = (S.basePdf && S.basePdf.length > 1) ? S.basePdf : null;
      var overlay = S.overlay || {};
      var pm3d = overlay.primaryMode;
      if (!pm3d) {
        if (overlay.adaptiveOn) pm3d = 'adaptive';
        else if (overlay.fixedOn) pm3d = 'fixed';
        else if (overlay.manualOn) pm3d = 'manual';
      }
      var rawCur = null, source = 'None';
      if (pm3d === 'adaptive' && overlay.adaptiveOn && S.optPdfAdaptive && S.optPdfAdaptive.length > 1) {
        rawCur = S.optPdfAdaptive; source = 'Guided (Level ' + (overlay.probeLevel || 3) + ')';
      } else if (pm3d === 'fixed' && overlay.fixedOn && S.optPdfFixed && S.optPdfFixed.length > 1) {
        rawCur = S.optPdfFixed; source = 'Optimized';
      } else if (pm3d === 'manual' && overlay.manualOn && S.adjPdf && S.adjPdf.length > 1) {
        rawCur = S.adjPdf; source = 'Explorer';
      }

      // Normalize: clamp negatives, trapezoid-normalize so ∫ = 1
      var basePdfN = rawBase ? trapNorm(rawBase) : null;
      var curPdfN  = null;
      if (rawCur && rawCur.length > 1 && basePdfN) {
        var resampled = basePdfN.map(function(p) {
          return { x: p.x, y: Math.max(0, interpY(rawCur, p.x)) };
        });
        curPdfN = trapNorm(resampled);
      }

      // Compute F₀(τ), F₁(τ), ΔP on normalized distributions (math unchanged)
      var tau  = (S.target != null) ? Number(S.target) : null;
      var F0   = (basePdfN && tau != null && M) ? M.trapezoidalCDF(basePdfN, tau) : null;
      var Fcur = (curPdfN  && tau != null && M) ? M.trapezoidalCDF(curPdfN,  tau) : F0;

      // ── Non-primary active strategy PDFs for ghost ribbons + extra needles ─
      var nonPrimStrats = [];
      var _allStratDefs = [
        { mode: 'adaptive', rawPdf: S.optPdfAdaptive, prob: S.adaptiveProb,  label: 'Guided',    hex: 0x8b5cf6 },
        { mode: 'fixed',    rawPdf: S.optPdfFixed,    prob: S.optimizedProb, label: 'Optimized', hex: 0x3b82f6 },
        { mode: 'manual',   rawPdf: S.adjPdf,         prob: S.adjustedProb,  label: 'Explorer',  hex: 0x10b981 }
      ];
      _allStratDefs.forEach(function(sd) {
        if (sd.mode === pm3d) return;                               // skip — already in curPdfN
        if (!overlay[sd.mode + 'On']) return;                      // skip if not active
        if (!sd.rawPdf || sd.rawPdf.length < 2 || !basePdfN) return;
        var res = basePdfN.map(function(p) {
          return { x: p.x, y: Math.max(0, interpY(sd.rawPdf, p.x)) };
        });
        var pdfN = trapNorm(res);
        if (pdfN && pdfN.length > 1) {
          nonPrimStrats.push({ pdfN: pdfN, prob: sd.prob, label: sd.label, hex: sd.hex });
        }
      });

      updateHUD(F0, Fcur, basePdfN, curPdfN || basePdfN);
      var _stratHex = pm3d === 'adaptive' ? 0x8b5cf6 :
                      pm3d === 'fixed'    ? 0x3b82f6 :
                      pm3d === 'manual'   ? 0x10b981 : 0x3b82f6;
      updateRibbons(basePdfN, curPdfN, tau, F0, Fcur, _stratHex, nonPrimStrats, source);
      updateHeptagon();

      var stratEl = document.getElementById('saco3dStratLabel');
      if (stratEl) stratEl.textContent = (source !== 'None') ? 'Strategy: ' + source : 'Baseline only';

      // ── All-strategies chips row ─────────────────────────────────────────────
      var stratRow = document.getElementById('saco3dStratRow');
      var anyActive = overlay.adaptiveOn || overlay.fixedOn || overlay.manualOn;
      if (stratRow) stratRow.style.display = anyActive ? 'flex' : 'none';
      var P0base = S.baselineProb;
      function _setChip(id, label, prob, p0) {
        var el = document.getElementById(id);
        if (!el) return;
        if (prob != null && isFinite(prob)) {
          var dp = p0 != null ? (prob - p0) * 100 : null;
          el.textContent = label + '\u202f' + (prob * 100).toFixed(1) + '%' +
            (dp != null ? '\u202f(\u0394P\u202f' + (dp >= 0 ? '+' : '') + dp.toFixed(1) + '%)' : '');
          el.style.display = 'inline-block';
        } else { el.style.display = 'none'; }
      }
      _setChip('saco3dChipBase',      'Baseline',   P0base,           null);
      _setChip('saco3dChipGuided',    overlay.adaptiveOn ? 'Guided'    : null, overlay.adaptiveOn ? S.adaptiveProb  : null, P0base);
      _setChip('saco3dChipOptimized', overlay.fixedOn    ? 'Optimized' : null, overlay.fixedOn    ? S.optimizedProb : null, P0base);
      _setChip('saco3dChipExplorer',  overlay.manualOn   ? 'Explorer'  : null, overlay.manualOn   ? S.adjustedProb  : null, P0base);
      var baseChip = document.getElementById('saco3dChipBase');
      if (baseChip) baseChip.style.display = (anyActive && P0base != null) ? 'inline-block' : 'none';
    }

    // ── EVENT WIRING (unchanged) ──────────────────────────────────────────────
    function isOverlayActive() {
      var t = document.querySelector('.tab[data-tab="overlay"]');
      return !!(t && t.classList.contains('active'));
    }

    document.addEventListener('DOMContentLoaded', function() {
      ['pmc:baseline:ready', 'pmc:variant:ready'].forEach(function(evt) {
        window.addEventListener(evt, function() { if (isOverlayActive()) render(); });
      });

      var ts = document.getElementById('targetSlider');
      if (ts) ts.addEventListener('input', function() { if (isOverlayActive()) render(); });

      var _origSUIF = window.scheduleUIRefresh;
      window.scheduleUIRefresh = function() {
        if (_origSUIF) _origSUIF.apply(this, arguments);
        if (isOverlayActive()) setTimeout(render, 200);
      };

      var sliderInputs = ['s_budget_range','s_schedule_range','s_scopeCert_range',
                          's_scopeRed_range','s_rework_range','s_risk_range','s_userConf_range'];
      sliderInputs.forEach(function(id) {
        var el = document.getElementById(id);
        if (el) el.addEventListener('input', function() { if (isOverlayActive()) updateHeptagon(); });
      });
    });

    window.PMCSaco3D = { render: render };
  })();
  </script>

  <!-- =====================================================================
       PROBABILITY SPHERE — 3D Three.js glass sphere with liquid fill.
       Spherical cap formula: V(h) = π h²(3R−h)/3, V_sphere = (4/3)πR³
       Bisection solves h for a target probability P.
       Baseline fill = gray.  Strategy lift = colored (purple/blue/green).
       renderer.localClippingEnabled = true to clip fills at their h level.
       ===================================================================== -->
  <script>
  (function() {
    'use strict';

    // ── Module state ─────────────────────────────────────────────────────────
    var _sR = 1.65;          // scene-unit sphere radius (fixed)
    var _sRen = null, _sScn = null, _sCam = null, _sCtl = null;
    var _sLastW = 0, _sLastH = 0;
    var _sFillBase = null;
    var _sFills    = [];           // per-strategy fills [Guided=0, Optimized=1, Explorer=2]
    var _sAnim = null, _sInited = false;
    var _sCurH0 = 0, _sTgtH0 = 0;
    var _sFillCurH = [0, 0, 0];   // animated heights for each strategy fill
    var _sFillTgtH = [0, 0, 0];   // target heights
    var EASE_S = 0.09;
    // Waterline rings follow fill heights — no separate state needed
    var _sRings = [];              // THREE.LineLoop objects [Guided=0, Optimized=1, Explorer=2]

    // ── Math: spherical cap h → clip-plane y (sphere centered at origin) ────
    // h ∈ [0, 2R];  y = h - R  maps [0,2R] → [-R, R]
    function hToY(h) { return h - _sR; }

    // Bisection: solve V(h)/V_sphere = P for fill height h
    function probToH3(P) {
      P = Math.max(0, Math.min(1, P || 0));
      if (P === 0) return 0;
      if (P >= 1)  return 2 * _sR;
      var R = _sR;
      var Vt = (4 / 3) * Math.PI * R * R * R;
      var Vg = P * Vt;
      var lo = 0, hi = 2 * R;
      for (var i = 0; i < 52; i++) {
        var m = (lo + hi) / 2;
        var Vm = Math.PI * m * m * (3 * R - m) / 3;
        if (Vm < Vg) lo = m; else hi = m;
      }
      return (lo + hi) / 2;
    }

    // ── Three.js scene init ──────────────────────────────────────────────────
    function initSphere(container) {
      if (_sInited) return;
      container.innerHTML = '';
      var w = container.clientWidth  || 220;
      var h = container.clientHeight || 220;

      _sScn = new THREE.Scene();
      _sScn.background = new THREE.Color(0xF0F4FA);

      _sCam = new THREE.PerspectiveCamera(36, w / h, 0.01, 50);
      _sCam.position.set(0, 0.6, 5.6);
      _sCam.lookAt(0, 0, 0);

      _sRen = new THREE.WebGLRenderer({ antialias: true });
      _sRen.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      _sRen.setSize(w, h);
      _sRen.localClippingEnabled = true;    // required for per-material clip planes
      _sRen.domElement.style.cssText = 'display:block;width:100%;height:100%;';
      container.appendChild(_sRen.domElement);

      // ── Lighting (tuned for light background) ────────────────────────────
      _sScn.add(new THREE.AmbientLight(0xdce8f8, 0.50));
      var kl = new THREE.DirectionalLight(0xfff8e8, 0.80);
      kl.position.set(3, 5, 5); _sScn.add(kl);
      var fl = new THREE.DirectionalLight(0xc0d4ff, 0.35);
      fl.position.set(-3, 2, -3); _sScn.add(fl);
      var rl = new THREE.DirectionalLight(0x8090c8, 0.22);
      rl.position.set(0, 3, -6); _sScn.add(rl);

      // ── Glass outer sphere ───────────────────────────────────────────────
      var sGeo = new THREE.SphereGeometry(_sR, 48, 48);
      _sScn.add(new THREE.Mesh(sGeo, new THREE.MeshPhysicalMaterial({
        color: 0x90b8e0, transparent: true, opacity: 0.18,
        roughness: 0.05, metalness: 0.0, clearcoat: 1.0, clearcoatRoughness: 0.08,
        side: THREE.FrontSide, depthWrite: false
      })));
      _sScn.add(new THREE.Mesh(new THREE.SphereGeometry(_sR * 0.998, 48, 48),
        new THREE.MeshPhysicalMaterial({
          color: 0x7090b8, transparent: true, opacity: 0.06,
          roughness: 0.05, metalness: 0.0, side: THREE.BackSide, depthWrite: false
        })));

      // ── Baseline fill (gray) — clipped at y ≤ hToY(_sCurH0) ────────────
      _sFillBase = new THREE.Mesh(
        new THREE.SphereGeometry(_sR * 0.992, 40, 40),
        new THREE.MeshStandardMaterial({
          color: 0x8898b8, transparent: true, opacity: 0.65,
          roughness: 0.60, metalness: 0.05,
          clippingPlanes: [new THREE.Plane(new THREE.Vector3(0, -1, 0), -_sR)],
          side: THREE.FrontSide
        })
      );
      _sScn.add(_sFillBase);

      // ── Per-strategy fills — distinct radii, invisible until strategy active ─
      // Guided=purple 0.984R, Optimized=blue 0.974R, Explorer=green 0.964R
      var _fillDefs = [
        { col: 0x8b5cf6, r: _sR * 0.984 },
        { col: 0x3b82f6, r: _sR * 0.974 },
        { col: 0x10b981, r: _sR * 0.964 }
      ];
      _fillDefs.forEach(function(fd) {
        var f = new THREE.Mesh(
          new THREE.SphereGeometry(fd.r, 40, 40),
          new THREE.MeshStandardMaterial({
            color: fd.col, transparent: true, opacity: 0,
            roughness: 0.28, metalness: 0.10, depthWrite: false,
            clippingPlanes: [new THREE.Plane(new THREE.Vector3(0, -1, 0), -_sR)],
            side: THREE.FrontSide
          })
        );
        _sScn.add(f);
        _sFills.push(f);
      });

      // ── Globe lines (equator + 3 meridians) ─────────────────────────────
      var eqPts = [];
      for (var i = 0; i <= 72; i++) {
        var a = 2 * Math.PI * i / 72;
        eqPts.push(new THREE.Vector3(_sR * Math.cos(a), 0, _sR * Math.sin(a)));
      }
      _sScn.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(eqPts),
        new THREE.LineBasicMaterial({ color: 0x7090b8, transparent: true, opacity: 0.50 })
      ));
      [0, Math.PI / 2.5, Math.PI / 1.25].forEach(function(ay) {
        var mPts = [];
        for (var j = 0; j <= 48; j++) {
          var b = 2 * Math.PI * j / 48;
          mPts.push(new THREE.Vector3(
            _sR * Math.sin(b) * Math.cos(ay),
            _sR * Math.cos(b),
            _sR * Math.sin(b) * Math.sin(ay)
          ));
        }
        _sScn.add(new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(mPts),
          new THREE.LineBasicMaterial({ color: 0x9ab0cc, transparent: true, opacity: 0.35 })
        ));
      });

      // ── Probability waterline rings (one per strategy) ───────────────────
      // Unit-circle LineLoops scaled each frame to the correct sphere-slice radius.
      // Color order: Guided=purple, Optimized=blue, Explorer=green
      var _ringCols = [0x8b5cf6, 0x3b82f6, 0x10b981];
      var _ringCircPts = [];
      for (var ri = 0; ri <= 80; ri++) {
        var ra = 2 * Math.PI * ri / 80;
        _ringCircPts.push(new THREE.Vector3(Math.cos(ra), 0, Math.sin(ra)));
      }
      _ringCols.forEach(function(col) {
        var ring = new THREE.LineLoop(
          new THREE.BufferGeometry().setFromPoints(_ringCircPts),
          new THREE.LineBasicMaterial({ color: col, transparent: true, opacity: 0.90 })
        );
        ring.visible = false;
        _sScn.add(ring);
        _sRings.push(ring);
      });

      // ── OrbitControls ────────────────────────────────────────────────────
      if (typeof THREE.OrbitControls !== 'undefined') {
        _sCtl = new THREE.OrbitControls(_sCam, _sRen.domElement);
        _sCtl.enableDamping = true; _sCtl.dampingFactor = 0.08;
        _sCtl.minDistance = 3; _sCtl.maxDistance = 12;
        _sCtl.target.set(0, 0, 0);
        _sCtl.autoRotate = true; _sCtl.autoRotateSpeed = 0.55;
        _sCtl.update();
      }

      _sInited = true;
      _startSphereLoop();
    }

    function _startSphereLoop() {
      if (_sAnim) return;
      function loop() {
        _sAnim = requestAnimationFrame(loop);
        // Ease baseline fill height
        _sCurH0 += (_sTgtH0 - _sCurH0) * EASE_S;
        if (_sFillBase && _sFillBase.material.clippingPlanes[0])
          _sFillBase.material.clippingPlanes[0].constant = hToY(_sCurH0);
        // Ease per-strategy fill heights + update their clip planes
        for (var _fi = 0; _fi < _sFills.length; _fi++) {
          _sFillCurH[_fi] += (_sFillTgtH[_fi] - _sFillCurH[_fi]) * EASE_S;
          if (_sFills[_fi] && _sFills[_fi].material.clippingPlanes[0])
            _sFills[_fi].material.clippingPlanes[0].constant = hToY(_sFillCurH[_fi]);
        }
        // Waterline rings track their fill's current height
        for (var _ri = 0; _ri < _sRings.length; _ri++) {
          if (!_sRings[_ri].visible) continue;
          var _ry = hToY(_sFillCurH[_ri]);
          var _rr = Math.sqrt(Math.max(0.001, _sR * _sR - _ry * _ry));
          _sRings[_ri].position.y = _ry;
          _sRings[_ri].scale.set(_rr, 1, _rr);
        }
        if (_sCtl) _sCtl.update();
        if (_sRen && _sScn && _sCam) _sRen.render(_sScn, _sCam);
      }
      loop();
    }

    // ── Public render: called whenever state changes ─────────────────────────
    function render() {
      if (typeof THREE === 'undefined') return;
      var S = window.S; if (!S) return;
      var container = document.getElementById('sphereContainer');
      if (!container) return;
      if (!_sInited) initSphere(container);

      // Resize renderer if container dimensions changed
      var sw = container.clientWidth || 360, sh = container.clientHeight || 360;
      if (_sRen && (Math.abs(sw - _sLastW) > 4 || Math.abs(sh - _sLastH) > 4)) {
        _sRen.setSize(sw, sh);
        if (_sCam) { _sCam.aspect = sw / sh; _sCam.updateProjectionMatrix(); }
        _sLastW = sw; _sLastH = sh;
      }

      var P0   = S.baselineProb || 0;
      var ov   = S.overlay || {};
      // Use primaryMode (last-focused strategy) for sphere; fall back to first active
      var pmSph = ov.primaryMode;
      if (!pmSph) {
        if (ov.adaptiveOn) pmSph = 'adaptive';
        else if (ov.fixedOn) pmSph = 'fixed';
        else if (ov.manualOn) pmSph = 'manual';
      }
      var Pcur = pmSph === 'adaptive' && ov.adaptiveOn ? (S.adaptiveProb  || P0)
               : pmSph === 'fixed'    && ov.fixedOn    ? (S.optimizedProb || P0)
               : pmSph === 'manual'   && ov.manualOn   ? (S.adjustedProb  || P0) : P0;

      _sTgtH0 = probToH3(P0);

      // ── Per-strategy fills: opacity + clip target for each active strategy ─
      var _stratProbs = [S.adaptiveProb,  S.optimizedProb, S.adjustedProb ];
      var _stratOn    = [ov.adaptiveOn,   ov.fixedOn,      ov.manualOn    ];
      for (var _sfi = 0; _sfi < _sFills.length; _sfi++) {
        if (!_sFills[_sfi]) continue;
        var _sfOn = !!(_stratOn[_sfi] && _stratProbs[_sfi] != null && isFinite(_stratProbs[_sfi]));
        _sFills[_sfi].material.opacity = _sfOn ? 0.62 : 0;
        _sFillTgtH[_sfi] = _sfOn ? probToH3(_stratProbs[_sfi]) : _sFillCurH[_sfi];
        // Ring visibility mirrors fill visibility
        if (_sRings[_sfi]) _sRings[_sfi].visible = _sfOn;
      }

      // ── HUD ──────────────────────────────────────────────────────────────
      var dP    = Pcur - P0;
      var p0El  = document.getElementById('sphereP0');
      var pEl   = document.getElementById('sphereP');
      var dpEl  = document.getElementById('sphereDeltaP');
      var stEl  = document.getElementById('sphereStratLabel');
      if (p0El) p0El.textContent = (P0   * 100).toFixed(2) + '%';
      if (pEl)  pEl.textContent  = (Pcur * 100).toFixed(2) + '%';
      if (dpEl) {
        dpEl.textContent = (dP >= 0 ? '+' : '') + (dP * 100).toFixed(2) + '%';
        dpEl.style.color = dP > 0.005 ? '#16A34A' : dP < -0.005 ? '#DC2626' : '#6B7280';
      }
      if (stEl) {
        stEl.textContent = pmSph === 'adaptive' && ov.adaptiveOn ? 'Guided (Level ' + (ov.probeLevel || 3) + ')' :
                           pmSph === 'fixed'    && ov.fixedOn    ? 'Optimized' :
                           pmSph === 'manual'   && ov.manualOn   ? 'Explorer' : 'Baseline';
      }
      if (window.PMCMath && typeof window.PMCMath.validateLift === 'function')
        window.PMCMath.validateLift(P0, Pcur, dP);

      // ── All-strategies row ────────────────────────────────────────────────
      var sphRow  = document.getElementById('sphereStratRow');
      var anyAct  = ov.adaptiveOn || ov.fixedOn || ov.manualOn;
      if (sphRow) sphRow.style.display = anyAct ? 'flex' : 'none';
      function _setSphChip(id, label, prob, p0base) {
        var el = document.getElementById(id);
        if (!el) return;
        if (label && prob != null && isFinite(prob)) {
          var dp2 = p0base != null ? (prob - p0base) * 100 : null;
          el.textContent = label + '\u202f' + (prob * 100).toFixed(1) + '%' +
            (dp2 != null ? '\u202f(\u0394P\u202f' + (dp2 >= 0 ? '+' : '') + dp2.toFixed(1) + '%)' : '');
          el.style.display = 'inline-block';
        } else { el.style.display = 'none'; }
      }
      var sphP0 = S.baselineProb;
      _setSphChip('sphChipBase',      anyAct ? 'Baseline' : null,   sphP0,              null);
      _setSphChip('sphChipGuided',    ov.adaptiveOn ? 'Guided'    : null, ov.adaptiveOn ? S.adaptiveProb  : null, sphP0);
      _setSphChip('sphChipOptimized', ov.fixedOn    ? 'Optimized' : null, ov.fixedOn    ? S.optimizedProb : null, sphP0);
      _setSphChip('sphChipExplorer',  ov.manualOn   ? 'Explorer'  : null, ov.manualOn   ? S.adjustedProb  : null, sphP0);
    }

    window.PMCSphere = { render: render };

    document.addEventListener('DOMContentLoaded', function() {
      function isOverlayActive() {
        var t = document.querySelector('.tab[data-tab="overlay"]');
        return !!(t && t.classList.contains('active'));
      }
      window.addEventListener('pmc:baseline:ready',  function() { if (isOverlayActive()) render(); });
      window.addEventListener('pmc:variant:ready',   function() { if (isOverlayActive()) render(); });

      var ts = document.getElementById('targetSlider');
      if (ts) ts.addEventListener('input', function() { if (isOverlayActive()) render(); });

      // Chain onto the SACO3D-patched scheduleUIRefresh
      var _prevSUIF = window.scheduleUIRefresh;
      window.scheduleUIRefresh = function() {
        if (_prevSUIF) _prevSUIF.apply(this, arguments);
        if (isOverlayActive()) setTimeout(render, 220);
      };
    });
  })();
  </script>
</body>
</html>
